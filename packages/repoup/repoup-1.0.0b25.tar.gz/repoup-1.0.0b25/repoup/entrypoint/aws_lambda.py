"""AWS Lambda entrypoint.

Use S3 as storage, Cloudfront as CDN and supports GPG key stored in SSM parameter store.

SSM parameters must be stored in a common fully qualified path defined
with SSM_PARAMETER_PATH environment variable.

The GPG key content must be passed to GPG_PRIVATE_KEY instead of the key path.

This lambda is intended to be triggered on S3 events "ObjectCreated:*" and
"ObjectRemoved:*".
It is recommended to trigger the Lambda using an SQS, trigger this queue by S3 events
and limit the lambda concurrency to 1. This ensures all packages are properly added to
the repository and avoid repository metadata to be updated simultaneously.

Logs are generated in JSON format to allow better use with Cloudwatch Insight. A single
JSON line is generated by package operation.
"""
from asyncio import new_event_loop
from json import loads, dumps
from os import close, environ, write
from os.path import basename
from tempfile import mkdtemp, mkstemp
from typing import Any, Dict, Union
from urllib.parse import unquote
from time import perf_counter
from traceback import format_exception

from boto3 import client

import repoup.repository as rep
from repoup.exceptions import RepositoryException
import repoup.storage.s3  # noqa

try:
    import uvloop  # noqa
except ImportError:  # pragma: no cover
    pass
else:
    uvloop.install()

LOOP = new_event_loop()


def _init_gpg() -> None:
    """Get GPG key and password from SSM parameter store."""
    try:
        ssm_path = environ["SSM_PARAMETER_PATH"]
    except KeyError:
        return
    params = {
        param["Name"].rsplit("/", 1)[1]: param["Value"]
        for param in client("ssm").get_parameters_by_path(
            Path=ssm_path, WithDecryption=True
        )["Parameters"]
    }

    try:
        key_content = params["GPG_PRIVATE_KEY"]
    except KeyError:
        return

    environ["GNUPGHOME"] = gpg_dir = mkdtemp(prefix=".gnupg-")
    fd, key_path = mkstemp(prefix="key-", suffix=".asc", dir=gpg_dir)
    try:
        write(fd, key_content.encode())
    finally:
        close(fd)
    rep.GPG_PRIVATE_KEY = key_path

    try:
        rep.GPG_PASSWORD = params["GPG_PASSWORD"]
    except KeyError:
        pass


_init_gpg()
del _init_gpg


async def update_repository(action: str, path: str, key: str) -> str:
    """Update repository.

    Args:
        action: Action to perform.
        path: Source S3 URI.
        key: S3 key to handle.

    Returns:
        Repository.
    """
    async with (await rep.get_repository(path)) as repo:
        await getattr(repo, action)(key)
        return repo.url


async def _async_handler(event: Dict[str, Any]) -> None:
    """AWS Lambda async entry point.

    Args:
        event: Event information.
    """
    try:
        event["Records"][0]["messageId"]
    except KeyError:
        # Directly triggered by S3
        records = event["Records"]
    else:
        # Triggered by S3 via SQS queue
        records = list()
        for record in event["Records"]:
            record = loads(record["body"])
            try:
                records += record["Records"]
            except KeyError:
                continue

    for record in records:
        if record["eventName"].startswith("ObjectCreated:"):
            action = "add"
        elif record["eventName"].startswith("ObjectRemoved:"):
            action = "remove"
        else:
            continue
        start = perf_counter()
        key = unquote(record["s3"]["object"]["key"])
        path = f"s3://{record['s3']['bucket']['name']}/{key}"
        log: Dict[str, Union[str, int, float]] = dict(
            path=path, package=basename(key), action=action
        )
        try:
            log["repository"] = await update_repository(action, path, key)
            log["level"] = "info"
            log["status_code"] = 200
        except RepositoryException as exc:
            log["level"] = "warning"
            log["status_code"] = exc.status
            log["error_detail"] = exc.message
        except Exception as exc:  # noqa
            log["level"] = "error"
            log["status_code"] = 500
            log["error_detail"] = "".join(
                format_exception(type(exc), exc, exc.__traceback__)
            )
        log["execution_time_ms"] = round((perf_counter() - start) * 1e3, 1)
        print(dumps(log))


def handler(event: Dict[str, Any], _: Any) -> None:
    """AWS Lambda entry point.

    Args:
        event: Event information.
        _: AWS lambda context.
    """
    LOOP.run_until_complete(_async_handler(event))
