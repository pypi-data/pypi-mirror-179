Metadata-Version: 2.1
Name: logicalinduction
Version: 0.1.5
Summary: A computable algorithm for quantifying uncertainty
Author-email: Kōshin Alex Flint <koshin@monasticacademy.org>
License: MIT License
        
        Copyright (c) 2022 Kōshin Alex Flint
        
        Permission is hereby granted, free of charge, to any person obtaining a copy
        of this software and associated documentation files (the "Software"), to deal
        in the Software without restriction, including without limitation the rights
        to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
        copies of the Software, and to permit persons to whom the Software is
        furnished to do so, subject to the following conditions:
        
        The above copyright notice and this permission notice shall be included in all
        copies or substantial portions of the Software.
        
        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
        OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
        SOFTWARE.
        
Project-URL: Homepage, https://github.com/monasticacademy/logicalinduction
Project-URL: Bug Tracker, https://github.com/monasticacademy/logicalinduction/issues
Classifier: Programming Language :: Python :: 3
Classifier: License :: OSI Approved :: MIT License
Classifier: Operating System :: OS Independent
Requires-Python: >=3.9
Description-Content-Type: text/markdown
License-File: LICENSE

![Continuous integration](https://github.com/monasticacademy/logical-induction/actions/workflows/integrate.yaml/badge.svg)

# Logical induction in Python

This repository contains code to support the guide to logical induction for
software engineers (which has not yet been published). It consists of a
straightforward python implementation of the logical induction algorithm
published by *Garrabrant et al* in 2018. I have prioritized simplicity over
efficiency.

To run the example code:
```bash
$ git clone git@github.com:monasticacademy/logical-induction.git
$ cd logical-induction
$ python examples/two_updates.py

after update 1:
  the sky is blue                          1.000000
  the sky is blue | the sky is green       0.000000

after update 2:
  the sky is green → the world is round    0.000000
  the sky is blue                          0.000000
  the sky is blue | the sky is green       1.000000
```

### Organization of the code

The main interface is the `LogicalInductor` class in `inductor.py`:

```python
class LogicalInductor(object):
    ...

    def update(self, observation, trading_algorithm):
        """
        Given: 
         * An observation
         * A trading algorithm
        Return:
         * A belief state
        
        Implements the logical induction algorithm as per 5.4.1 in the paper
        """
```

The update function takes as input an observation, which is a logical sentence
that is to be taken to be true from here on, and a trading algorithm, which is a
set of formulas specifying trades to be executed that the logical inductor will
set its credences in order to avoid being exploited by.

The representation of logical sentences is implemented in `sentence.py` and
works as follows. The class `sentence.Atom` represents a claim about the world
not further reducible by logical connectives such as AND, OR, NOT. Its
constructor takes a string, which can be anything and is only to help humans
keep track of what is going on. The other classes in this file implement
conjunctions, disjunctions, logical negation, and material implication.

The representation of trading formulas is implemented in `formula.py`. A trading
formula is a simple language for expressing buy/sell trades that a logical
inductor must not be exploited by. The classes in this file follow section A.2
from the paper.

The representation of belief states and histories of is in `credence.py`. A
belief state is a map from sentences to credences, and a history of belief
states is a list of belief states.

The code in `enumerator.py` provides various routines for enumerating possible
worlds.

The code in `example/two_updates.py` instantiates a logical inductor and
feeds it two observations, printing out the credences it receives in response.
