# AUTOGENERATED! DO NOT EDIT! File to edit: ../01_collection.ipynb.

# %% auto 0
__all__ = ['NFTCollection', 'Token']

# %% ../01_collection.ipynb 4
import pandas as pd
from dateparser import parse as parse_date
from functools import cache
from dataclasses import dataclass
from datetime import datetime, timedelta
from .connectors import Connector
from fastcore.utils import patch
from fastcore.basics import basic_repr
from box import Box
from operator import attrgetter
from typing import Callable
from jinja2 import Template

# %% ../01_collection.ipynb 5
def _parse_start_end_dates(start_time: str, end_time: str = "now") -> tuple[datetime]:
    # ensure you have end_time:
    end_time = end_time or 'now'
    shortcuts = {
        # put more here, but should be convertible to dateparser lib conventions.
        "latest": 'now',
    }
    start_time = str(datetime.utcnow().date()) if start_time == 'today' else start_time
    if start_time in shortcuts: start_time = shortcuts[start_time]
    return parse_date(start_time, settings={'TIMEZONE': 'UTC'}), parse_date(end_time, settings={'TIMEZONE': 'UTC'})

# %% ../01_collection.ipynb 7
def _chain_prefix(chain: str):
    return '' if chain == 'eth' else chain + '_'
def _build_trade_statement(chain: str, 
                           start_dt:datetime, 
                           end_dt:datetime, 
                           collection_address:str='',
                           mints_only=False,
                           token_id:str=''):
    table = f'{_chain_prefix(chain)}{"trades" if not mints_only else "mints"}'
    template = """
        SELECT *
        FROM onchain.{{table}}
        WHERE timestamp >= {{ start_ts }} AND timestamp <= {{ end_ts }}
        {%- if collection_address %}
        AND collection_address = '{{ collection_address }}'
        {% endif %}
        {%- if token_id %}
        AND token_id = '{{ token_id }}'
        {% endif %}
    """
    return Template(template,lstrip_blocks=True,trim_blocks=True, autoescape=True).render(
        table=table,
        start_ts=round(start_dt.timestamp()),
        end_ts=round(end_dt.timestamp()),
        mints_only=mints_only,
        collection_address=collection_address,
        token_id=token_id).replace('\n','').replace('   ', ' ')                        

# %% ../01_collection.ipynb 9
@cache
def __fetch_trades(conn: Connector,
                 start_dt: datetime, # start time in UTC. You can use shortcuts like today, yesterday or even clauses such as "1 day/week ago".
                 end_dt: datetime, # default now. Same type as start_time 
                 chain:str = 'eth', 
                 collection_address: str = '', # collection address
                 token_id: str = '', # token id
                 mints_only: bool = False
                ) -> pd.DataFrame:
    return conn.query(_build_trade_statement(chain, start_dt, end_dt, collection_address=collection_address, token_id=token_id, mints_only=mints_only))

def _fetch_trades(conn: Connector,
                 start_time: str, # start time in UTC. You can use shortcuts like today, yesterday or even clauses such as "1 day/week ago".
                 end_time: str = 'now', # default now. Same type as start_time 
                 chain:str = 'eth', 
                 collection_address: str = '', # collection address
                 token_id: str = '', # token id
                 mints_only: bool = False # filter for mints if True
                ) -> pd.DataFrame:
    start_dt, end_dt = _parse_start_end_dates(start_time, end_time=end_time)
    # we cache the one below because "yesterday" etc. style start_time is relative.
    return __fetch_trades(conn, start_dt, end_dt, chain=chain, collection_address=collection_address, mints_only=mints_only, token_id=token_id)

@cache
def _fetch_metadata(conn: Connector, collection_id:str, chain: str = 'eth'):
    res = conn.query(f"""
        select * from offchain.{_chain_prefix(chain)}collection_metadata
        where collection_id='{collection_id.lower()}'""").squeeze()
    res.name = res['name']
    if 'volume_all' in res: del res['volume_all']
    if 'volume_daily' in res: del res['volume_daily']
    if 'volume_weekly' in res: del res['volume_weekly']
    if 'item_count' in res: del res['item_count']
    return res

@cache
def _fetch_socials(conn: Connector, collection_slug: str):
    return conn.get(f'/socials/{collection_slug}').json()

# %% ../01_collection.ipynb 10
class NFTCollection:
    """NFT Collection object"""
    def __init__(self,
                 conn: Connector,
                 collection_id: str, # collection_address e.g. 0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D
                 chain: str ='eth'): # chain_id - currently only "eth" or "bnb" allowed
        self._conn, self.chain, self.collection_id = conn, chain, collection_id.lower()

# %% ../01_collection.ipynb 11
@patch
def trades(self: NFTCollection,
           start_time: str, # start time in UTC. You can use shortcuts like today, yesterday or even clauses such as "1 day/week ago".
           end_time: str = 'now' # default now. Same type as start_time 
          ):
    return _fetch_trades(
        self._conn,
        start_time, 
        end_time=end_time, 
        chain=self.chain,
        collection_address=self.collection_id,
    )
@patch
def token(self: NFTCollection, token_id: str): return Token(self._conn, token_id, self.collection_id, chain=self.chain)
@patch
def metadata(self: NFTCollection): return _fetch_metadata(self._conn, self.collection_id, chain=self.chain)
@patch
def mints(self: NFTCollection,
           start_time: str, # start time in UTC. You can use shortcuts like today, yesterday or even clauses such as "1 day/week ago".
           end_time: str = 'now' # default now. Same type as start_time 
          ):
    return _fetch_trades(
        self._conn,
        start_time,
        end_time=end_time,
        chain=self.chain,
        collection_address=self.collection_id,
        mints_only=True
    )

# %% ../01_collection.ipynb 12
def _timeseries_to_df(timeseries: list) -> pd.DataFrame:
    """turn socials timeseries to pd dataframe"""
    if not timeseries: return timeseries
    _ts = pd.DataFrame([dict(i) for i in timeseries])
    _ts['ts'] = _ts['ts'].apply(pd.to_datetime)
    _ts.set_index('ts')
    return _ts

@patch
def socials(self: NFTCollection, collection_slug: str):
    _socials = Box(self._conn.get(f'/socials/{collection_slug}').json())
    _socials.discord = _timeseries_to_df(_socials.discord.timeseries)
    _socials.twitter = _timeseries_to_df(_socials.twitter.timeseries)
    return _socials

# %% ../01_collection.ipynb 13
class Token:
    __repr__= basic_repr(['collection_id', 'token_id', 'token_type', 'chain'])
    def __init__(self, conn: Connector, token_id: str, collection_id:str, chain:str='eth', token_type='721'):
        self._conn, self.token_id, self.chain, self.token_type = conn, token_id, chain, token_type
        self.collection_id = collection_id
    def trades(self: 'Token',
           start_time: str, # start time in UTC. You can use shortcuts like today, yesterday or even clauses such as "1 day/week ago".
           end_time: str = 'now' # default now. Same type as start_time 
          ):
        return _fetch_trades(
            self._conn,
            start_time,
            end_time=end_time, 
            chain=self.chain,
            collection_address=self.collection_id,
            token_id=self.token_id
        )
    @cache
    def metadata(self): return self._conn.rpc(self.chain).get_token_metadata(self.token_id, self.collection_id)
