# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/utils/convert_legacy.ipynb (unless otherwise specified).

__all__ = ['__author__', '__copyright__', '__license__', 'get_parameters_columns', 'get_scores_columns',
           'get_scores_names', 'update_data_format', 'convert_run_numbers', 'update_and_replace_experiment_data',
           'convert_run_numbers_and_replace']

# Cell
__author__ = "Jaume Amores"
__copyright__ = "Copyright 2021, Johnson Controls"
__license__ = "MIT"

# Cell
import pandas as pd
import numpy as np
import pickle
import os
import sys
import time
import warnings
warnings.filterwarnings('ignore')

from ..config import hp_defaults as dflt
from .experiment_utils import read_df, write_df

# Cell
def get_parameters_columns (experiment_data, only_not_null=False):
    parameters =  [par for par in experiment_data.columns if not par[0].isdigit() and (par.find('time_')<0) and (par.find('date')<0)]
    if only_not_null:
        parameters = np.array(parameters)[~experiment_data.loc[:,parameters].isnull().all(axis=0)].tolist()
    return parameters

# Cell
def get_scores_columns (experiment_data=None, suffix_results='', class_ids = None):
    """
    Determine the columnns that provide evaluation scores.

    We assume that they start with the class number, and that the other columns
    do not start with a digit.
    """
    if class_ids is not None:
        scores_columns = ['%d%s' %(col,suffix_results) for col in class_ids]
    else:
        if experiment_data is None:
            raise ValueError ('Either experiment_data or class_ids should be different than None')
        scores_columns = [col for col in experiment_data.columns if col[0].isdigit()]
        # For some experiments, we have multiple scores per class (e.g., due to different evaluation criteria). The argument suffix_results can be used to select the appropriate score.
        if len(suffix_results) > 0:
            scores_columns = [col for col in scores_columns if (len(col.split(suffix_results))==2) and (len(col.split(suffix_results)[1])==0) and (col.split(suffix_results)[0].isdigit()) ]
        else:
            # We assume that default scores are in columns whose names only have the class number
            scores_columns = [col for col in scores_columns if (len(col.split('_'))>=1)]
    return scores_columns

# Cell
def get_scores_names (experiment_data=None, run_number=None, experiment=None, only_valid=True,
                      sort=False):
    """
    Determine the names of the scores included in experiment data.

    We assume that the score columns start with the class number, and that the other columns do not start with a digit.

    If run_number is provided, we provide the scores stored for that run number. If, in addition to this,
    experiment is provided, and only_valid=True, we provide only the scores that are not NaN for the given
    experiment number.
    """

    if run_number is None:
        scores_names = np.unique([('_'.join(col.split('_')[1:]) if (len(col.split('_')) > 1) else '')
                                    for col in experiment_data.columns if col[0].isdigit()])

    else:
        scores_names = [col.split(f'{run_number}')[1] for col in experiment_data.columns if col.startswith(str(run_number))]
        scores_names = [('_'.join(col.split('_')[1:]) if (len(col.split('_')) > 1) else '')
                                    for col in scores_names]
        if (experiment is not None) and only_valid:
            scores_names = [name for name in scores_names if not np.isnan(experiment_data.loc[experiment, f'{run_number}_{name}'])]
        if sort:
            scores_names = list(np.sort(scores_names))
    # remove special names
    scores_names = [name for name in scores_names if name != 'finished']
    return scores_names

# Cell
def update_data_format (df):
    par_cols_src = get_parameters_columns(df)
    par_cols_dst = pd.MultiIndex.from_product ([[dflt.parameters_col], par_cols_src, ['']])
    par_df = df[par_cols_src]
    par_df.columns = par_cols_dst

    score_cols_src = [c for c in get_scores_columns (df) if not c.endswith('finished')]
    score_cols_src = np.sort(score_cols_src).tolist()
    run_number = np.unique([c.split('_')[0] for c in score_cols_src])
    scores_names = get_scores_names (df)
    scores_names = np.sort(scores_names).tolist()
    score_cols_dst = pd.MultiIndex.from_product ([[dflt.scores_col], scores_names, run_number.tolist()])
    scores_dst_sort = np.sort(pd.MultiIndex.from_tuples([(t[0], t[2], t[1]) for t in score_cols_dst]))
    score_cols_dst = pd.MultiIndex.from_tuples([(t[0], t[2], t[1]) for t in scores_dst_sort])
    score_df = df[score_cols_src]
    score_df.columns = score_cols_dst

    finished_cols_src = [c for c in get_scores_columns (df) if c.endswith('finished')]
    finished_cols_src = np.sort(finished_cols_src).tolist()
    finished_cols_dst = pd.MultiIndex.from_product ([[dflt.run_info_col], ['finished'], run_number.tolist()])
    finished_df = df[finished_cols_src]
    finished_df.columns = finished_cols_dst

    time_cols_src = [c for c in df.columns if c.startswith('time')]
    time_cols_src = np.sort(time_cols_src).tolist()
    time_cols_dst = pd.MultiIndex.from_product ([[dflt.run_info_col], ['time'], run_number.tolist()])
    time_df = df[time_cols_src]
    time_df.columns = time_cols_dst

    date_cols_src = [c for c in df.columns if c.startswith('date')]
    date_cols_src = np.sort(date_cols_src).tolist()
    date_cols_dst = pd.MultiIndex.from_product ([[dflt.run_info_col], ['date'], run_number.tolist()])
    date_df = df[date_cols_src*len(date_cols_dst)]
    date_df.columns = date_cols_dst

    df = pd.concat ([par_df, score_df, finished_df, time_df, date_df], axis=1)
    df = df[df.columns.sort_values()]

    return df

# Cell
def convert_run_numbers (df):
    columns = df.columns
    columns2 = []
    unique_columns = []
    for x in columns:
        try:
            column = (x[0], x[1], int(x[2]))
            if column not in columns2:
                other_column = (x[0], x[1], str(x[2]))
                if column in columns and other_column in columns:
                    x = df[other_column]
                    y = df[column]
                    y[y.isna()] = x[y.isna()]
                    df[column] = y
                    unique_columns.append(column)
                elif column in columns:
                    unique_columns.append(column)
                elif other_column in columns:
                    unique_columns.append(other_column)
                else:
                    raise RuntimeError (f'unexpected column: {x}')
        except ValueError:
            column = (x[0], x[1], '')
            if column not in columns2: unique_columns.append(column)
        if column not in columns2: columns2.append (column)

    df = df[pd.MultiIndex.from_tuples(unique_columns)]
    df.columns = pd.MultiIndex.from_tuples (columns2)
    return df

# Cell
def update_and_replace_experiment_data (path_experiments):
    df = read_df (path_experiments)
    df = update_data_format (df)
    df = convert_run_numbers (df)
    write_df (df, path_experiments)

# Cell
def convert_run_numbers_and_replace (path_experiments):
    df = read_df (path_experiments)
    df = convert_run_numbers (df)
    write_df (df, path_experiments)