# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/MachineLearningModels/base_nn/athena_experiment_manager.ipynb (unless otherwise specified).

__all__ = ['AthenaExperimentManager', 'root_path']

# Cell

import sys
sys.path.append('./src')
from hpsearch.experiment_manager import ExperimentManager
from ..YK_YT_400Hz.train_YK_YT_400Hz_model_with_single_input_per_dataset import ModelWithSingleInputPerDataset
from ..YK_YT_400Hz.train_YK_YT_400Hz_model_with_multiple_inputs_per_dataset import ModelWithMultipleInputsPerDataset

root_path = 'data'

class AthenaExperimentManager (ExperimentManager):

    def __init__ (self):
        super().__init__()

    def run_experiment (self, parameters={}, path_results='./results'):
        Model = self.get_model_class (parameters)
        self.model = Model (path_results=path_results, **parameters)

        frequency_range = parameters.get('frequency_range', '400Hz')
        if frequency_range == '400Hz':
            path_data='data/YK_YT_400Hz_data'
        elif frequency_range == '3kHz':
            path_data='data/YK_YT_3kHz_data'
        else:
            raise ValueError (f'frequency_range {frequency_range} not valid')

        self.model.extract_data (path_data=path_data, save_training=True)

        if parameters.get('recompute_metrics', False):
            self.recompute_metrics (parameters, path_results)
        else:
            self.model.construct_model ()

            _ = self.model.fit_model()
        return self.model.dict_results

    def get_model_class (self, parameters):
        input_type = parameters.get('input_type', 'single')
        if input_type == 'single':
            return ModelWithSingleInputPerDataset
        elif input_type == 'multiple':
            return ModelWithMultipleInputsPerDataset
        else:
            raise ValueError (f'input type {input_type} not valid')

    def get_default_parameters (self, parameters):
        defaults = dict(early_stop=False,
                      early_stop_metric='val_main_output_accuracy',
                      reduce_lr_on_plateau=True,
                      reduce_lr_metric='main_output_loss',
                      learning_rate = 0.0001,
                      epochs = 100,
                      batch_size = 512,
                      regularization=0.1,
                      target_recall=0.96,
                      min_recall=0.95,
                      max_recall=0.97,
                      architecture='big',
                      dropout_factor=1,
                      input_type='single',
                      gaussian_noise=0.005,
                      last_activation='sigmoid',
                      normal_sample_weight=0.1,
                      alert_sample_weight=0.6,
                      alarm_sample_weight=1.0,
                      normal_weight=0.1,
                      abnormal_weight=0.8,
                      reduce_lr_factor=0.2,
                      reduce_lr_patience=5,
                      cnn_frozen=0,
                      fc_frozen=0)

        if parameters.get('frequency_range', '400Hz') == '3kHz':
            defaults.update (regularization=100.0,
                            gaussian_noise=0.0,
                            cnn_frozen=2,
                            alert_sample_weight=1.0,
                            alarm_sample_weight=1.4,
                            normal_weight=1.0,
                            abnormal_weight=1.0,
                            batch_size=1024)

        return defaults

    def get_path_experiments (self, path_experiments = None, folder = None):
        """Gives the root path to the folder where results of experiments are stored."""
        path_experiments = 'data/hpsearch'

        if folder != None:
            path_experiments = f'{path_experiments}/{folder}'

        return path_experiments


    def get_path_alternative (self, path_results):
        root1 = 'data/hpsearch'
        #root1 = '/mnt/datascience-vol'
        root2 = '/mnt/datascience-vol'
        path_alternative = path_results.replace(root1, root2)

        return path_alternative


    def get_default_operations (self):
        default_operations = dict (root='400Hz_sinput',
                                   metric='precision_bigger',
                                   op='max')

        return default_operations

    ###############
    # recomputation, visualization, and other specific methods
    def recompute_metrics (self, parameters, path_results):
        path_model = f'{path_results}/best_precision_bigger.h5'
        self.model.load_model(path_model=path_model)
        recall, precision, tp, fp, tn, fn, pthr, rthr = self.model.recompute_metrics (on_test=True)
        dict_results = dict(recall=recall,
                            precision=precision,
                            tp=tp,
                            fp=fp,
                            tn=tn,
                            fn=fn,
                            pthr=pthr,
                            rthr=rthr)
        print (dict_results)

