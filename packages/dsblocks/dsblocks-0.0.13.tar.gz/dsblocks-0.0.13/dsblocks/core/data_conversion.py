# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/core/data_conversion.ipynb.

# %% auto 0
__all__ = ['DataConverter', 'NoConverter', 'GenericConverter', 'StandardConverter', 'PandasConverter', 'Window2Dto3Dconverter',
           'data_converter_factory']

# %% ../../nbs/core/data_conversion.ipynb 3
__author__ = "Jaume Amores"
__copyright__ = "Copyright 2021, Johnson Controls"
__license__ = "MIT"

# %% ../../nbs/core/data_conversion.ipynb 4
import abc
import pandas as pd
import numpy as np
import warnings
import copy
from typing import Callable, Optional, Union

from fastcore.meta import delegates

from ..config import bt_defaults as dflt
from ..utils.utils import set_logger
from .callback import BaseCallback

# %% ../../nbs/core/data_conversion.ipynb 7
#@delegates ()
class DataConverter (BaseCallback):
    """
    Convert input and output data format.

    This class allows to convert the format of the data before fitting
    and before transforming, and revert the changes back after performing
    these operations. This allows to decouple the implementation of a
    particular component from the remaining components in the pipeline,
    making it more reusable across different pipelines.
    
    Parameters
    ----------
    logger : logging.Logger or None, optional
        Logger used to write messages
    verbose : int, optional
        Verbosity, 0: warning or critical, 1: info, 2: debug.
    inplace: bool, optional.
        Whether or not the data conversion mutates the value of the input data variables.
    convert_before: function or None, optional.
        Function used to convert the data before the `fit`, `fit_apply` or `apply`, 
        method (or any of their synonyms) are called.
    convert_before_applying: function or None, optional.
        Function used to convert the data before the `apply`, `transform`, or or any of 
        their synonyms are called.
    convert_before_fitting: function or None, optional.
        Function used to convert the data before the `fit` method is called.
    convert_after: function or None, optional.
        Function used to convert the data *after* the `fit`, `fit_apply` or `apply`, 
        method (or any of their synonyms) are called.
    convert_after_applying: function or None, optional.
        Function used to convert the data after the `apply`, `transform`, or or any of 
        their synonyms are called.
    convert_after_fitting: function or None, optional.
        Function used to convert the data before the `fit` method is called.
    convert_before_applying_after_fit: function or None, optional.
        Function to be applied in `fit_transform`, `fit_apply` or any of its synonyms, 
        after the fit part of this method has finished, and before the `transform` or `apply`
        part begins.
    convert_after_applying_after_fit: function or None, optional.
        Function to be applied in `fit_transform`, `fit_apply` or any of its synonyms, 
        after the fit and the `transform` or `apply` parts finish.
    unpack_single_tuple_for_fitting: bool, optional.
        Whether or not to convert an input which is a single tuple (X,) to X before fitting.
    unpack_single_tuple_for_applying: bool, optional.
        Whether or not to convert an input which is a single tuple (X,) to X before transforming.
    unpack_single_tuple: bool, optional.
        Whether or not to convert an input which is a single tuple (X,) to X before either
        fitting or transforming.
    unpack_single_tuple_for_result_func: bool, optional.
        Whether or not to convert an input which is a single tuple (X,) to X appying the 
        underlying _apply function.
    component_returns_nothing: bool, optional.
        Whether None means something returned by the component, or means that the component 
        returns nothing.
    ensure_tuple: bool, optional.
        Whether a data variable X that is not a tuple should be transformed to a tuple (X,) 
        before processing it.
    """
    def __init__ (self, 
                  logger=None, 
                  verbose: int=dflt.verbose, 
                  inplace: bool=True,
                  convert_before: Optional[Callable]=None, 
                  convert_before_applying: Optional[Callable]=None, 
                  convert_before_fitting: Optional[Callable]=None,
                  convert_after: Optional[Callable]=None, 
                  convert_after_applying: Optional[Callable]=None, 
                  convert_after_fitting: Optional[Callable]=None,
                  convert_before_applying_after_fit: Optional[Callable]=None,
                  convert_after_applying_after_fit: Optional[Callable]=None,
                  unpack_single_tuple_for_fitting: bool=True, 
                  unpack_single_tuple_for_applying: bool=True,
                  unpack_single_tuple: Optional[bool]=None, 
                  unpack_single_tuple_for_result_func: bool=False,
                  component_returns_nothing: bool=dflt.component_returns_nothing, 
                  ensure_tuple: bool=True, 
                  **kwargs):
        super().__init__ (but='logger', **kwargs)
        
        # logger used to display messages
        if logger is None:
            self.logger = set_logger ('dsblocks', verbose=verbose)
        else:
            self.logger = logger
        self.inplace = inplace
        self._set_convert_from_functions (
            convert_before=convert_before,
            convert_before_applying=convert_before_applying,
            convert_before_fitting=convert_before_fitting,
            convert_after=convert_after,
            convert_after_applying=convert_after_applying,
            convert_after_fitting=convert_after_fitting,
            convert_before_applying_after_fit=convert_before_applying_after_fit,
            convert_after_applying_after_fit=convert_after_applying_after_fit)

        unpack_single_tuple_for_fitting = (
            unpack_single_tuple if unpack_single_tuple is not None
            else unpack_single_tuple_for_fitting)
        unpack_single_tuple_for_applying = (
            unpack_single_tuple if unpack_single_tuple is not None
            else unpack_single_tuple_for_applying)
        self.convert_single_tuple_for_fitting = (
            self.convert_single_tuple if unpack_single_tuple_for_fitting
            else self.do_not_convert_single_tuple)
        self.convert_single_tuple_for_applying = (
            self.convert_single_tuple if unpack_single_tuple_for_applying
            else self.do_not_convert_single_tuple)

        self.convert_single_tuple_for_result_func = (
            self.convert_single_tuple if unpack_single_tuple_for_result_func
            else self.do_not_convert_single_tuple)
        if component_returns_nothing:
            self.original_convert_single_tuple_for_result_func = self.convert_single_tuple_for_result_func
            self.convert_single_tuple_for_result_func = self.make_none_empty_tuple

        self.convert_no_tuple = (self.convert_no_tuple if ensure_tuple
                                 else self.do_not_convert_no_tuple)

    def convert_single_tuple (self, X):
        return X[0] if (len(X)==1 and type(X[0]) is tuple) else X

    def do_not_convert_single_tuple (self, X):
        return X
    
    def make_none_empty_tuple (self, X):
        if type(X) is tuple and len(X)==1 and X[0] is None:
            return ()
        else:
            return self.original_convert_single_tuple_for_result_func (X)

    def convert_no_tuple (self, X):
        X = X if type (X) is tuple else (X,)
        return X

    def do_not_convert_no_tuple (self, X):
        return X

    def convert_varargs_to_x_y (self, X):
        assert len(X)==1 or len(X)==2
        X, y = X if len(X)==2 else (X[0], None)
        return X, y

    def convert_before_fitting (self, *X):
        """
        Convert incoming data before running fit method.

        Parameters
        ----------
        X : data (N observations x D dimensions)
            data used for fitting model parameters

        Returns
        -------
        X : data (N observations x D dimensions)
            data with transformed format but same content
        """
        return X

    def convert_after_fitting (self, *X):
        """
        Convert data after running fit method.

        Calling this method is only required when convert_before_fitting
        changes X "in place", instead of changing a copy of X. This might
        be more efficient sometimes, and we have convert_after_fitting to
        revert the previous change.

        Parameters
        ----------
        X : data (N observations x D dimensions)
            data used for fitting model parameters

        Returns
        -------
        X : data (N observations x D dimensions)
            data with transformed format but same content
        """
        return X

    def convert_before_applying (self, *X, **kwargs):
        """
        Convert data before running transform method.

        Parameters
        ----------
        X : data (N observations x D dimensions)
            data used to be transformed

        Returns
        -------
        X : data (N observations x D dimensions)
            data with transformed format but same content
        """
        return X

    def convert_after_applying (self, result, **kwargs):
        """
        Convert result obtained after by transform method.

        Parameters
        ----------
        result : data (N' observations x D' dimensions)
                result obtained by transformed method

        Returns
        -------
        result : data (N' observations x D' dimensions)
            result with transformed format but same content
        """
        return result

    def convert_before_fit_apply (self, *X, sequential_fit_apply=False, **kwargs):
        #return self.convert_before_fitting (*X)
        X_original = copy.deepcopy (X) if self.inplace else X
        _ = self.convert_before_applying (
            *X_original, fit_apply=True, sequential_fit_apply=sequential_fit_apply, **kwargs)
        X = self.convert_before_fitting (*X)
        if self.inplace:
            self.X = X
        return X

    def convert_after_fit_apply (self, result, sequential_fit_apply=False, **kwargs):
        #return self.convert_after_applying (result, **kwargs)
        if self.inplace:
            _ = self.convert_after_fitting (*self.X)
            self.X = None
        return self.convert_after_applying (
            result, fit_apply=True, sequential_fit_apply=sequential_fit_apply, **kwargs)

    ## methods based on passed-in functions
    def _set_convert_from_functions (self, convert_before=None, convert_before_applying=None,
                                     convert_before_fitting=None, convert_after=None,
                                     convert_after_applying=None, convert_after_fitting=None,
                                     convert_before_applying_after_fit=None,
                                     convert_after_applying_after_fit=None):
        # functions
        if convert_before is not None:
            if convert_before_applying is None: convert_before_applying = convert_before
            if convert_before_fitting is None:
                self._convert_before_fitting = convert_before
                self.convert_before_fitting = self.convert_before_fitting_from_function
            #if convert_before_fit_apply is None: convert_before_fit_apply=convert_before

        if convert_before_applying is not None:
            self._convert_before_applying = convert_before_applying
            self.convert_before_applying = self.convert_before_applying_from_function
            self._convert_before_applying_after_fit = (
                self._convert_before_applying if convert_before_applying_after_fit is None
                else convert_before_applying_after_fit)
        if convert_before_fitting is not None:
            self._convert_before_fitting = convert_before_fitting
            self.convert_before_fitting = self.convert_before_fitting_from_function

        if convert_after is not None:
            if convert_after_applying is None: convert_after_applying = convert_after
            if convert_after_fitting is None: convert_after_fitting = convert_after
        if convert_after_applying is not None:
            self._convert_after_applying = convert_after_applying
            self.convert_after_applying = self.convert_after_applying_from_function
            self._convert_after_applying_after_fit = (
                self._convert_after_applying if convert_after_applying_after_fit is None
                else convert_after_applying_after_fit)
        if convert_after_fitting is not None:
            self._convert_after_fitting = convert_after_fitting
            self.convert_after_fitting = self.convert_after_fitting_from_function

    def convert_before_fitting_from_function (self, *X):
        return self._convert_before_fitting (*X)

    def convert_after_fitting_from_function (self, *X):
        return self._convert_after_fitting (*X)

    def convert_before_applying_from_function (self, *X, fit_apply=False,
                                                   sequential_fit_apply=False, **kwargs):
        if fit_apply or sequential_fit_apply:
            return self._convert_before_applying_after_fit (*X, **kwargs)
        else:
            return self._convert_before_applying (*X, **kwargs)

    def convert_after_applying_from_function (self, result, fit_apply=False,
                                                  sequential_fit_apply=False, **kwargs):
        if fit_apply or sequential_fit_apply:
            return self._convert_after_applying_after_fit (result, **kwargs)
        else:
            return self._convert_after_applying (result, **kwargs)

# %% ../../nbs/core/data_conversion.ipynb 11
#@delegates ()
class NoConverter (DataConverter):
    """Performs no conversion."""
    def __init__ (self, **kwargs):
        super().__init__(inplace=False, **kwargs)

# %% ../../nbs/core/data_conversion.ipynb 15
#@delegates ()
class GenericConverter (DataConverter):
    """
    Converts inputs that may or may not have data and labels 
    into two separate arguments `X` and `y` to the format required 
    by the component.

    It also takes care of converting multiple inputs and outputs 
    appropriately.

    By default, when calling to the `fit_apply` method (or any of its 
    aliases, `fit_transform`, `fit_predict`, etc.), with data `X` and 
    labels `y`, the component calls  first `fit` with both `X` and `y`,
    and then it calls `apply` (or any of its aliases, `transform`, etc)
    with only `X`, and only returns the result of calling `apply`, without
    including the labels `y` in the output. However, this behavior
    can change based on the parameters given when constructing the 
    GenericConverter object, see below.
    
    Parameters
    ----------
    inner_apply_receives_labels : bool or None, optional
        If True, the inner _apply method of the component needs to
        consumes ground-truth labels.
        When calling `fit_apply/fit_transform`, or any
        of the aliases, with input data `X` and labels `y`, then:
         - `X` and `y` are provided to the `fit` method.
         - `X` and `y` are provided to the `apply` method (or its aliases)
    outer_fit_apply_may_receive_labels_in_sequential : bool or None, optional
        If True, we assume that the apply method receives labels when
        calling fit_apply by parent Sequential object.
    inner_apply_returns_labels : bool or None, optional
        If True, the input labels are assummed to be returned by the 
        inner _apply method of the component.
    outer_apply_returns_labels : bool or None, optional
        If True, the input labels need to be attached to whatever 
        is returned by the _apply method. For instance, if `X_r` is returned
        by `_apply`, then (X_r, y) is returned when calling the component's
        apply method.
    do_not_attach_labels_to_outer_apply_output : bool or None, optional
        If True, we avoid attaching y to the result obtained by the inner
        _apply method, even if we are calling fit_apply in a Sequential object.
    raise_error_if_no_label_inconsistency : bool or None, optional
        Raises an error if no_label=True but labels are found in the input.
    raise_warning_if_no_label_inconsistency : bool or None, optional
        Raises a warning if no_label=True but labels are found in the input.
    inplace : bool or None, optional
        Whether or not the data conversion mutates the value of the input data variables.
    observations_are_rows : bool or None, optional
        If True, given a data matrix X, we assume each row is an observation.
    """

    error_warning_message = 'Did not find y as separate argument, but no_labels is False'

    def __init__ (self, 
                  inner_apply_receives_labels: bool=False, 
                  outer_fit_apply_may_receive_labels_in_sequential: bool=True, 
                  inner_apply_returns_labels: Optional[bool]=None, 
                  outer_apply_returns_labels: Optional[bool]=None,
                  do_not_attach_labels_to_outer_apply_output: bool =False,
                  raise_error_if_no_label_inconsistency: bool=False,
                  raise_warning_if_no_label_inconsistency: bool=False,
                  inplace: bool=False, 
                  observations_are_rows:bool=True, 
                  **kwargs):

        super().__init__(inplace=False, **kwargs)

        # whether the _transform method receives a DataFrame that includes the labels, or it doesn't
        self.stored_y = False
        self.inner_apply_returns_labels = (inner_apply_returns_labels
                                             if inner_apply_returns_labels is not None
                                             else self.inner_apply_receives_labels)
        self.outer_apply_returns_labels = (
            outer_apply_returns_labels if outer_apply_returns_labels is not None
            else self.inner_apply_receives_labels)

    def _may_have_y (self, X):
        if len(X)<=1 or not self.outer_fit_apply_may_receive_labels_in_sequential:
            return False
        *Xrest, Xy = X
        if type(Xy) is np.ndarray: Xy = Xy.ravel()
        if type(Xy) is pd.DataFrame: Xy = Xy.values.ravel()
        y_shape = len(Xy) if hasattr(Xy, '__len__') and not isinstance(Xy, str) else None
        if y_shape is not None:
            rest_shape = np.array([x.shape[0] if (self.observations_are_rows and
                                                   (type(x) is np.ndarray or type (x) is pd.DataFrame))
                                   else x.shape[1] if (not self.observations_are_rows and
                                                   (type(x) is np.ndarray or type (x) is pd.DataFrame))
                                   else len(x) if (hasattr(x, '__len__') and not isinstance(x, str))
                                   else None
                                   for x in Xrest])
            return (y_shape == rest_shape).any()
        else:
            return False
        
    def convert_before_applying (self, *X, fit_apply=False, sequential_fit_apply=False, **kwargs):
        """
        By default, remove labels from incoming input.
        """
        self.stored_y = False
        if (not (fit_apply or sequential_fit_apply or self.inner_apply_receives_labels) 
            or not self._may_have_y (X)):
            return X
        if self.inner_apply_receives_labels:
            if sequential_fit_apply:
                self.stored_y = True
                *_, self.y = X
            return X
        else:
            # extract labels from X
            *X, y = X
            X = tuple(X)
            if sequential_fit_apply:
                self.stored_y = True
                self.y = y
            return X

    def convert_after_applying (self, result, fit_apply=False, sequential_fit_apply=False, **kwargs):
        """
        Convert the result produced by `transform`to DataFrame format.

        If the input to `transform` was in DataFrame format, the `result`
        given by `transform` is converted to DataFrame if it is not
        produced in this format. Furthermore, if the `label` column was
        in the input to `transform` and it is not in the output given
        by `transform`, it is appended to the result.
        """
        if (not (sequential_fit_apply or self.outer_apply_returns_labels) 
            or self.inner_apply_returns_labels or 
            not self.stored_y or self.do_not_attach_labels_to_outer_apply_output):
            return result
        if type(result) is tuple:
            result = result + (self.y, )
        else:
            result = (result, self.y)
        self.stored_y = False
        self.y = None
        return result

# %% ../../nbs/core/data_conversion.ipynb 23
#@delegates ()
class StandardConverter (DataConverter):
    """
    Simple Data Converter that removes `y` labels from input 
    before passing it to the underlying _apply method. 
    
    Parameters `inplace`, `unpack_single_tuple` and `unpack_single_tuple_for_result_func`
    are overriden to always be False, False and True respectively. See description of
    those parameters in `DataConverter` class.
    """
    def __init__ (self, inplace=False, unpack_single_tuple=False,
                  unpack_single_tuple_for_result_func=True, **kwargs):
        # logger used to display messages
        super().__init__(inplace=False, unpack_single_tuple=False,
                         unpack_single_tuple_for_result_func=True, **kwargs)

    def convert_before_applying (self, *X, fit_apply=False, sequential_fit_apply=False, **kwargs):
        """
        Convert data before running transform method.
        """
        if ((fit_apply or sequential_fit_apply) and len(X)==2):
            X, self.y = X
        else:
            self.y = None
        return X

    def convert_after_applying (self, result, sequential_fit_apply=False, **kwargs):
        """
        Convert result obtained after by transform method.
        """
        if sequential_fit_apply and self.y is not None:
            result = (result, self.y)
        self.y = None
        return result

# %% ../../nbs/core/data_conversion.ipynb 30
#@delegates ()
class PandasConverter (DataConverter):
    """
    Convert DataFrame to numpy array and back, if needed.

    By default, this class assumes the following:

        - When calling the fit method, the data is received
          as a DataFrame. This DataFrame contains not only the
          data to be used for fitting our model, but also the
          ground-truth labels. The `PandasConverter` takes only
          the data needed for fitting the model, and puts it
          into a matrix `X`, and then takes the labels and puts
          them into a separate vector `y`. While all this is done
          by default, the `PandasConverter` also allows other
          possibilities: receiving the data and the labels separately
          in `X` and `y`, in which case no action is needed, or avoiding
          to separate the data and the labels (if the flag `separate_labels` is False),
          in which case the matrix `X` will contain both data and labels.
          It also allows to receive numpy arrays instead of DataFrames,
          in which case the data format is preserved.

        - When calling the `transform` method, the `PandasConverter`
          removes by default the labels from the incoming DataFrame,
          and then puts them back after performing the transformation.
          This behaviour can change if we set `apply_needs_labels=True`.
          In this case, the labels are kept in the matrix `X` so that
          they can be used during the transformation. This is done in
          particular by one type of component called `SamplingComponent`,
          defined in `core.component_types`. This is useful for
          components that do some sort of under-sampling or over-sampling,
          changing the number of observations. When this occurs, the
          labels need to be adjusted accordingly, so that the `transform`
          method modifies both the data and the labels, both of whom are
          contained in the output matrix `X`.

        The  default `DataConverter` used in the current implementation is the
        `PandasConverter`.

        Parameters
        ----------
        apply_uses_labels : bool, optional
            If True, the `transform` method receives as input data `X` a DataFrame where
            one of the columns is `label`, containing the ground-truth labels. This allows
            the transform method to modify the number of observations,
            changing the number of rows in the data and in the labels.
            See `SamplingComponent` class in `dsblocks.core.component_types`.
            If False, the input data `X` only contains data consumed by , without
            ground-truth labels.
        output_index : array-like or None, optional
            Used after transforming the data. If the result of the transformation is
            a numpy array, two things can happen: 1) if the number of rows of this array
            is the same as the number of rows of the input DataFrame, then we convert
            the array to a DataFrame with the same index as the original; 2) if the number
            of rows is not the same, the index used for the new DataFrame is
            `output_index` if provided, or 0..N-1 (where N=number of rows) if not
            provided.
        output_columns : array-like or None, optional
            Used after transforming the data. If the result of the transformation is
            a numpy array, two things can happen: 1) if the number of columns of this array
            is the same as the number of columns of the input DataFrame, then we convert
            the array to a DataFrame with the same columns as the original; 2) if the number
            of columns is not the same, the columns used for the new DataFrame is
            `output_columns` if provided, or 0..D-1 (where D=number of columns) if not
            provided.
        separate_labels : bool, optional
            Used before calling the fit method. If separate_labels=True (default value),
            the `fit` method receives the data and labels separately in `X` and `y`
            respectively. If separate_labels=False, the `fit` method receives both the
            data and the labels in the same input `X`, where the labels are in a
            column of `X` called `label` (TODO: make this configurable). This last
            option is used by the `Pipeline` class, and its rationale is provided in
            the description of that class.
        inplace: bool, optional.
            Whether or not the data conversion mutates the value of the input data variables.
        metadata: list of strings or None, optional.
            List of columns that are not required by the current component's
            `fit` or `apply` methods, but may be required later by subsequent
            components in the pipeline. This metadata is not passed to the
            current component's methods, but it included in the result provided 
            by the component so that later components have it available as columns
            of their input dataframe.
    """
    def __init__ (self, apply_uses_labels=False, output_index=None, output_columns=None,
                  separate_labels=True, inplace=False, metadata=None, **kwargs):

        super().__init__(inplace=inplace, **kwargs)

        # whether the _transform method receives a DataFrame that includes the labels, or it doesn't
        self.apply_uses_labels = apply_uses_labels

        # configuration for converting the transformed data into a DataFrame
        self.output_index = output_index
        self.output_columns = output_columns

        # whether the _fit method receives a DataFrame that includes the labels, or the labels are placed separately in y
        self.separate_labels = separate_labels

        self.metadata=metadata

    def convert_before_fitting (self, *X):
        """
        By default, convert DataFrame X to numpy arrays X and y

        The most common use of this method is:
        - When calling the fit method, the data is received
          as a DataFrame.
        - This DataFrame contains not only the data to be
          used for fitting our model, but also the
          ground-truth labels. This method takes only
          the data needed for fitting the model, and puts it
          into a matrix `X`, and then takes the labels and puts
          them into a separate vector `y`.

        Other possibilities are:
          - If the data and the labels are separated in `X` and `y`
          (i.e., X does not include labels), no action is performed.
          - If `self.separate_labels` is False, the data and the labels
          are not separated, in which case the data `X`
          passed to the fit method will contain both data and labels.
          - It also allows to receive numpy arrays instead of DataFrames,
          in which case the data format is preserved.
        """
        X, y = self.convert_varargs_to_x_y (X)
        if self.separate_labels and (type(X) is pd.DataFrame) and ('label' in X.columns):
            if y is None:
                y = X['label']
            else:
                assert (y==X['label']).all(), "discrepancy between y and X['label']"

            X = X.drop(columns='label')
            self.restore_label_fitting = True
            self.y_fitting = y
        else:
            self.restore_label_fitting = False

        if self.metadata is not None:
            self.df = X[self.metadata]
            X = X.drop(columns=self.metadata)

        return X, y

    def convert_after_fitting (self, *X):
        """Do nothing. Return same data received."""
        return X

    def convert_before_applying (self, X, new_columns=None, **kwargs):
        """
        By default, remove labels from incoming DataFrame.

        This method allows to remove the labels from the incoming DataFrame,
        and then put them back after performing the transformation.
        This behaviour can change if we set `self.apply_needs_labels=True`.
        In this case, the labels are kept in the matrix `X` so that they can be
        used during the transformation. This is done in particular by one type of
        component called `SamplingComponent`, defined in `core.component_types`.
        This is useful for components that do some sort of under-sampling or
        over-sampling, changing the number of observations. When this occurs,
        the labels need to be adjusted accordingly, so that the `transform` method
        modifies both the data and the labels, both of whom are contained in the output
        matrix `X`.


        """
        if new_columns is None:
            new_columns = self.output_columns
        self.new_columns = new_columns
        if (type(X) is pd.DataFrame) and ('label' in X.columns) and (not self.apply_uses_labels):
            y = X['label']
            X = X.drop(columns='label')
            self.restore_label_transform = True
            self.y_transform = y
        else:
            self.restore_label_transform = False

        if self.metadata is not None:
            self.df = X[self.metadata]
            X = X.drop(columns=self.metadata)

        self.type_X = type(X)
        if self.type_X is pd.DataFrame:
            self.X_shape = X.shape
            self.X_index = X.index
            self.X_columns = X.columns
            if 'label' in self.X_columns:
                self.X_label = X['label']

        return X

    def convert_after_applying (self, result, **kwargs):
        """
        Convert the result produced by `transform`to DataFrame format.

        If the input to `transform` was in DataFrame format, the `result`
        given by `transform` is converted to DataFrame if it is not
        produced in this format. Furthermore, if the `label` column was
        in the input to `transform` and it is not in the output given
        by `transform`, it is appended to the result.
        """

        result = self.convert_to_dataframe (result)
        if self.restore_label_transform:
            if type(result) is pd.DataFrame:
                if 'label' in result.columns:
                    self.logger.warning ('label already part of result')
                result['label'] = self.y_transform
            else:
                self.logger.warning ('result is not DataFrame')

        if self.metadata is not None:
            result[self.metadata] = self.df
            del self.df

        return result

    def convert_to_dataframe (self, result):
        """Convert the `result` produced by `transform`to DataFrame format."""

        if self.type_X is pd.DataFrame:
            if type(result) is np.ndarray or type(result) is pd.Series:
                if result.shape[0] == self.X_shape[0]:
                    index = self.X_index
                else:
                    index = self.output_index if (self.output_index is None) else range(result.shape[0])
                if (result.ndim > 1) and (result.shape[1] == self.X_shape[1]):
                    columns = self.X_columns
                else:
                    columns = self.new_columns if (self.new_columns is not None) else range(result.shape[1]) if (result.ndim > 1) else [0]

                result = pd.DataFrame (result, index=index, columns=columns)
            elif (type(result) is pd.DataFrame and self.new_columns is not None and
                  result.shape[1]==len(self.new_columns) and not (result.columns==self.new_columns).all()):
                result.columns = self.new_columns

            if type(result) is pd.DataFrame:
                if ('label' in self.X_columns) and ('label' not in result.columns):
                    self.logger.info ('label column not found in result, but found in input DataFrame')
                    result['label'] = self.X_label
        return result

# %% ../../nbs/core/data_conversion.ipynb 34
#@delegates ()
class Window2Dto3Dconverter (DataConverter):
    """Convert sequence of windows from WindowGenerator's 2D format to 3D.

    Given a 2D Dataframe of size N x (W*D), where N=number of windows,
    D=number of variables (dimensions), and W=size of windows, converts this
    to a numpy array of N x D x W. Note that the order of the elements is
    transposed: for each window, the has first the elements of a window in
    one dimension, then the elements in the second dimension, etc. This
    is transposed in the output to have the second and third axis be D and W
    respectively.
    """
    def __init__ (self, sequence_length: int, data_converter: DataConverter = None, **kwargs):
        """
        Initialize common attributes and fields.

        Parameters
        ----------
        sequence_length : int
            Size of each window.
        data_converter : DataConverter, optional
            DataConverter that will transform the input data to a 2D DataFrame of
            size N x (D*W), if it is not already in this format. PandasConverter
            is used by default.
        """
        self.sequence_length = sequence_length
        if data_converter is None:
            self.data_converter = PandasConverter (**kwargs)
        else:
            self.data_converter = data_converter
        super ().__init__ (inplace=self.data_converter.inplace, **kwargs)

    def convert_before_fitting (self, X, y=None):
        """
        Convert incoming data before running fit method.

        Parameters
        ----------
        X : data (N observations x D dimensions)
            data used for fitting model parameters
        y : labels (N observations), optional
            One dimensional array with N groundtruth labels.

        Returns
        -------
        X : data (N observations x D dimensions)
            data with transformed format but same content
        y : labels (N observations)
            labels with transformed format but same content
        """
        X, y = self.data_converter.convert_before_fitting (X, y)
        X = self.transform (X)
        return X, y

    def convert_after_fitting (self, X):
        """
        Convert data after running fit method.

        Calling this method is only required when convert_before_fitting
        changes X "in place", instead of changing a copy of X. This might
        be more efficient sometimes, and we have convert_after_fitting to
        revert the previous change.

        Parameters
        ----------
        X : data (N observations x D dimensions)
            data used for fitting model parameters

        Returns
        -------
        X : data (N observations x D dimensions)
            data with transformed format but same content
        """
        return self.data_converter.convert_after_fitting (X)

    def convert_before_applying (self, X, **kwargs):
        """
        Convert data before running transform method.

        Parameters
        ----------
        X : data (N observations x D dimensions)
            data used to be transformed

        Returns
        -------
        X : data (N observations x D dimensions)
            data with transformed format but same content
        """
        X = self.data_converter.convert_before_applying (X, **kwargs)
        X = self.transform (X)
        return X

    def convert_after_applying (self, result, **kwargs):
        """
        Convert result obtained after by transform method.

        Parameters
        ----------
        result : data (N' observations x D' dimensions)
                result obtained by transformed method

        Returns
        -------
        result : data (N' observations x D' dimensions)
            result with transformed format but same content
        """
        result = self.inverse_transform (result)
        result = self.data_converter.convert_after_applying (result, **kwargs)
        return result

    def transform (self, df):
        """
        Convert input DataFrame `df` to numpy array in 3D format.

        Given a 2D Dataframe of size N x (W*D), where N=number of windows,
        D=number of variables (dimensions), and W=size of windows, converts this
        to a numpy array of N x D x W. Note that the order of the elements is
        transposed: for each window, the has first the elements of a window in
        one dimension, then the elements in the second dimension, etc. This
        is transposed in the output to have the second and third axis be D and W
        respectively.
        """
        data = df.values.reshape(df.shape[0], -1, self.sequence_length)
        data = np.transpose(data, (0,2,1))
        return data

    def inverse_transform (self, data):
        """
        Convert 3D numpy array `data` to 2D DataFrame.

        Given a 3D numpy array of size N x D x W, convert this to Dataframe
        of size N x (W*D), where N=number of windows, D=number of variables
        (dimensions), and W=size of windows. Note that the order of the
        elements is transposed: for each window, the output provides first
        the elements of the first variable across the time-steps of the window,
        then the elements of the second variable, etc.
        """
        data = np.transpose (data, (0,2,1))
        data = data.reshape (data.shape[0], -1)
        return data

# %% ../../nbs/core/data_conversion.ipynb 40
def data_converter_factory (converter,
                            *args,
                            **kwargs):
    if type(converter) is str:
        cls = eval(converter)
    elif type(converter) is type:
        cls = converter
    elif isinstance (converter, DataConverter):
        return converter
    else:
        raise ValueError (f'invalid converter {converter}, must be str, class or object instance of DataConverter')
    return cls(*args, **kwargs)
