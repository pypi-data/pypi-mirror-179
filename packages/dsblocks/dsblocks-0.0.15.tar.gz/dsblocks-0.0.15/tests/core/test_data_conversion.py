# AUTOGENERATED! DO NOT EDIT! File to edit: ../../../nbs/00_tests/core/tst.data_conversion.ipynb.

# %% auto 0
__all__ = ['generate_input_for_window_generator', 'test_data_converter_functions', 'test_no_converter', 'test_generic_converter',
           'test_may_have_y', 'test_standard_converter_in_component', 'test_standard_converter',
           'test_pandas_converter', 'test_window2d_to_3d_converter', 'test_data_converter_factory']

# %% ../../../nbs/00_tests/core/tst.data_conversion.ipynb 2
from dsblocks.core.data_conversion import *

# %% ../../../nbs/00_tests/core/tst.data_conversion.ipynb 3
import pytest 
import numpy as np
import os
import joblib
from IPython.display import display
import pandas as pd

from dsblocks.core.components import Component
from dsblocks.utils.utils import remove_previous_results
import dsblocks.config.bt_defaults as dflt
from dsblocks.core.compose import Sequential
from dsblocks.utils.dummies import Min10direct, SumXY
from dsblocks.blocks.preprocessing import WindowGenerator


# %% ../../../nbs/00_tests/core/tst.data_conversion.ipynb 4
def generate_input_for_window_generator ():
    index = pd.period_range (start='2022-01-14', end='2022-01-18', freq='H')
    df = pd.DataFrame (index=index.to_timestamp (), columns=['a','b','label'])
    df.index.name = 'timestamp'
    df['a'] = 10
    df['b'] = 20
    df['label'] = 0
    df.loc[('2022-01-15' <= index) & (index < '2022-01-16'),'label'] = 1
    df.loc[('2022-01-15' <= index) & (index < '2022-01-16'),'a'] = 11
    df.loc[('2022-01-15' <= index) & (index < '2022-01-16'),'b'] = 21
    return df

# %% ../../../nbs/00_tests/core/tst.data_conversion.ipynb 5
def test_data_converter_functions ():
    X, y = np.array([[1,2,3]]), np.array([0,1,0])
    
    dc = DataConverter (convert_before=lambda x, y: (x.ravel(), y),
                        convert_after=lambda x: {'test':x})
    
    Xr, yr = dc.convert_before_fitting (X, y)
    assert (Xr==X.ravel()).all() and Xr.shape==(3,)
    assert (yr==y).all()
    
    Xr, yr = dc.convert_before_applying (X, y)
    assert (Xr==X.ravel()).all() and Xr.shape==(3,)
    assert (yr==y).all()
    
    Xr = dc.convert_after_fitting (X)
    assert (Xr['test']==X).all() and Xr['test'].shape==(1,3) and list(Xr.keys())==['test']
    
    Xr = dc.convert_after_applying (X)
    assert (Xr['test']==X).all() and Xr['test'].shape==(1,3) and list(Xr.keys())==['test']
    
    dc = DataConverter (convert_before_fitting=lambda x, y: (x.ravel(), y),
                        convert_after_fitting=lambda x: {'train':x},
                        convert_before_applying=lambda x: x.tolist(),
                        convert_after_applying=lambda x: {'test':x})
    
    Xr, yr = dc.convert_before_fitting (X, y)
    assert (Xr==X.ravel()).all() and Xr.shape==(3,)
    assert (yr==y).all()
    
    Xr = dc.convert_after_fitting (X)
    assert (Xr['train']==X).all() and Xr['train'].shape==(1,3) and list(Xr.keys())==['train']
    
    Xr = dc.convert_before_applying (X)
    assert (Xr==X.tolist()) and type(Xr) is list
    
    Xr = dc.convert_after_applying (X)
    assert (Xr['test']==X).all() and Xr['test'].shape==(1,3) and list(Xr.keys())==['test']
    
    dc = DataConverter (convert_before_fitting=lambda x, y: (x.ravel(), y),
                        convert_after_applying=lambda x: {'test':x})
    
    Xr, yr = dc.convert_before_fitting (X, y)
    assert (Xr==X.ravel()).all() and Xr.shape==(3,)
    assert (yr==y).all()
    
    Xr = dc.convert_after_fitting (X)
    assert Xr == (X,)
    
    Xr = dc.convert_before_applying (X)
    assert Xr == (X,)
    
    Xr = dc.convert_after_applying (X)
    assert (Xr['test']==X).all() and Xr['test'].shape==(1,3) and list(Xr.keys())==['test']


# %% ../../../nbs/00_tests/core/tst.data_conversion.ipynb 6
def test_no_converter ():
    dc = NoConverter()
    X, y = [1,2,3], [0,1,0]
    Xr, yr = dc.convert_before_fitting (X, y)
    assert X==Xr
    assert y==yr
    
    # We can pass conversion functions to the NoConverter class. 
    # In that case, the NoConverter behaves as the base class DataConverter
    X, y = np.array([[1,2,3]]), np.array([0,1,0])
    dc = NoConverter (convert_before_fitting=lambda x, y: (x.ravel(), y),
                        convert_after_applying=lambda x: {'test':x})
    
    Xr, yr = dc.convert_before_fitting (X, y)
    assert (Xr==X.ravel()).all() and Xr.shape==(3,)
    assert (yr==y).all()
    
    Xr = dc.convert_after_fitting (X)
    assert Xr == (X,)
    
    Xr = dc.convert_before_applying (X)
    assert Xr == (X,)
    
    Xr = dc.convert_after_applying (X)
    assert (Xr['test']==X).all() and Xr['test'].shape==(1,3) and list(Xr.keys())==['test']


# %% ../../../nbs/00_tests/core/tst.data_conversion.ipynb 7
def test_generic_converter ():
    class GCComponent (Component):
        def __init__ (self, test_func=None, **kwargs):
            super ().__init__ (data_converter=GenericConverter, **kwargs)
        def _apply (self, *args, **kwargs):
            return self.test_func (*args, **kwargs)
        def _fit (self, *args, **kwargs):
            self.args=args
            self.kwargs=kwargs
            pass
    
    def doesnt_receive_labels_one_X (X):
        return X
    
    def doesnt_receive_labels_two_X (a, b):
        return a, b
       
    def receives_labels_doesnt_return_labels_one_X (X, y):
        return X
    
    def receives_labels_doesnt_return_labels_two_X (a, b, y):
        return a, b
    
    def receives_labels_returns_labels_one_X (X, y):
        return X, y
    
    def receives_labels_returns_labels_two_X (a, b, y):
        return a, b, y
    
    # -----------------------------------------
    # 1. doesnt_receive_labels_one_X
    func = doesnt_receive_labels_one_X
    args = ([10], )
    args_fa = ([10], [1])
    result = GCComponent(test_func=func).apply (*args)
    assert result==[10]
    
    component=GCComponent(test_func=func)
    result = component.fit_apply (*args)
    assert result==[10]
    assert component.args==([10],)
    
    result = component.fit_apply (*args_fa)
    assert result==[10]
    assert component.args==([10], [1])
    
    # 1.1 Sequential
    component0=GCComponent(test_func=func)
    component=GCComponent(test_func=func)
    result = Sequential (component0, component).fit_apply (*args)
    assert result==[10]
    assert component.args==args
    
    component0=GCComponent(test_func=func)
    component=GCComponent(test_func=func)
    result = Sequential (component0, component).fit_apply (*args_fa)
    assert result==args[0]
    assert component.args==args_fa
    
    # -----------------------------------------
    # 2. doesnt_receive_labels_two_X
    func = doesnt_receive_labels_two_X
    args = ([10], [20])
    args_fa = ([10], [20], [1])
    result = GCComponent(test_func=func).apply (*args)
    assert result==args
    
    component=GCComponent(test_func=func)
    result = component.fit_apply (*args_fa)
    assert result==args
    assert component.args==args_fa
    
    # 2.1. Sequential
    component0=GCComponent(test_func=func)
    component=GCComponent(test_func=func)
    result = Sequential (component0, component).fit_apply (*args_fa)
    assert result==args
    assert component.args==args_fa
    
    # -----------------------------------------
    # 3. receives_labels_doesnt_return_labels_one_X
    func = receives_labels_doesnt_return_labels_one_X
    args = ([10], )
    args_fa = ([10], [1])
    result = GCComponent(test_func=func).apply (*args_fa)
    assert result==args[0]
    
    component=GCComponent(test_func=func, inner_apply_receives_labels=True)
    result = component.fit_apply (*args_fa)
    assert result==args[0]
    assert component.args==args_fa
    
    # 3.1. Sequential
    # when using inner_apply_receives_labels=True, inner_apply_returns_labels is set to True by default, unless
    # we indicate its value
    component0=GCComponent(test_func=func, inner_apply_receives_labels=True, inner_apply_returns_labels=False)
    component=GCComponent(test_func=func, inner_apply_receives_labels=True, inner_apply_returns_labels=False)
    result = Sequential (component0, component).fit_apply (*args_fa)
    assert result==args[0]
    assert component.args==args_fa
    
    # -----------------------------------------
    # 4. receives_labels_doesnt_return_labels_two_X
    func = receives_labels_doesnt_return_labels_two_X
    args = ([10], [20])
    args_fa = ([10], [20], [1])
    result = GCComponent(test_func=func).apply (*args_fa)
    assert result==args
    
    component=GCComponent(test_func=func, inner_apply_receives_labels=True)
    result = component.fit_apply (*args_fa)
    assert result==args
    assert component.args==args_fa
    
    # 4.1. Sequential
    # when using inner_apply_receives_labels=True, inner_apply_returns_labels is set to True by default, unless
    # we indicate its value
    component0=GCComponent(test_func=func, inner_apply_receives_labels=True, inner_apply_returns_labels=False)
    component=GCComponent(test_func=func, inner_apply_receives_labels=True, inner_apply_returns_labels=False)
    result = Sequential (component0, component).fit_apply (*args_fa)
    assert result==args
    assert component.args==args_fa
    #result
    #component.args
    
    # -----------------------------------------
    # 5. receives_labels_returns_labels_one_X
    func = receives_labels_returns_labels_one_X
    args = ([10], )
    args_fa = ([10], [1])
    result = GCComponent(test_func=func).apply (*args_fa)
    assert result==args_fa
    
    component=GCComponent(test_func=func, inner_apply_receives_labels=True)
    result = component.fit_apply (*args_fa)
    assert result==args_fa
    assert component.args==args_fa
    
    # 5.1. Sequential
    component0=GCComponent(test_func=func, inner_apply_receives_labels=True)
    component=GCComponent(test_func=func, inner_apply_receives_labels=True)
    result = Sequential (component0, component).fit_apply (*args_fa)
    assert result==args_fa
    assert component.args==args_fa
    
    # -----------------------------------------
    # 6. receives_labels_returns_labels_two_X
    func = receives_labels_returns_labels_two_X
    args = ([10], [20])
    args_fa = ([10], [20], [1])
    result = GCComponent(test_func=func).apply (*args_fa)
    assert result==args_fa
    
    component=GCComponent(test_func=func, inner_apply_receives_labels=True)
    result = component.fit_apply (*args_fa)
    assert result==args_fa
    assert component.args==args_fa
    
    # 6.1. Sequential
    component0=GCComponent(test_func=func, inner_apply_receives_labels=True)
    component=GCComponent(test_func=func, inner_apply_receives_labels=True)
    result = Sequential (component0, component).fit_apply (*args_fa)
    assert result==args_fa
    assert component.args==args_fa


# %% ../../../nbs/00_tests/core/tst.data_conversion.ipynb 8
def test_may_have_y ():
    data_converter = GenericConverter ()
    assert data_converter._may_have_y (
                 ([1,2,3,4], np.array ([[2,1,3],[3,4,5]]), [1,2,4,5])
                 )
    
    assert data_converter._may_have_y (
                 ('yes', np.array ([[2,1,3],[3,4,5]]), [1,2])
                 )
    
    assert not data_converter._may_have_y (
                ([1,2,3,4], np.array ([[2,1,3],[3,4,5]]), [1,2,4,5,6])
                )
    
    assert not data_converter._may_have_y (
                 ([1,2,3,4], np.array ([[2,1,3],[3,4,5]]), [1,2,4])
                 )
    
    assert not data_converter._may_have_y (
                ([1,2,3,4], np.array ([[2,1,3],[3,4,5]]), 3)
                )
                 
    assert not data_converter._may_have_y (
                 ('yes', 'no', [1,2])
                 )


# %% ../../../nbs/00_tests/core/tst.data_conversion.ipynb 9
def test_standard_converter_in_component ():
    component = Min10direct (data_converter='StandardConverter')
    
    X, y = np.array([1,2,3]), np.array([0,1,0])
    
    Xr = component.fit_apply (X, y)
    assert (Xr==X*10+X.min()).all()
    
    Xr, yr = component.fit_apply (X, y, sequential_fit_apply=True)
    assert (Xr==X*10+X.min()).all()
    assert (yr==y).all()
    
    component = SumXY (data_converter='StandardConverter')
    
    Xr = component.fit_apply ((X,X*2), y=None)
    assert (Xr==X+X*2).all()
    
    Xr = component.fit_apply ((X,X*2), y=None, sequential_fit_apply=True)
    assert (Xr==X+X*2).all()
    
    #Xr, yr = component.fit_apply ((X,X*2), y, sequential_fit_apply=True)
    Xr, yr = component.fit_apply ((X,X*2), y, sequential_fit_apply=True)
    assert (Xr==X+X*2).all()
    assert (yr==y).all()


# %% ../../../nbs/00_tests/core/tst.data_conversion.ipynb 10
def test_standard_converter ():
    X, y = np.array([[1,2,3]]), np.array([0,1,0])
    
    dc = StandardConverter ()
    
    Xr, yr = dc.convert_before_fitting (X, y)
    assert (Xr==X).all().all() and Xr.shape==(1, 3)
    assert (yr==y).all()
    
    Xr, yr = dc.convert_before_applying (X, y)
    assert (Xr==X).all().all() and Xr.shape==(1, 3)
    assert (yr==y).all()
    
    Xr = dc.convert_before_applying (X, y, fit_apply=True)
    assert (Xr==X).all().all() and Xr.shape==(1, 3)
    
    Xr, yr = dc.convert_after_applying (X, sequential_fit_apply=True)
    assert (Xr==X).all().all() and Xr.shape==(1, 3)
    assert (yr==y).all()
    
    Xr = dc.convert_before_applying (X, y, fit_apply=True)
    assert (Xr==X).all().all() and Xr.shape==(1, 3)
    
    Xr = dc.convert_after_applying (X)
    assert (Xr==X).all().all() and Xr.shape==(1, 3)
    
    Xr, yr = dc.convert_before_applying ((X,X*2), y)
    assert type(Xr) is tuple and len(Xr)==2
    assert (Xr[0]==X).all().all() and Xr[0].shape==(1, 3)
    assert (Xr[1]==X*2).all().all() and Xr[1].shape==(1, 3)
    assert (yr==y).all()
    
    Xr = dc.convert_before_applying ((X,X*2), y, fit_apply=True)
    assert type(Xr) is tuple and len(Xr)==2
    assert (Xr[0]==X).all().all() and Xr[0].shape==(1, 3)
    assert (Xr[1]==X*2).all().all() and Xr[1].shape==(1, 3)
    
    Xr, yr = dc.convert_after_applying ((X, X*2), sequential_fit_apply=True)
    assert type(Xr) is tuple and len(Xr)==2
    assert (Xr[0]==X).all().all() and Xr[0].shape==(1, 3)
    assert (yr==y).all()    


# %% ../../../nbs/00_tests/core/tst.data_conversion.ipynb 11
def test_pandas_converter ():
    dc = PandasConverter()
    
    # First case: if the input is a DataFrame, the output is a DataFrame, 
    # even when the transformer outputs a numpy array
    dc = PandasConverter()
    X, y = pd.DataFrame({'a':[1,2,3],'b':[4,5,6]}), np.array([0,1,0])
    Xr, yr = dc.convert_before_fitting (X, y)
    assert (X==Xr).all().all() and (y==yr).all() and type(Xr)==type(X) and type(yr)==type(y)
    Xr = dc.convert_before_applying (X)
    assert (X==Xr).all().all() and type(Xr)==type(X)
    Xo = dc.convert_after_applying (Xr.values)
    assert (X==Xo).all().all() and type(Xo)==type(X)
    
    # Second case: the transformer outputs a DataFrame
    Xo = dc.convert_after_applying (Xr)
    assert (X==Xo).all().all()
    
    # Third case: if the input is a numpy array, the output is a numpy array, 
    # when the transformer outputs a numpy array
    X, y = np.array([[1,2,3],[4,5,6]]), np.array([0,1,0])
    Xr, yr = dc.convert_before_fitting (X, y)
    assert (X==Xr).all().all() and (y==yr).all() and type(Xr)==type(X) and type(yr)==type(y)
    Xr = dc.convert_before_applying (X)
    assert (X==Xr).all().all() and type(Xr)==type(X)
    Xo = dc.convert_after_applying (Xr)
    assert (X==Xo).all().all() and type(Xo)==type(X)
    
    # Fourth case: if the transformer outputs a DataFrame, the output is 
    # a DataFrame, even if the input was a numpy array. 
    # TODO: we might want to have the possibility to output a numpy 
    # array in this case.
    Xo = dc.convert_after_applying (pd.DataFrame(Xr))
    assert (X==Xo).all().all() and type(Xo)==pd.DataFrame


# %% ../../../nbs/00_tests/core/tst.data_conversion.ipynb 12
def test_window2d_to_3d_converter ():
    df = generate_input_for_window_generator ()
    window_generator = WindowGenerator(sequence_length=3, sequence_stride=1, sampling_interval=60)
    window_data = window_generator.transform(df)
    assert window_data.shape==(91, 7)
    
    dc = Window2Dto3Dconverter (sequence_length=3)
    dfr = dc.convert_before_applying(window_data)
    assert dfr.shape==(91, 3, 2)
    
    window_datar = dc.convert_after_applying(dfr)
    #print (window_datar.shape)
    assert window_datar.shape==(91, 7)
    
    dfr2,y = dc.convert_before_fitting (window_data)
    assert dfr2.shape==(91, 3, 2) and y.shape==(91,)
    
    aux = dc.convert_after_fitting (dfr2)[0]
    assert aux.shape==(91, 3, 2)
    
    assert (np.unique(dfr.sum(axis=1))==[30,33,60,63]).all()
    assert (np.where(dfr.sum(axis=1)[:,0]==33)[0]==range(22,44)).all()
    assert (np.where(dfr.sum(axis=1)[:,1]==63)[0]==range(22,44)).all()


# %% ../../../nbs/00_tests/core/tst.data_conversion.ipynb 13
def test_data_converter_factory ():
    converter = data_converter_factory ('PandasConverter', separate_labels=False)
    assert type(converter) is PandasConverter
    assert converter.separate_labels is False

