# AUTOGENERATED! DO NOT EDIT! File to edit: ../../../nbs/00_tests/utils/tst.utils.ipynb.

# %% auto 0
__all__ = ['sh_imported', 'test_make_reproducible', 'test_set_logger', 'test_set_tf_loglevel', 'test_get_top_function',
           'test_get_calling_modules', 'test_check_last_part', 'test_action', 'test_save_config', 'test_store_attr',
           'test_get_hierarchy', 'test_replace_attr_and_store', 'test_replace_attr_and_store_no_rec']

# %% ../../../nbs/00_tests/utils/tst.utils.ipynb 2
from dsblocks.utils.utils import *

# %% ../../../nbs/00_tests/utils/tst.utils.ipynb 3
import pytest
import numpy as np
from sklearn.utils import Bunch
import os
import joblib
from IPython.display import display
import pandas as pd
import logging
import shutil
from pathlib import Path
import copy
#try:
#    import sh
#    sh_imported = True
#except ImportError:
#    sh_imported = False

from sklearn.utils import Bunch

import dsblocks.config.bt_defaults as dflt
sh_imported = False
from dsblocks.core.utils import Comparator
from sklearn.utils import Bunch

# %% ../../../nbs/00_tests/utils/tst.utils.ipynb 4
def test_make_reproducible ():
    make_reproducible ()
    x = np.random.rand(10)
    make_reproducible ()
    x2 = np.random.rand(10)
    assert (x==x2).all()


# %% ../../../nbs/00_tests/utils/tst.utils.ipynb 5
def test_set_logger ():
    path_results = 'test_logger'
    logger = set_logger ('test', path_results=path_results)
    assert os.listdir ('test_logger')==['null.log']
    assert logger.level==logging.WARNING
    
    logger = set_logger ('test', path_results=path_results, verbose=0)
    assert sorted(os.listdir ('test_logger'))==['null.log', 'test.log']
    assert logger.level==logging.WARNING
    
    logger = set_logger ('test', path_results=path_results, verbose=1)
    assert logger.level==logging.INFO
    
    for hdlr in logger.handlers[:]:  
        assert hdlr.level==logging.INFO
    
    delete_logger ('test', path_results=path_results)
    assert os.listdir ('test_logger')==['null.log']
    
    logger = set_empty_logger ()
    assert os.listdir ('test_logger')==['null.log']
    
    shutil.rmtree (path_results)


# %% ../../../nbs/00_tests/utils/tst.utils.ipynb 6
def test_set_tf_loglevel ():
    set_tf_loglevel (logging.DEBUG)
    assert logging.getLogger('tensorflow').getEffectiveLevel()==logging.DEBUG


# %% ../../../nbs/00_tests/utils/tst.utils.ipynb 7
def test_get_top_function ():
    def f (x):
        g (x)
    def g (x):
        h (x)
    def h (x):
        i (x)
    def i (x):
        j (x)
    def j (x):
        function = get_top_function (folder='/tmp/ipykernel_')
        print (function, x)
    
    f (5)


# %% ../../../nbs/00_tests/utils/tst.utils.ipynb 8
def test_get_calling_modules ():
    def f (x):
        g (x)
    def g (x):
        h (x)
    def h (x):
        i (x)
    def i (x):
        j (x)
    def j (x):
        modules = get_calling_modules (folder='all')
        print (modules[-1], x)
    
        modules = get_calling_modules (folder='all', but={'<module>'})
        print ('\n', modules[-1], x)
    
    f (5)


# %% ../../../nbs/00_tests/utils/tst.utils.ipynb 9
def test_check_last_part ():
    check_last_part (Path ('/hello/there/world.txt'), 'there/world.txt')
    with pytest.raises (AssertionError):
        check_last_part (Path ('/hello/there/world.txt'), '/there/world.txt')


# %% ../../../nbs/00_tests/utils/tst.utils.ipynb 10
def test_action ():
    from IPython.testing.globalipapp import start_ipython


# %% ../../../nbs/00_tests/utils/tst.utils.ipynb 11
def test_save_config ():
    path_results='test_save_config'
    remove_previous_results (path_results)
    save_config (path_config_file=f'{path_results}/config.json')
    assert os.path.exists (f'{path_results}/complete/config.json')
    assert os.path.exists (f'{path_results}/default/config.json')
    remove_previous_results (path_results)
    
    config = {'par1': [1,2],
              'par2': dict (key1='yes',
                            key2=dict(part1=1.098,
                                      part2=[1,2.34,2,3,4.5],
                                      part3=['aaa','bbb'])
                           ),
              'jiji': 23.6,
              'MyClass': dict(hey=12),
              'path': 'path/to/file',
              'par3': [2,3,5.1],
              'yes': 'hello',
              'no': 'bye',
              'yesdiff': 'toremove',
              'last': 'zzz'
             }
    dflt_config = copy.deepcopy(config)
    dflt_config.update (jiji = 23.5, par3=[2,3,5.2], yesdiff='to_remove')
    del dflt_config['MyClass']
    del dflt_config['no']
    
    save_config (path_config_file=f'{path_results}/config.json', dflt=dflt_config, **config)
    
    c = Comparator ()
    
    config_r = json_load (f'{path_results}/complete/config.json')
    assert c.compare (config_r, config)==''
    
    #import pprint
    #pprint.pprint (config_r)
    
    config_r = json_load (f'{path_results}/required/config.json')
    assert c.compare (config_r, {
                         'MyClass': {'hey': 12},
                         'jiji': 23.6,
                         'par3': [2, 3, 5.1],
                         'yesdiff': 'toremove'})==''
    
    dflt_config['par2']['key2']['part3']=['aaa','bab']
    save_config (path_config_file=f'{path_results}/config.json', dflt=dflt_config, **config)
    
    config_r = json_load (f'{path_results}/required/config.json')
    assert c.compare (config_r, {
         'MyClass': {'hey': 12},
         'jiji': 23.6,
         'par2': {'key1': 'yes',
                  'key2': {'part1': 1.098,
                           'part2': [1, 2.34, 2, 3, 4.5],
                           'part3': ['aaa', 'bbb']}},
         'par3': [2, 3, 5.1],
         'yesdiff': 'toremove'})==''
    
    del config['par2']
    save_config (path_config_file=f'{path_results}/config.json', dflt=dflt_config, **config)
    
    config_r = json_load (f'{path_results}/required/config.json')
    assert c.compare (config_r, {
         'MyClass': {'hey': 12},
         'jiji': 23.6,
         'par3': [2, 3, 5.1],
         'yesdiff': 'toremove'})==''
    
    config_r = json_load (f'{path_results}/def_diff/config.json')
    assert c.compare(config_r, {'jiji': 23.5, 'par3': [2, 3, 5.2], 'yesdiff': 'to_remove'})==''
    
    remove_previous_results (path_results)


# %% ../../../nbs/00_tests/utils/tst.utils.ipynb 12
def test_store_attr ():
    def f (x=3, y=4, d=[1,2,3]):
        my_args = Bunch ()
        store_attr (store_args=False, self=my_args)
        return my_args
    
    my_args = f (y=40, d=[1,20,3])
    assert my_args == {'x': 3, 'y': 40, 'd': [1, 20, 3]}
    
    class A:
        def __init__ (self, x=3, y=4):
            store_attr ()
        def f (self, a=1, b=2):
            my_args = Bunch ()
            store_attr (store_args=False, self=my_args)
            return my_args
    
    a = A(y=40)
    assert a.x==3 and a.y==40
    my_args = a.f (b=20)
    assert my_args == {'a':1, 'b': 20}


# %% ../../../nbs/00_tests/utils/tst.utils.ipynb 13
def test_get_hierarchy ():
    def f (**kwargs):
        return B(**kwargs)
    
    class A ():
        def __init__ (self, x=3, **kwargs):
            self.hierarchy_level = get_hierarchy_level(base_class=A)
    
    class B(A):
        def __init__ (self, y=10, **kwargs):
            super().__init__ (**kwargs)
            self.ab = A (**kwargs)
    
    class C(B):
        def __init__ (self, z=100, **kwargs):
            super().__init__ (**kwargs)
            self.a = A(**kwargs)
            self.b = f(**kwargs)
    class D(C):
        def __init__ (self, h=100, **kwargs):
            super().__init__ (**kwargs)
            self.c = C(**kwargs)
            self.b = f(**kwargs)
    a = A()
    b = B()
    c = C()
    d = D()
    
    assert (a.hierarchy_level==0 and b.hierarchy_level==0 and c.hierarchy_level==0
            and c.a.hierarchy_level==1 and c.b.hierarchy_level==1 and c.ab.hierarchy_level==1 
            and c.b.ab.hierarchy_level==2 
            and d.hierarchy_level == 0 and d.a.hierarchy_level == 1 and d.b.hierarchy_level == 1
            and d.ab.hierarchy_level == 1 
            and d.b.hierarchy_level==1 and d.b.ab.hierarchy_level==2 and d.c.b.ab.hierarchy_level==3)


# %% ../../../nbs/00_tests/utils/tst.utils.ipynb 14
def test_replace_attr_and_store ():
    def f (**kwargs):
        return B(**kwargs)
    
    class A ():
        def __init__ (self, x=3, **kwargs):
            replace_attr_and_store (base_class=A)
    
    class B(A):
        def __init__ (self, y=10, **kwargs):
            super().__init__ (**kwargs)
            self.ab = A (**kwargs)
    
    class C(A):
        def __init__ (self, z=100, **kwargs):
            super().__init__ (**kwargs)
            self.a = A(**kwargs)
            self.b = f(**kwargs)
    a = A()
    b = B()
    c = C()
    
    assert a.x==3 and b.y==10 and b.x==3 and c.z==100 and c.x==3 and c.a.x==3 and c.b.y==10 and c.b.x==3
    
    with pytest.raises (AttributeError):
        print (c.y)
    
    with pytest.raises (AttributeError):
        print (c.a.y)
    
    with pytest.raises (AttributeError):
        print (c.a.z)
    
    with pytest.raises (AttributeError):
        print (b.z)
    
    with pytest.raises (AttributeError):
        print (b.ab.y)
    
    # **************************************************
    # test changing the argument
    # **************************************************
    def f2 (y=10, **kwargs):
        y = 2*y
        return B2 (y=y, **kwargs)
    
    class A2 ():
        def __init__ (self, x='hello', **kwargs):
            x=f'{x} world'
            replace_attr_and_store (base_class=A2)
    
    class B2 (A2):
        def __init__ (self, y=10, **kwargs):
            super().__init__ (**kwargs)
            self.ab = A2 (**kwargs)
    
    class C2 (A2):
        def __init__ (self, z=100, **kwargs):
            super().__init__ (**kwargs)
            self.a = A2(**kwargs)
            self.b = f2 (**kwargs)
    a = A2()
    b = B2()
    c = C2()
    assert (a.x, b.x, b.ab.x) == ('hello world', 'hello world', 'hello world')
    assert c.b.y == 20
    
    a = A2 ('hey')
    b = B2 ()
    assert (a.x, b.x, b.ab.x) == ('hey world', 'hello world', 'hello world')
    
    c = C2 (y=3, x='Hi')
    assert (c.b.y, c.b.x) == (6, 'Hi world')
    
    # **************************************************
    # test error_if_present
    # **************************************************
    
    def f3 (**kwargs):
        return B(**kwargs)
    
    class A3 ():
        def __init__ (self, x=3, ignore=set(), **kwargs):
            replace_attr_and_store (base_class=A3, error_if_present=True,
                                    ignore=ignore, but='ignore')
    
    class B3(A3):
        def __init__ (self, y=10, **kwargs):
            super().__init__ (**kwargs)
            self.ab = A3 (**kwargs)
    
    
    a = A3()
    
    b = B3()
    
    b2 = B3(x=5, y=20)
    
    assert a.x==3 and b.y==10 and b.x==3 and b.ab.x==3 and b2.x==5 and b2.y==20 and b2.ab.x==5
    
    # *******************
    # test using same field in B4 and in A3, but
    # B4 passes that value to A3 in super()
    # *****************
    class B4(A3):
        def __init__ (self, x=30, y=10, **kwargs):
            super().__init__ (x=x, **kwargs)
            self.ab = A3 (**kwargs)
    
    b3 = B4 ()
    assert b3.x==30 and b3.ab.x==3 and b3.y==10
    
    # *******************
    # test using same field in B4 and in A3, but
    # B4 passes that value to A3 in super(),
    # after modifying it
    # *****************
    class B5(A3):
        def __init__ (self, x=30, y=10, **kwargs):
            x = x*2
            super().__init__ (x=x, **kwargs)
            self.ab = A3 (**kwargs)
    
    b3 = B5 ()
    assert b3.x==60 and b3.ab.x==3 and b3.y==10
    
    b3 = B5 (x=6)
    assert b3.x==12 and b3.ab.x==3 and b3.y==10
    
    # *******************
    # test using same field in D and in A3, but
    # the field is modified in a parent B5
    # *****************
    class D(B5):
        def __init__ (self, x=40, z=100, **kwargs):
            super().__init__ (x=x, **kwargs)
            self.b = B5(**kwargs)
    
    with pytest.raises (RuntimeError):
        d = D ()
    
    d = D(ignore={'x'})
    assert d.x==80 and d.y==10 and d.z==100 and d.b.x==60 and d.b.y==10
    
    d = D (x=9, ignore={'x'})
    assert d.x==18 and d.y==10 and d.z==100 and d.b.x==60 and d.b.y==10
    
    assert not hasattr(d, 'ignore')
    
    # *******************
    # test having a field with same name
    # *******************
    class C3(A3):
        def __init__ (self, x=4, z=100, **kwargs):
            super().__init__ (**kwargs)
            self.a = A3(**kwargs)
            self.b = f3(**kwargs)
    
    with pytest.raises (RuntimeError):
        c = C3()
    
    # **************************************************
    # test overwrite
    # **************************************************
    class A4 ():
        def __init__ (self, x=3, **kwargs):
            replace_attr_and_store (base_class=A4, overwrite=True)
    
    class C5(A4):
        def __init__ (self, x=4, z=100, **kwargs):
            super().__init__ (x=x, **kwargs)
            self.a = A4(**kwargs)
    
    c = C5 ()
    assert c.x == 4 and c.a.x==3


# %% ../../../nbs/00_tests/utils/tst.utils.ipynb 15
def test_replace_attr_and_store_no_rec ():
    # test without recursiveness
    
    def f (x=3, y=4, z=5, **kwargs):
        estimator = Bunch ()
        replace_attr_and_store (recursive=False,
                                self=estimator, include_first=True)
        return estimator
    
    estimator = f (y=40, z=50)
    
    stored_args = estimator.pop('__stored_args__')
    not_stored_args = estimator.pop('__not_stored_args__')
    assert estimator=={'x': 3, 'y': 40, 'z': 50}
    assert stored_args == estimator
    assert not_stored_args == {''}
    
    # test without kwargs
    def g (x=3, y=4, z=5):
        estimator = Bunch ()
        replace_attr_and_store (recursive=False,
                                self=estimator, include_first=True)
        return estimator
    
    estimator = g (y=40, z=50)
    
    stored_args = estimator.pop('__stored_args__')
    not_stored_args = estimator.pop('__not_stored_args__')
    assert estimator=={'x': 3, 'y': 40, 'z': 50}
    assert stored_args == estimator
    
    # test without kwargs and with replace_generic_attr=False
    def h (x=3, y=4, z=5):
        estimator = Bunch ()
        replace_attr_and_store (recursive=False,
                                self=estimator, include_first=True, replace_generic_attr=False)
        return estimator
    
    estimator = h (y=40, z=50)
    
    stored_args = estimator.pop('__stored_args__')
    not_stored_args = estimator.pop('__not_stored_args__')
    assert estimator=={'x': 3, 'y': 40, 'z': 50}
    assert stored_args == estimator

