#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Sun Nov  8 13:00:27 2020 by generateDS.py version 2.36.2.
# Python 3.8.5 (default, Jul 28 2020, 12:59:40)  [GCC 9.3.0]
#
# Command line options:
#   ('-o', 'emllib.py')
#   ('--member-specs', 'list')
#
# Command line arguments:
#   ../xsd/eml.xsd
#
# Command line:
#   /home/ju/Projets/pndb/metasnake/.py38/bin/generateDS -o "emllib.py" --member-specs="list" ../xsd/eml.xsd
#
# Current working directory (os.getcwd()):
#   emllib220
#

from six.moves import zip_longest
import os
import sys
import re as re_
import base64
import datetime as datetime_
import decimal as decimal_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
SaveElementTreeNode = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    try:
        if isinstance(infile, os.PathLike):
            infile = os.path.join(infile)
    except AttributeError:
        pass
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for an example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#
# Additionally, the generatedsnamespaces module can contain a python
# dictionary named GenerateDSNamespaceTypePrefixes that associates element
# types with the namespace prefixes that are to be added to the
# "xsi:type" attribute value.  See the exportAttributes method of
# any generated element type and the generation of "xsi:type" for an
# example of the use of this table.
# An example table:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceTypePrefixes = {
#         "ElementtypeC": "aaa:",
#         "ElementtypeD": "bbb:",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}
try:
    from generatedsnamespaces import GenerateDSNamespaceTypePrefixes as GenerateDSNamespaceTypePrefixes_
except ImportError:
    GenerateDSNamespaceTypePrefixes_ = {}

#
# You can replace the following class definition by defining an
# importable module named "generatedscollector" containing a class
# named "GdsCollector".  See the default class definition below for
# clues about the possible content of that class.
#
try:
    from generatedscollector import GdsCollector as GdsCollector_
except ImportError:

    class GdsCollector_(object):

        def __init__(self, messages=None):
            if messages is None:
                self.messages = []
            else:
                self.messages = messages

        def add_message(self, msg):
            self.messages.append(msg)

        def get_messages(self):
            return self.messages

        def clear_messages(self):
            self.messages = []

        def print_messages(self):
            for msg in self.messages:
                print("Warning: {}".format(msg))

        def write_messages(self, outstream):
            for msg in self.messages:
                outstream.write("Warning: {}\n".format(msg))


#
# The super-class for enum types
#

try:
    from enum import Enum
except ImportError:
    Enum = object

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        __hash__ = object.__hash__
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_parse_string(self, input_data, node=None, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_parse_integer(self, input_data, node=None, input_name=''):
            try:
                ival = int(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires integer value: %s' % exp)
            return ival
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            try:
                value = int(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires integer value')
            return value
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integer valuess')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_parse_float(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires float or double value: %s' % exp)
            return fval_
        def gds_validate_float(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires float value')
            return value
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of float values')
            return values
        def gds_format_decimal(self, input_data, input_name=''):
            return_value = '%s' % input_data
            if '.' in return_value:
                return_value = return_value.rstrip('0')
                if return_value.endswith('.'):
                    return_value = return_value.rstrip('.')
            return return_value
        def gds_parse_decimal(self, input_data, node=None, input_name=''):
            try:
                decimal_value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return decimal_value
        def gds_validate_decimal(self, input_data, node=None, input_name=''):
            try:
                value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return value
        def gds_format_decimal_list(self, input_data, input_name=''):
            return ' '.join([self.gds_format_decimal(item) for item in input_data])
        def gds_validate_decimal_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    decimal_.Decimal(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of decimal values')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_parse_double(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires double or float value: %s' % exp)
            return fval_
        def gds_validate_double(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires double or float value')
            return value
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(
                        node, 'Requires sequence of double or float values')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_parse_boolean(self, input_data, node=None, input_name=''):
            if input_data in ('true', '1'):
                bval = True
            elif input_data in ('false', '0'):
                bval = False
            else:
                raise_parse_error(node, 'Requires boolean value')
            return bval
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            if input_data not in (True, 1, False, 0, ):
                raise_parse_error(
                    node,
                    'Requires boolean value '
                    '(one of True, 1, False, 0)')
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in (True, 1, False, 0, ):
                    raise_parse_error(
                        node,
                        'Requires sequence of boolean values '
                        '(one of True, 1, False, 0)')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_check_cardinality_(
                self, value, input_name,
                min_occurs=0, max_occurs=1, required=None):
            if value is None:
                length = 0
            elif isinstance(value, list):
                length = len(value)
            else:
                length = 1
            if required is not None :
                if required and length < 1:
                    self.gds_collector_.add_message(
                        "Required value {}{} is missing".format(
                            input_name, self.gds_get_node_lineno_()))
            if length < min_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is below "
                    "the minimum allowed, "
                    "expected at least {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        min_occurs, length))
            elif length > max_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is above "
                    "the maximum allowed, "
                    "expected at most {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        max_occurs, length))
        def gds_validate_builtin_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value, input_name=input_name)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_validate_defined_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            # provide default value in case option --disable-xml is used.
            content = ""
            content = etree_.tostring(node, encoding="unicode")
            return content
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            def excl_select_objs_(obj):
                return (obj[0] != 'parent_object_' and
                        obj[0] != 'gds_collector_')
            if type(self) != type(other):
                return False
            return all(x == y for x, y in zip_longest(
                filter(excl_select_objs_, self.__dict__.items()),
                filter(excl_select_objs_, other.__dict__.items())))
        def __ne__(self, other):
            return not self.__eq__(other)
        # Django ETL transform hooks.
        def gds_djo_etl_transform(self):
            pass
        def gds_djo_etl_transform_db_obj(self, dbobj):
            pass
        # SQLAlchemy ETL transform hooks.
        def gds_sqa_etl_transform(self):
            return 0, None
        def gds_sqa_etl_transform_db_obj(self, dbobj):
            pass
        def gds_get_node_lineno_(self):
            if (hasattr(self, "gds_elementtree_node_") and
                    self.gds_elementtree_node_ is not None):
                return ' near line {}'.format(
                    self.gds_elementtree_node_.sourceline)
            else:
                return ""
    
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
# Set this to false in order to deactivate during export, the use of
# name space prefixes captured from the input document.
UseCapturedNS_ = True
CapturedNsmap_ = {}
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


def encode_str_2_3(instr):
    return instr


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if node is not None:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name_=name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element, mapping_=None, nsmap_=None):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self, mapping_=None, nsmap_=None):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class Action(str, Enum):
    INSTALL='install'
    ASSERT='assert'


class CardinalityChildOccurancesType(str, Enum):
    MANY='many'


class CellGeometryType(str, Enum):
    PIXEL='pixel'
    MATRIX='matrix'


class CellValueType(str, Enum):
    VALUES='Values'
    CODED='Coded'
    RGB='RGB'
    CODES='Codes'
    HIS='HIS'
    HLS='HLS'
    TEK_HVC='tekHVC'


class DescriptorType(str, Enum):
    CLIMATE='climate'
    HYDROLOGY='hydrology'
    SOILS='soils'
    GEOLOGY='geology'
    DISTURBANCE='disturbance'
    BAILEY='bailey'
    BIOME='biome'


class FunctionType(str, Enum):
    DOWNLOAD='download'
    INFORMATION='information'


class GeometryType(str, Enum):
    POINT='Point'
    LINE_STRING='LineString'
    LINEAR_RING='LinearRing'
    POLYGON='Polygon'
    MULTI_POINT='MultiPoint'
    MULTI_LINE_STRING='MultiLineString'
    MULTI_POLYGON='MultiPolygon'
    MULTI_GEOMETRY='MultiGeometry'


class ImagingConditionCode(str, Enum):
    BLURREDIMAGE='blurredimage'
    CLOUD='cloud'
    DEGRADING_OBLIQUITY='degradingObliquity'
    FOG='fog'
    HEAVY_SMOKEOR_DUST='heavySmokeorDust'
    NIGHT='night'
    RAIN='rain'
    SEMI_DARKNESS='semiDarkness'
    SHADOW='shadow'
    SNOW='snow'
    TERRAIN_MASKING='terrainMasking'


class KeyTypeCode(str, Enum):
    PLACE='place'
    STRATUM='stratum'
    TEMPORAL='temporal'
    THEME='theme'
    TAXONOMIC='taxonomic'


class LengthUnitType(str, Enum):
    METER='meter'
    NANOMETER='nanometer'
    MICROMETER='micrometer'
    MICRON='micron'
    MILLIMETER='millimeter'
    CENTIMETER='centimeter'
    DECIMETER='decimeter'
    DEKAMETER='dekameter'
    HECTOMETER='hectometer'
    KILOMETER='kilometer'
    MEGAMETER='megameter'
    ANGSTROM='angstrom'
    INCH='inch'
    FOOT_US='Foot_US'
    FOOT='foot'
    FOOT__GOLD__COAST='Foot_Gold_Coast'
    FATHOM='fathom'
    NAUTICAL_MILE='nauticalMile'
    YARD='yard'
    YARD__INDIAN='Yard_Indian'
    LINK__CLARKE='Link_Clarke'
    YARD__SEARS='Yard_Sears'
    MILE='mile'


class MaintUpFreqType(str, Enum):
    ANNUALLY='annually'
    AS_NEEDED='asNeeded'
    BIANNUALLY='biannually'
    CONTINUALLY='continually'
    DAILY='daily'
    IRREGULAR='irregular'
    MONTHLY='monthly'
    NOT_PLANNED='notPlanned'
    WEEKLY='weekly'
    UNKNOWN='unknown'
    UNKOWN='unkown'
    OTHER_MAINTENANCE_PERIOD='otherMaintenancePeriod'


class MassUnitType(str, Enum):
    KILOGRAM='kilogram'
    NANOGRAM='nanogram'
    MICROGRAM='microgram'
    MILLIGRAM='milligram'
    CENTIGRAM='centigram'
    DECIGRAM='decigram'
    GRAM='gram'
    DEKAGRAM='dekagram'
    HECTOGRAM='hectogram'
    MEGAGRAM='megagram'
    TONNE='tonne'
    POUND='pound'
    TON='ton'


class NumberType(str, Enum):
    NATURAL='natural'
    WHOLE='whole'
    INTEGER='integer'
    REAL='real'


class RoleType(str, Enum):
    CONTENT_PROVIDER='contentProvider'
    CUSTODIAN_STEWARD='custodianSteward'
    OWNER='owner'
    USER='user'
    DISTRIBUTOR='distributor'
    METADATA_PROVIDER='metadataProvider'
    ORIGINATOR='originator'
    POINT_OF_CONTACT='pointOfContact'
    PRINCIPAL_INVESTIGATOR='principalInvestigator'
    PROCESSOR='processor'
    PUBLISHER='publisher'
    AUTHOR='author'
    EDITOR='editor'


class ScopeType(str, Enum):
    SYSTEM='system'
    DOCUMENT='document'


class TopologyLevel(str, Enum):
    GEOMETRY_ONLY='geometryOnly'
    NON_PLANAR_GRAPH='nonPlanarGraph'
    PLANAR_LINE_GRAPH='planarLineGraph'
    FULL_PLANAR_GRAPH='fullPlanarGraph'
    SURFACE_GRAPH='surfaceGraph'
    FULL_TOPOLOGY_3_D='fullTopology3D'


class angleUnitType(str, Enum):
    RADIAN='radian'
    DEGREE='degree'
    GRAD='grad'
    STERADIAN='steradian'


class angleUnits(str, Enum):
    RADIAN='radian'
    DEGREE='degree'
    GRAD='grad'
    DEGREE_1='degree'
    GRAD_1='grad'


class attributeOrientationType(str, Enum):
    COLUMN='column'
    ROW='row'


class caseSensitiveType(str, Enum):
    YES='yes'
    NO='no'


class collapseDelimitersType(str, Enum):
    YES='yes'
    NO='no'


class collapseDelimitersType26(str, Enum):
    YES='yes'
    NO='no'


class enforcedType(str, Enum):
    YES='yes'
    NO='no'


class horizCoordSysNameType(str, Enum):
    GCS__ABIDJAN__1987='GCS_Abidjan_1987'
    GCS__ACCRA='GCS_Accra'
    GCS__ADINDAN='GCS_Adindan'
    GCS__AFGOOYE='GCS_Afgooye'
    GCS__AGADEZ='GCS_Agadez'
    GCS__AIN_EL__ABD__1970='GCS_Ain_el_Abd_1970'
    GCS__ARC__1950='GCS_Arc_1950'
    GCS__ARC__1960='GCS_Arc_1960'
    GCS__AYABELLE='GCS_Ayabelle'
    GCS__BEDUARAM='GCS_Beduaram'
    GCS__BISSAU='GCS_Bissau'
    GCS__CAMACUPA='GCS_Camacupa'
    GCS__CAPE='GCS_Cape'
    GCS__CARTHAGE__DEGREE='GCS_Carthage_Degree'
    GCS__CARTHAGE__PARIS='GCS_Carthage_Paris'
    GCS__CARTHAGE='GCS_Carthage'
    GCS__CONAKRY__1905='GCS_Conakry_1905'
    GCS__COTE_D__IVOIRE='GCS_Cote_d_Ivoire'
    GCS__DABOLA='GCS_Dabola'
    GCS__DOUALA='GCS_Douala'
    GCS__EGYPT__1907='GCS_Egypt_1907'
    GCS__EUROPEAN__1950='GCS_European_1950'
    GCS__EUROPEAN__LIBYAN__DATUM__1979='GCS_European_Libyan_Datum_1979'
    GCS__GAROUA='GCS_Garoua'
    GCS__HARTEBEESTHOEK__1994='GCS_Hartebeesthoek_1994'
    GCS__KUWAIT__OIL__COMPANY='GCS_Kuwait_Oil_Company'
    GCS_KUDAMS='GCS_KUDAMS'
    GCS__LEIGON='GCS_Leigon'
    GCS__LIBERIA__1964='GCS_Liberia_1964'
    GCS__LOCODJO__1965='GCS_Locodjo_1965'
    GCS__LOME='GCS_Lome'
    GCS__MPORALOKO='GCS_Mporaloko'
    GCS__MADZANSUA='GCS_Madzansua'
    GCS__MAHE__1971='GCS_Mahe_1971'
    GCS__MALONGO__1987='GCS_Malongo_1987'
    GCS__MANOCA='GCS_Manoca'
    GCS__MASSAWA='GCS_Massawa'
    GCS__MERCHICH__DEGREE='GCS_Merchich_Degree'
    GCS__MERCHICH='GCS_Merchich'
    GCS__MHAST='GCS_Mhast'
    GCS__MINNA='GCS_Minna'
    GCS__MOZNET='GCS_Moznet'
    GCS__NAHRWAN__1967='GCS_Nahrwan_1967'
    GCS_NGN='GCS_NGN'
    GCS__NORD__SAHARA__1959='GCS_Nord_Sahara_1959'
    GCS__OBSERVATARIO='GCS_Observatario'
    GCS__OMAN='GCS_Oman'
    GCS__PALESTINE__1923='GCS_Palestine_1923'
    GCS_PDO__1993='GCS_PDO_1993'
    GCS__POINT__58='GCS_Point_58'
    GCS__POINTE__NOIRE='GCS_Pointe_Noire'
    GCS__QATAR__1948='GCS_Qatar_1948'
    GCS__QATAR='GCS_Qatar'
    GCS__SCHWARZECK='GCS_Schwarzeck'
    GCS__SIERRA__LEONE__1924='GCS_Sierra_Leone_1924'
    GCS__SIERRA__LEONE__1960='GCS_Sierra_Leone_1960'
    GCS__SIERRA__LEONE__1968='GCS_Sierra_Leone_1968'
    GCS__SOUTH__YEMEN='GCS_South_Yemen'
    GCS__SUDAN='GCS_Sudan'
    GCS__TANANARIVE__1925__PARIS='GCS_Tananarive_1925_Paris'
    GCS__TANANARIVE__1925='GCS_Tananarive_1925'
    GCS__TETE='GCS_Tete'
    GCS__TRUCIAL__COAST__1948='GCS_Trucial_Coast_1948'
    GCS__VOIROL__1875__DEGREE='GCS_Voirol_1875_Degree'
    GCS__VOIROL__1875__PARIS='GCS_Voirol_1875_Paris'
    GCS__VOIROL__1875='GCS_Voirol_1875'
    GCS__VOIROL__UNIFIE__1960__DEGREE='GCS_Voirol_Unifie_1960_Degree'
    GCS__VOIROL__UNIFIE__1960__PARIS='GCS_Voirol_Unifie_1960_Paris'
    GCS__VOIROL__UNIFIE__1960='GCS_Voirol_Unifie_1960'
    GCS__YEMEN_NGN__1996='GCS_Yemen_NGN_1996'
    GCS__YOFF='GCS_Yoff'
    GCS__CAMP__AREA='GCS_Camp_Area'
    GCS__DECEPTION__ISLAND='GCS_Deception_Island'
    GCS__AIN_EL__ABD__1970_1='GCS_Ain_el_Abd_1970'
    GCS__BATAVIA__JAKARTA='GCS_Batavia_Jakarta'
    GCS__BATAVIA='GCS_Batavia'
    GCS__BEIJING__1954='GCS_Beijing_1954'
    GCS__BUKIT__RIMPAH='GCS_Bukit_Rimpah'
    GCS__DEIR_EZ__ZOR='GCS_Deir_ez_Zor'
    GCS__EUROPEAN__1950_ED_77='GCS_European_1950_ED77'
    GCS__EUROPEAN__1950_1='GCS_European_1950'
    GCS__EVEREST_DEF__1962='GCS_Everest_def_1962'
    GCS__EVEREST_DEF__1967='GCS_Everest_def_1967'
    GCS__EVEREST_DEF__1975='GCS_Everest_def_1975'
    GCS__EVEREST__BANGLADESH='GCS_Everest_Bangladesh'
    GCS__EVEREST__INDIA__NEPAL='GCS_Everest_India_Nepal'
    GCS__EVEREST__1830='GCS_Everest_1830'
    GCS__EVEREST__MODIFIED='GCS_Everest_Modified'
    GCS__FAHUD='GCS_Fahud'
    GCS_FD__1958='GCS_FD_1958'
    GCS__GANDAJIKA__1970='GCS_Gandajika_1970'
    GCS__GUNUNG__SEGARA='GCS_Gunung_Segara'
    GCS__HANOI__1972='GCS_Hanoi_1972'
    GCS__HERAT__NORTH='GCS_Herat_North'
    GCS__HONG__KONG__1963='GCS_Hong_Kong_1963'
    GCS__HONG__KONG__1980='GCS_Hong_Kong_1980'
    GCS__HU__TZU__SHAN='GCS_Hu_Tzu_Shan'
    GCS__INDIAN__1954='GCS_Indian_1954'
    GCS__INDIAN__1960='GCS_Indian_1960'
    GCS__INDIAN__1975='GCS_Indian_1975'
    GCS__INDONESIAN__1974='GCS_Indonesian_1974'
    GCS__ISRAEL='GCS_Israel'
    GCS_JGD__2000='GCS_JGD_2000'
    GCS__KALIANPUR__1880='GCS_Kalianpur_1880'
    GCS__KALIANPUR__1937='GCS_Kalianpur_1937'
    GCS__KALIANPUR__1962='GCS_Kalianpur_1962'
    GCS__KALIANPUR__1975='GCS_Kalianpur_1975'
    GCS__KANDAWALA='GCS_Kandawala'
    GCS__KERTAU='GCS_Kertau'
    GCS__KOREAN__DATUM__1985='GCS_Korean_Datum_1985'
    GCS__KOREAN__DATUM__1995='GCS_Korean_Datum_1995'
    GCS__KUWAIT__OIL__COMPANY_1='GCS_Kuwait_Oil_Company'
    GCS_KUDAMS_1='GCS_KUDAMS'
    GCS__LUZON__1911='GCS_Luzon_1911'
    GCS__MAKASSAR__JAKARTA='GCS_Makassar_Jakarta'
    GCS__MAKASSAR='GCS_Makassar'
    GCS__NAHRWAN__1967_1='GCS_Nahrwan_1967'
    GCS_NGN_1='GCS_NGN'
    GCS__OMAN_1='GCS_Oman'
    GCS__PADANG__1884__JAKARTA='GCS_Padang_1884_Jakarta'
    GCS__PADANG__1884='GCS_Padang_1884'
    GCS__PALESTINE__1923_1='GCS_Palestine_1923'
    GCS__PULKOVO__1942='GCS_Pulkovo_1942'
    GCS__PULKOVO__1995='GCS_Pulkovo_1995'
    GCS__QATAR__1948_1='GCS_Qatar_1948'
    GCS__QATAR_1='GCS_Qatar'
    GCS__RASSADIRAN='GCS_Rassadiran'
    GCS__SAMBOJA='GCS_Samboja'
    GCS__SEGORA='GCS_Segora'
    GCS__SERINDUNG='GCS_Serindung'
    GCS__SOUTH__ASIA__SINGAPORE='GCS_South_Asia_Singapore'
    GCS__TIMBALAI__1948='GCS_Timbalai_1948'
    GCS__TOKYO='GCS_Tokyo'
    GCS__TRUCIAL__COAST__1948_1='GCS_Trucial_Coast_1948'
    GCS__AUSTRALIAN__1966='GCS_Australian_1966'
    GCS__AUSTRALIAN__1984='GCS_Australian_1984'
    GCS_GDA__1994='GCS_GDA_1994'
    GCS__NEW__ZEALAND__1949='GCS_New_Zealand_1949'
    GCS_NZGD__2000='GCS_NZGD_2000'
    GCS__AMERSFOORT='GCS_Amersfoort'
    GCS_ATF__PARIS='GCS_ATF_Paris'
    GCS__BELGE__1950__BRUSSELS='GCS_Belge_1950_Brussels'
    GCS__BELGE__1972='GCS_Belge_1972'
    GCS__BERN__1898__BERN='GCS_Bern_1898_Bern'
    GCS__BERN__1898='GCS_Bern_1898'
    GCS__BERN__1938='GCS_Bern_1938'
    GCS_CH_1903='GCS_CH1903+'
    GCS_CH_1903_1='GCS_CH1903'
    GCS__DATUM__73='GCS_Datum_73'
    GCS__DATUM__LISBOA__BESSEL='GCS_Datum_Lisboa_Bessel'
    GCS__DATUM__LISBOA__BESSEL_1='GCS_Datum_Lisboa_Bessel'
    GCS__DEALUL__PISCULUI__1933='GCS_Dealul_Piscului_1933'
    GCS__DEALUL__PISCULUI__1970='GCS_Dealul_Piscului_1970'
    GCS__DEUTSCHE__HAUPTDREIECKSNETZ='GCS_Deutsche_Hauptdreiecksnetz'
    GCS__ESTONIA__1937='GCS_Estonia_1937'
    GCS__ESTONIA__1992='GCS_Estonia_1992'
    GCS_ETRF__1989='GCS_ETRF_1989'
    GCS__EUROPEAN__1979='GCS_European_1979'
    GCS__EUROPEAN__1950_2='GCS_European_1950'
    GCS__EUROPEAN__1987='GCS_European_1987'
    GCS__GREEK__ATHENS='GCS_Greek_Athens'
    GCS__GREEK='GCS_Greek'
    GCS__HERMANNSKOGEL='GCS_Hermannskogel'
    GCS__HJORSEY__1955='GCS_Hjorsey_1955'
    GCS__HUNGARIAN__1972='GCS_Hungarian_1972'
    GCS_IRENET_95='GCS_IRENET95'
    GCS_KKJ='GCS_KKJ'
    GCS__LISBON__LISBON='GCS_Lisbon_Lisbon'
    GCS__LISBON='GCS_Lisbon'
    GCS_LKS__1994='GCS_LKS_1994'
    GCS__MADRID__1870__MADRID='GCS_Madrid_1870_Madrid'
    GCS_MGI__FERRO='GCS_MGI_Ferro'
    GCS_MGI='GCS_MGI'
    GCS__MONTE__MARIO__ROME='GCS_Monte_Mario_Rome'
    GCS__MONTE__MARIO='GCS_Monte_Mario'
    GCS_NGO__1948__OSLO='GCS_NGO_1948_Oslo'
    GCS_NGO__1948='GCS_NGO_1948'
    GCS__NORD_DE__GUERRE__PARIS='GCS_Nord_de_Guerre_Paris'
    GCS_NTF='GCS_NTF'
    GCS_NTF__PARIS='GCS_NTF_Paris'
    GCS_OS_SN__1980='GCS_OS_SN_1980'
    GCS_OSGB__1936='GCS_OSGB_1936'
    GCS_OSGB__1970_SN='GCS_OSGB_1970_SN'
    GCS__PULKOVO__1942_1='GCS_Pulkovo_1942'
    GCS__PULKOVO__1995_1='GCS_Pulkovo_1995'
    GCS__QORNOQ='GCS_Qornoq'
    GCS__BELGE__1950='GCS_Belge_1950'
    GCS__BELGE__1972_1='GCS_Belge_1972'
    GCS_RGF__1993='GCS_RGF_1993'
    GCS_RT__1990='GCS_RT_1990'
    GCS_RT_38__STOCKHOLM='GCS_RT38_Stockholm'
    GCS_RT_38='GCS_RT38'
    GCS_S_42__HUNGARY='GCS_S42_Hungary'
    GCS_S_JTSK='GCS_S_JTSK'
    GCS__SWISS_TRF__1995='GCS_Swiss_TRF_1995'
    GCS_TM_65='GCS_TM65'
    GCS_TM_75='GCS_TM75'
    GCS__ALASKAN__ISLANDS='GCS_Alaskan_Islands'
    GCS__AMERICAN__SAMOA__1962='GCS_American_Samoa_1962'
    GCS_ATS__1977='GCS_ATS_1977'
    GCS__BARBADOS='GCS_Barbados'
    GCS__BERMUDA__1957='GCS_Bermuda_1957'
    GCS__CAPE__CANAVERAL='GCS_Cape_Canaveral'
    GCS__GUAM__1963='GCS_Guam_1963'
    GCS__JAMAICA__1875='GCS_Jamaica_1875'
    GCS__JAMAICA__1969='GCS_Jamaica_1969'
    GCS_NAD__1927_CGQ_77='GCS_NAD_1927_CGQ77'
    GCS_NAD__1927__DEFINITION__1976='GCS_NAD_1927_Definition_1976'
    GCS__NORTH__AMERICAN__MICHIGAN='GCS_North_American_Michigan'
    GCS__NORTH__AMERICAN__1983_CSRS_98='GCS_North_American_1983_CSRS98'
    GCS__NORTH__AMERICAN__1983_HARN='GCS_North_American_1983_HARN'
    GCS__NORTH__AMERICAN__1927='GCS_North_American_1927'
    GCS__NORTH__AMERICAN__1983='GCS_North_American_1983'
    GCS__OLD__HAWAIIAN='GCS_Old_Hawaiian'
    GCS__PUERTO__RICO='GCS_Puerto_Rico'
    GCS__QORNOQ_1='GCS_Qornoq'
    GCS__ST__GEORGE__ISLAND='GCS_St_George_Island'
    GCS__ST__LAWRENCE__ISLAND='GCS_St_Lawrence_Island'
    GCS__ST__PAUL__ISLAND='GCS_St_Paul_Island'
    GCS__ALASKAN__ISLANDS_1='GCS_Alaskan_Islands'
    GCS__AMERICAN__SAMOA__1962_1='GCS_American_Samoa_1962'
    GCS__ANGUILLA__1957='GCS_Anguilla_1957'
    GCS__ANNA__1__1965='GCS_Anna_1_1965'
    GCS__ANTIGUA__1943='GCS_Antigua_1943'
    GCS__ASCENSION__ISLAND__1958='GCS_Ascension_Island_1958'
    GCS__BEACON_E__1945='GCS_Beacon_E_1945'
    GCS_DOS__71__4='GCS_DOS_71_4'
    GCS__ASTRO__1952='GCS_Astro_1952'
    GCS__BAB__SOUTH='GCS_Bab_South'
    GCS__BARBADOS__1938='GCS_Barbados_1938'
    GCS__BARBADOS_1='GCS_Barbados'
    GCS__BELLEVUE_IGN='GCS_Bellevue_IGN'
    GCS__BERMUDA__1957_1='GCS_Bermuda_1957'
    GCS__CANTON__1966='GCS_Canton_1966'
    GCS__CHATHAM__ISLAND__1971='GCS_Chatham_Island_1971'
    GCS__DOMINICA__1945='GCS_Dominica_1945'
    GCS_DOS__1968='GCS_DOS_1968'
    GCS__EASTER__ISLAND__1967='GCS_Easter_Island_1967'
    GCS__FORT__THOMAS__1955='GCS_Fort_Thomas_1955'
    GCS__GAN__1970='GCS_Gan_1970'
    GCS__GRACIOSA__BASE_SW__1948='GCS_Graciosa_Base_SW_1948'
    GCS__GRENADA__1953='GCS_Grenada_1953'
    GCS__GUAM__1963_1='GCS_Guam_1963'
    GCS_GUX__1='GCS_GUX_1'
    GCS__HJORSEY__1955_1='GCS_Hjorsey_1955'
    GCS_ISTS__061__1968='GCS_ISTS_061_1968'
    GCS_ISTS__073__1969='GCS_ISTS_073_1969'
    GCS__JAMAICA__1875_1='GCS_Jamaica_1875'
    GCS__JAMAICA__1969_1='GCS_Jamaica_1969'
    GCS__JOHNSTON__ISLAND__1961='GCS_Johnston_Island_1961'
    GCS__KERGUELEN__ISLAND__1949='GCS_Kerguelen_Island_1949'
    GCS__KUSAIE__1951='GCS_Kusaie_1951'
    GCS_LC_5__1961='GCS_LC5_1961'
    GCS__MAHE__1971_1='GCS_Mahe_1971'
    GCS__MAJURO='GCS_Majuro'
    GCS__MIDWAY__1961='GCS_Midway_1961'
    GCS__MONTSERRAT__1958='GCS_Montserrat_1958'
    GCS__OBSERV__METEOROLOGICO__1939='GCS_Observ_Meteorologico_1939'
    GCS__OLD__HAWAIIAN_1='GCS_Old_Hawaiian'
    GCS__PICO_DE__LAS__NIEVES='GCS_Pico_de_Las_Nieves'
    GCS__PITCAIRN__1967='GCS_Pitcairn_1967'
    GCS__POHNPEI='GCS_Pohnpei'
    GCS__PORTO__SANTO__1936='GCS_Porto_Santo_1936'
    GCS__PUERTO__RICO_1='GCS_Puerto_Rico'
    GCS__REUNION='GCS_Reunion'
    GCS__SANTO_DOS__1965='GCS_Santo_DOS_1965'
    GCS__SAO__BRAZ='GCS_Sao_Braz'
    GCS__SAPPER__HILL__1943='GCS_Sapper_Hill_1943'
    GCS__SELVAGEM__GRANDE__1938='GCS_Selvagem_Grande_1938'
    GCS__ST__KITTS__1955='GCS_St_Kitts_1955'
    GCS__ST__LUCIA__1955='GCS_St_Lucia_1955'
    GCS__ST__VINCENT__1945='GCS_St_Vincent_1945'
    GCS__TERN__ISLAND__1961='GCS_Tern_Island_1961'
    GCS__TRISTAN__1968='GCS_Tristan_1968'
    GCS__VITI__LEVU__1916='GCS_Viti_Levu_1916'
    GCS__WAKE__ISLAND__1952='GCS_Wake_Island_1952'
    GCS__WAKE__ENIWETOK__1960='GCS_Wake_Eniwetok_1960'
    GCS__ARATU='GCS_Aratu'
    GCS__BOGOTA__BOGOTA='GCS_Bogota_Bogota'
    GCS__BOGOTA='GCS_Bogota'
    GCS__CAMPO__INCHAUSPE='GCS_Campo_Inchauspe'
    GCS__CHOS__MALAL__1914='GCS_Chos_Malal_1914'
    GCS__CHUA='GCS_Chua'
    GCS__CORREGO__ALEGRE='GCS_Corrego_Alegre'
    GCS__GUYANE__FRANCAISE='GCS_Guyane_Francaise'
    GCS__HITO_XVIII__1963='GCS_Hito_XVIII_1963'
    GCS__LA__CANOA='GCS_La_Canoa'
    GCS__LAKE='GCS_Lake'
    GCS__LOMA__QUINTANA='GCS_Loma_Quintana'
    GCS__MOUNT__DILLON='GCS_Mount_Dillon'
    GCS__NAPARIMA__1955='GCS_Naparima_1955'
    GCS__NAPARIMA__1972='GCS_Naparima_1972'
    GCS__PAMPA_DEL__CASTILLO='GCS_Pampa_del_Castillo'
    GCS_POSGAR='GCS_POSGAR'
    GCS_REGVEN='GCS_REGVEN'
    GCS__SAPPER__HILL__1943_1='GCS_Sapper_Hill_1943'
    GCS_SIRGAS='GCS_SIRGAS'
    GCS__SOUTH__AMERICAN__1969='GCS_South_American_1969'
    GCS__TRINIDAD__1903='GCS_Trinidad_1903'
    GCS__YACARE='GCS_Yacare'
    GCS__ZANDERIJ='GCS_Zanderij'
    GCS__AIRY__1830='GCS_Airy_1830'
    GCS__AIRY__MODIFIED='GCS_Airy_Modified'
    GCS__AUSTRALIAN='GCS_Australian'
    GCS__SPHERE_ARC_INFO='GCS_Sphere_ARC_INFO'
    GCS__SPHERE='GCS_Sphere'
    GCS_ATS__1977_1='GCS_ATS_1977'
    GCS__BESSEL__1841='GCS_Bessel_1841'
    GCS__BESSEL__MODIFIED='GCS_Bessel_Modified'
    GCS__BESSEL__NAMIBIA='GCS_Bessel_Namibia'
    GCS__CLARKE__1858='GCS_Clarke_1858'
    GCS__CLARKE__1866__MICHIGAN='GCS_Clarke_1866_Michigan'
    GCS__CLARKE__1866='GCS_Clarke_1866'
    GCS__CLARKE__1880__ARC='GCS_Clarke_1880_Arc'
    GCS__CLARKE__1880__BENOIT='GCS_Clarke_1880_Benoit'
    GCS__CLARKE__1880_IGN='GCS_Clarke_1880_IGN'
    GCS__CLARKE__1880_RGS='GCS_Clarke_1880_RGS'
    GCS__CLARKE__1880_SGA='GCS_Clarke_1880_SGA'
    GCS__CLARKE__1880='GCS_Clarke_1880'
    GCS__EVEREST_DEF__1967_1='GCS_Everest_def_1967'
    GCS__EVEREST_DEF__1975_1='GCS_Everest_def_1975'
    GCS__EVEREST__1830_1='GCS_Everest_1830'
    GCS__EVEREST__MODIFIED__1969='GCS_Everest_Modified_1969'
    GCS__EVEREST__MODIFIED_1='GCS_Everest_Modified'
    GCS__FISCHER__1960='GCS_Fischer_1960'
    GCS__FISCHER__1968='GCS_Fischer_1968'
    GCS__FISCHER__MODIFIED='GCS_Fischer_Modified'
    GCS_GEM__10_C='GCS_GEM_10C'
    GCS_GRS__1967='GCS_GRS_1967'
    GCS_GRS__1980='GCS_GRS_1980'
    GCS__HELMERT__1906='GCS_Helmert_1906'
    GCS__HOUGH__1960='GCS_Hough_1960'
    GCS__INDONESIAN='GCS_Indonesian'
    GCS__INTERNATIONAL__1924='GCS_International_1924'
    GCS__INTERNATIONAL__1967='GCS_International_1967'
    GCS__KRASOVSKY__1940='GCS_Krasovsky_1940'
    GCS_OSU__86_F='GCS_OSU_86F'
    GCS_OSU__91_A='GCS_OSU_91A'
    GCS__PLESSIS__1817='GCS_Plessis_1817'
    GCS__STRUVE__1860='GCS_Struve_1860'
    GCS_NWL__9_D='GCS_NWL_9D'
    GCS__WALBECK='GCS_Walbeck'
    GCS__WAR__OFFICE='GCS_War_Office'
    GCS_WGS__1966='GCS_WGS_1966'
    GCS_NSWC__9_Z__2='GCS_NSWC_9Z_2'
    GCS_WGS__1966_1='GCS_WGS_1966'
    GCS_WGS__1972_BE='GCS_WGS_1972_BE'
    GCS_WGS__1972='GCS_WGS_1972'
    GCS_WGS__1984='GCS_WGS_1984'
    AFRICA__ALBERS__EQUAL__AREA__CONIC='Africa_Albers_Equal_Area_Conic'
    AFRICA__EQUIDISTANT__CONIC='Africa_Equidistant_Conic'
    AFRICA__LAMBERT__CONFORMAL__CONIC='Africa_Lambert_Conformal_Conic'
    AFRICA__SINUSOIDAL='Africa_Sinusoidal'
    ASIA__LAMBERT__CONFORMAL__CONIC='Asia_Lambert_Conformal_Conic'
    ASIA__NORTH__ALBERS__EQUAL__AREA__CONIC='Asia_North_Albers_Equal_Area_Conic'
    ASIA__NORTH__EQUIDISTANT__CONIC='Asia_North_Equidistant_Conic'
    ASIA__NORTH__LAMBERT__CONFORMAL__CONIC='Asia_North_Lambert_Conformal_Conic'
    ASIA__SOUTH__ALBERS__EQUAL__AREA__CONIC='Asia_South_Albers_Equal_Area_Conic'
    ASIA__SOUTH__EQUIDISTANT__CONIC='Asia_South_Equidistant_Conic'
    ASIA__SOUTH__LAMBERT__CONFORMAL__CONIC='Asia_South_Lambert_Conformal_Conic'
    EUROPE__ALBERS__EQUAL__AREA__CONIC='Europe_Albers_Equal_Area_Conic'
    EUROPE__EQUIDISTANT__CONIC='Europe_Equidistant_Conic'
    EUROPE__LAMBERT__CONFORMAL__CONIC='Europe_Lambert_Conformal_Conic'
    ALASKA__ALBERS__EQUAL__AREA__CONIC='Alaska_Albers_Equal_Area_Conic'
    CANADA__ALBERS__EQUAL__AREA__CONIC='Canada_Albers_Equal_Area_Conic'
    CANADA__LAMBERT__CONFORMAL__CONIC='Canada_Lambert_Conformal_Conic'
    HAWAII__ALBERS__EQUAL__AREA__CONIC='Hawaii_Albers_Equal_Area_Conic'
    NORTH__AMERICA__ALBERS__EQUAL__AREA__CONIC='North_America_Albers_Equal_Area_Conic'
    NORTH__AMERICA__EQUIDISTANT__CONIC='North_America_Equidistant_Conic'
    NORTH__AMERICA__LAMBERT__CONFORMAL__CONIC='North_America_Lambert_Conformal_Conic'
    USA__CONTIGUOUS__ALBERS__EQUAL__AREA__CONIC_USGS_VERSION='USA_Contiguous_Albers_Equal_Area_Conic_USGS_version'
    USA__CONTIGUOUS__ALBERS__EQUAL__AREA__CONIC='USA_Contiguous_Albers_Equal_Area_Conic'
    USA__CONTIGUOUS__EQUIDISTANT__CONIC='USA_Contiguous_Equidistant_Conic'
    USA__CONTIGUOUS__LAMBERT__CONFORMAL__CONIC='USA_Contiguous_Lambert_Conformal_Conic'
    SOUTH__AMERICA__ALBERS__EQUAL__AREA__CONIC='South_America_Albers_Equal_Area_Conic'
    SOUTH__AMERICA__EQUIDISTANT__CONIC='South_America_Equidistant_Conic'
    SOUTH__AMERICA__LAMBERT__CONFORMAL__CONIC='South_America_Lambert_Conformal_Conic'
    BEIJING__1954_GK__ZONE__13='Beijing_1954_GK_Zone_13'
    BEIJING__1954_GK__ZONE__13_N='Beijing_1954_GK_Zone_13N'
    BEIJING__1954_GK__ZONE__14='Beijing_1954_GK_Zone_14'
    BEIJING__1954_GK__ZONE__14_N='Beijing_1954_GK_Zone_14N'
    BEIJING__1954_GK__ZONE__15='Beijing_1954_GK_Zone_15'
    BEIJING__1954_GK__ZONE__15_N='Beijing_1954_GK_Zone_15N'
    BEIJING__1954_GK__ZONE__16='Beijing_1954_GK_Zone_16'
    BEIJING__1954_GK__ZONE__16_N='Beijing_1954_GK_Zone_16N'
    BEIJING__1954_GK__ZONE__17='Beijing_1954_GK_Zone_17'
    BEIJING__1954_GK__ZONE__17_N='Beijing_1954_GK_Zone_17N'
    BEIJING__1954_GK__ZONE__18='Beijing_1954_GK_Zone_18'
    BEIJING__1954_GK__ZONE__18_N='Beijing_1954_GK_Zone_18N'
    BEIJING__1954_GK__ZONE__19='Beijing_1954_GK_Zone_19'
    BEIJING__1954_GK__ZONE__19_N='Beijing_1954_GK_Zone_19N'
    BEIJING__1954_GK__ZONE__20='Beijing_1954_GK_Zone_20'
    BEIJING__1954_GK__ZONE__20_N='Beijing_1954_GK_Zone_20N'
    BEIJING__1954_GK__ZONE__21='Beijing_1954_GK_Zone_21'
    BEIJING__1954_GK__ZONE__21_N='Beijing_1954_GK_Zone_21N'
    BEIJING__1954_GK__ZONE__22='Beijing_1954_GK_Zone_22'
    BEIJING__1954_GK__ZONE__22_N='Beijing_1954_GK_Zone_22N'
    BEIJING__1954_GK__ZONE__23='Beijing_1954_GK_Zone_23'
    BEIJING__1954_GK__ZONE__23_N='Beijing_1954_GK_Zone_23N'
    HANOI__1972_GK__ZONE__18='Hanoi_1972_GK_Zone_18'
    HANOI__1972_GK__ZONE__19='Hanoi_1972_GK_Zone_19'
    SOUTH__YEMEN_GK__ZONE__8='South_Yemen_GK_Zone_8'
    SOUTH__YEMEN_GK__ZONE__9='South_Yemen_GK_Zone_9'
    PULKOVO__1942_GK__ZONE__10='Pulkovo_1942_GK_Zone_10'
    PULKOVO__1942_GK__ZONE__10_N='Pulkovo_1942_GK_Zone_10N'
    PULKOVO__1942_GK__ZONE__11='Pulkovo_1942_GK_Zone_11'
    PULKOVO__1942_GK__ZONE__11_N='Pulkovo_1942_GK_Zone_11N'
    PULKOVO__1942_GK__ZONE__12='Pulkovo_1942_GK_Zone_12'
    PULKOVO__1942_GK__ZONE__12_N='Pulkovo_1942_GK_Zone_12N'
    PULKOVO__1942_GK__ZONE__13='Pulkovo_1942_GK_Zone_13'
    PULKOVO__1942_GK__ZONE__13_N='Pulkovo_1942_GK_Zone_13N'
    PULKOVO__1942_GK__ZONE__14='Pulkovo_1942_GK_Zone_14'
    PULKOVO__1942_GK__ZONE__14_N='Pulkovo_1942_GK_Zone_14N'
    PULKOVO__1942_GK__ZONE__15='Pulkovo_1942_GK_Zone_15'
    PULKOVO__1942_GK__ZONE__15_N='Pulkovo_1942_GK_Zone_15N'
    PULKOVO__1942_GK__ZONE__16='Pulkovo_1942_GK_Zone_16'
    PULKOVO__1942_GK__ZONE__16_N='Pulkovo_1942_GK_Zone_16N'
    PULKOVO__1942_GK__ZONE__17='Pulkovo_1942_GK_Zone_17'
    PULKOVO__1942_GK__ZONE__17_N='Pulkovo_1942_GK_Zone_17N'
    PULKOVO__1942_GK__ZONE__18='Pulkovo_1942_GK_Zone_18'
    PULKOVO__1942_GK__ZONE__18_N='Pulkovo_1942_GK_Zone_18N'
    PULKOVO__1942_GK__ZONE__19='Pulkovo_1942_GK_Zone_19'
    PULKOVO__1942_GK__ZONE__19_N='Pulkovo_1942_GK_Zone_19N'
    PULKOVO__1942_GK__ZONE__2='Pulkovo_1942_GK_Zone_2'
    PULKOVO__1942_GK__ZONE__20='Pulkovo_1942_GK_Zone_20'
    PULKOVO__1942_GK__ZONE__20_N='Pulkovo_1942_GK_Zone_20N'
    PULKOVO__1942_GK__ZONE__21='Pulkovo_1942_GK_Zone_21'
    PULKOVO__1942_GK__ZONE__21_N='Pulkovo_1942_GK_Zone_21N'
    PULKOVO__1942_GK__ZONE__22='Pulkovo_1942_GK_Zone_22'
    PULKOVO__1942_GK__ZONE__22_N='Pulkovo_1942_GK_Zone_22N'
    PULKOVO__1942_GK__ZONE__23='Pulkovo_1942_GK_Zone_23'
    PULKOVO__1942_GK__ZONE__23_N='Pulkovo_1942_GK_Zone_23N'
    PULKOVO__1942_GK__ZONE__24='Pulkovo_1942_GK_Zone_24'
    PULKOVO__1942_GK__ZONE__24_N='Pulkovo_1942_GK_Zone_24N'
    PULKOVO__1942_GK__ZONE__25='Pulkovo_1942_GK_Zone_25'
    PULKOVO__1942_GK__ZONE__25_N='Pulkovo_1942_GK_Zone_25N'
    PULKOVO__1942_GK__ZONE__26='Pulkovo_1942_GK_Zone_26'
    PULKOVO__1942_GK__ZONE__26_N='Pulkovo_1942_GK_Zone_26N'
    PULKOVO__1942_GK__ZONE__27='Pulkovo_1942_GK_Zone_27'
    PULKOVO__1942_GK__ZONE__27_N='Pulkovo_1942_GK_Zone_27N'
    PULKOVO__1942_GK__ZONE__28='Pulkovo_1942_GK_Zone_28'
    PULKOVO__1942_GK__ZONE__28_N='Pulkovo_1942_GK_Zone_28N'
    PULKOVO__1942_GK__ZONE__29='Pulkovo_1942_GK_Zone_29'
    PULKOVO__1942_GK__ZONE__29_N='Pulkovo_1942_GK_Zone_29N'
    PULKOVO__1942_GK__ZONE__2_N='Pulkovo_1942_GK_Zone_2N'
    PULKOVO__1942_GK__ZONE__3='Pulkovo_1942_GK_Zone_3'
    PULKOVO__1942_GK__ZONE__30='Pulkovo_1942_GK_Zone_30'
    PULKOVO__1942_GK__ZONE__30_N='Pulkovo_1942_GK_Zone_30N'
    PULKOVO__1942_GK__ZONE__31='Pulkovo_1942_GK_Zone_31'
    PULKOVO__1942_GK__ZONE__31_N='Pulkovo_1942_GK_Zone_31N'
    PULKOVO__1942_GK__ZONE__32='Pulkovo_1942_GK_Zone_32'
    PULKOVO__1942_GK__ZONE__32_N='Pulkovo_1942_GK_Zone_32N'
    PULKOVO__1942_GK__ZONE__3_N='Pulkovo_1942_GK_Zone_3N'
    PULKOVO__1942_GK__ZONE__4='Pulkovo_1942_GK_Zone_4'
    PULKOVO__1942_GK__ZONE__4_N='Pulkovo_1942_GK_Zone_4N'
    PULKOVO__1942_GK__ZONE__5='Pulkovo_1942_GK_Zone_5'
    PULKOVO__1942_GK__ZONE__5_N='Pulkovo_1942_GK_Zone_5N'
    PULKOVO__1942_GK__ZONE__6='Pulkovo_1942_GK_Zone_6'
    PULKOVO__1942_GK__ZONE__6_N='Pulkovo_1942_GK_Zone_6N'
    PULKOVO__1942_GK__ZONE__7='Pulkovo_1942_GK_Zone_7'
    PULKOVO__1942_GK__ZONE__7_N='Pulkovo_1942_GK_Zone_7N'
    PULKOVO__1942_GK__ZONE__8='Pulkovo_1942_GK_Zone_8'
    PULKOVO__1942_GK__ZONE__8_N='Pulkovo_1942_GK_Zone_8N'
    PULKOVO__1942_GK__ZONE__9='Pulkovo_1942_GK_Zone_9'
    PULKOVO__1942_GK__ZONE__9_N='Pulkovo_1942_GK_Zone_9N'
    PULKOVO__1995_GK__ZONE__10='Pulkovo_1995_GK_Zone_10'
    PULKOVO__1995_GK__ZONE__10_N='Pulkovo_1995_GK_Zone_10N'
    PULKOVO__1995_GK__ZONE__11='Pulkovo_1995_GK_Zone_11'
    PULKOVO__1995_GK__ZONE__11_N='Pulkovo_1995_GK_Zone_11N'
    PULKOVO__1995_GK__ZONE__12='Pulkovo_1995_GK_Zone_12'
    PULKOVO__1995_GK__ZONE__12_N='Pulkovo_1995_GK_Zone_12N'
    PULKOVO__1995_GK__ZONE__13='Pulkovo_1995_GK_Zone_13'
    PULKOVO__1995_GK__ZONE__13_N='Pulkovo_1995_GK_Zone_13N'
    PULKOVO__1995_GK__ZONE__14='Pulkovo_1995_GK_Zone_14'
    PULKOVO__1995_GK__ZONE__14_N='Pulkovo_1995_GK_Zone_14N'
    PULKOVO__1995_GK__ZONE__15='Pulkovo_1995_GK_Zone_15'
    PULKOVO__1995_GK__ZONE__15_N='Pulkovo_1995_GK_Zone_15N'
    PULKOVO__1995_GK__ZONE__16='Pulkovo_1995_GK_Zone_16'
    PULKOVO__1995_GK__ZONE__16_N='Pulkovo_1995_GK_Zone_16N'
    PULKOVO__1995_GK__ZONE__17='Pulkovo_1995_GK_Zone_17'
    PULKOVO__1995_GK__ZONE__17_N='Pulkovo_1995_GK_Zone_17N'
    PULKOVO__1995_GK__ZONE__18='Pulkovo_1995_GK_Zone_18'
    PULKOVO__1995_GK__ZONE__18_N='Pulkovo_1995_GK_Zone_18N'
    PULKOVO__1995_GK__ZONE__19='Pulkovo_1995_GK_Zone_19'
    PULKOVO__1995_GK__ZONE__19_N='Pulkovo_1995_GK_Zone_19N'
    PULKOVO__1995_GK__ZONE__2='Pulkovo_1995_GK_Zone_2'
    PULKOVO__1995_GK__ZONE__20='Pulkovo_1995_GK_Zone_20'
    PULKOVO__1995_GK__ZONE__20_N='Pulkovo_1995_GK_Zone_20N'
    PULKOVO__1995_GK__ZONE__21='Pulkovo_1995_GK_Zone_21'
    PULKOVO__1995_GK__ZONE__21_N='Pulkovo_1995_GK_Zone_21N'
    PULKOVO__1995_GK__ZONE__22='Pulkovo_1995_GK_Zone_22'
    PULKOVO__1995_GK__ZONE__22_N='Pulkovo_1995_GK_Zone_22N'
    PULKOVO__1995_GK__ZONE__23='Pulkovo_1995_GK_Zone_23'
    PULKOVO__1995_GK__ZONE__23_N='Pulkovo_1995_GK_Zone_23N'
    PULKOVO__1995_GK__ZONE__24='Pulkovo_1995_GK_Zone_24'
    PULKOVO__1995_GK__ZONE__24_N='Pulkovo_1995_GK_Zone_24N'
    PULKOVO__1995_GK__ZONE__25='Pulkovo_1995_GK_Zone_25'
    PULKOVO__1995_GK__ZONE__25_N='Pulkovo_1995_GK_Zone_25N'
    PULKOVO__1995_GK__ZONE__26='Pulkovo_1995_GK_Zone_26'
    PULKOVO__1995_GK__ZONE__26_N='Pulkovo_1995_GK_Zone_26N'
    PULKOVO__1995_GK__ZONE__27='Pulkovo_1995_GK_Zone_27'
    PULKOVO__1995_GK__ZONE__27_N='Pulkovo_1995_GK_Zone_27N'
    PULKOVO__1995_GK__ZONE__28='Pulkovo_1995_GK_Zone_28'
    PULKOVO__1995_GK__ZONE__28_N='Pulkovo_1995_GK_Zone_28N'
    PULKOVO__1995_GK__ZONE__29='Pulkovo_1995_GK_Zone_29'
    PULKOVO__1995_GK__ZONE__29_N='Pulkovo_1995_GK_Zone_29N'
    PULKOVO__1995_GK__ZONE__2_N='Pulkovo_1995_GK_Zone_2N'
    PULKOVO__1995_GK__ZONE__3='Pulkovo_1995_GK_Zone_3'
    PULKOVO__1995_GK__ZONE__30='Pulkovo_1995_GK_Zone_30'
    PULKOVO__1995_GK__ZONE__30_N='Pulkovo_1995_GK_Zone_30N'
    PULKOVO__1995_GK__ZONE__31='Pulkovo_1995_GK_Zone_31'
    PULKOVO__1995_GK__ZONE__31_N='Pulkovo_1995_GK_Zone_31N'
    PULKOVO__1995_GK__ZONE__32='Pulkovo_1995_GK_Zone_32'
    PULKOVO__1995_GK__ZONE__32_N='Pulkovo_1995_GK_Zone_32N'
    PULKOVO__1995_GK__ZONE__3_N='Pulkovo_1995_GK_Zone_3N'
    PULKOVO__1995_GK__ZONE__4='Pulkovo_1995_GK_Zone_4'
    PULKOVO__1995_GK__ZONE__4_N='Pulkovo_1995_GK_Zone_4N'
    PULKOVO__1995_GK__ZONE__5='Pulkovo_1995_GK_Zone_5'
    PULKOVO__1995_GK__ZONE__5_N='Pulkovo_1995_GK_Zone_5N'
    PULKOVO__1995_GK__ZONE__6='Pulkovo_1995_GK_Zone_6'
    PULKOVO__1995_GK__ZONE__6_N='Pulkovo_1995_GK_Zone_6N'
    PULKOVO__1995_GK__ZONE__7='Pulkovo_1995_GK_Zone_7'
    PULKOVO__1995_GK__ZONE__7_N='Pulkovo_1995_GK_Zone_7N'
    PULKOVO__1995_GK__ZONE__8='Pulkovo_1995_GK_Zone_8'
    PULKOVO__1995_GK__ZONE__8_N='Pulkovo_1995_GK_Zone_8N'
    PULKOVO__1995_GK__ZONE__9='Pulkovo_1995_GK_Zone_9'
    PULKOVO__1995_GK__ZONE__9_N='Pulkovo_1995_GK_Zone_9N'
    ABIDJAN__1987_TM__5_NW='Abidjan_1987_TM_5_NW'
    ACCRA__GHANA__GRID='Accra_Ghana_Grid'
    ACCRA_TM__1_NW='Accra_TM_1_NW'
    SAMOA__1962__SAMOA__LAMBERT='Samoa_1962_Samoa_Lambert'
    ANGUILLA__1957__BRITISH__WEST__INDIES__GRID='Anguilla_1957_British_West_Indies_Grid'
    ANTIGUA__1943__BRITISH__WEST__INDIES__GRID='Antigua_1943_British_West_Indies_Grid'
    ARGENTINA__ZONE__1='Argentina_Zone_1'
    ARGENTINA__ZONE__2='Argentina_Zone_2'
    ARGENTINA__ZONE__3='Argentina_Zone_3'
    ARGENTINA__ZONE__4='Argentina_Zone_4'
    ARGENTINA__ZONE__5='Argentina_Zone_5'
    ARGENTINA__ZONE__6='Argentina_Zone_6'
    ARGENTINA__ZONE__7='Argentina_Zone_7'
    AGD__1966_AMG__ZONE__48='AGD_1966_AMG_Zone_48'
    AGD__1966_AMG__ZONE__49='AGD_1966_AMG_Zone_49'
    AGD__1966_AMG__ZONE__50='AGD_1966_AMG_Zone_50'
    AGD__1966_AMG__ZONE__51='AGD_1966_AMG_Zone_51'
    AGD__1966_AMG__ZONE__52='AGD_1966_AMG_Zone_52'
    AGD__1966_AMG__ZONE__53='AGD_1966_AMG_Zone_53'
    AGD__1966_AMG__ZONE__54='AGD_1966_AMG_Zone_54'
    AGD__1966_AMG__ZONE__55='AGD_1966_AMG_Zone_55'
    AGD__1966_AMG__ZONE__56='AGD_1966_AMG_Zone_56'
    AGD__1966_AMG__ZONE__57='AGD_1966_AMG_Zone_57'
    AGD__1966_AMG__ZONE__58='AGD_1966_AMG_Zone_58'
    AGD__1966_VICGRID='AGD_1966_VICGRID'
    AGD__1984_AMG__ZONE__48='AGD_1984_AMG_Zone_48'
    AGD__1984_AMG__ZONE__49='AGD_1984_AMG_Zone_49'
    AGD__1984_AMG__ZONE__50='AGD_1984_AMG_Zone_50'
    AGD__1984_AMG__ZONE__51='AGD_1984_AMG_Zone_51'
    AGD__1984_AMG__ZONE__52='AGD_1984_AMG_Zone_52'
    AGD__1984_AMG__ZONE__53='AGD_1984_AMG_Zone_53'
    AGD__1984_AMG__ZONE__54='AGD_1984_AMG_Zone_54'
    AGD__1984_AMG__ZONE__55='AGD_1984_AMG_Zone_55'
    AGD__1984_AMG__ZONE__56='AGD_1984_AMG_Zone_56'
    AGD__1984_AMG__ZONE__57='AGD_1984_AMG_Zone_57'
    AGD__1984_AMG__ZONE__58='AGD_1984_AMG_Zone_58'
    GDA__1994_MGA__ZONE__48='GDA_1994_MGA_Zone_48'
    GDA__1994_MGA__ZONE__49='GDA_1994_MGA_Zone_49'
    GDA__1994_MGA__ZONE__50='GDA_1994_MGA_Zone_50'
    GDA__1994_MGA__ZONE__51='GDA_1994_MGA_Zone_51'
    GDA__1994_MGA__ZONE__52='GDA_1994_MGA_Zone_52'
    GDA__1994_MGA__ZONE__53='GDA_1994_MGA_Zone_53'
    GDA__1994_MGA__ZONE__54='GDA_1994_MGA_Zone_54'
    GDA__1994_MGA__ZONE__55='GDA_1994_MGA_Zone_55'
    GDA__1994_MGA__ZONE__56='GDA_1994_MGA_Zone_56'
    GDA__1994_MGA__ZONE__57='GDA_1994_MGA_Zone_57'
    GDA__1994_MGA__ZONE__58='GDA_1994_MGA_Zone_58'
    GDA__1994__SOUTH__AUSTRALIA__LAMBERT='GDA_1994_South_Australia_Lambert'
    GDA__1994_VICGRID_94='GDA_1994_VICGRID94'
    AUSTRIA__CENTRAL__ZONE='Austria_Central_Zone'
    AUSTRIA__EAST__ZONE='Austria_East_Zone'
    AUSTRIA__WEST__ZONE='Austria_West_Zone'
    BAHRAIN__STATE__GRID='Bahrain_State_Grid'
    BARBADOS__1938__BARBADOS__GRID='Barbados_1938_Barbados_Grid'
    BARBADOS__1938__BRITISH__WEST__INDIES__GRID='Barbados_1938_British_West_Indies_Grid'
    BELGE__LAMBERT__1950='Belge_Lambert_1950'
    BELGE__LAMBERT__1972='Belge_Lambert_1972'
    BERN__1898__BERN_LV_03_C='Bern_1898_Bern_LV03C'
    BRITISH__NATIONAL__GRID='British_National_Grid'
    CAMACUPA_TM__11__30_SE='Camacupa_TM_11_30_SE'
    CAMACUPA_TM__12_SE='Camacupa_TM_12_SE'
    ATS__1977_MTM__4__NOVA__SCOTIA='ATS_1977_MTM_4_Nova_Scotia'
    ATS__1977_MTM__5__NOVA__SCOTIA='ATS_1977_MTM_5_Nova_Scotia'
    ATS__1977__NEW__BRUNSWICK__STEREOGRAPHIC='ATS_1977_New_Brunswick_Stereographic'
    NAD__1927__10_TM_AEP__FOREST='NAD_1927_10TM_AEP_Forest'
    NAD__1927__10_TM_AEP__RESOURCE='NAD_1927_10TM_AEP_Resource'
    NAD__1927__3_TM__111='NAD_1927_3TM_111'
    NAD__1927__3_TM__114='NAD_1927_3TM_114'
    NAD__1927__3_TM__117='NAD_1927_3TM_117'
    NAD__1927__3_TM__120='NAD_1927_3TM_120'
    NAD__1927_CGQ_77_MTM__10_S_CO_PQ='NAD_1927_CGQ77_MTM_10_SCoPQ'
    NAD__1927_CGQ_77_MTM__2_S_CO_PQ='NAD_1927_CGQ77_MTM_2_SCoPQ'
    NAD__1927_CGQ_77_MTM__3_S_CO_PQ='NAD_1927_CGQ77_MTM_3_SCoPQ'
    NAD__1927_CGQ_77_MTM__4_S_CO_PQ='NAD_1927_CGQ77_MTM_4_SCoPQ'
    NAD__1927_CGQ_77_MTM__5_S_CO_PQ='NAD_1927_CGQ77_MTM_5_SCoPQ'
    NAD__1927_CGQ_77_MTM__6_S_CO_PQ='NAD_1927_CGQ77_MTM_6_SCoPQ'
    NAD__1927_CGQ_77_MTM__7_S_CO_PQ='NAD_1927_CGQ77_MTM_7_SCoPQ'
    NAD__1927_CGQ_77_MTM__8_S_CO_PQ='NAD_1927_CGQ77_MTM_8_SCoPQ'
    NAD__1927_CGQ_77_MTM__9_S_CO_PQ='NAD_1927_CGQ77_MTM_9_SCoPQ'
    NAD__1927_CGQ_77__QUEBEC__LAMBERT='NAD_1927_CGQ77_Quebec_Lambert'
    NAD__1927_CGQ_77_UTM__ZONE__17_N='NAD_1927_CGQ77_UTM_Zone_17N'
    NAD__1927_CGQ_77_UTM__ZONE__18_N='NAD_1927_CGQ77_UTM_Zone_18N'
    NAD__1927_CGQ_77_UTM__ZONE__19_N='NAD_1927_CGQ77_UTM_Zone_19N'
    NAD__1927_CGQ_77_UTM__ZONE__20_N='NAD_1927_CGQ77_UTM_Zone_20N'
    NAD__1927_CGQ_77_UTM__ZONE__21_N='NAD_1927_CGQ77_UTM_Zone_21N'
    NAD__1927_DEF__1976_MTM__10='NAD_1927_DEF_1976_MTM_10'
    NAD__1927_DEF__1976_MTM__11='NAD_1927_DEF_1976_MTM_11'
    NAD__1927_DEF__1976_MTM__12='NAD_1927_DEF_1976_MTM_12'
    NAD__1927_DEF__1976_MTM__13='NAD_1927_DEF_1976_MTM_13'
    NAD__1927_DEF__1976_MTM__14='NAD_1927_DEF_1976_MTM_14'
    NAD__1927_DEF__1976_MTM__15='NAD_1927_DEF_1976_MTM_15'
    NAD__1927_DEF__1976_MTM__16='NAD_1927_DEF_1976_MTM_16'
    NAD__1927_DEF__1976_MTM__17='NAD_1927_DEF_1976_MTM_17'
    NAD__1927_DEF__1976_MTM__8='NAD_1927_DEF_1976_MTM_8'
    NAD__1927_DEF__1976_MTM__9='NAD_1927_DEF_1976_MTM_9'
    NAD__1927_DEF__1976_UTM__ZONE__15_N='NAD_1927_DEF_1976_UTM_Zone_15N'
    NAD__1927_DEF__1976_UTM__ZONE__16_N='NAD_1927_DEF_1976_UTM_Zone_16N'
    NAD__1927_DEF__1976_UTM__ZONE__17_N='NAD_1927_DEF_1976_UTM_Zone_17N'
    NAD__1927_DEF__1976_UTM__ZONE__18_N='NAD_1927_DEF_1976_UTM_Zone_18N'
    NAD__1927_MTM__1='NAD_1927_MTM_1'
    NAD__1927_MTM__2='NAD_1927_MTM_2'
    NAD__1927_MTM__3='NAD_1927_MTM_3'
    NAD__1927_MTM__4='NAD_1927_MTM_4'
    NAD__1927_MTM__5='NAD_1927_MTM_5'
    NAD__1927_MTM__6='NAD_1927_MTM_6'
    NAD__1927__QUEBEC__LAMBERT='NAD_1927_Quebec_Lambert'
    NAD__1983__10_TM_AEP__FOREST='NAD_1983_10TM_AEP_Forest'
    NAD__1983__10_TM_AEP__RESOURCE='NAD_1983_10TM_AEP_Resource'
    NAD__1983__3_TM__111='NAD_1983_3TM_111'
    NAD__1983__3_TM__114='NAD_1983_3TM_114'
    NAD__1983__3_TM__117='NAD_1983_3TM_117'
    NAD__1983__3_TM__120='NAD_1983_3TM_120'
    NAD__1983_BC__ENVIRONMENT__ALBERS='NAD_1983_BC_Environment_Albers'
    NAD__1983_CRS_98_MTM__10='NAD_1983_CRS98_MTM_10'
    NAD__1983_CSRS_98_MTM__2_S_CO_PQ='NAD_1983_CSRS98_MTM_2_SCoPQ'
    NAD__1983_CRS_98_MTM__3='NAD_1983_CRS98_MTM_3'
    NAD__1983_CRS_98_MTM__4='NAD_1983_CRS98_MTM_4'
    NAD__1983_CRS_98_MTM__5='NAD_1983_CRS98_MTM_5'
    NAD__1983_CRS_98_MTM__6='NAD_1983_CRS98_MTM_6'
    NAD__1983_CRS_98_MTM__7='NAD_1983_CRS98_MTM_7'
    NAD__1983_CRS_98_MTM__8='NAD_1983_CRS98_MTM_8'
    NAD__1983_CRS_98_MTM__9='NAD_1983_CRS98_MTM_9'
    NAD__1983_CSRS_98__NEW__BRUNSWICK__STEREOGRAPHIC='NAD_1983_CSRS98_New_Brunswick_Stereographic'
    NAD__1983_CSRS_98__PRINCE__EDWARD__ISLAND='NAD_1983_CSRS98_Prince_Edward_Island'
    NAD__1983_CSRS_98_UTM__ZONE__21_N='NAD_1983_CSRS98_UTM_Zone_21N'
    NAD__1983_CSRS_98_UTM__ZONE__11_N='NAD_1983_CSRS98_UTM_Zone_11N'
    NAD__1983_CSRS_98_UTM__ZONE__12_N='NAD_1983_CSRS98_UTM_Zone_12N'
    NAD__1983_CSRS_98_UTM__ZONE__13_N='NAD_1983_CSRS98_UTM_Zone_13N'
    NAD__1983_CSRS_98_UTM__ZONE__17_N='NAD_1983_CSRS98_UTM_Zone_17N'
    NAD__1983_CSRS_98_UTM__ZONE__18_N='NAD_1983_CSRS98_UTM_Zone_18N'
    NAD__1983_CSRS_98_UTM__ZONE__19_N='NAD_1983_CSRS98_UTM_Zone_19N'
    NAD__1983_CSRS_98_UTM__ZONE__20_N='NAD_1983_CSRS98_UTM_Zone_20N'
    NAD__1983_MTM__1='NAD_1983_MTM_1'
    NAD__1983_MTM__10='NAD_1983_MTM_10'
    NAD__1983_MTM__11='NAD_1983_MTM_11'
    NAD__1983_MTM__12='NAD_1983_MTM_12'
    NAD__1983_MTM__13='NAD_1983_MTM_13'
    NAD__1983_MTM__14='NAD_1983_MTM_14'
    NAD__1983_MTM__15='NAD_1983_MTM_15'
    NAD__1983_MTM__16='NAD_1983_MTM_16'
    NAD__1983_MTM__17='NAD_1983_MTM_17'
    NAD__1983_MTM__2_S_CO_PQ='NAD_1983_MTM_2_SCoPQ'
    NAD__1983_MTM__2='NAD_1983_MTM_2'
    NAD__1983_MTM__3='NAD_1983_MTM_3'
    NAD__1983_MTM__4='NAD_1983_MTM_4'
    NAD__1983_MTM__5='NAD_1983_MTM_5'
    NAD__1983_MTM__6='NAD_1983_MTM_6'
    NAD__1983_MTM__7='NAD_1983_MTM_7'
    NAD__1983_MTM__8='NAD_1983_MTM_8'
    NAD__1983_MTM__9='NAD_1983_MTM_9'
    NAD__1983__QUEBEC__LAMBERT='NAD_1983_Quebec_Lambert'
    PRINCE__EDWARD__ISLAND__STEREOGRAPHIC='Prince_Edward_Island_Stereographic'
    CARTHAGE_TM__11_NE='Carthage_TM_11_NE'
    CENTRE__FRANCE='Centre_France'
    CH_1903_LV_03='CH1903_LV03'
    CH_1903_LV_95='CH1903+_LV95'
    CHOS__MALAL__1914__ARGENTINA__2='Chos_Malal_1914_Argentina_2'
    COLOMBIA__BOGOTA__ZONE='Colombia_Bogota_Zone'
    COLOMBIA__EAST__CENTRAL__ZONE='Colombia_East_Central_Zone'
    COLOMBIA__EAST__ZONE='Colombia_East_Zone'
    COLOMBIA__WEST__ZONE='Colombia_West_Zone'
    CORSE='Corse'
    DATUM__73__HAYFORD__GAUSS_I_GEO_E='Datum_73_Hayford_Gauss_IGeoE'
    DATUM__73__HAYFORD__GAUSS_IPCC='Datum_73_Hayford_Gauss_IPCC'
    DEIR_EZ__ZOR__LEVANT__STEREOGRAPHIC='Deir_ez_Zor_Levant_Stereographic'
    DEIR_EZ__ZOR__LEVANT__ZONE='Deir_ez_Zor_Levant_Zone'
    DEIR_EZ__ZOR__SYRIA__LAMBERT='Deir_ez_Zor_Syria_Lambert'
    DHDN__3__DEGREE__GAUSS__ZONE__1='DHDN_3_Degree_Gauss_Zone_1'
    DHDN__3__DEGREE__GAUSS__ZONE__2='DHDN_3_Degree_Gauss_Zone_2'
    DHDN__3__DEGREE__GAUSS__ZONE__3='DHDN_3_Degree_Gauss_Zone_3'
    DHDN__3__DEGREE__GAUSS__ZONE__4='DHDN_3_Degree_Gauss_Zone_4'
    DHDN__3__DEGREE__GAUSS__ZONE__5='DHDN_3_Degree_Gauss_Zone_5'
    DOMINICA__1945__BRITISH__WEST__INDIES__GRID='Dominica_1945_British_West_Indies_Grid'
    ED__1950_TM__0_N='ED_1950_TM_0_N'
    ED__1950_TM__5_NE='ED_1950_TM_5_NE'
    EGYPT__BLUE__BELT='Egypt_Blue_Belt'
    EGYPT__EXTENDED__PURPLE__BELT='Egypt_Extended_Purple_Belt'
    EGYPT__PURPLE__BELT='Egypt_Purple_Belt'
    EGYPT__RED__BELT='Egypt_Red_Belt'
    ELD__1979__LIBYA__10='ELD_1979_Libya_10'
    ELD__1979__LIBYA__11='ELD_1979_Libya_11'
    ELD__1979__LIBYA__12='ELD_1979_Libya_12'
    ELD__1979__LIBYA__13='ELD_1979_Libya_13'
    ELD__1979__LIBYA__5='ELD_1979_Libya_5'
    ELD__1979__LIBYA__6='ELD_1979_Libya_6'
    ELD__1979__LIBYA__7='ELD_1979_Libya_7'
    ELD__1979__LIBYA__8='ELD_1979_Libya_8'
    ELD__1979__LIBYA__9='ELD_1979_Libya_9'
    ELD__1979_TM__12_NE='ELD_1979_TM_12_NE'
    ESTONIAN__COORDINATE__SYSTEM_OF__1992='Estonian_Coordinate_System_of_1992'
    ETRF__1989_TM__BALTIC__1993='ETRF_1989_TM_Baltic_1993'
    FD__1958__IRAQ='FD_1958_Iraq'
    FINLAND__ZONE__1='Finland_Zone_1'
    FINLAND__ZONE__2='Finland_Zone_2'
    FINLAND__ZONE__3='Finland_Zone_3'
    FINLAND__ZONE__4='Finland_Zone_4'
    FRANCE_I='France_I'
    FRANCE_II='France_II'
    FRANCE_III='France_III'
    FRANCE_IV='France_IV'
    GERMANY__ZONE__1='Germany_Zone_1'
    GERMANY__ZONE__2='Germany_Zone_2'
    GERMANY__ZONE__3='Germany_Zone_3'
    GERMANY__ZONE__4='Germany_Zone_4'
    GERMANY__ZONE__5='Germany_Zone_5'
    GHANA__METRE__GRID='Ghana_Metre_Grid'
    GREEK__GRID='Greek_Grid'
    GRENADA__1953__BRITISH__WEST__INDIES__GRID='Grenada_1953_British_West_Indies_Grid'
    HANOI__1972_GK__106_NE='Hanoi_1972_GK_106_NE'
    HD__1972__EGYSEGES__ORSZAGOS__VETULETI='HD_1972_Egyseges_Orszagos_Vetuleti'
    HITO_XVIII__1963__ARGENTINA__2='Hito_XVIII_1963_Argentina_2'
    HONG__KONG__1980__GRID='Hong_Kong_1980_Grid'
    INDIAN__1960_TM__106_NE='Indian_1960_TM_106NE'
    KALIANPUR__1880__INDIA__ZONE__0='Kalianpur_1880_India_Zone_0'
    KALIANPUR__1880__INDIA__ZONE_I='Kalianpur_1880_India_Zone_I'
    KALIANPUR__1880__INDIA__ZONE_I_IA='Kalianpur_1880_India_Zone_IIa'
    KALIANPUR__1880__INDIA__ZONE_I_IB='Kalianpur_1880_India_Zone_IIb'
    KALIANPUR__1880__INDIA__ZONE_III='Kalianpur_1880_India_Zone_III'
    KALIANPUR__1880__INDIA__ZONE_IV='Kalianpur_1880_India_Zone_IV'
    KALIANPUR__1937__INDIA__ZONE_I_IB='Kalianpur_1937_India_Zone_IIb'
    KALIANPUR__1937_UTM__ZONE__45_N='Kalianpur_1937_UTM_Zone_45N'
    KALIANPUR__1937_UTM__ZONE__46_N='Kalianpur_1937_UTM_Zone_46N'
    KALIANPUR__1962__INDIA__ZONE_I='Kalianpur_1962_India_Zone_I'
    KALIANPUR__1962__INDIA__ZONE_I_IA='Kalianpur_1962_India_Zone_IIa'
    KALIANPUR__1962_UTM__ZONE__41_N='Kalianpur_1962_UTM_Zone_41N'
    KALIANPUR__1962_UTM__ZONE__42_N='Kalianpur_1962_UTM_Zone_42N'
    KALIANPUR__1962_UTM__ZONE__43_N='Kalianpur_1962_UTM_Zone_43N'
    KALIANPUR__1975__INDIA__ZONE_I='Kalianpur_1975_India_Zone_I'
    KALIANPUR__1975__INDIA__ZONE_I_IA='Kalianpur_1975_India_Zone_IIa'
    KALIANPUR__1975__INDIA__ZONE_I_IB='Kalianpur_1975_India_Zone_IIb'
    KALIANPUR__1975__INDIA__ZONE_III='Kalianpur_1975_India_Zone_III'
    KALIANPUR__1975__INDIA__ZONE_IV='Kalianpur_1975_India_Zone_IV'
    KALIANPUR__1975_UTM__ZONE__42_N='Kalianpur_1975_UTM_Zone_42N'
    KALIANPUR__1975_UTM__ZONE__43_N='Kalianpur_1975_UTM_Zone_43N'
    KALIANPUR__1975_UTM__ZONE__44_N='Kalianpur_1975_UTM_Zone_44N'
    KALIANPUR__1975_UTM__ZONE__45_N='Kalianpur_1975_UTM_Zone_45N'
    KALIANPUR__1975_UTM__ZONE__46_N='Kalianpur_1975_UTM_Zone_46N'
    KALIANPUR__1975_UTM__ZONE__47_N='Kalianpur_1975_UTM_Zone_47N'
    IRENET_95_IRISH__TRANSVERSE__MERCATOR='IRENET95_IRISH_Transverse_Mercator'
    IRISH__NATIONAL__GRID='Irish_National_Grid'
    ISRAEL_TM__GRID='Israel_TM_Grid'
    JAMAICA__1875__OLD__GRID='Jamaica_1875_Old_Grid'
    JAMAICA__GRID='Jamaica_Grid'
    JAPAN__ZONE__1='Japan_Zone_1'
    JAPAN__ZONE__10='Japan_Zone_10'
    JAPAN__ZONE__11='Japan_Zone_11'
    JAPAN__ZONE__12='Japan_Zone_12'
    JAPAN__ZONE__13='Japan_Zone_13'
    JAPAN__ZONE__14='Japan_Zone_14'
    JAPAN__ZONE__15='Japan_Zone_15'
    JAPAN__ZONE__16='Japan_Zone_16'
    JAPAN__ZONE__17='Japan_Zone_17'
    JAPAN__ZONE__18='Japan_Zone_18'
    JAPAN__ZONE__19='Japan_Zone_19'
    JAPAN__ZONE__2='Japan_Zone_2'
    JAPAN__ZONE__3='Japan_Zone_3'
    JAPAN__ZONE__4='Japan_Zone_4'
    JAPAN__ZONE__5='Japan_Zone_5'
    JAPAN__ZONE__6='Japan_Zone_6'
    JAPAN__ZONE__7='Japan_Zone_7'
    JAPAN__ZONE__8='Japan_Zone_8'
    JAPAN__ZONE__9='Japan_Zone_9'
    KERTAU__SINGAPORE__GRID='Kertau_Singapore_Grid'
    KOC__LAMBERT='KOC_Lambert'
    KOREAN__1985__KOREA__CENTRAL__BELT='Korean_1985_Korea_Central_Belt'
    KOREAN__1985__KOREA__EAST__BELT='Korean_1985_Korea_East_Belt'
    KOREAN__1985__KOREA__WEST__BELT='Korean_1985_Korea_West_Belt'
    KUDAMS_KTM='KUDAMS_KTM'
    KOC__LAMBERT_1='KOC_Lambert'
    KUDAMS_KTM_1='KUDAMS_KTM'
    LAKE__MARACAIBO__GRID_M_1='Lake_Maracaibo_Grid_M1'
    LAKE__MARACAIBO__GRID_M_3='Lake_Maracaibo_Grid_M3'
    LAKE__MARACAIBO__GRID='Lake_Maracaibo_Grid'
    LAKE__MARACAIBO__LA__ROSA__GRID='Lake_Maracaibo_La_Rosa_Grid'
    LIETUVOS__KOORDINACIU__SISTEMA='Lietuvos_Koordinaciu_Sistema'
    LISBOA__BESSEL__BONNE='Lisboa_Bessel_Bonne'
    LISBOA__HAYFORD__GAUSS_I_GEO_E='Lisboa_Hayford_Gauss_IGeoE'
    LISBOA__HAYFORD__GAUSS_IPCC='Lisboa_Hayford_Gauss_IPCC'
    LOCODJO__1965_TM__5_NW='Locodjo_1965_TM_5_NW'
    MADRID__1870__MADRID__SPAIN='Madrid_1870_Madrid_Spain'
    MGI__3__DEGREE__GAUSS__ZONE__5='MGI_3_Degree_Gauss_Zone_5'
    MGI__3__DEGREE__GAUSS__ZONE__6='MGI_3_Degree_Gauss_Zone_6'
    MGI__3__DEGREE__GAUSS__ZONE__7='MGI_3_Degree_Gauss_Zone_7'
    MGI__3__DEGREE__GAUSS__ZONE__8='MGI_3_Degree_Gauss_Zone_8'
    MGI__AUSTRIA__LAMBERT='MGI_Austria_Lambert'
    MGI__BALKANS__5='MGI_Balkans_5'
    MGI__BALKANS__6='MGI_Balkans_6'
    MGI__BALKANS__8='MGI_Balkans_8'
    MGI__BALKANS__8_1='MGI_Balkans_8'
    MGI_M_28='MGI_M28'
    MGI_M_31='MGI_M31'
    MGI_M_34='MGI_M34'
    MONTE__MARIO__ROME__ITALY__1='Monte_Mario_Rome_Italy_1'
    MONTE__MARIO__ROME__ITALY__2='Monte_Mario_Rome_Italy_2'
    MONTE__MARIO__ITALY__1='Monte_Mario_Italy_1'
    MONTE__MARIO__ITALY__2='Monte_Mario_Italy_2'
    MONTSERRAT__1958__BRITISH__WEST__INDIES__GRID='Montserrat_1958_British_West_Indies_Grid'
    MOUNT__DILLON__TOBAGO__GRID='Mount_Dillon_Tobago_Grid'
    NAD__1927__CUBA__NORTE='NAD_1927_Cuba_Norte'
    NAD__1927__CUBA__SUR='NAD_1927_Cuba_Sur'
    NAD__1927__GUATEMALA__NORTE='NAD_1927_Guatemala_Norte'
    NAD__1927__GUATEMALA__SUR='NAD_1927_Guatemala_Sur'
    NAD__1927__MICHIGAN__GEO_REF__METERS='NAD_1927_Michigan_GeoRef_Meters'
    NAD__1927__MICHIGAN__GEO_REF__FEET_US='NAD_1927_Michigan_GeoRef_Feet_US'
    NAD__1983_HARN__GUAM__MAP__GRID='NAD_1983_HARN_Guam_Map_Grid'
    NAD__1983__MICHIGAN__GEO_REF__METERS='NAD_1983_Michigan_GeoRef_Meters'
    NAD__1983__MICHIGAN__GEO_REF__FEET_US='NAD_1983_Michigan_GeoRef_Feet_US'
    GD__1949__NEW__ZEALAND__MAP__GRID='GD_1949_New_Zealand_Map_Grid'
    NEW__ZEALAND__NORTH__ISLAND='New_Zealand_North_Island'
    NEW__ZEALAND__SOUTH__ISLAND='New_Zealand_South_Island'
    NZGD__1949__AMURI__CIRCUIT='NZGD_1949_Amuri_Circuit'
    NZGD__1949__BAY_OF__PLENTY__CIRCUIT='NZGD_1949_Bay_of_Plenty_Circuit'
    NZGD__1949__BLUFF__CIRCUIT='NZGD_1949_Bluff_Circuit'
    NZGD__1949__BULLER__CIRCUIT='NZGD_1949_Buller_Circuit'
    NZGD__1949__COLLINGWOOD__CIRCUIT='NZGD_1949_Collingwood_Circuit'
    NZGD__1949__GAWLER__CIRCUIT='NZGD_1949_Gawler_Circuit'
    NZGD__1949__GREY__CIRCUIT='NZGD_1949_Grey_Circuit'
    NZGD__1949__HAWKES__BAY__CIRCUIT='NZGD_1949_Hawkes_Bay_Circuit'
    NZGD__1949__HOKITIKA__CIRCUIT='NZGD_1949_Hokitika_Circuit'
    NZGD__1949__JACKSONS__BAY__CIRCUIT='NZGD_1949_Jacksons_Bay_Circuit'
    NZGD__1949__KARAMEA__CIRCUIT='NZGD_1949_Karamea_Circuit'
    NZGD__1949__LINDIS__PEAK__CIRCUIT='NZGD_1949_Lindis_Peak_Circuit'
    NZGD__1949__MARLBOROUGH__CIRCUIT='NZGD_1949_Marlborough_Circuit'
    NZGD__1949__MOUNT__EDEN__CIRCUIT='NZGD_1949_Mount_Eden_Circuit'
    NZGD__1949__MOUNT__NICHOLAS__CIRCUIT='NZGD_1949_Mount_Nicholas_Circuit'
    NZGD__1949__MOUNT__PLEASANT__CIRCUIT='NZGD_1949_Mount_Pleasant_Circuit'
    NZGD__1949__MOUNT__YORK__CIRCUIT='NZGD_1949_Mount_York_Circuit'
    NZGD__1949__NELSON__CIRCUIT='NZGD_1949_Nelson_Circuit'
    NZGD__1949__NORTH__TAIERI__CIRCUIT='NZGD_1949_North_Taieri_Circuit'
    NZGD__1949__OBSERVATION__POINT__CIRCUIT='NZGD_1949_Observation_Point_Circuit'
    NZGD__1949__OKARITO__CIRCUIT='NZGD_1949_Okarito_Circuit'
    NZGD__1949__POVERTY__BAY__CIRCUIT='NZGD_1949_Poverty_Bay_Circuit'
    NZGD__1949__TARANAKI__CIRCUIT='NZGD_1949_Taranaki_Circuit'
    NZGD__1949__TIMARU__CIRCUIT='NZGD_1949_Timaru_Circuit'
    NZGD__1949__TUHIRANGI__CIRCUIT='NZGD_1949_Tuhirangi_Circuit'
    NZGD__1949_UTM__ZONE__58_S='NZGD_1949_UTM_Zone_58S'
    NZGD__1949_UTM__ZONE__59_S='NZGD_1949_UTM_Zone_59S'
    NZGD__1949_UTM__ZONE__60_S='NZGD_1949_UTM_Zone_60S'
    NZGD__1949__WAIRARAPA__CIRCUIT='NZGD_1949_Wairarapa_Circuit'
    NZGD__1949__WANGANUI__CIRCUIT='NZGD_1949_Wanganui_Circuit'
    NZGD__1949__WELLINGTON__CIRCUIT='NZGD_1949_Wellington_Circuit'
    NZGD__2000__AMURI__CIRCUIT='NZGD_2000_Amuri_Circuit'
    NZGD__2000__BAY_OF__PLENTY__CIRCUIT='NZGD_2000_Bay_of_Plenty_Circuit'
    NZGD__2000__BLUFF__CIRCUIT='NZGD_2000_Bluff_Circuit'
    NZGD__2000__BULLER__CIRCUIT='NZGD_2000_Buller_Circuit'
    NZGD__2000__COLLINGWOOD__CIRCUIT='NZGD_2000_Collingwood_Circuit'
    NZGD__2000__GAWLER__CIRCUIT='NZGD_2000_Gawler_Circuit'
    NZGD__2000__GREY__CIRCUIT='NZGD_2000_Grey_Circuit'
    NZGD__2000__HAWKES__BAY__CIRCUIT='NZGD_2000_Hawkes_Bay_Circuit'
    NZGD__2000__HOKITIKA__CIRCUIT='NZGD_2000_Hokitika_Circuit'
    NZGD__2000__JACKSONS__BAY__CIRCUIT='NZGD_2000_Jacksons_Bay_Circuit'
    NZGD__2000__KARAMEA__CIRCUIT='NZGD_2000_Karamea_Circuit'
    NZGD__2000__LINDIS__PEAK__CIRCUIT='NZGD_2000_Lindis_Peak_Circuit'
    NZGD__2000__MARLBOROUGH__CIRCUIT='NZGD_2000_Marlborough_Circuit'
    NZGD__2000__MOUNT__EDEN__CIRCUIT='NZGD_2000_Mount_Eden_Circuit'
    NZGD__2000__MOUNT__NICHOLAS__CIRCUIT='NZGD_2000_Mount_Nicholas_Circuit'
    NZGD__2000__MOUNT__PLEASANT__CIRCUIT='NZGD_2000_Mount_Pleasant_Circuit'
    NZGD__2000__MOUNT__YORK__CIRCUIT='NZGD_2000_Mount_York_Circuit'
    NZGD__2000__NELSON__CIRCUIT='NZGD_2000_Nelson_Circuit'
    NZGD__2000__NORTH__TAIERI__CIRCUIT='NZGD_2000_North_Taieri_Circuit'
    NZGD__2000__OBSERVATION__POINT__CIRCUIT='NZGD_2000_Observation_Point_Circuit'
    NZGD__2000__OKARITO__CIRCUIT='NZGD_2000_Okarito_Circuit'
    NZGD__2000__POVERTY__BAY__CIRCUIT='NZGD_2000_Poverty_Bay_Circuit'
    NZGD__2000__TARANAKI__CIRCUIT='NZGD_2000_Taranaki_Circuit'
    NZGD__2000__TIMARU__CIRCUIT='NZGD_2000_Timaru_Circuit'
    NZGD__2000__TUHIRANGI__CIRCUIT='NZGD_2000_Tuhirangi_Circuit'
    NZGD__2000_UTM__ZONE__58_S='NZGD_2000_UTM_Zone_58S'
    NZGD__2000_UTM__ZONE__59_S='NZGD_2000_UTM_Zone_59S'
    NZGD__2000_UTM__ZONE__60_S='NZGD_2000_UTM_Zone_60S'
    NZGD__2000__WAIRARAPA__CIRCUIT='NZGD_2000_Wairarapa_Circuit'
    NZGD__2000__WANGANUI__CIRCUIT='NZGD_2000_Wanganui_Circuit'
    NZGD__2000__WELLINGTON__CIRCUIT='NZGD_2000_Wellington_Circuit'
    GD__1949__NEW__ZEALAND__MAP__GRID_1='GD_1949_New_Zealand_Map_Grid'
    NEW__ZEALAND__NORTH__ISLAND_1='New_Zealand_North_Island'
    NEW__ZEALAND__SOUTH__ISLAND_1='New_Zealand_South_Island'
    NIGERIA__EAST__BELT='Nigeria_East_Belt'
    NIGERIA__MID__BELT='Nigeria_Mid_Belt'
    NIGERIA__WEST__BELT='Nigeria_West_Belt'
    NORD__ALGERIE__DEGREE='Nord_Algerie_Degree'
    NORD__ALGERIE__ANCIENNE__DEGREE='Nord_Algerie_Ancienne_Degree'
    SUD__ALGERIE__ANCIENNE='Sud_Algerie_Ancienne'
    NORD__ALGERIE='Nord_Algerie'
    NORD_DE__GUERRE='Nord_de_Guerre'
    NORD__FRANCE='Nord_France'
    NORD__MAROC__DEGREE='Nord_Maroc_Degree'
    NORD__MAROC='Nord_Maroc'
    NORD__TUNISIE='Nord_Tunisie'
    NGO__1948__BAERUM__KOMMUNE='NGO_1948_Baerum_Kommune'
    NGO__1948__BERGENHALVOEN='NGO_1948_Bergenhalvoen'
    NGO__1948__NORWAY__ZONE__1='NGO_1948_Norway_Zone_1'
    NGO__1948__NORWAY__ZONE__2='NGO_1948_Norway_Zone_2'
    NGO__1948__NORWAY__ZONE__3='NGO_1948_Norway_Zone_3'
    NGO__1948__NORWAY__ZONE__4='NGO_1948_Norway_Zone_4'
    NGO__1948__NORWAY__ZONE__5='NGO_1948_Norway_Zone_5'
    NGO__1948__NORWAY__ZONE__6='NGO_1948_Norway_Zone_6'
    NGO__1948__NORWAY__ZONE__7='NGO_1948_Norway_Zone_7'
    NGO__1948__NORWAY__ZONE__8='NGO_1948_Norway_Zone_8'
    NGO__1948__OSLO__KOMMUNE='NGO_1948_Oslo_Kommune'
    NGO__1948__OSLO__NORWAY__ZONE__1='NGO_1948_Oslo_Norway_Zone_1'
    NGO__1948__OSLO__NORWAY__ZONE__2='NGO_1948_Oslo_Norway_Zone_2'
    NGO__1948__OSLO__NORWAY__ZONE__3='NGO_1948_Oslo_Norway_Zone_3'
    NGO__1948__OSLO__NORWAY__ZONE__4='NGO_1948_Oslo_Norway_Zone_4'
    NGO__1948__OSLO__NORWAY__ZONE__5='NGO_1948_Oslo_Norway_Zone_5'
    NGO__1948__OSLO__NORWAY__ZONE__6='NGO_1948_Oslo_Norway_Zone_6'
    NGO__1948__OSLO__NORWAY__ZONE__7='NGO_1948_Oslo_Norway_Zone_7'
    NGO__1948__OSLO__NORWAY__ZONE__8='NGO_1948_Oslo_Norway_Zone_8'
    NTF__FRANCE_I_DEGREES='NTF_France_I_degrees'
    NTF__FRANCE_II_DEGREES='NTF_France_II_degrees'
    NTF__FRANCE_III_DEGREES='NTF_France_III_degrees'
    NTF__FRANCE_IV_DEGREES='NTF_France_IV_degrees'
    PALESTINE__1923__ISRAEL_CS__GRID='Palestine_1923_Israel_CS_Grid'
    PALESTINE__1923__PALESTINE__BELT='Palestine_1923_Palestine_Belt'
    PALESTINE__1923__PALESTINE__GRID='Palestine_1923_Palestine_Grid'
    PAMPA_DEL__CASTILLO__ARGENTINA__2='Pampa_del_Castillo_Argentina_2'
    PERU__CENTRAL__ZONE='Peru_Central_Zone'
    PERU__EAST__ZONE='Peru_East_Zone'
    PERU__WEST__ZONE='Peru_West_Zone'
    PHILIPPINES__ZONE_I='Philippines_Zone_I'
    PHILIPPINES__ZONE_II='Philippines_Zone_II'
    PHILIPPINES__ZONE_III='Philippines_Zone_III'
    PHILIPPINES__ZONE_IV='Philippines_Zone_IV'
    PHILIPPINES__ZONE_V='Philippines_Zone_V'
    PORTUGUESE__NATIONAL__GRID='Portuguese_National_Grid'
    QATAR__1948__QATAR__GRID='Qatar_1948_Qatar_Grid'
    QATAR__NATIONAL__GRID='Qatar_National_Grid'
    RD__OLD='RD_Old'
    RGF__1993__LAMBERT__93='RGF_1993_Lambert_93'
    RIJKSDRIEHOEKSTELSEL__NEW='Rijksdriehoekstelsel_New'
    RT_90__25_GON_W='RT90_25_gon_W'
    SJTSK__FERRO__KROVAK__EAST__NORTH='S-JTSK_Ferro_Krovak_East_North'
    SJTSK__FERRO__KROVAK='S-JTSK_Ferro_Krovak'
    SJTSK__KROVAK__EAST__NORTH='S-JTSK_Krovak_East_North'
    SJTSK__KROVAK='S-JTSK_Krovak'
    SAD__1969__BRAZIL__POLYCONIC='SAD_1969_Brazil_Polyconic'
    SAHARA__DEGREE='Sahara_Degree'
    SAHARA='Sahara'
    SIERRA__LEONE__1924__NEW__COLONY__GRID='Sierra_Leone_1924_New_Colony_Grid'
    SIERRA__LEONE__1924__NEW__WAR__OFFICE__GRID='Sierra_Leone_1924_New_War_Office_Grid'
    ST__KITTS__1955__BRITISH__WEST__INDIES__GRID='St_Kitts_1955_British_West_Indies_Grid'
    ST__LUCIA__1955__BRITISH__WEST__INDIES__GRID='St_Lucia_1955_British_West_Indies_Grid'
    ST__VINCENT__1945__BRITISH__WEST__INDIES__GRID='St_Vincent_1945_British_West_Indies_Grid'
    STEREO__33='Stereo_33'
    STEREO__70='Stereo_70'
    SUD__ALGERIE__DEGREE='Sud_Algerie_Degree'
    SUD__ALGERIE__ANCIENNE__DEGREE='Sud_Algerie_Ancienne_Degree'
    SUD__ALGERIE='Sud_Algerie'
    SUD__FRANCE='Sud_France'
    SUD__MAROC__DEGREE='Sud_Maroc_Degree'
    SUD__MAROC='Sud_Maroc'
    SUD__TUNISIE='Sud_Tunisie'
    SWEDISH__NATIONAL__GRID='Swedish_National_Grid'
    TRINIDAD__1903__TRINIDAD__GRID='Trinidad_1903_Trinidad_Grid'
    UWPP__1992='UWPP_1992'
    UWPP__2000_PAS__5='UWPP_2000_pas_5'
    UWPP__2000_PAS__6='UWPP_2000_pas_6'
    UWPP__2000_PAS__7='UWPP_2000_pas_7'
    UWPP__2000_PAS__8='UWPP_2000_pas_8'
    WGS__1972_BE_TM__106_NE='WGS_1972_BE_TM_106_NE'
    WGS__1984_TM__36_SE='WGS_1984_TM_36_SE'
    ZANDERIJ__SURINAME__OLD_TM='Zanderij_Suriname_Old_TM'
    ZANDERIJ__SURINAME_TM='Zanderij_Suriname_TM'
    ZANDERIJ_TM__54_NW='Zanderij_TM_54_NW'
    NORTH__POLE__AZIMUTHAL__EQUIDISTANT='North_Pole_Azimuthal_Equidistant'
    NORTH__POLE__GNOMONIC='North_Pole_Gnomonic'
    NORTH__POLE__LAMBERT__AZIMUTHAL__EQUAL__AREA='North_Pole_Lambert_Azimuthal_Equal_Area'
    NORTH__POLE__ORTHOGRAPHIC='North_Pole_Orthographic'
    NORTH__POLE__STEREOGRAPHIC='North_Pole_Stereographic'
    SOUTH__POLE__AZIMUTHAL__EQUIDISTANT='South_Pole_Azimuthal_Equidistant'
    SOUTH__POLE__GNOMONIC='South_Pole_Gnomonic'
    SOUTH__POLE__LAMBERT__AZIMUTHAL__EQUAL__AREA='South_Pole_Lambert_Azimuthal_Equal_Area'
    SOUTH__POLE__ORTHOGRAPHIC='South_Pole_Orthographic'
    SOUTH__POLE__STEREOGRAPHIC='South_Pole_Stereographic'
    UPS__NORTH='UPS_North'
    UPS__SOUTH='UPS_South'
    NAD__1927__STATE_PLANE__ALABAMA__EAST_FIPS__0101='NAD_1927_StatePlane_Alabama_East_FIPS_0101'
    NAD__1927__STATE_PLANE__ALABAMA__WEST_FIPS__0102='NAD_1927_StatePlane_Alabama_West_FIPS_0102'
    NAD__1927__STATE_PLANE__ALASKA__1_FIPS__5001='NAD_1927_StatePlane_Alaska_1_FIPS_5001'
    NAD__1927__STATE_PLANE__ALASKA__10_FIPS__5010='NAD_1927_StatePlane_Alaska_10_FIPS_5010'
    NAD__1927__STATE_PLANE__ALASKA__2_FIPS__5002='NAD_1927_StatePlane_Alaska_2_FIPS_5002'
    NAD__1927__STATE_PLANE__ALASKA__3_FIPS__5003='NAD_1927_StatePlane_Alaska_3_FIPS_5003'
    NAD__1927__STATE_PLANE__ALASKA__4_FIPS__5004='NAD_1927_StatePlane_Alaska_4_FIPS_5004'
    NAD__1927__STATE_PLANE__ALASKA__5_FIPS__5005='NAD_1927_StatePlane_Alaska_5_FIPS_5005'
    NAD__1927__STATE_PLANE__ALASKA__6_FIPS__5006='NAD_1927_StatePlane_Alaska_6_FIPS_5006'
    NAD__1927__STATE_PLANE__ALASKA__7_FIPS__5007='NAD_1927_StatePlane_Alaska_7_FIPS_5007'
    NAD__1927__STATE_PLANE__ALASKA__8_FIPS__5008='NAD_1927_StatePlane_Alaska_8_FIPS_5008'
    NAD__1927__STATE_PLANE__ALASKA__9_FIPS__5009='NAD_1927_StatePlane_Alaska_9_FIPS_5009'
    NAD__1927__STATE_PLANE__ARIZONA__CENTRAL_FIPS__0202='NAD_1927_StatePlane_Arizona_Central_FIPS_0202'
    NAD__1927__STATE_PLANE__ARIZONA__EAST_FIPS__0201='NAD_1927_StatePlane_Arizona_East_FIPS_0201'
    NAD__1927__STATE_PLANE__ARIZONA__WEST_FIPS__0203='NAD_1927_StatePlane_Arizona_West_FIPS_0203'
    NAD__1927__STATE_PLANE__ARKANSAS__NORTH_FIPS__0301='NAD_1927_StatePlane_Arkansas_North_FIPS_0301'
    NAD__1927__STATE_PLANE__ARKANSAS__SOUTH_FIPS__0302='NAD_1927_StatePlane_Arkansas_South_FIPS_0302'
    NAD__1927__STATE_PLANE__CALIFORNIA_I_FIPS__0401='NAD_1927_StatePlane_California_I_FIPS_0401'
    NAD__1927__STATE_PLANE__CALIFORNIA_II_FIPS__0402='NAD_1927_StatePlane_California_II_FIPS_0402'
    NAD__1927__STATE_PLANE__CALIFORNIA_III_FIPS__0403='NAD_1927_StatePlane_California_III_FIPS_0403'
    NAD__1927__STATE_PLANE__CALIFORNIA_IV_FIPS__0404='NAD_1927_StatePlane_California_IV_FIPS_0404'
    NAD__1927__STATE_PLANE__CALIFORNIA_V_FIPS__0405='NAD_1927_StatePlane_California_V_FIPS_0405'
    NAD__1927__STATE_PLANE__CALIFORNIA_VI_FIPS__0406='NAD_1927_StatePlane_California_VI_FIPS_0406'
    NAD__1927__STATE_PLANE__CALIFORNIA_VII_FIPS__0407='NAD_1927_StatePlane_California_VII_FIPS_0407'
    NAD__1927__STATE_PLANE__COLORADO__CENTRAL_FIPS__0502='NAD_1927_StatePlane_Colorado_Central_FIPS_0502'
    NAD__1927__STATE_PLANE__COLORADO__NORTH_FIPS__0501='NAD_1927_StatePlane_Colorado_North_FIPS_0501'
    NAD__1927__STATE_PLANE__COLORADO__SOUTH_FIPS__0503='NAD_1927_StatePlane_Colorado_South_FIPS_0503'
    NAD__1927__STATE_PLANE__CONNECTICUT_FIPS__0600='NAD_1927_StatePlane_Connecticut_FIPS_0600'
    NAD__1927__STATE_PLANE__DELAWARE_FIPS__0700='NAD_1927_StatePlane_Delaware_FIPS_0700'
    NAD__1927__STATE_PLANE__FLORIDA__EAST_FIPS__0901='NAD_1927_StatePlane_Florida_East_FIPS_0901'
    NAD__1927__STATE_PLANE__FLORIDA__NORTH_FIPS__0903='NAD_1927_StatePlane_Florida_North_FIPS_0903'
    NAD__1927__STATE_PLANE__FLORIDA__WEST_FIPS__0902='NAD_1927_StatePlane_Florida_West_FIPS_0902'
    NAD__1927__STATE_PLANE__GEORGIA__EAST_FIPS__1001='NAD_1927_StatePlane_Georgia_East_FIPS_1001'
    NAD__1927__STATE_PLANE__GEORGIA__WEST_FIPS__1002='NAD_1927_StatePlane_Georgia_West_FIPS_1002'
    NAD__1927__STATE_PLANE__GUAM_FIPS__5400='NAD_1927_StatePlane_Guam_FIPS_5400'
    NAD__1927__STATE_PLANE__IDAHO__CENTRAL_FIPS__1102='NAD_1927_StatePlane_Idaho_Central_FIPS_1102'
    NAD__1927__STATE_PLANE__IDAHO__EAST_FIPS__1101='NAD_1927_StatePlane_Idaho_East_FIPS_1101'
    NAD__1927__STATE_PLANE__IDAHO__WEST_FIPS__1103='NAD_1927_StatePlane_Idaho_West_FIPS_1103'
    NAD__1927__STATE_PLANE__ILLINOIS__EAST_FIPS__1201='NAD_1927_StatePlane_Illinois_East_FIPS_1201'
    NAD__1927__STATE_PLANE__ILLINOIS__WEST_FIPS__1202='NAD_1927_StatePlane_Illinois_West_FIPS_1202'
    NAD__1927__STATE_PLANE__INDIANA__EAST_FIPS__1301='NAD_1927_StatePlane_Indiana_East_FIPS_1301'
    NAD__1927__STATE_PLANE__INDIANA__WEST_FIPS__1302='NAD_1927_StatePlane_Indiana_West_FIPS_1302'
    NAD__1927__STATE_PLANE__IOWA__NORTH_FIPS__1401='NAD_1927_StatePlane_Iowa_North_FIPS_1401'
    NAD__1927__STATE_PLANE__IOWA__SOUTH_FIPS__1402='NAD_1927_StatePlane_Iowa_South_FIPS_1402'
    NAD__1927__STATE_PLANE__KANSAS__NORTH_FIPS__1501='NAD_1927_StatePlane_Kansas_North_FIPS_1501'
    NAD__1927__STATE_PLANE__KANSAS__SOUTH_FIPS__1502='NAD_1927_StatePlane_Kansas_South_FIPS_1502'
    NAD__1927__STATE_PLANE__KENTUCKY__NORTH_FIPS__1601='NAD_1927_StatePlane_Kentucky_North_FIPS_1601'
    NAD__1927__STATE_PLANE__KENTUCKY__SOUTH_FIPS__1602='NAD_1927_StatePlane_Kentucky_South_FIPS_1602'
    NAD__1927__STATE_PLANE__LOUISIANA__NORTH_FIPS__1701='NAD_1927_StatePlane_Louisiana_North_FIPS_1701'
    NAD__1927__STATE_PLANE__LOUISIANA__SOUTH_FIPS__1702='NAD_1927_StatePlane_Louisiana_South_FIPS_1702'
    NAD__1927__STATE_PLANE__MAINE__EAST_FIPS__1801='NAD_1927_StatePlane_Maine_East_FIPS_1801'
    NAD__1927__STATE_PLANE__MAINE__WEST_FIPS__1802='NAD_1927_StatePlane_Maine_West_FIPS_1802'
    NAD__1927__STATE_PLANE__MARYLAND_FIPS__1900='NAD_1927_StatePlane_Maryland_FIPS_1900'
    NAD__1927__STATE_PLANE__MASSACHUSETTS__ISLAND_FIPS__2002='NAD_1927_StatePlane_Massachusetts_Island_FIPS_2002'
    NAD__1927__STATE_PLANE__MASSACHUSETTS__MAINLAND_FIPS__2001='NAD_1927_StatePlane_Massachusetts_Mainland_FIPS_2001'
    NAD__1927__STATE_PLANE__MICHIGAN__CENTRAL_FIPS__2112='NAD_1927_StatePlane_Michigan_Central_FIPS_2112'
    NAD__1927__STATE_PLANE__MICHIGAN__NORTH_FIPS__2111='NAD_1927_StatePlane_Michigan_North_FIPS_2111'
    NAD__1927__STATE_PLANE__MICHIGAN__SOUTH_FIPS__2113='NAD_1927_StatePlane_Michigan_South_FIPS_2113'
    NAD__1927__STATE_PLANE__MINNESOTA__CENTRAL_FIPS__2202='NAD_1927_StatePlane_Minnesota_Central_FIPS_2202'
    NAD__1927__STATE_PLANE__MINNESOTA__NORTH_FIPS__2201='NAD_1927_StatePlane_Minnesota_North_FIPS_2201'
    NAD__1927__STATE_PLANE__MINNESOTA__SOUTH_FIPS__2203='NAD_1927_StatePlane_Minnesota_South_FIPS_2203'
    NAD__1927__STATE_PLANE__MISSISSIPPI__EAST_FIPS__2301='NAD_1927_StatePlane_Mississippi_East_FIPS_2301'
    NAD__1927__STATE_PLANE__MISSISSIPPI__WEST_FIPS__2302='NAD_1927_StatePlane_Mississippi_West_FIPS_2302'
    NAD__1927__STATE_PLANE__MISSOURI__CENTRAL_FIPS__2402='NAD_1927_StatePlane_Missouri_Central_FIPS_2402'
    NAD__1927__STATE_PLANE__MISSOURI__EAST_FIPS__2401='NAD_1927_StatePlane_Missouri_East_FIPS_2401'
    NAD__1927__STATE_PLANE__MISSOURI__WEST_FIPS__2403='NAD_1927_StatePlane_Missouri_West_FIPS_2403'
    NAD__1927__STATE_PLANE__MONTANA__CENTRAL_FIPS__2502='NAD_1927_StatePlane_Montana_Central_FIPS_2502'
    NAD__1927__STATE_PLANE__MONTANA__NORTH_FIPS__2501='NAD_1927_StatePlane_Montana_North_FIPS_2501'
    NAD__1927__STATE_PLANE__MONTANA__SOUTH_FIPS__2503='NAD_1927_StatePlane_Montana_South_FIPS_2503'
    NAD__1927__STATE_PLANE__NEBRASKA__NORTH_FIPS__2601='NAD_1927_StatePlane_Nebraska_North_FIPS_2601'
    NAD__1927__STATE_PLANE__NEBRASKA__SOUTH_FIPS__2602='NAD_1927_StatePlane_Nebraska_South_FIPS_2602'
    NAD__1927__STATE_PLANE__NEVADA__CENTRAL_FIPS__2702='NAD_1927_StatePlane_Nevada_Central_FIPS_2702'
    NAD__1927__STATE_PLANE__NEVADA__EAST_FIPS__2701='NAD_1927_StatePlane_Nevada_East_FIPS_2701'
    NAD__1927__STATE_PLANE__NEVADA__WEST_FIPS__2703='NAD_1927_StatePlane_Nevada_West_FIPS_2703'
    NAD__1927__STATE_PLANE__NEW__HAMPSHIRE_FIPS__2800='NAD_1927_StatePlane_New_Hampshire_FIPS_2800'
    NAD__1927__STATE_PLANE__NEW__JERSEY_FIPS__2900='NAD_1927_StatePlane_New_Jersey_FIPS_2900'
    NAD__1927__STATE_PLANE__NEW__MEXICO__CENTRAL_FIPS__3002='NAD_1927_StatePlane_New_Mexico_Central_FIPS_3002'
    NAD__1927__STATE_PLANE__NEW__MEXICO__EAST_FIPS__3001='NAD_1927_StatePlane_New_Mexico_East_FIPS_3001'
    NAD__1927__STATE_PLANE__NEW__MEXICO__WEST_FIPS__3003='NAD_1927_StatePlane_New_Mexico_West_FIPS_3003'
    NAD__1927__STATE_PLANE__NEW__YORK__CENTRAL_FIPS__3102='NAD_1927_StatePlane_New_York_Central_FIPS_3102'
    NAD__1927__STATE_PLANE__NEW__YORK__EAST_FIPS__3101='NAD_1927_StatePlane_New_York_East_FIPS_3101'
    NAD__1927__STATE_PLANE__NEW__YORK__LONG__ISLAND_FIPS__3104='NAD_1927_StatePlane_New_York_Long_Island_FIPS_3104'
    NAD__1927__STATE_PLANE__NEW__YORK__WEST_FIPS__3103='NAD_1927_StatePlane_New_York_West_FIPS_3103'
    NAD__1927__STATE_PLANE__NORTH__CAROLINA_FIPS__3200='NAD_1927_StatePlane_North_Carolina_FIPS_3200'
    NAD__1927__STATE_PLANE__NORTH__DAKOTA__NORTH_FIPS__3301='NAD_1927_StatePlane_North_Dakota_North_FIPS_3301'
    NAD__1927__STATE_PLANE__NORTH__DAKOTA__SOUTH_FIPS__3302='NAD_1927_StatePlane_North_Dakota_South_FIPS_3302'
    NAD__1927__STATE_PLANE__OHIO__NORTH_FIPS__3401='NAD_1927_StatePlane_Ohio_North_FIPS_3401'
    NAD__1927__STATE_PLANE__OHIO__SOUTH_FIPS__3402='NAD_1927_StatePlane_Ohio_South_FIPS_3402'
    NAD__1927__STATE_PLANE__OKLAHOMA__NORTH_FIPS__3501='NAD_1927_StatePlane_Oklahoma_North_FIPS_3501'
    NAD__1927__STATE_PLANE__OKLAHOMA__SOUTH_FIPS__3502='NAD_1927_StatePlane_Oklahoma_South_FIPS_3502'
    NAD__1927__STATE_PLANE__OREGON__NORTH_FIPS__3601='NAD_1927_StatePlane_Oregon_North_FIPS_3601'
    NAD__1927__STATE_PLANE__OREGON__SOUTH_FIPS__3602='NAD_1927_StatePlane_Oregon_South_FIPS_3602'
    NAD__1927__STATE_PLANE__PENNSYLVANIA__NORTH_FIPS__3701='NAD_1927_StatePlane_Pennsylvania_North_FIPS_3701'
    NAD__1927__STATE_PLANE__PENNSYLVANIA__SOUTH_FIPS__3702='NAD_1927_StatePlane_Pennsylvania_South_FIPS_3702'
    NAD__1927__STATE_PLANE__PUERTO__RICO_FIPS__5201='NAD_1927_StatePlane_Puerto_Rico_FIPS_5201'
    NAD__1927__STATE_PLANE__RHODE__ISLAND_FIPS__3800='NAD_1927_StatePlane_Rhode_Island_FIPS_3800'
    NAD__1927__STATE_PLANE__SOUTH__CAROLINA__NORTH_FIPS__3901='NAD_1927_StatePlane_South_Carolina_North_FIPS_3901'
    NAD__1927__STATE_PLANE__SOUTH__CAROLINA__SOUTH_FIPS__3902='NAD_1927_StatePlane_South_Carolina_South_FIPS_3902'
    NAD__1927__STATE_PLANE__SOUTH__DAKOTA__NORTH_FIPS__4001='NAD_1927_StatePlane_South_Dakota_North_FIPS_4001'
    NAD__1927__STATE_PLANE__SOUTH__DAKOTA__SOUTH_FIPS__4002='NAD_1927_StatePlane_South_Dakota_South_FIPS_4002'
    NAD__1927__STATE_PLANE__TENNESSEE_FIPS__4100='NAD_1927_StatePlane_Tennessee_FIPS_4100'
    NAD__1927__STATE_PLANE__TEXAS__CENTRAL_FIPS__4203='NAD_1927_StatePlane_Texas_Central_FIPS_4203'
    NAD__1927__STATE_PLANE__TEXAS__NORTH__CENTRAL_FIPS__4202='NAD_1927_StatePlane_Texas_North_Central_FIPS_4202'
    NAD__1927__STATE_PLANE__TEXAS__NORTH_FIPS__4201='NAD_1927_StatePlane_Texas_North_FIPS_4201'
    NAD__1927__STATE_PLANE__TEXAS__SOUTH__CENTRAL_FIPS__4204='NAD_1927_StatePlane_Texas_South_Central_FIPS_4204'
    NAD__1927__STATE_PLANE__TEXAS__SOUTH_FIPS__4205='NAD_1927_StatePlane_Texas_South_FIPS_4205'
    NAD__1927__STATE_PLANE__UTAH__CENTRAL_FIPS__4302='NAD_1927_StatePlane_Utah_Central_FIPS_4302'
    NAD__1927__STATE_PLANE__UTAH__NORTH_FIPS__4301='NAD_1927_StatePlane_Utah_North_FIPS_4301'
    NAD__1927__STATE_PLANE__UTAH__SOUTH_FIPS__4303='NAD_1927_StatePlane_Utah_South_FIPS_4303'
    NAD__1927__STATE_PLANE__VERMONT_FIPS__3400='NAD_1927_StatePlane_Vermont_FIPS_3400'
    NAD__1927__STATE_PLANE__VIRGINIA__NORTH_FIPS__4501='NAD_1927_StatePlane_Virginia_North_FIPS_4501'
    NAD__1927__STATE_PLANE__VIRGINIA__SOUTH_FIPS__4502='NAD_1927_StatePlane_Virginia_South_FIPS_4502'
    NAD__1927__STATE_PLANE__WASHINGTON__NORTH_FIPS__4601='NAD_1927_StatePlane_Washington_North_FIPS_4601'
    NAD__1927__STATE_PLANE__WASHINGTON__SOUTH_FIPS__4602='NAD_1927_StatePlane_Washington_South_FIPS_4602'
    NAD__1927__STATE_PLANE__WEST__VIRGINIA__NORTH_FIPS__4701='NAD_1927_StatePlane_West_Virginia_North_FIPS_4701'
    NAD__1927__STATE_PLANE__WEST__VIRGINIA__SOUTH_FIPS__4702='NAD_1927_StatePlane_West_Virginia_South_FIPS_4702'
    NAD__1927__STATE_PLANE__WISCONSIN__CENTRAL_FIPS__4802='NAD_1927_StatePlane_Wisconsin_Central_FIPS_4802'
    NAD__1927__STATE_PLANE__WISCONSIN__NORTH_FIPS__4801='NAD_1927_StatePlane_Wisconsin_North_FIPS_4801'
    NAD__1927__STATE_PLANE__WISCONSIN__SOUTH_FIPS__4803='NAD_1927_StatePlane_Wisconsin_South_FIPS_4803'
    NAD__1927__STATE_PLANE__WYOMING__EAST__CENTRAL_FIPS__4902='NAD_1927_StatePlane_Wyoming_East_Central_FIPS_4902'
    NAD__1927__STATE_PLANE__WYOMING__EAST_FIPS__4901='NAD_1927_StatePlane_Wyoming_East_FIPS_4901'
    NAD__1927__STATE_PLANE__WYOMING__WEST__CENTRAL_FIPS__4903='NAD_1927_StatePlane_Wyoming_West_Central_FIPS_4903'
    NAD__1927__STATE_PLANE__WYOMING__WEST_FIPS__4904='NAD_1927_StatePlane_Wyoming_West_FIPS_4904'
    NAD__1983__STATE_PLANE__ALABAMA__EAST_FIPS__0101='NAD_1983_StatePlane_Alabama_East_FIPS_0101'
    NAD__1983__STATE_PLANE__ALABAMA__WEST_FIPS__0102='NAD_1983_StatePlane_Alabama_West_FIPS_0102'
    NAD__1983__STATE_PLANE__ALASKA__1_FIPS__5001='NAD_1983_StatePlane_Alaska_1_FIPS_5001'
    NAD__1983__STATE_PLANE__ALASKA__10_FIPS__5010='NAD_1983_StatePlane_Alaska_10_FIPS_5010'
    NAD__1983__STATE_PLANE__ALASKA__2_FIPS__5002='NAD_1983_StatePlane_Alaska_2_FIPS_5002'
    NAD__1983__STATE_PLANE__ALASKA__3_FIPS__5003='NAD_1983_StatePlane_Alaska_3_FIPS_5003'
    NAD__1983__STATE_PLANE__ALASKA__4_FIPS__5004='NAD_1983_StatePlane_Alaska_4_FIPS_5004'
    NAD__1983__STATE_PLANE__ALASKA__5_FIPS__5005='NAD_1983_StatePlane_Alaska_5_FIPS_5005'
    NAD__1983__STATE_PLANE__ALASKA__6_FIPS__5006='NAD_1983_StatePlane_Alaska_6_FIPS_5006'
    NAD__1983__STATE_PLANE__ALASKA__7_FIPS__5007='NAD_1983_StatePlane_Alaska_7_FIPS_5007'
    NAD__1983__STATE_PLANE__ALASKA__8_FIPS__5008='NAD_1983_StatePlane_Alaska_8_FIPS_5008'
    NAD__1983__STATE_PLANE__ALASKA__9_FIPS__5009='NAD_1983_StatePlane_Alaska_9_FIPS_5009'
    NAD__1983__STATE_PLANE__ARIZONA__CENTRAL_FIPS__0202='NAD_1983_StatePlane_Arizona_Central_FIPS_0202'
    NAD__1983__STATE_PLANE__ARIZONA__EAST_FIPS__0201='NAD_1983_StatePlane_Arizona_East_FIPS_0201'
    NAD__1983__STATE_PLANE__ARIZONA__WEST_FIPS__0203='NAD_1983_StatePlane_Arizona_West_FIPS_0203'
    NAD__1983__STATE_PLANE__ARKANSAS__NORTH_FIPS__0301='NAD_1983_StatePlane_Arkansas_North_FIPS_0301'
    NAD__1983__STATE_PLANE__ARKANSAS__SOUTH_FIPS__0302='NAD_1983_StatePlane_Arkansas_South_FIPS_0302'
    NAD__1983__STATE_PLANE__CALIFORNIA_I_FIPS__0401='NAD_1983_StatePlane_California_I_FIPS_0401'
    NAD__1983__STATE_PLANE__CALIFORNIA_II_FIPS__0402='NAD_1983_StatePlane_California_II_FIPS_0402'
    NAD__1983__STATE_PLANE__CALIFORNIA_III_FIPS__0403='NAD_1983_StatePlane_California_III_FIPS_0403'
    NAD__1983__STATE_PLANE__CALIFORNIA_IV_FIPS__0404='NAD_1983_StatePlane_California_IV_FIPS_0404'
    NAD__1983__STATE_PLANE__CALIFORNIA_V_FIPS__0405='NAD_1983_StatePlane_California_V_FIPS_0405'
    NAD__1983__STATE_PLANE__CALIFORNIA_VI_FIPS__0406='NAD_1983_StatePlane_California_VI_FIPS_0406'
    NAD__1983__STATE_PLANE__COLORADO__CENTRAL_FIPS__0502='NAD_1983_StatePlane_Colorado_Central_FIPS_0502'
    NAD__1983__STATE_PLANE__COLORADO__NORTH_FIPS__0501='NAD_1983_StatePlane_Colorado_North_FIPS_0501'
    NAD__1983__STATE_PLANE__COLORADO__SOUTH_FIPS__0503='NAD_1983_StatePlane_Colorado_South_FIPS_0503'
    NAD__1983__STATE_PLANE__CONNECTICUT_FIPS__0600='NAD_1983_StatePlane_Connecticut_FIPS_0600'
    NAD__1983__STATE_PLANE__DELAWARE_FIPS__0700='NAD_1983_StatePlane_Delaware_FIPS_0700'
    NAD__1983__STATE_PLANE__FLORIDA__EAST_FIPS__0901='NAD_1983_StatePlane_Florida_East_FIPS_0901'
    NAD__1983__STATE_PLANE__FLORIDA__NORTH_FIPS__0903='NAD_1983_StatePlane_Florida_North_FIPS_0903'
    NAD__1983__STATE_PLANE__FLORIDA__WEST_FIPS__0902='NAD_1983_StatePlane_Florida_West_FIPS_0902'
    NAD__1983__STATE_PLANE__GEORGIA__EAST_FIPS__1001='NAD_1983_StatePlane_Georgia_East_FIPS_1001'
    NAD__1983__STATE_PLANE__GEORGIA__WEST_FIPS__1002='NAD_1983_StatePlane_Georgia_West_FIPS_1002'
    NAD__1983__STATE_PLANE__GUAM_FIPS__5400='NAD_1983_StatePlane_Guam_FIPS_5400'
    NAD__1983__STATE_PLANE__HAWAII__1_FIPS__5101='NAD_1983_StatePlane_Hawaii_1_FIPS_5101'
    NAD__1983__STATE_PLANE__HAWAII__2_FIPS__5102='NAD_1983_StatePlane_Hawaii_2_FIPS_5102'
    NAD__1983__STATE_PLANE__HAWAII__3_FIPS__5103='NAD_1983_StatePlane_Hawaii_3_FIPS_5103'
    NAD__1983__STATE_PLANE__HAWAII__4_FIPS__5104='NAD_1983_StatePlane_Hawaii_4_FIPS_5104'
    NAD__1983__STATE_PLANE__HAWAII__5_FIPS__5105='NAD_1983_StatePlane_Hawaii_5_FIPS_5105'
    NAD__1983__STATE_PLANE__IDAHO__CENTRAL_FIPS__1102='NAD_1983_StatePlane_Idaho_Central_FIPS_1102'
    NAD__1983__STATE_PLANE__IDAHO__EAST_FIPS__1101='NAD_1983_StatePlane_Idaho_East_FIPS_1101'
    NAD__1983__STATE_PLANE__IDAHO__WEST_FIPS__1103='NAD_1983_StatePlane_Idaho_West_FIPS_1103'
    NAD__1983__STATE_PLANE__ILLINOIS__EAST_FIPS__1201='NAD_1983_StatePlane_Illinois_East_FIPS_1201'
    NAD__1983__STATE_PLANE__ILLINOIS__WEST_FIPS__1202='NAD_1983_StatePlane_Illinois_West_FIPS_1202'
    NAD__1983__STATE_PLANE__INDIANA__EAST_FIPS__1301='NAD_1983_StatePlane_Indiana_East_FIPS_1301'
    NAD__1983__STATE_PLANE__INDIANA__WEST_FIPS__1302='NAD_1983_StatePlane_Indiana_West_FIPS_1302'
    NAD__1983__STATE_PLANE__IOWA__NORTH_FIPS__1401='NAD_1983_StatePlane_Iowa_North_FIPS_1401'
    NAD__1983__STATE_PLANE__IOWA__SOUTH_FIPS__1402='NAD_1983_StatePlane_Iowa_South_FIPS_1402'
    NAD__1983__STATE_PLANE__KANSAS__NORTH_FIPS__1501='NAD_1983_StatePlane_Kansas_North_FIPS_1501'
    NAD__1983__STATE_PLANE__KANSAS__SOUTH_FIPS__1502='NAD_1983_StatePlane_Kansas_South_FIPS_1502'
    NAD__1983__STATE_PLANE__KENTUCKY_FIPS__1600='NAD_1983_StatePlane_Kentucky_FIPS_1600'
    NAD__1983__STATE_PLANE__KENTUCKY__NORTH_FIPS__1601='NAD_1983_StatePlane_Kentucky_North_FIPS_1601'
    NAD__1983__STATE_PLANE__KENTUCKY__SOUTH_FIPS__1602='NAD_1983_StatePlane_Kentucky_South_FIPS_1602'
    NAD__1983__STATE_PLANE__LOUISIANA__NORTH_FIPS__1701='NAD_1983_StatePlane_Louisiana_North_FIPS_1701'
    NAD__1983__STATE_PLANE__LOUISIANA__SOUTH_FIPS__1702='NAD_1983_StatePlane_Louisiana_South_FIPS_1702'
    NAD__1983__STATE_PLANE__MAINE__EAST_FIPS__1801='NAD_1983_StatePlane_Maine_East_FIPS_1801'
    NAD__1983__STATE_PLANE__MAINE__WEST_FIPS__1802='NAD_1983_StatePlane_Maine_West_FIPS_1802'
    NAD__1983__STATE_PLANE__MARYLAND_FIPS__1900='NAD_1983_StatePlane_Maryland_FIPS_1900'
    NAD__1983__STATE_PLANE__MASSACHUSETTS__ISLAND_FIPS__2002='NAD_1983_StatePlane_Massachusetts_Island_FIPS_2002'
    NAD__1983__STATE_PLANE__MASSACHUSETTS__MAINLAND_FIPS__2001='NAD_1983_StatePlane_Massachusetts_Mainland_FIPS_2001'
    NAD__1983__STATE_PLANE__MICHIGAN__CENTRAL_FIPS__2202='NAD_1983_StatePlane_Michigan_Central_FIPS_2202'
    NAD__1983__STATE_PLANE__MICHIGAN__NORTH_FIPS__2111='NAD_1983_StatePlane_Michigan_North_FIPS_2111'
    NAD__1983__STATE_PLANE__MICHIGAN__SOUTH_FIPS__2113='NAD_1983_StatePlane_Michigan_South_FIPS_2113'
    NAD__1983__STATE_PLANE__MINNESOTA__CENTRAL_FIPS__2202='NAD_1983_StatePlane_Minnesota_Central_FIPS_2202'
    NAD__1983__STATE_PLANE__MINNESOTA__NORTH_FIPS__2201='NAD_1983_StatePlane_Minnesota_North_FIPS_2201'
    NAD__1983__STATE_PLANE__MINNESOTA__SOUTH_FIPS__2203='NAD_1983_StatePlane_Minnesota_South_FIPS_2203'
    NAD__1983__STATE_PLANE__MISSISSIPPI__EAST_FIPS__2301='NAD_1983_StatePlane_Mississippi_East_FIPS_2301'
    NAD__1983__STATE_PLANE__MISSISSIPPI__WEST_FIPS__2302='NAD_1983_StatePlane_Mississippi_West_FIPS_2302'
    NAD__1983__STATE_PLANE__MISSOURI__CENTRAL_FIPS__2402='NAD_1983_StatePlane_Missouri_Central_FIPS_2402'
    NAD__1983__STATE_PLANE__MISSOURI__EAST_FIPS__2401='NAD_1983_StatePlane_Missouri_East_FIPS_2401'
    NAD__1983__STATE_PLANE__MISSOURI__WEST_FIPS__2403='NAD_1983_StatePlane_Missouri_West_FIPS_2403'
    NAD__1983__STATE_PLANE__MONTANA_FIPS__2500='NAD_1983_StatePlane_Montana_FIPS_2500'
    NAD__1983__STATE_PLANE__NEBRASKA_FIPS__2600='NAD_1983_StatePlane_Nebraska_FIPS_2600'
    NAD__1983__STATE_PLANE__NEVADA__CENTRAL_FIPS__2702='NAD_1983_StatePlane_Nevada_Central_FIPS_2702'
    NAD__1983__STATE_PLANE__NEVADA__EAST_FIPS__2701='NAD_1983_StatePlane_Nevada_East_FIPS_2701'
    NAD__1983__STATE_PLANE__NEVADA__WEST_FIPS__2703='NAD_1983_StatePlane_Nevada_West_FIPS_2703'
    NAD__1983__STATE_PLANE__NEW__HAMPSHIRE_FIPS__2800='NAD_1983_StatePlane_New_Hampshire_FIPS_2800'
    NAD__1983__STATE_PLANE__NEW__JERSEY_FIPS__2900='NAD_1983_StatePlane_New_Jersey_FIPS_2900'
    NAD__1983__STATE_PLANE__NEW__MEXICO__CENTRAL_FIPS__3002='NAD_1983_StatePlane_New_Mexico_Central_FIPS_3002'
    NAD__1983__STATE_PLANE__NEW__MEXICO__EAST_FIPS__3001='NAD_1983_StatePlane_New_Mexico_East_FIPS_3001'
    NAD__1983__STATE_PLANE__NEW__MEXICO__WEST_FIPS__3003='NAD_1983_StatePlane_New_Mexico_West_FIPS_3003'
    NAD__1983__STATE_PLANE__NEW__YORK__CENTRAL_FIPS__3102='NAD_1983_StatePlane_New_York_Central_FIPS_3102'
    NAD__1983__STATE_PLANE__NEW__YORK__EAST_FIPS__3101='NAD_1983_StatePlane_New_York_East_FIPS_3101'
    NAD__1983__STATE_PLANE__NEW__YORK__LONG__ISLAND_FIPS__3104='NAD_1983_StatePlane_New_York_Long_Island_FIPS_3104'
    NAD__1983__STATE_PLANE__NEW__YORK__WEST_FIPS__3103='NAD_1983_StatePlane_New_York_West_FIPS_3103'
    NAD__1983__STATE_PLANE__NORTH__CAROLINA_FIPS__3200='NAD_1983_StatePlane_North_Carolina_FIPS_3200'
    NAD__1983__STATE_PLANE__NORTH__DAKOTA__NORTH_FIPS__3301='NAD_1983_StatePlane_North_Dakota_North_FIPS_3301'
    NAD__1983__STATE_PLANE__NORTH__DAKOTA__SOUTH_FIPS__3302='NAD_1983_StatePlane_North_Dakota_South_FIPS_3302'
    NAD__1983__STATE_PLANE__OHIO__NORTH_FIPS__3401='NAD_1983_StatePlane_Ohio_North_FIPS_3401'
    NAD__1983__STATE_PLANE__OHIO__SOUTH_FIPS__3402='NAD_1983_StatePlane_Ohio_South_FIPS_3402'
    NAD__1983__STATE_PLANE__OKLAHOMA__NORTH_FIPS__3501='NAD_1983_StatePlane_Oklahoma_North_FIPS_3501'
    NAD__1983__STATE_PLANE__OKLAHOMA__SOUTH_FIPS__3502='NAD_1983_StatePlane_Oklahoma_South_FIPS_3502'
    NAD__1983__STATE_PLANE__OREGON__NORTH_FIPS__3601='NAD_1983_StatePlane_Oregon_North_FIPS_3601'
    NAD__1983__STATE_PLANE__OREGON__SOUTH_FIPS__3602='NAD_1983_StatePlane_Oregon_South_FIPS_3602'
    NAD__1983__STATE_PLANE__PENNSYLVANIA__NORTH_FIPS__3701='NAD_1983_StatePlane_Pennsylvania_North_FIPS_3701'
    NAD__1983__STATE_PLANE__PENNSYLVANIA__SOUTH_FIPS__3702='NAD_1983_StatePlane_Pennsylvania_South_FIPS_3702'
    NAD__1983__STATE_PLANE__PUERTO__RICO__VIRGIN__ISLANDS_FIPS__5200='NAD_1983_StatePlane_Puerto_Rico_Virgin_Islands_FIPS_5200'
    NAD__1983__STATE_PLANE__RHODE__ISLAND_FIPS__3800='NAD_1983_StatePlane_Rhode_Island_FIPS_3800'
    NAD__1983__STATE_PLANE__SOUTH__CAROLINA_FIPS__3900='NAD_1983_StatePlane_South_Carolina_FIPS_3900'
    NAD__1983__STATE_PLANE__SOUTH__DAKOTA__NORTH_FIPS__4001='NAD_1983_StatePlane_South_Dakota_North_FIPS_4001'
    NAD__1983__STATE_PLANE__SOUTH__DAKOTA__SOUTH_FIPS__4002='NAD_1983_StatePlane_South_Dakota_South_FIPS_4002'
    NAD__1983__STATE_PLANE__TENNESSEE_FIPS__4100='NAD_1983_StatePlane_Tennessee_FIPS_4100'
    NAD__1983__STATE_PLANE__TEXAS__CENTRAL_FIPS__4203='NAD_1983_StatePlane_Texas_Central_FIPS_4203'
    NAD__1983__STATE_PLANE__TEXAS__NORTH__CENTRAL_FIPS__4202='NAD_1983_StatePlane_Texas_North_Central_FIPS_4202'
    NAD__1983__STATE_PLANE__TEXAS__NORTH_FIPS__4201='NAD_1983_StatePlane_Texas_North_FIPS_4201'
    NAD__1983__STATE_PLANE__TEXAS__SOUTH__CENTRAL_FIPS__4204='NAD_1983_StatePlane_Texas_South_Central_FIPS_4204'
    NAD__1983__STATE_PLANE__TEXAS__SOUTH_FIPS__4205='NAD_1983_StatePlane_Texas_South_FIPS_4205'
    NAD__1983__STATE_PLANE__UTAH__CENTRAL_FIPS__4302='NAD_1983_StatePlane_Utah_Central_FIPS_4302'
    NAD__1983__STATE_PLANE__UTAH__NORTH_FIPS__4301='NAD_1983_StatePlane_Utah_North_FIPS_4301'
    NAD__1983__STATE_PLANE__UTAH__SOUTH_FIPS__4303='NAD_1983_StatePlane_Utah_South_FIPS_4303'
    NAD__1983__STATE_PLANE__VERMONT_FIPS__4400='NAD_1983_StatePlane_Vermont_FIPS_4400'
    NAD__1983__STATE_PLANE__VIRGINIA__NORTH_FIPS__4501='NAD_1983_StatePlane_Virginia_North_FIPS_4501'
    NAD__1983__STATE_PLANE__VIRGINIA__SOUTH_FIPS__4502='NAD_1983_StatePlane_Virginia_South_FIPS_4502'
    NAD__1983__STATE_PLANE__WASHINGTON__NORTH_FIPS__4601='NAD_1983_StatePlane_Washington_North_FIPS_4601'
    NAD__1983__STATE_PLANE__WASHINGTON__SOUTH_FIPS__4602='NAD_1983_StatePlane_Washington_South_FIPS_4602'
    NAD__1983__STATE_PLANE__WEST__VIRGINIA__NORTH_FIPS__4701='NAD_1983_StatePlane_West_Virginia_North_FIPS_4701'
    NAD__1983__STATE_PLANE__WEST__VIRGINIA__SOUTH_FIPS__4702='NAD_1983_StatePlane_West_Virginia_South_FIPS_4702'
    NAD__1983__STATE_PLANE__WISCONSIN__CENTRAL_FIPS__4802='NAD_1983_StatePlane_Wisconsin_Central_FIPS_4802'
    NAD__1983__STATE_PLANE__WISCONSIN__NORTH_FIPS__4801='NAD_1983_StatePlane_Wisconsin_North_FIPS_4801'
    NAD__1983__STATE_PLANE__WISCONSIN__SOUTH_FIPS__4803='NAD_1983_StatePlane_Wisconsin_South_FIPS_4803'
    NAD__1983__STATE_PLANE__WYOMING__EAST__CENTRAL_FIPS__4902='NAD_1983_StatePlane_Wyoming_East_Central_FIPS_4902'
    NAD__1983__STATE_PLANE__WYOMING__EAST_FIPS__4901='NAD_1983_StatePlane_Wyoming_East_FIPS_4901'
    NAD__1983__STATE_PLANE__WYOMING__WEST__CENTRAL_FIPS__4903='NAD_1983_StatePlane_Wyoming_West_Central_FIPS_4903'
    NAD__1983__STATE_PLANE__WYOMING__WEST_FIPS__4904='NAD_1983_StatePlane_Wyoming_West_FIPS_4904'
    NAD__1983__STATE_PLANE__ALABAMA__EAST_FIPS__0101__FEET='NAD_1983_StatePlane_Alabama_East_FIPS_0101_Feet'
    NAD__1983__STATE_PLANE__ALABAMA__WEST_FIPS__0102__FEET='NAD_1983_StatePlane_Alabama_West_FIPS_0102_Feet'
    NAD__1983__STATE_PLANE__ALASKA__1_FIPS__5001__FEET='NAD_1983_StatePlane_Alaska_1_FIPS_5001_Feet'
    NAD__1983__STATE_PLANE__ALASKA__10_FIPS__5010__FEET='NAD_1983_StatePlane_Alaska_10_FIPS_5010_Feet'
    NAD__1983__STATE_PLANE__ALASKA__2_FIPS__5002__FEET='NAD_1983_StatePlane_Alaska_2_FIPS_5002_Feet'
    NAD__1983__STATE_PLANE__ALASKA__3_FIPS__5003__FEET='NAD_1983_StatePlane_Alaska_3_FIPS_5003_Feet'
    NAD__1983__STATE_PLANE__ALASKA__4_FIPS__5004__FEET='NAD_1983_StatePlane_Alaska_4_FIPS_5004_Feet'
    NAD__1983__STATE_PLANE__ALASKA__5_FIPS__5005__FEET='NAD_1983_StatePlane_Alaska_5_FIPS_5005_Feet'
    NAD__1983__STATE_PLANE__ALASKA__6_FIPS__5006__FEET='NAD_1983_StatePlane_Alaska_6_FIPS_5006_Feet'
    NAD__1983__STATE_PLANE__ALASKA__7_FIPS__5007__FEET='NAD_1983_StatePlane_Alaska_7_FIPS_5007_Feet'
    NAD__1983__STATE_PLANE__ALASKA__8_FIPS__5008__FEET='NAD_1983_StatePlane_Alaska_8_FIPS_5008_Feet'
    NAD__1983__STATE_PLANE__ALASKA__9_FIPS__5009__FEET='NAD_1983_StatePlane_Alaska_9_FIPS_5009_Feet'
    NAD__1983__STATE_PLANE__ARIZONA__CENTRAL_FIPS__0202__FEET='NAD_1983_StatePlane_Arizona_Central_FIPS_0202_Feet'
    NAD__1983__STATE_PLANE__ARIZONA__EAST_FIPS__0201__FEET='NAD_1983_StatePlane_Arizona_East_FIPS_0201_Feet'
    NAD__1983__STATE_PLANE__ARIZONA__WEST_FIPS__0203__FEET='NAD_1983_StatePlane_Arizona_West_FIPS_0203_Feet'
    NAD__1983__STATE_PLANE__ARKANSAS__NORTH_FIPS__0301__FEET='NAD_1983_StatePlane_Arkansas_North_FIPS_0301_Feet'
    NAD__1983__STATE_PLANE__ARKANSAS__SOUTH_FIPS__0302__FEET='NAD_1983_StatePlane_Arkansas_South_FIPS_0302_Feet'
    NAD__1983__STATE_PLANE__CALIFORNIA_I_FIPS__0401__FEET='NAD_1983_StatePlane_California_I_FIPS_0401_Feet'
    NAD__1983__STATE_PLANE__CALIFORNIA_II_FIPS__0402__FEET='NAD_1983_StatePlane_California_II_FIPS_0402_Feet'
    NAD__1983__STATE_PLANE__CALIFORNIA_III_FIPS__0403__FEET='NAD_1983_StatePlane_California_III_FIPS_0403_Feet'
    NAD__1983__STATE_PLANE__CALIFORNIA_IV_FIPS__0404__FEET='NAD_1983_StatePlane_California_IV_FIPS_0404_Feet'
    NAD__1983__STATE_PLANE__CALIFORNIA_V_FIPS__0405__FEET='NAD_1983_StatePlane_California_V_FIPS_0405_Feet'
    NAD__1983__STATE_PLANE__CALIFORNIA_VI_FIPS__0406__FEET='NAD_1983_StatePlane_California_VI_FIPS_0406_Feet'
    NAD__1983__STATE_PLANE__COLORADO__CENTRAL_FIPS__0502__FEET='NAD_1983_StatePlane_Colorado_Central_FIPS_0502_Feet'
    NAD__1983__STATE_PLANE__COLORADO__NORTH_FIPS__0501__FEET='NAD_1983_StatePlane_Colorado_North_FIPS_0501_Feet'
    NAD__1983__STATE_PLANE__COLORADO__SOUTH_FIPS__0503__FEET='NAD_1983_StatePlane_Colorado_South_FIPS_0503_Feet'
    NAD__1983__STATE_PLANE__CONNECTICUT_FIPS__0600__FEET='NAD_1983_StatePlane_Connecticut_FIPS_0600_Feet'
    NAD__1983__STATE_PLANE__DELAWARE_FIPS__0700__FEET='NAD_1983_StatePlane_Delaware_FIPS_0700_Feet'
    NAD__1983__STATE_PLANE__FLORIDA__EAST_FIPS__0901__FEET='NAD_1983_StatePlane_Florida_East_FIPS_0901_Feet'
    NAD__1983__STATE_PLANE__FLORIDA__NORTH_FIPS__0903__FEET='NAD_1983_StatePlane_Florida_North_FIPS_0903_Feet'
    NAD__1983__STATE_PLANE__FLORIDA__WEST_FIPS__0902__FEET='NAD_1983_StatePlane_Florida_West_FIPS_0902_Feet'
    NAD__1983__STATE_PLANE__GEORGIA__EAST_FIPS__1001__FEET='NAD_1983_StatePlane_Georgia_East_FIPS_1001_Feet'
    NAD__1983__STATE_PLANE__GEORGIA__WEST_FIPS__1002__FEET='NAD_1983_StatePlane_Georgia_West_FIPS_1002_Feet'
    NAD__1983__STATE_PLANE__GUAM_FIPS__5400__FEET='NAD_1983_StatePlane_Guam_FIPS_5400_Feet'
    NAD__1983__STATE_PLANE__HAWAII__1_FIPS__5101__FEET='NAD_1983_StatePlane_Hawaii_1_FIPS_5101_Feet'
    NAD__1983__STATE_PLANE__HAWAII__2_FIPS__5102__FEET='NAD_1983_StatePlane_Hawaii_2_FIPS_5102_Feet'
    NAD__1983__STATE_PLANE__HAWAII__3_FIPS__5103__FEET='NAD_1983_StatePlane_Hawaii_3_FIPS_5103_Feet'
    NAD__1983__STATE_PLANE__HAWAII__4_FIPS__5104__FEET='NAD_1983_StatePlane_Hawaii_4_FIPS_5104_Feet'
    NAD__1983__STATE_PLANE__HAWAII__5_FIPS__5105__FEET='NAD_1983_StatePlane_Hawaii_5_FIPS_5105_Feet'
    NAD__1983__STATE_PLANE__IDAHO__CENTRAL_FIPS__1102__FEET='NAD_1983_StatePlane_Idaho_Central_FIPS_1102_Feet'
    NAD__1983__STATE_PLANE__IDAHO__EAST_FIPS__1101__FEET='NAD_1983_StatePlane_Idaho_East_FIPS_1101_Feet'
    NAD__1983__STATE_PLANE__IDAHO__WEST_FIPS__1103__FEET='NAD_1983_StatePlane_Idaho_West_FIPS_1103_Feet'
    NAD__1983__STATE_PLANE__ILLINOIS__EAST_FIPS__1201__FEET='NAD_1983_StatePlane_Illinois_East_FIPS_1201_Feet'
    NAD__1983__STATE_PLANE__ILLINOIS__WEST_FIPS__1202__FEET='NAD_1983_StatePlane_Illinois_West_FIPS_1202_Feet'
    NAD__1983__STATE_PLANE__INDIANA__EAST_FIPS__1301__FEET='NAD_1983_StatePlane_Indiana_East_FIPS_1301_Feet'
    NAD__1983__STATE_PLANE__INDIANA__WEST_FIPS__1302__FEET='NAD_1983_StatePlane_Indiana_West_FIPS_1302_Feet'
    NAD__1983__STATE_PLANE__IOWA__NORTH_FIPS__1401__FEET='NAD_1983_StatePlane_Iowa_North_FIPS_1401_Feet'
    NAD__1983__STATE_PLANE__IOWA__SOUTH_FIPS__1402__FEET='NAD_1983_StatePlane_Iowa_South_FIPS_1402_Feet'
    NAD__1983__STATE_PLANE__KANSAS__NORTH_FIPS__1501__FEET='NAD_1983_StatePlane_Kansas_North_FIPS_1501_Feet'
    NAD__1983__STATE_PLANE__KANSAS__SOUTH_FIPS__1502__FEET='NAD_1983_StatePlane_Kansas_South_FIPS_1502_Feet'
    NAD__1983__STATE_PLANE__KENTUCKY_FIPS__1600__FEET='NAD_1983_StatePlane_Kentucky_FIPS_1600_Feet'
    NAD__1983__STATE_PLANE__KENTUCKY__NORTH_FIPS__1601__FEET='NAD_1983_StatePlane_Kentucky_North_FIPS_1601_Feet'
    NAD__1983__STATE_PLANE__KENTUCKY__SOUTH_FIPS__1602__FEET='NAD_1983_StatePlane_Kentucky_South_FIPS_1602_Feet'
    NAD__1983__STATE_PLANE__LOUISIANA__NORTH_FIPS__1701__FEET='NAD_1983_StatePlane_Louisiana_North_FIPS_1701_Feet'
    NAD__1983__STATE_PLANE__LOUISIANA__SOUTH_FIPS__1702__FEET='NAD_1983_StatePlane_Louisiana_South_FIPS_1702_Feet'
    NAD__1983__STATE_PLANE__MAINE__EAST_FIPS__1801__FEET='NAD_1983_StatePlane_Maine_East_FIPS_1801_Feet'
    NAD__1983__STATE_PLANE__MAINE__WEST_FIPS__1802__FEET='NAD_1983_StatePlane_Maine_West_FIPS_1802_Feet'
    NAD__1983__STATE_PLANE__MARYLAND_FIPS__1900__FEET='NAD_1983_StatePlane_Maryland_FIPS_1900_Feet'
    NAD__1983__STATE_PLANE__MASSACHUSETTS__ISLAND_FIPS__2002__FEET='NAD_1983_StatePlane_Massachusetts_Island_FIPS_2002_Feet'
    NAD__1983__STATE_PLANE__MASSACHUSETTS__MAINLAND_FIPS__2001__FEET='NAD_1983_StatePlane_Massachusetts_Mainland_FIPS_2001_Feet'
    NAD__1983__STATE_PLANE__MICHIGAN__CENTRAL_FIPS__2202__FEET='NAD_1983_StatePlane_Michigan_Central_FIPS_2202_Feet'
    NAD__1983__STATE_PLANE__MICHIGAN__NORTH_FIPS__2111__FEET='NAD_1983_StatePlane_Michigan_North_FIPS_2111_Feet'
    NAD__1983__STATE_PLANE__MICHIGAN__SOUTH_FIPS__2113__FEET='NAD_1983_StatePlane_Michigan_South_FIPS_2113_Feet'
    NAD__1983__STATE_PLANE__MINNESOTA__CENTRAL_FIPS__2202__FEET='NAD_1983_StatePlane_Minnesota_Central_FIPS_2202_Feet'
    NAD__1983__STATE_PLANE__MINNESOTA__NORTH_FIPS__2201__FEET='NAD_1983_StatePlane_Minnesota_North_FIPS_2201_Feet'
    NAD__1983__STATE_PLANE__MINNESOTA__SOUTH_FIPS__2203__FEET='NAD_1983_StatePlane_Minnesota_South_FIPS_2203_Feet'
    NAD__1983__STATE_PLANE__MISSISSIPPI__EAST_FIPS__2301__FEET='NAD_1983_StatePlane_Mississippi_East_FIPS_2301_Feet'
    NAD__1983__STATE_PLANE__MISSISSIPPI__WEST_FIPS__2302__FEET='NAD_1983_StatePlane_Mississippi_West_FIPS_2302_Feet'
    NAD__1983__STATE_PLANE__MISSOURI__CENTRAL_FIPS__2402__FEET='NAD_1983_StatePlane_Missouri_Central_FIPS_2402_Feet'
    NAD__1983__STATE_PLANE__MISSOURI__EAST_FIPS__2401__FEET='NAD_1983_StatePlane_Missouri_East_FIPS_2401_Feet'
    NAD__1983__STATE_PLANE__MISSOURI__WEST_FIPS__2403__FEET='NAD_1983_StatePlane_Missouri_West_FIPS_2403_Feet'
    NAD__1983__STATE_PLANE__MONTANA_FIPS__2500__FEET='NAD_1983_StatePlane_Montana_FIPS_2500_Feet'
    NAD__1983__STATE_PLANE__NEBRASKA_FIPS__2600__FEET='NAD_1983_StatePlane_Nebraska_FIPS_2600_Feet'
    NAD__1983__STATE_PLANE__NEVADA__CENTRAL_FIPS__2702__FEET='NAD_1983_StatePlane_Nevada_Central_FIPS_2702_Feet'
    NAD__1983__STATE_PLANE__NEVADA__EAST_FIPS__2701__FEET='NAD_1983_StatePlane_Nevada_East_FIPS_2701_Feet'
    NAD__1983__STATE_PLANE__NEVADA__WEST_FIPS__2703__FEET='NAD_1983_StatePlane_Nevada_West_FIPS_2703_Feet'
    NAD__1983__STATE_PLANE__NEW__HAMPSHIRE_FIPS__2800__FEET='NAD_1983_StatePlane_New_Hampshire_FIPS_2800_Feet'
    NAD__1983__STATE_PLANE__NEW__JERSEY_FIPS__2900__FEET='NAD_1983_StatePlane_New_Jersey_FIPS_2900_Feet'
    NAD__1983__STATE_PLANE__NEW__MEXICO__CENTRAL_FIPS__3002__FEET='NAD_1983_StatePlane_New_Mexico_Central_FIPS_3002_Feet'
    NAD__1983__STATE_PLANE__NEW__MEXICO__EAST_FIPS__3001__FEET='NAD_1983_StatePlane_New_Mexico_East_FIPS_3001_Feet'
    NAD__1983__STATE_PLANE__NEW__MEXICO__WEST_FIPS__3003__FEET='NAD_1983_StatePlane_New_Mexico_West_FIPS_3003_Feet'
    NAD__1983__STATE_PLANE__NEW__YORK__CENTRAL_FIPS__3102__FEET='NAD_1983_StatePlane_New_York_Central_FIPS_3102_Feet'
    NAD__1983__STATE_PLANE__NEW__YORK__EAST_FIPS__3101__FEET='NAD_1983_StatePlane_New_York_East_FIPS_3101_Feet'
    NAD__1983__STATE_PLANE__NEW__YORK__LONG__ISLAND_FIPS__3104__FEET='NAD_1983_StatePlane_New_York_Long_Island_FIPS_3104_Feet'
    NAD__1983__STATE_PLANE__NEW__YORK__WEST_FIPS__3103__FEET='NAD_1983_StatePlane_New_York_West_FIPS_3103_Feet'
    NAD__1983__STATE_PLANE__NORTH__CAROLINA_FIPS__3200__FEET='NAD_1983_StatePlane_North_Carolina_FIPS_3200_Feet'
    NAD__1983__STATE_PLANE__NORTH__DAKOTA__NORTH_FIPS__3301__FEET='NAD_1983_StatePlane_North_Dakota_North_FIPS_3301_Feet'
    NAD__1983__STATE_PLANE__NORTH__DAKOTA__SOUTH_FIPS__3302__FEET='NAD_1983_StatePlane_North_Dakota_South_FIPS_3302_Feet'
    NAD__1983__STATE_PLANE__OHIO__NORTH_FIPS__3401__FEET='NAD_1983_StatePlane_Ohio_North_FIPS_3401_Feet'
    NAD__1983__STATE_PLANE__OHIO__SOUTH_FIPS__3402__FEET='NAD_1983_StatePlane_Ohio_South_FIPS_3402_Feet'
    NAD__1983__STATE_PLANE__OKLAHOMA__NORTH_FIPS__3501__FEET='NAD_1983_StatePlane_Oklahoma_North_FIPS_3501_Feet'
    NAD__1983__STATE_PLANE__OKLAHOMA__SOUTH_FIPS__3502__FEET='NAD_1983_StatePlane_Oklahoma_South_FIPS_3502_Feet'
    NAD__1983__STATE_PLANE__OREGON__NORTH_FIPS__3601__FEET='NAD_1983_StatePlane_Oregon_North_FIPS_3601_Feet'
    NAD__1983__STATE_PLANE__OREGON__SOUTH_FIPS__3602__FEET='NAD_1983_StatePlane_Oregon_South_FIPS_3602_Feet'
    NAD__1983__STATE_PLANE__PENNSYLVANIA__NORTH_FIPS__3701__FEET='NAD_1983_StatePlane_Pennsylvania_North_FIPS_3701_Feet'
    NAD__1983__STATE_PLANE__PENNSYLVANIA__SOUTH_FIPS__3702__FEET='NAD_1983_StatePlane_Pennsylvania_South_FIPS_3702_Feet'
    NAD__1983__STATE_PLANE__PUERTO__RICO__VIRGIN__ISLANDS_FIPS__5200__FEET='NAD_1983_StatePlane_Puerto_Rico_Virgin_Islands_FIPS_5200_Feet'
    NAD__1983__STATE_PLANE__RHODE__ISLAND_FIPS__3800__FEET='NAD_1983_StatePlane_Rhode_Island_FIPS_3800_Feet'
    NAD__1983__STATE_PLANE__SOUTH__CAROLINA_FIPS__3900__FEET='NAD_1983_StatePlane_South_Carolina_FIPS_3900_Feet'
    NAD__1983__STATE_PLANE__SOUTH__DAKOTA__NORTH_FIPS__4001__FEET='NAD_1983_StatePlane_South_Dakota_North_FIPS_4001_Feet'
    NAD__1983__STATE_PLANE__SOUTH__DAKOTA__SOUTH_FIPS__4002__FEET='NAD_1983_StatePlane_South_Dakota_South_FIPS_4002_Feet'
    NAD__1983__STATE_PLANE__TENNESSEE_FIPS__4100__FEET='NAD_1983_StatePlane_Tennessee_FIPS_4100_Feet'
    NAD__1983__STATE_PLANE__TEXAS__CENTRAL_FIPS__4203__FEET='NAD_1983_StatePlane_Texas_Central_FIPS_4203_Feet'
    NAD__1983__STATE_PLANE__TEXAS__NORTH__CENTRAL_FIPS__4202__FEET='NAD_1983_StatePlane_Texas_North_Central_FIPS_4202_Feet'
    NAD__1983__STATE_PLANE__TEXAS__NORTH_FIPS__4201__FEET='NAD_1983_StatePlane_Texas_North_FIPS_4201_Feet'
    NAD__1983__STATE_PLANE__TEXAS__SOUTH__CENTRAL_FIPS__4204__FEET='NAD_1983_StatePlane_Texas_South_Central_FIPS_4204_Feet'
    NAD__1983__STATE_PLANE__TEXAS__SOUTH_FIPS__4205__FEET='NAD_1983_StatePlane_Texas_South_FIPS_4205_Feet'
    NAD__1983__STATE_PLANE__UTAH__CENTRAL_FIPS__4302__FEET='NAD_1983_StatePlane_Utah_Central_FIPS_4302_Feet'
    NAD__1983__STATE_PLANE__UTAH__NORTH_FIPS__4301__FEET='NAD_1983_StatePlane_Utah_North_FIPS_4301_Feet'
    NAD__1983__STATE_PLANE__UTAH__SOUTH_FIPS__4303__FEET='NAD_1983_StatePlane_Utah_South_FIPS_4303_Feet'
    NAD__1983__STATE_PLANE__VERMONT_FIPS__4400__FEET='NAD_1983_StatePlane_Vermont_FIPS_4400_Feet'
    NAD__1983__STATE_PLANE__VIRGINIA__NORTH_FIPS__4501__FEET='NAD_1983_StatePlane_Virginia_North_FIPS_4501_Feet'
    NAD__1983__STATE_PLANE__VIRGINIA__SOUTH_FIPS__4502__FEET='NAD_1983_StatePlane_Virginia_South_FIPS_4502_Feet'
    NAD__1983__STATE_PLANE__WASHINGTON__NORTH_FIPS__4601__FEET='NAD_1983_StatePlane_Washington_North_FIPS_4601_Feet'
    NAD__1983__STATE_PLANE__WASHINGTON__SOUTH_FIPS__4602__FEET='NAD_1983_StatePlane_Washington_South_FIPS_4602_Feet'
    NAD__1983__STATE_PLANE__WEST__VIRGINIA__NORTH_FIPS__4701__FEET='NAD_1983_StatePlane_West_Virginia_North_FIPS_4701_Feet'
    NAD__1983__STATE_PLANE__WEST__VIRGINIA__SOUTH_FIPS__4702__FEET='NAD_1983_StatePlane_West_Virginia_South_FIPS_4702_Feet'
    NAD__1983__STATE_PLANE__WISCONSIN__CENTRAL_FIPS__4802__FEET='NAD_1983_StatePlane_Wisconsin_Central_FIPS_4802_Feet'
    NAD__1983__STATE_PLANE__WISCONSIN__NORTH_FIPS__4801__FEET='NAD_1983_StatePlane_Wisconsin_North_FIPS_4801_Feet'
    NAD__1983__STATE_PLANE__WISCONSIN__SOUTH_FIPS__4803__FEET='NAD_1983_StatePlane_Wisconsin_South_FIPS_4803_Feet'
    NAD__1983__STATE_PLANE__WYOMING__EAST__CENTRAL_FIPS__4902__FEET='NAD_1983_StatePlane_Wyoming_East_Central_FIPS_4902_Feet'
    NAD__1983__STATE_PLANE__WYOMING__EAST_FIPS__4901__FEET='NAD_1983_StatePlane_Wyoming_East_FIPS_4901_Feet'
    NAD__1983__STATE_PLANE__WYOMING__WEST__CENTRAL_FIPS__4903__FEET='NAD_1983_StatePlane_Wyoming_West_Central_FIPS_4903_Feet'
    NAD__1983__STATE_PLANE__WYOMING__WEST_FIPS__4904__FEET='NAD_1983_StatePlane_Wyoming_West_FIPS_4904_Feet'
    NAD__1983_HARN__STATE_PLANE__ALABAMA__EAST_FIPS__0101='NAD_1983_HARN_StatePlane_Alabama_East_FIPS_0101'
    NAD__1983_HARN__STATE_PLANE__ALABAMA__WEST_FIPS__0102='NAD_1983_HARN_StatePlane_Alabama_West_FIPS_0102'
    NAD__1983_HARN__STATE_PLANE__ARIZONA__CENTRAL_FIPS__0202='NAD_1983_HARN_StatePlane_Arizona_Central_FIPS_0202'
    NAD__1983_HARN__STATE_PLANE__ARIZONA__EAST_FIPS__0201='NAD_1983_HARN_StatePlane_Arizona_East_FIPS_0201'
    NAD__1983_HARN__STATE_PLANE__ARIZONA__WEST_FIPS__0203='NAD_1983_HARN_StatePlane_Arizona_West_FIPS_0203'
    NAD__1983_HARN__STATE_PLANE__CALIFORNIA_I_FIPS__0401='NAD_1983_HARN_StatePlane_California_I_FIPS_0401'
    NAD__1983_HARN__STATE_PLANE__CALIFORNIA_II_FIPS__0402='NAD_1983_HARN_StatePlane_California_II_FIPS_0402'
    NAD__1983_HARN__STATE_PLANE__CALIFORNIA_III_FIPS__0403='NAD_1983_HARN_StatePlane_California_III_FIPS_0403'
    NAD__1983_HARN__STATE_PLANE__CALIFORNIA_IV_FIPS__0404='NAD_1983_HARN_StatePlane_California_IV_FIPS_0404'
    NAD__1983_HARN__STATE_PLANE__CALIFORNIA_V_FIPS__0405='NAD_1983_HARN_StatePlane_California_V_FIPS_0405'
    NAD__1983_HARN__STATE_PLANE__CALIFORNIA_VI_FIPS__0406='NAD_1983_HARN_StatePlane_California_VI_FIPS_0406'
    NAD__1983_HARN__STATE_PLANE__COLORADO__CENTRAL_FIPS__0502='NAD_1983_HARN_StatePlane_Colorado_Central_FIPS_0502'
    NAD__1983_HARN__STATE_PLANE__COLORADO__NORTH_FIPS__0501='NAD_1983_HARN_StatePlane_Colorado_North_FIPS_0501'
    NAD__1983_HARN__STATE_PLANE__COLORADO__SOUTH_FIPS__0503='NAD_1983_HARN_StatePlane_Colorado_South_FIPS_0503'
    NAD__1983_HARN__STATE_PLANE__CONNECTICUT_FIPS__0600='NAD_1983_HARN_StatePlane_Connecticut_FIPS_0600'
    NAD__1983_HARN__STATE_PLANE__DELAWARE_FIPS__0700='NAD_1983_HARN_StatePlane_Delaware_FIPS_0700'
    NAD__1983_HARN__STATE_PLANE__FLORIDA__EAST_FIPS__0901='NAD_1983_HARN_StatePlane_Florida_East_FIPS_0901'
    NAD__1983_HARN__STATE_PLANE__FLORIDA__NORTH_FIPS__0903='NAD_1983_HARN_StatePlane_Florida_North_FIPS_0903'
    NAD__1983_HARN__STATE_PLANE__FLORIDA__WEST_FIPS__0902='NAD_1983_HARN_StatePlane_Florida_West_FIPS_0902'
    NAD__1983_HARN__STATE_PLANE__GEORGIA__EAST_FIPS__1001='NAD_1983_HARN_StatePlane_Georgia_East_FIPS_1001'
    NAD__1983_HARN__STATE_PLANE__GEORGIA__WEST_FIPS__1002='NAD_1983_HARN_StatePlane_Georgia_West_FIPS_1002'
    NAD__1983_HARN__STATE_PLANE__HAWAII__1_FIPS__5101='NAD_1983_HARN_StatePlane_Hawaii_1_FIPS_5101'
    NAD__1983_HARN__STATE_PLANE__HAWAII__2_FIPS__5102='NAD_1983_HARN_StatePlane_Hawaii_2_FIPS_5102'
    NAD__1983_HARN__STATE_PLANE__HAWAII__3_FIPS__5103='NAD_1983_HARN_StatePlane_Hawaii_3_FIPS_5103'
    NAD__1983_HARN__STATE_PLANE__HAWAII__4_FIPS__5104='NAD_1983_HARN_StatePlane_Hawaii_4_FIPS_5104'
    NAD__1983_HARN__STATE_PLANE__HAWAII__5_FIPS__5105='NAD_1983_HARN_StatePlane_Hawaii_5_FIPS_5105'
    NAD__1983_HARN__STATE_PLANE__IDAHO__CENTRAL_FIPS__1102='NAD_1983_HARN_StatePlane_Idaho_Central_FIPS_1102'
    NAD__1983_HARN__STATE_PLANE__IDAHO__EAST_FIPS__1101='NAD_1983_HARN_StatePlane_Idaho_East_FIPS_1101'
    NAD__1983_HARN__STATE_PLANE__IDAHO__WEST_FIPS__1103='NAD_1983_HARN_StatePlane_Idaho_West_FIPS_1103'
    NAD__1983_HARN__STATE_PLANE__ILLINOIS__EAST_FIPS__1201='NAD_1983_HARN_StatePlane_Illinois_East_FIPS_1201'
    NAD__1983_HARN__STATE_PLANE__ILLINOIS__WEST_FIPS__1202='NAD_1983_HARN_StatePlane_Illinois_West_FIPS_1202'
    NAD__1983_HARN__STATE_PLANE__INDIANA__EAST_FIPS__1301='NAD_1983_HARN_StatePlane_Indiana_East_FIPS_1301'
    NAD__1983_HARN__STATE_PLANE__INDIANA__WEST_FIPS__1302='NAD_1983_HARN_StatePlane_Indiana_West_FIPS_1302'
    NAD__1983_HARN__STATE_PLANE__KANSAS__NORTH_FIPS__1501='NAD_1983_HARN_StatePlane_Kansas_North_FIPS_1501'
    NAD__1983_HARN__STATE_PLANE__KANSAS__SOUTH_FIPS__1502='NAD_1983_HARN_StatePlane_Kansas_South_FIPS_1502'
    NAD__1983_HARN__STATE_PLANE__KENTUCKY__NORTH_FIPS__1601='NAD_1983_HARN_StatePlane_Kentucky_North_FIPS_1601'
    NAD__1983_HARN__STATE_PLANE__KENTUCKY__SOUTH_FIPS__1602='NAD_1983_HARN_StatePlane_Kentucky_South_FIPS_1602'
    NAD__1983_HARN__STATE_PLANE__LOUISIANA__NORTH_FIPS__1701='NAD_1983_HARN_StatePlane_Louisiana_North_FIPS_1701'
    NAD__1983_HARN__STATE_PLANE__LOUISIANA__SOUTH_FIPS__1702='NAD_1983_HARN_StatePlane_Louisiana_South_FIPS_1702'
    NAD__1983_HARN__STATE_PLANE__MAINE__EAST_FIPS__1801='NAD_1983_HARN_StatePlane_Maine_East_FIPS_1801'
    NAD__1983_HARN__STATE_PLANE__MAINE__WEST_FIPS__1802='NAD_1983_HARN_StatePlane_Maine_West_FIPS_1802'
    NAD__1983_HARN__STATE_PLANE__MARYLAND_FIPS__1900='NAD_1983_HARN_StatePlane_Maryland_FIPS_1900'
    NAD__1983_HARN__STATE_PLANE__MASSACHUSETTS__ISLAND_FIPS__2002='NAD_1983_HARN_StatePlane_Massachusetts_Island_FIPS_2002'
    NAD__1983_HARN__STATE_PLANE__MASSACHUSETTS__MAINLAND_FIPS__2001='NAD_1983_HARN_StatePlane_Massachusetts_Mainland_FIPS_2001'
    NAD__1983_HARN__STATE_PLANE__MICHIGAN__CENTRAL_FIPS__2202='NAD_1983_HARN_StatePlane_Michigan_Central_FIPS_2202'
    NAD__1983_HARN__STATE_PLANE__MICHIGAN__NORTH_FIPS__2111='NAD_1983_HARN_StatePlane_Michigan_North_FIPS_2111'
    NAD__1983_HARN__STATE_PLANE__MICHIGAN__SOUTH_FIPS__2113='NAD_1983_HARN_StatePlane_Michigan_South_FIPS_2113'
    NAD__1983_HARN__STATE_PLANE__MISSISSIPPI__EAST_FIPS__2301='NAD_1983_HARN_StatePlane_Mississippi_East_FIPS_2301'
    NAD__1983_HARN__STATE_PLANE__MISSISSIPPI__WEST_FIPS__2302='NAD_1983_HARN_StatePlane_Mississippi_West_FIPS_2302'
    NAD__1983_HARN__STATE_PLANE__MONTANA_FIPS__2500='NAD_1983_HARN_StatePlane_Montana_FIPS_2500'
    NAD__1983_HARN__STATE_PLANE__NEBRASKA_FIPS__2600='NAD_1983_HARN_StatePlane_Nebraska_FIPS_2600'
    NAD__1983_HARN__STATE_PLANE__NEVADA__CENTRAL_FIPS__2702='NAD_1983_HARN_StatePlane_Nevada_Central_FIPS_2702'
    NAD__1983_HARN__STATE_PLANE__NEVADA__EAST_FIPS__2701='NAD_1983_HARN_StatePlane_Nevada_East_FIPS_2701'
    NAD__1983_HARN__STATE_PLANE__NEVADA__WEST_FIPS__2703='NAD_1983_HARN_StatePlane_Nevada_West_FIPS_2703'
    NAD__1983_HARN__STATE_PLANE__NEW__HAMPSHIRE_FIPS__2800='NAD_1983_HARN_StatePlane_New_Hampshire_FIPS_2800'
    NAD__1983_HARN__STATE_PLANE__NEW__JERSEY_FIPS__2900='NAD_1983_HARN_StatePlane_New_Jersey_FIPS_2900'
    NAD__1983_HARN__STATE_PLANE__NEW__MEXICO__CENTRAL_FIPS__3002='NAD_1983_HARN_StatePlane_New_Mexico_Central_FIPS_3002'
    NAD__1983_HARN__STATE_PLANE__NEW__MEXICO__EAST_FIPS__3001='NAD_1983_HARN_StatePlane_New_Mexico_East_FIPS_3001'
    NAD__1983_HARN__STATE_PLANE__NEW__MEXICO__WEST_FIPS__3003='NAD_1983_HARN_StatePlane_New_Mexico_West_FIPS_3003'
    NAD__1983_HARN__STATE_PLANE__NEW__YORK__CENTRAL_FIPS__3102='NAD_1983_HARN_StatePlane_New_York_Central_FIPS_3102'
    NAD__1983_HARN__STATE_PLANE__NEW__YORK__EAST_FIPS__3101='NAD_1983_HARN_StatePlane_New_York_East_FIPS_3101'
    NAD__1983_HARN__STATE_PLANE__NEW__YORK__LONG__ISLAND_FIPS__3104='NAD_1983_HARN_StatePlane_New_York_Long_Island_FIPS_3104'
    NAD__1983_HARN__STATE_PLANE__NEW__YORK__WEST_FIPS__3103='NAD_1983_HARN_StatePlane_New_York_West_FIPS_3103'
    NAD__1983_HARN__STATE_PLANE__NORTH__DAKOTA__NORTH_FIPS__3301='NAD_1983_HARN_StatePlane_North_Dakota_North_FIPS_3301'
    NAD__1983_HARN__STATE_PLANE__NORTH__DAKOTA__SOUTH_FIPS__3302='NAD_1983_HARN_StatePlane_North_Dakota_South_FIPS_3302'
    NAD__1983_HARN__STATE_PLANE__OHIO__NORTH_FIPS__3401='NAD_1983_HARN_StatePlane_Ohio_North_FIPS_3401'
    NAD__1983_HARN__STATE_PLANE__OHIO__SOUTH_FIPS__3402='NAD_1983_HARN_StatePlane_Ohio_South_FIPS_3402'
    NAD__1983_HARN__STATE_PLANE__OKLAHOMA__NORTH_FIPS__3501='NAD_1983_HARN_StatePlane_Oklahoma_North_FIPS_3501'
    NAD__1983_HARN__STATE_PLANE__OKLAHOMA__SOUTH_FIPS__3502='NAD_1983_HARN_StatePlane_Oklahoma_South_FIPS_3502'
    NAD__1983_HARN__STATE_PLANE__OREGON__NORTH_FIPS__3601='NAD_1983_HARN_StatePlane_Oregon_North_FIPS_3601'
    NAD__1983_HARN__STATE_PLANE__OREGON__SOUTH_FIPS__3602='NAD_1983_HARN_StatePlane_Oregon_South_FIPS_3602'
    NAD__1983_HARN__STATE_PLANE__PUERTO__RICO__VIRGIN__ISLANDS_FIPS__5200='NAD_1983_HARN_StatePlane_Puerto_Rico_Virgin_Islands_FIPS_5200'
    NAD__1983_HARN__STATE_PLANE__RHODE__ISLAND_FIPS__3800='NAD_1983_HARN_StatePlane_Rhode_Island_FIPS_3800'
    NAD__1983_HARN__STATE_PLANE__SOUTH__DAKOTA__NORTH_FIPS__4001='NAD_1983_HARN_StatePlane_South_Dakota_North_FIPS_4001'
    NAD__1983_HARN__STATE_PLANE__SOUTH__DAKOTA__SOUTH_FIPS__4002='NAD_1983_HARN_StatePlane_South_Dakota_South_FIPS_4002'
    NAD__1983_HARN__STATE_PLANE__TENNESSEE_FIPS__4100='NAD_1983_HARN_StatePlane_Tennessee_FIPS_4100'
    NAD__1983_HARN__STATE_PLANE__TEXAS__CENTRAL_FIPS__4203='NAD_1983_HARN_StatePlane_Texas_Central_FIPS_4203'
    NAD__1983_HARN__STATE_PLANE__TEXAS__NORTH__CENTRAL_FIPS__4202='NAD_1983_HARN_StatePlane_Texas_North_Central_FIPS_4202'
    NAD__1983_HARN__STATE_PLANE__TEXAS__NORTH_FIPS__4201='NAD_1983_HARN_StatePlane_Texas_North_FIPS_4201'
    NAD__1983_HARN__STATE_PLANE__TEXAS__SOUTH__CENTRAL_FIPS__4204='NAD_1983_HARN_StatePlane_Texas_South_Central_FIPS_4204'
    NAD__1983_HARN__STATE_PLANE__TEXAS__SOUTH_FIPS__4205='NAD_1983_HARN_StatePlane_Texas_South_FIPS_4205'
    NAD__1983_HARN__STATE_PLANE__UTAH__CENTRAL_FIPS__4302='NAD_1983_HARN_StatePlane_Utah_Central_FIPS_4302'
    NAD__1983_HARN__STATE_PLANE__UTAH__NORTH_FIPS__4301='NAD_1983_HARN_StatePlane_Utah_North_FIPS_4301'
    NAD__1983_HARN__STATE_PLANE__UTAH__SOUTH_FIPS__4303='NAD_1983_HARN_StatePlane_Utah_South_FIPS_4303'
    NAD__1983_HARN__STATE_PLANE__VERMONT_FIPS__4400='NAD_1983_HARN_StatePlane_Vermont_FIPS_4400'
    NAD__1983_HARN__STATE_PLANE__VIRGINIA__NORTH_FIPS__4501='NAD_1983_HARN_StatePlane_Virginia_North_FIPS_4501'
    NAD__1983_HARN__STATE_PLANE__VIRGINIA__SOUTH_FIPS__4502='NAD_1983_HARN_StatePlane_Virginia_South_FIPS_4502'
    NAD__1983_HARN__STATE_PLANE__WASHINGTON__NORTH_FIPS__4601='NAD_1983_HARN_StatePlane_Washington_North_FIPS_4601'
    NAD__1983_HARN__STATE_PLANE__WASHINGTON__SOUTH_FIPS__4602='NAD_1983_HARN_StatePlane_Washington_South_FIPS_4602'
    NAD__1983_HARN__STATE_PLANE__WEST__VIRGINIA__NORTH_FIPS__4701='NAD_1983_HARN_StatePlane_West_Virginia_North_FIPS_4701'
    NAD__1983_HARN__STATE_PLANE__WEST__VIRGINIA__SOUTH_FIPS__4702='NAD_1983_HARN_StatePlane_West_Virginia_South_FIPS_4702'
    NAD__1983_HARN__STATE_PLANE__WISCONSIN__CENTRAL_FIPS__4802='NAD_1983_HARN_StatePlane_Wisconsin_Central_FIPS_4802'
    NAD__1983_HARN__STATE_PLANE__WISCONSIN__NORTH_FIPS__4801='NAD_1983_HARN_StatePlane_Wisconsin_North_FIPS_4801'
    NAD__1983_HARN__STATE_PLANE__WISCONSIN__SOUTH_FIPS__4803='NAD_1983_HARN_StatePlane_Wisconsin_South_FIPS_4803'
    NAD__1983_HARN__STATE_PLANE__WYOMING__EAST_FIPS__4901='NAD_1983_HARN_StatePlane_Wyoming_East_FIPS_4901'
    NAD__1983_HARN__STATE_PLANE__WYOMING__EAST__CENTRAL_FIPS__4902='NAD_1983_HARN_StatePlane_Wyoming_East_Central_FIPS_4902'
    NAD__1983_HARN__STATE_PLANE__WYOMING__WEST__CENTRAL_FIPS__4903='NAD_1983_HARN_StatePlane_Wyoming_West_Central_FIPS_4903'
    NAD__1983_HARN__STATE_PLANE__WYOMING__WEST_FIPS__4904='NAD_1983_HARN_StatePlane_Wyoming_West_FIPS_4904'
    AMERICAN__SAMOA__1962__STATE_PLANE__AMERICAN__SAMOA_FIPS__5300='American_Samoa_1962_StatePlane_American_Samoa_FIPS_5300'
    NAD__1983_HARN__GUAM__MAP__GRID_1='NAD_1983_HARN_Guam_Map_Grid'
    NAD__1983_HARN_UTM__ZONE__2_S='NAD_1983_HARN_UTM_Zone_2S'
    NAD__MICHIGAN__STATE_PLANE__MICHIGAN__CENTRAL_FIPS__2112='NAD_Michigan_StatePlane_Michigan_Central_FIPS_2112'
    NAD__MICHIGAN__STATE_PLANE__MICHIGAN__CENTRAL__OLD_FIPS__2102='NAD_Michigan_StatePlane_Michigan_Central_Old_FIPS_2102'
    NAD__MICHIGAN__STATE_PLANE__MICHIGAN__EAST__OLD_FIPS__2101='NAD_Michigan_StatePlane_Michigan_East_Old_FIPS_2101'
    NAD__MICHIGAN__STATE_PLANE__MICHIGAN__NORTH_FIPS__2111='NAD_Michigan_StatePlane_Michigan_North_FIPS_2111'
    NAD__MICHIGAN__STATE_PLANE__MICHIGAN__SOUTH_FIPS__2113='NAD_Michigan_StatePlane_Michigan_South_FIPS_2113'
    NAD__MICHIGAN__STATE_PLANE__MICHIGAN__WEST__OLD_FIPS__2103='NAD_Michigan_StatePlane_Michigan_West_Old_FIPS_2103'
    OLD__HAWAIIAN__STATE_PLANE__HAWAII__1_FIPS__5101='Old_Hawaiian_StatePlane_Hawaii_1_FIPS_5101'
    OLD__HAWAIIAN__STATE_PLANE__HAWAII__2_FIPS__5102='Old_Hawaiian_StatePlane_Hawaii_2_FIPS_5102'
    OLD__HAWAIIAN__STATE_PLANE__HAWAII__3_FIPS__5103='Old_Hawaiian_StatePlane_Hawaii_3_FIPS_5103'
    OLD__HAWAIIAN__STATE_PLANE__HAWAII__4_FIPS__5104='Old_Hawaiian_StatePlane_Hawaii_4_FIPS_5104'
    OLD__HAWAIIAN__STATE_PLANE__HAWAII__5_FIPS__5105='Old_Hawaiian_StatePlane_Hawaii_5_FIPS_5105'
    PUERTO__RICO__STATE_PLANE__PUERTO__RICO_FIPS__5201='Puerto_Rico_StatePlane_Puerto_Rico_FIPS_5201'
    PUERTO__RICO__STATE_PLANE__VIRGIN__ISLANDS__ST__CROIX_FIPS__5202='Puerto_Rico_StatePlane_Virgin_Islands_St_Croix_FIPS_5202'
    NAD__1927_UTM__ZONE__10_N='NAD_1927_UTM_Zone_10N'
    NAD__1927_UTM__ZONE__11_N='NAD_1927_UTM_Zone_11N'
    NAD__1927_UTM__ZONE__12_N='NAD_1927_UTM_Zone_12N'
    NAD__1927_UTM__ZONE__13_N='NAD_1927_UTM_Zone_13N'
    NAD__1927_UTM__ZONE__14_N='NAD_1927_UTM_Zone_14N'
    NAD__1927_UTM__ZONE__15_N='NAD_1927_UTM_Zone_15N'
    NAD__1927_UTM__ZONE__16_N='NAD_1927_UTM_Zone_16N'
    NAD__1927_UTM__ZONE__17_N='NAD_1927_UTM_Zone_17N'
    NAD__1927_UTM__ZONE__18_N='NAD_1927_UTM_Zone_18N'
    NAD__1927_UTM__ZONE__19_N='NAD_1927_UTM_Zone_19N'
    NAD__1927_UTM__ZONE__20_N='NAD_1927_UTM_Zone_20N'
    NAD__1927_UTM__ZONE__21_N='NAD_1927_UTM_Zone_21N'
    NAD__1927_UTM__ZONE__22_N='NAD_1927_UTM_Zone_22N'
    NAD__1927_UTM__ZONE__3_N='NAD_1927_UTM_Zone_3N'
    NAD__1927_UTM__ZONE__4_N='NAD_1927_UTM_Zone_4N'
    NAD__1927_UTM__ZONE__5_N='NAD_1927_UTM_Zone_5N'
    NAD__1927_UTM__ZONE__6_N='NAD_1927_UTM_Zone_6N'
    NAD__1927_UTM__ZONE__7_N='NAD_1927_UTM_Zone_7N'
    NAD__1927_UTM__ZONE__8_N='NAD_1927_UTM_Zone_8N'
    NAD__1927_UTM__ZONE__9_N='NAD_1927_UTM_Zone_9N'
    NAD__1983_UTM__ZONE__10_N='NAD_1983_UTM_Zone_10N'
    NAD__1983_UTM__ZONE__11_N='NAD_1983_UTM_Zone_11N'
    NAD__1983_UTM__ZONE__12_N='NAD_1983_UTM_Zone_12N'
    NAD__1983_UTM__ZONE__13_N='NAD_1983_UTM_Zone_13N'
    NAD__1983_UTM__ZONE__14_N='NAD_1983_UTM_Zone_14N'
    NAD__1983_UTM__ZONE__15_N='NAD_1983_UTM_Zone_15N'
    NAD__1983_UTM__ZONE__16_N='NAD_1983_UTM_Zone_16N'
    NAD__1983_UTM__ZONE__17_N='NAD_1983_UTM_Zone_17N'
    NAD__1983_UTM__ZONE__18_N='NAD_1983_UTM_Zone_18N'
    NAD__1983_UTM__ZONE__19_N='NAD_1983_UTM_Zone_19N'
    NAD__1983_UTM__ZONE__20_N='NAD_1983_UTM_Zone_20N'
    NAD__1983_UTM__ZONE__21_N='NAD_1983_UTM_Zone_21N'
    NAD__1983_UTM__ZONE__22_N='NAD_1983_UTM_Zone_22N'
    NAD__1983_UTM__ZONE__23_N='NAD_1983_UTM_Zone_23N'
    NAD__1983_UTM__ZONE__3_N='NAD_1983_UTM_Zone_3N'
    NAD__1983_UTM__ZONE__4_N='NAD_1983_UTM_Zone_4N'
    NAD__1983_UTM__ZONE__5_N='NAD_1983_UTM_Zone_5N'
    NAD__1983_UTM__ZONE__6_N='NAD_1983_UTM_Zone_6N'
    NAD__1983_UTM__ZONE__7_N='NAD_1983_UTM_Zone_7N'
    NAD__1983_UTM__ZONE__8_N='NAD_1983_UTM_Zone_8N'
    NAD__1983_UTM__ZONE__9_N='NAD_1983_UTM_Zone_9N'
    ABIDJAN__1987_UTM__ZONE__29_N='Abidjan_1987_UTM_Zone_29N'
    ABIDJAN__1987_UTM__ZONE__30_N='Abidjan_1987_UTM_Zone_30N'
    ADINDAN_UTM__ZONE__37_N='Adindan_UTM_Zone_37N'
    ADINDAN_UTM__ZONE__38_N='Adindan_UTM_Zone_38N'
    AFGOOYE_UTM__ZONE__38_N='Afgooye_UTM_Zone_38N'
    AFGOOYE_UTM__ZONE__39_N='Afgooye_UTM_Zone_39N'
    AIN_EL__ABD_UTM__ZONE__37_N='Ain_el_Abd_UTM_Zone_37N'
    AIN_EL__ABD_UTM__ZONE__38_N='Ain_el_Abd_UTM_Zone_38N'
    AIN_EL__ABD_UTM__ZONE__39_N='Ain_el_Abd_UTM_Zone_39N'
    ARATU_UTM__ZONE__22_S='Aratu_UTM_Zone_22S'
    ARATU_UTM__ZONE__23_S='Aratu_UTM_Zone_23S'
    ARATU_UTM__ZONE__24_S='Aratu_UTM_Zone_24S'
    ARC__1950_UTM__ZONE__34_S='Arc_1950_UTM_Zone_34S'
    ARC__1950_UTM__ZONE__35_S='Arc_1950_UTM_Zone_35S'
    ARC__1950_UTM__ZONE__36_S='Arc_1950_UTM_Zone_36S'
    ARC__1960_UTM__ZONE__35_N='Arc_1960_UTM_Zone_35N'
    ARC__1960_UTM__ZONE__35_S='Arc_1960_UTM_Zone_35S'
    ARC__1960_UTM__ZONE__36_N='Arc_1960_UTM_Zone_36N'
    ARC__1960_UTM__ZONE__36_S='Arc_1960_UTM_Zone_36S'
    ARC__1960_UTM__ZONE__37_N='Arc_1960_UTM_Zone_37N'
    ARC__1960_UTM__ZONE__37_S='Arc_1960_UTM_Zone_37S'
    ATS__1977_UTM__ZONE__19_N='ATS_1977_UTM_Zone_19N'
    ATS__1977_UTM__ZONE__20_N='ATS_1977_UTM_Zone_20N'
    BATAVIA_UTM__ZONE__48_S='Batavia_UTM_Zone_48S'
    BATAVIA_UTM__ZONE__49_S='Batavia_UTM_Zone_49S'
    BATAVIA_UTM__ZONE__50_S='Batavia_UTM_Zone_50S'
    BISSAU_UTM__ZONE__28_N='Bissau_UTM_Zone_28N'
    BOGOTA_UTM__ZONE__17_N='Bogota_UTM_Zone_17N'
    BOGOTA_UTM__ZONE__18_N='Bogota_UTM_Zone_18N'
    CAMACUPA_UTM__ZONE__32_S='Camacupa_UTM_Zone_32S'
    CAMACUPA_UTM__ZONE__33_S='Camacupa_UTM_Zone_33S'
    CAPE_UTM__ZONE__34_S='Cape_UTM_Zone_34S'
    CAPE_UTM__ZONE__35_S='Cape_UTM_Zone_35S'
    CAPE_UTM__ZONE__36_S='Cape_UTM_Zone_36S'
    CARTHAGE_UTM__ZONE__32_N='Carthage_UTM_Zone_32N'
    CONAKRY__1905_UTM__ZONE__28_N='Conakry_1905_UTM_Zone_28N'
    CONAKRY__1905_UTM__ZONE__29_N='Conakry_1905_UTM_Zone_29N'
    CORREGO__ALEGRE_UTM__ZONE__23_S='Corrego_Alegre_UTM_Zone_23S'
    CORREGO__ALEGRE_UTM__ZONE__24_S='Corrego_Alegre_UTM_Zone_24S'
    DABOLA_UTM__ZONE__28_N='Dabola_UTM_Zone_28N'
    DABOLA_UTM__ZONE__29_N='Dabola_UTM_Zone_29N'
    DATUM__73_UTM__ZONE__29_N='Datum_73_UTM_Zone_29N'
    DOUALA_UTM__ZONE__32_N='Douala_UTM_Zone_32N'
    ED__1950_ED_77_UTM__ZONE__38_N='ED_1950_ED77_UTM_Zone_38N'
    ED__1950_ED_77_UTM__ZONE__39_N='ED_1950_ED77_UTM_Zone_39N'
    ED__1950_ED_77_UTM__ZONE__40_N='ED_1950_ED77_UTM_Zone_40N'
    ED__1950_ED_77_UTM__ZONE__41_N='ED_1950_ED77_UTM_Zone_41N'
    ELD__1979_UTM__ZONE__32_N='ELD_1979_UTM_Zone_32N'
    ELD__1979_UTM__ZONE__33_N='ELD_1979_UTM_Zone_33N'
    ELD__1979_UTM__ZONE__34_N='ELD_1979_UTM_Zone_34N'
    ELD__1979_UTM__ZONE__35_N='ELD_1979_UTM_Zone_35N'
    ETRF__1989_UTM__ZONE__28_N='ETRF_1989_UTM_Zone_28N'
    ETRF__1989_UTM__ZONE__29_N='ETRF_1989_UTM_Zone_29N'
    ETRF__1989_UTM__ZONE__30_N='ETRF_1989_UTM_Zone_30N'
    ETRF__1989_UTM__ZONE__31_N='ETRF_1989_UTM_Zone_31N'
    ETRF__1989_UTM__ZONE__32_N='ETRF_1989_UTM_Zone_32N'
    ETRF__1989_UTM__ZONE__33_N='ETRF_1989_UTM_Zone_33N'
    ETRF__1989_UTM__ZONE__34_N='ETRF_1989_UTM_Zone_34N'
    ETRF__1989_UTM__ZONE__35_N='ETRF_1989_UTM_Zone_35N'
    ETRF__1989_UTM__ZONE__36_N='ETRF_1989_UTM_Zone_36N'
    ETRF__1989_UTM__ZONE__37_N='ETRF_1989_UTM_Zone_37N'
    ETRF__1989_UTM__ZONE__38_N='ETRF_1989_UTM_Zone_38N'
    ED__1950_UTM__ZONE__28_N='ED_1950_UTM_Zone_28N'
    ED__1950_UTM__ZONE__29_N='ED_1950_UTM_Zone_29N'
    ED__1950_UTM__ZONE__30_N='ED_1950_UTM_Zone_30N'
    ED__1950_UTM__ZONE__31_N='ED_1950_UTM_Zone_31N'
    ED__1950_UTM__ZONE__32_N='ED_1950_UTM_Zone_32N'
    ED__1950_UTM__ZONE__33_N='ED_1950_UTM_Zone_33N'
    ED__1950_UTM__ZONE__34_N='ED_1950_UTM_Zone_34N'
    ED__1950_UTM__ZONE__35_N='ED_1950_UTM_Zone_35N'
    ED__1950_UTM__ZONE__36_N='ED_1950_UTM_Zone_36N'
    ED__1950_UTM__ZONE__37_N='ED_1950_UTM_Zone_37N'
    ED__1950_UTM__ZONE__38_N='ED_1950_UTM_Zone_38N'
    FAHUD_UTM__ZONE__39_N='Fahud_UTM_Zone_39N'
    FAHUD_UTM__ZONE__40_N='Fahud_UTM_Zone_40N'
    GAROUA_UTM__ZONE__33_N='Garoua_UTM_Zone_33N'
    GRACIOSA__BASE_SW__1948_UTM__ZONE__26_N='Graciosa_Base_SW_1948_UTM_Zone_26N'
    HITO_XVIII__1963_UTM__19_S='Hito_XVIII_1963_UTM_19S'
    HONG__KONG__1980_UTM__ZONE__49_N='Hong_Kong_1980_UTM_Zone_49N'
    HONG__KONG__1980_UTM__ZONE__50_N='Hong_Kong_1980_UTM_Zone_50N'
    INDIAN__1954_UTM__ZONE__46_N='Indian_1954_UTM_Zone_46N'
    INDIAN__1954_UTM__ZONE__47_N='Indian_1954_UTM_Zone_47N'
    INDIAN__1954_UTM__ZONE__48_N='Indian_1954_UTM_Zone_48N'
    INDIAN__1960_UTM__ZONE__48_N='Indian_1960_UTM_Zone_48N'
    INDIAN__1960_UTM__ZONE__49_N='Indian_1960_UTM_Zone_49N'
    INDIAN__1975_UTM__ZONE__47_N='Indian_1975_UTM_Zone_47N'
    INDIAN__1975_UTM__ZONE__48_N='Indian_1975_UTM_Zone_48N'
    INDONESIAN__1974_UTM__ZONE__46_N='Indonesian_1974_UTM_Zone_46N'
    INDONESIAN__1974_UTM__ZONE__46_S='Indonesian_1974_UTM_Zone_46S'
    INDONESIAN__1974_UTM__ZONE__47_N='Indonesian_1974_UTM_Zone_47N'
    INDONESIAN__1974_UTM__ZONE__47_S='Indonesian_1974_UTM_Zone_47S'
    INDONESIAN__1974_UTM__ZONE__48_N='Indonesian_1974_UTM_Zone_48N'
    INDONESIAN__1974_UTM__ZONE__48_S='Indonesian_1974_UTM_Zone_48S'
    INDONESIAN__1974_UTM__ZONE__49_N='Indonesian_1974_UTM_Zone_49N'
    INDONESIAN__1974_UTM__ZONE__49_S='Indonesian_1974_UTM_Zone_49S'
    INDONESIAN__1974_UTM__ZONE__50_N='Indonesian_1974_UTM_Zone_50N'
    INDONESIAN__1974_UTM__ZONE__50_S='Indonesian_1974_UTM_Zone_50S'
    INDONESIAN__1974_UTM__ZONE__51_N='Indonesian_1974_UTM_Zone_51N'
    INDONESIAN__1974_UTM__ZONE__51_S='Indonesian_1974_UTM_Zone_51S'
    INDONESIAN__1974_UTM__ZONE__52_N='Indonesian_1974_UTM_Zone_52N'
    INDONESIAN__1974_UTM__ZONE__52_S='Indonesian_1974_UTM_Zone_52S'
    INDONESIAN__1974_UTM__ZONE__53_N='Indonesian_1974_UTM_Zone_53N'
    INDONESIAN__1974_UTM__ZONE__53_S='Indonesian_1974_UTM_Zone_53S'
    INDONESIAN__1974_UTM__ZONE__54_S='Indonesian_1974_UTM_Zone_54S'
    IRENET_95_UTM__ZONE__29_N='IRENET95_UTM_Zone_29N'
    KERTAU_UTM__ZONE__47_N='Kertau_UTM_Zone_47N'
    KERTAU_UTM__ZONE__48_N='Kertau_UTM_Zone_48N'
    LA__CANOA_UTM__ZONE__18_N='La_Canoa_UTM_Zone_18N'
    LA__CANOA_UTM__ZONE__19_N='La_Canoa_UTM_Zone_19N'
    LA__CANOA_UTM__ZONE__20_N='La_Canoa_UTM_Zone_20N'
    LA__CANOA_UTM__ZONE__21_N='La_Canoa_UTM_Zone_21N'
    LOCODJO__1965_UTM__ZONE__29_N='Locodjo_1965_UTM_Zone_29N'
    LOCODJO__1965_UTM__ZONE__30_N='Locodjo_1965_UTM_Zone_30N'
    LOME_UTM__ZONE__31_N='Lome_UTM_Zone_31N'
    MPORALOKO_UTM__ZONE__32_N='Mporaloko_UTM_Zone_32N'
    MPORALOKO_UTM__ZONE__32_S='Mporaloko_UTM_Zone_32S'
    MALONGO__1987_UTM__ZONE__32_S='Malongo_1987_UTM_Zone_32S'
    MASSAWA_UTM__ZONE__37_N='Massawa_UTM_Zone_37N'
    MHAST_UTM__ZONE__32_S='Mhast_UTM_Zone_32S'
    MINNA_UTM__ZONE__31_N='Minna_UTM_Zone_31N'
    MINNA_UTM__ZONE__32_N='Minna_UTM_Zone_32N'
    MOZNET_UTM__ZONE__36_S='Moznet_UTM_Zone_36S'
    MOZNET_UTM__ZONE__37_S='Moznet_UTM_Zone_37S'
    NAD__1927_BLM__ZONE__14_N='NAD_1927_BLM_Zone_14N'
    NAD__1927_BLM__ZONE__15_N='NAD_1927_BLM_Zone_15N'
    NAD__1927_BLM__ZONE__16_N='NAD_1927_BLM_Zone_16N'
    NAD__1927_BLM__ZONE__17_N='NAD_1927_BLM_Zone_17N'
    NAD__1983_HARN_UTM__ZONE__2_S_1='NAD_1983_HARN_UTM_Zone_2S'
    NAHRWAN__1967_UTM__ZONE__38_N='Nahrwan_1967_UTM_Zone_38N'
    NAHRWAN__1967_UTM__ZONE__39_N='Nahrwan_1967_UTM_Zone_39N'
    NAHRWAN__1967_UTM__ZONE__40_N='Nahrwan_1967_UTM_Zone_40N'
    NAPARIMA__1955_UTM__ZONE__20_N='Naparima_1955_UTM_Zone_20N'
    NAPARIMA__1972_UTM__ZONE__20_N='Naparima_1972_UTM_Zone_20N'
    NGN_UTM__ZONE__38_N='NGN_UTM_Zone_38N'
    NGN_UTM__ZONE__39_N='NGN_UTM_Zone_39N'
    NGO__1948_UTM__ZONE__32_N='NGO_1948_UTM_Zone_32N'
    NGO__1948_UTM__ZONE__33_N='NGO_1948_UTM_Zone_33N'
    NGO__1948_UTM__ZONE__34_N='NGO_1948_UTM_Zone_34N'
    NGO__1948_UTM__ZONE__35_N='NGO_1948_UTM_Zone_35N'
    NORD__SAHARA__1959_UTM__ZONE__29_N='Nord_Sahara_1959_UTM_Zone_29N'
    NORD__SAHARA__1959_UTM__ZONE__30_N='Nord_Sahara_1959_UTM_Zone_30N'
    NORD__SAHARA__1959_UTM__ZONE__31_N='Nord_Sahara_1959_UTM_Zone_31N'
    NORD__SAHARA__1959_UTM__ZONE__32_N='Nord_Sahara_1959_UTM_Zone_32N'
    NZGD__1949_UTM__ZONE__58_S_1='NZGD_1949_UTM_Zone_58S'
    NZGD__1949_UTM__ZONE__59_S_1='NZGD_1949_UTM_Zone_59S'
    NZGD__1949_UTM__ZONE__60_S_1='NZGD_1949_UTM_Zone_60S'
    NZGD__2000_UTM__ZONE__58_S_1='NZGD_2000_UTM_Zone_58S'
    NZGD__2000_UTM__ZONE__59_S_1='NZGD_2000_UTM_Zone_59S'
    NZGD__2000_UTM__ZONE__60_S_1='NZGD_2000_UTM_Zone_60S'
    OBSERV__METEOROLOGICO__1939_UTM__ZONE__25_N='Observ_Meteorologico_1939_UTM_Zone_25N'
    OLD__HAWAIIAN_UTM__ZONE__4_N='Old_Hawaiian_UTM_Zone_4N'
    OLD__HAWAIIAN_UTM__ZONE__5_N='Old_Hawaiian_UTM_Zone_5N'
    PDO__1993_UTM__ZONE__39_N='PDO_1993_UTM_Zone_39N'
    PDO__1993_UTM__ZONE__40_N='PDO_1993_UTM_Zone_40N'
    POINTE__NOIRE_UTM__ZONE__32_S='Pointe_Noire_UTM_Zone_32S'
    PORTO__SANTO__1936_UTM__ZONE__28_N='Porto_Santo_1936_UTM_Zone_28N'
    PSAD__1956_UTM__ZONE__17_S='PSAD_1956_UTM_Zone_17S'
    PSAD__1956_UTM__ZONE__18_N='PSAD_1956_UTM_Zone_18N'
    PSAD__1956_UTM__ZONE__18_S='PSAD_1956_UTM_Zone_18S'
    PSAD__1956_UTM__ZONE__19_N='PSAD_1956_UTM_Zone_19N'
    PSAD__1956_UTM__ZONE__19_S='PSAD_1956_UTM_Zone_19S'
    PSAD__1956_UTM__ZONE__20_N='PSAD_1956_UTM_Zone_20N'
    PSAD__1956_UTM__ZONE__20_S='PSAD_1956_UTM_Zone_20S'
    PSAD__1956_UTM__ZONE__21_N='PSAD_1956_UTM_Zone_21N'
    PSAD__1956_UTM__ZONE__22_S='PSAD_1956_UTM_Zone_22S'
    PUERTO__RICO_UTM__ZONE__20_N='Puerto_Rico_UTM_Zone_20N'
    SAMBOJA_UTM__ZONE__50_S='Samboja_UTM_Zone_50S'
    SAO__BRAZ_UTM__ZONE__26_N='Sao_Braz_UTM_Zone_26N'
    SAPPER__HILL__1943_UTM__ZONE__20_S='Sapper_Hill_1943_UTM_Zone_20S'
    SAPPER__HILL__1943_UTM__ZONE__21_S='Sapper_Hill_1943_UTM_Zone_21S'
    SCHWARZECK_UTM__ZONE__33_S='Schwarzeck_UTM_Zone_33S'
    SELVAGEM__GRANDE__1938_UTM__ZONE__28_N='Selvagem_Grande_1938_UTM_Zone_28N'
    SIERRA__LEONE__1968_UTM__ZONE__28_N='Sierra_Leone_1968_UTM_Zone_28N'
    SIERRA__LEONE__1968_UTM__ZONE__29_N='Sierra_Leone_1968_UTM_Zone_29N'
    SIRGAS_UTM__ZONE__17_N='SIRGAS_UTM_Zone_17N'
    SIRGAS_UTM__ZONE__17_S='SIRGAS_UTM_Zone_17S'
    SIRGAS_UTM__ZONE__18_N='SIRGAS_UTM_Zone_18N'
    SIRGAS_UTM__ZONE__18_S='SIRGAS_UTM_Zone_18S'
    SIRGAS_UTM__ZONE__19_N='SIRGAS_UTM_Zone_19N'
    SIRGAS_UTM__ZONE__19_S='SIRGAS_UTM_Zone_19S'
    SIRGAS_UTM__ZONE__20_N='SIRGAS_UTM_Zone_20N'
    SIRGAS_UTM__ZONE__20_S='SIRGAS_UTM_Zone_20S'
    SIRGAS_UTM__ZONE__21_N='SIRGAS_UTM_Zone_21N'
    SIRGAS_UTM__ZONE__21_S='SIRGAS_UTM_Zone_21S'
    SIRGAS_UTM__ZONE__22_N='SIRGAS_UTM_Zone_22N'
    SIRGAS_UTM__ZONE__22_S='SIRGAS_UTM_Zone_22S'
    SIRGAS_UTM__ZONE__23_S='SIRGAS_UTM_Zone_23S'
    SIRGAS_UTM__ZONE__24_S='SIRGAS_UTM_Zone_24S'
    SIRGAS_UTM__ZONE__25_S='SIRGAS_UTM_Zone_25S'
    SAD__1969_UTM__ZONE__17_S='SAD_1969_UTM_Zone_17S'
    SAD__1969_UTM__ZONE__18_N='SAD_1969_UTM_Zone_18N'
    SAD__1969_UTM__ZONE__18_S='SAD_1969_UTM_Zone_18S'
    SAD__1969_UTM__ZONE__19_N='SAD_1969_UTM_Zone_19N'
    SAD__1969_UTM__ZONE__19_S='SAD_1969_UTM_Zone_19S'
    SAD__1969_UTM__ZONE__20_N='SAD_1969_UTM_Zone_20N'
    SAD__1969_UTM__ZONE__20_S='SAD_1969_UTM_Zone_20S'
    SAD__1969_UTM__ZONE__21_N='SAD_1969_UTM_Zone_21N'
    SAD__1969_UTM__ZONE__21_S='SAD_1969_UTM_Zone_21S'
    SAD__1969_UTM__ZONE__22_N='SAD_1969_UTM_Zone_22N'
    SAD__1969_UTM__ZONE__22_S='SAD_1969_UTM_Zone_22S'
    SAD__1969_UTM__ZONE__23_S='SAD_1969_UTM_Zone_23S'
    SAD__1969_UTM__ZONE__24_S='SAD_1969_UTM_Zone_24S'
    SAD__1969_UTM__ZONE__25_S='SAD_1969_UTM_Zone_25S'
    SUDAN_UTM__ZONE__35_N='Sudan_UTM_Zone_35N'
    SUDAN_UTM__ZONE__36_N='Sudan_UTM_Zone_36N'
    TANANARIVE__1925_UTM__ZONE__38_S='Tananarive_1925_UTM_Zone_38S'
    TANANARIVE__1925_UTM__ZONE__39_S='Tananarive_1925_UTM_Zone_39S'
    TETE_UTM__ZONE__36_S='Tete_UTM_Zone_36S'
    TETE_UTM__ZONE__37_S='Tete_UTM_Zone_37S'
    TIMBALAI__1948_UTM__ZONE__49_N='Timbalai_1948_UTM_Zone_49N'
    TIMBALAI__1948_UTM__ZONE__50_N='Timbalai_1948_UTM_Zone_50N'
    TOKYO_UTM__ZONE__51_N='Tokyo_UTM_Zone_51N'
    TOKYO_UTM__ZONE__52_N='Tokyo_UTM_Zone_52N'
    TOKYO_UTM__ZONE__53_N='Tokyo_UTM_Zone_53N'
    TOKYO_UTM__ZONE__54_N='Tokyo_UTM_Zone_54N'
    TOKYO_UTM__ZONE__55_N='Tokyo_UTM_Zone_55N'
    TOKYO_UTM__ZONE__56_N='Tokyo_UTM_Zone_56N'
    TC__1948_UTM__ZONE__39_N='TC_1948_UTM_Zone_39N'
    TC__1948_UTM__ZONE__40_N='TC_1948_UTM_Zone_40N'
    YEMEN_NGN__1996_UTM__ZONE__38_N='Yemen_NGN_1996_UTM_Zone_38N'
    YEMEN_NGN__1996_UTM__ZONE__39_N='Yemen_NGN_1996_UTM_Zone_39N'
    YOFF__1972_UTM__ZONE__28_N='Yoff_1972_UTM_Zone_28N'
    ZANDERIJ__1972_UTM__ZONE__21_N='Zanderij_1972_UTM_Zone_21N'
    WGS__1972_UTM__ZONE__10_N='WGS_1972_UTM_Zone_10N'
    WGS__1972_UTM__ZONE__10_S='WGS_1972_UTM_Zone_10S'
    WGS__1972_UTM__ZONE__11_N='WGS_1972_UTM_Zone_11N'
    WGS__1972_UTM__ZONE__11_S='WGS_1972_UTM_Zone_11S'
    WGS__1972_UTM__ZONE__12_N='WGS_1972_UTM_Zone_12N'
    WGS__1972_UTM__ZONE__12_S='WGS_1972_UTM_Zone_12S'
    WGS__1972_UTM__ZONE__13_N='WGS_1972_UTM_Zone_13N'
    WGS__1972_UTM__ZONE__13_S='WGS_1972_UTM_Zone_13S'
    WGS__1972_UTM__ZONE__14_N='WGS_1972_UTM_Zone_14N'
    WGS__1972_UTM__ZONE__14_S='WGS_1972_UTM_Zone_14S'
    WGS__1972_UTM__ZONE__15_N='WGS_1972_UTM_Zone_15N'
    WGS__1972_UTM__ZONE__15_S='WGS_1972_UTM_Zone_15S'
    WGS__1972_UTM__ZONE__16_N='WGS_1972_UTM_Zone_16N'
    WGS__1972_UTM__ZONE__16_S='WGS_1972_UTM_Zone_16S'
    WGS__1972_UTM__ZONE__17_N='WGS_1972_UTM_Zone_17N'
    WGS__1972_UTM__ZONE__17_S='WGS_1972_UTM_Zone_17S'
    WGS__1972_UTM__ZONE__18_N='WGS_1972_UTM_Zone_18N'
    WGS__1972_UTM__ZONE__18_S='WGS_1972_UTM_Zone_18S'
    WGS__1972_UTM__ZONE__19_N='WGS_1972_UTM_Zone_19N'
    WGS__1972_UTM__ZONE__19_S='WGS_1972_UTM_Zone_19S'
    WGS__1972_UTM__ZONE__1_N='WGS_1972_UTM_Zone_1N'
    WGS__1972_UTM__ZONE__1_S='WGS_1972_UTM_Zone_1S'
    WGS__1972_UTM__ZONE__20_N='WGS_1972_UTM_Zone_20N'
    WGS__1972_UTM__ZONE__20_S='WGS_1972_UTM_Zone_20S'
    WGS__1972_UTM__ZONE__21_N='WGS_1972_UTM_Zone_21N'
    WGS__1972_UTM__ZONE__21_S='WGS_1972_UTM_Zone_21S'
    WGS__1972_UTM__ZONE__22_N='WGS_1972_UTM_Zone_22N'
    WGS__1972_UTM__ZONE__22_S='WGS_1972_UTM_Zone_22S'
    WGS__1972_UTM__ZONE__23_N='WGS_1972_UTM_Zone_23N'
    WGS__1972_UTM__ZONE__23_S='WGS_1972_UTM_Zone_23S'
    WGS__1972_UTM__ZONE__24_N='WGS_1972_UTM_Zone_24N'
    WGS__1972_UTM__ZONE__24_S='WGS_1972_UTM_Zone_24S'
    WGS__1972_UTM__ZONE__25_N='WGS_1972_UTM_Zone_25N'
    WGS__1972_UTM__ZONE__25_S='WGS_1972_UTM_Zone_25S'
    WGS__1972_UTM__ZONE__26_N='WGS_1972_UTM_Zone_26N'
    WGS__1972_UTM__ZONE__26_S='WGS_1972_UTM_Zone_26S'
    WGS__1972_UTM__ZONE__27_N='WGS_1972_UTM_Zone_27N'
    WGS__1972_UTM__ZONE__27_S='WGS_1972_UTM_Zone_27S'
    WGS__1972_UTM__ZONE__28_N='WGS_1972_UTM_Zone_28N'
    WGS__1972_UTM__ZONE__28_S='WGS_1972_UTM_Zone_28S'
    WGS__1972_UTM__ZONE__29_N='WGS_1972_UTM_Zone_29N'
    WGS__1972_UTM__ZONE__29_S='WGS_1972_UTM_Zone_29S'
    WGS__1972_UTM__ZONE__2_N='WGS_1972_UTM_Zone_2N'
    WGS__1972_UTM__ZONE__2_S='WGS_1972_UTM_Zone_2S'
    WGS__1972_UTM__ZONE__30_N='WGS_1972_UTM_Zone_30N'
    WGS__1972_UTM__ZONE__30_S='WGS_1972_UTM_Zone_30S'
    WGS__1972_UTM__ZONE__31_N='WGS_1972_UTM_Zone_31N'
    WGS__1972_UTM__ZONE__31_S='WGS_1972_UTM_Zone_31S'
    WGS__1972_UTM__ZONE__32_N='WGS_1972_UTM_Zone_32N'
    WGS__1972_UTM__ZONE__32_S='WGS_1972_UTM_Zone_32S'
    WGS__1972_UTM__ZONE__33_N='WGS_1972_UTM_Zone_33N'
    WGS__1972_UTM__ZONE__33_S='WGS_1972_UTM_Zone_33S'
    WGS__1972_UTM__ZONE__34_N='WGS_1972_UTM_Zone_34N'
    WGS__1972_UTM__ZONE__34_S='WGS_1972_UTM_Zone_34S'
    WGS__1972_UTM__ZONE__35_N='WGS_1972_UTM_Zone_35N'
    WGS__1972_UTM__ZONE__35_S='WGS_1972_UTM_Zone_35S'
    WGS__1972_UTM__ZONE__36_N='WGS_1972_UTM_Zone_36N'
    WGS__1972_UTM__ZONE__36_S='WGS_1972_UTM_Zone_36S'
    WGS__1972_UTM__ZONE__37_N='WGS_1972_UTM_Zone_37N'
    WGS__1972_UTM__ZONE__37_S='WGS_1972_UTM_Zone_37S'
    WGS__1972_UTM__ZONE__38_N='WGS_1972_UTM_Zone_38N'
    WGS__1972_UTM__ZONE__38_S='WGS_1972_UTM_Zone_38S'
    WGS__1972_UTM__ZONE__39_N='WGS_1972_UTM_Zone_39N'
    WGS__1972_UTM__ZONE__39_S='WGS_1972_UTM_Zone_39S'
    WGS__1972_UTM__ZONE__3_N='WGS_1972_UTM_Zone_3N'
    WGS__1972_UTM__ZONE__3_S='WGS_1972_UTM_Zone_3S'
    WGS__1972_UTM__ZONE__40_N='WGS_1972_UTM_Zone_40N'
    WGS__1972_UTM__ZONE__40_S='WGS_1972_UTM_Zone_40S'
    WGS__1972_UTM__ZONE__41_N='WGS_1972_UTM_Zone_41N'
    WGS__1972_UTM__ZONE__41_S='WGS_1972_UTM_Zone_41S'
    WGS__1972_UTM__ZONE__42_N='WGS_1972_UTM_Zone_42N'
    WGS__1972_UTM__ZONE__42_S='WGS_1972_UTM_Zone_42S'
    WGS__1972_UTM__ZONE__43_N='WGS_1972_UTM_Zone_43N'
    WGS__1972_UTM__ZONE__43_S='WGS_1972_UTM_Zone_43S'
    WGS__1972_UTM__ZONE__44_N='WGS_1972_UTM_Zone_44N'
    WGS__1972_UTM__ZONE__44_S='WGS_1972_UTM_Zone_44S'
    WGS__1972_UTM__ZONE__45_N='WGS_1972_UTM_Zone_45N'
    WGS__1972_UTM__ZONE__45_S='WGS_1972_UTM_Zone_45S'
    WGS__1972_UTM__ZONE__46_N='WGS_1972_UTM_Zone_46N'
    WGS__1972_UTM__ZONE__46_S='WGS_1972_UTM_Zone_46S'
    WGS__1972_UTM__ZONE__47_N='WGS_1972_UTM_Zone_47N'
    WGS__1972_UTM__ZONE__47_S='WGS_1972_UTM_Zone_47S'
    WGS__1972_UTM__ZONE__48_N='WGS_1972_UTM_Zone_48N'
    WGS__1972_UTM__ZONE__48_S='WGS_1972_UTM_Zone_48S'
    WGS__1972_UTM__ZONE__49_N='WGS_1972_UTM_Zone_49N'
    WGS__1972_UTM__ZONE__49_S='WGS_1972_UTM_Zone_49S'
    WGS__1972_UTM__ZONE__4_N='WGS_1972_UTM_Zone_4N'
    WGS__1972_UTM__ZONE__4_S='WGS_1972_UTM_Zone_4S'
    WGS__1972_UTM__ZONE__50_N='WGS_1972_UTM_Zone_50N'
    WGS__1972_UTM__ZONE__50_S='WGS_1972_UTM_Zone_50S'
    WGS__1972_UTM__ZONE__51_N='WGS_1972_UTM_Zone_51N'
    WGS__1972_UTM__ZONE__51_S='WGS_1972_UTM_Zone_51S'
    WGS__1972_UTM__ZONE__52_N='WGS_1972_UTM_Zone_52N'
    WGS__1972_UTM__ZONE__52_S='WGS_1972_UTM_Zone_52S'
    WGS__1972_UTM__ZONE__53_N='WGS_1972_UTM_Zone_53N'
    WGS__1972_UTM__ZONE__53_S='WGS_1972_UTM_Zone_53S'
    WGS__1972_UTM__ZONE__54_N='WGS_1972_UTM_Zone_54N'
    WGS__1972_UTM__ZONE__54_S='WGS_1972_UTM_Zone_54S'
    WGS__1972_UTM__ZONE__55_N='WGS_1972_UTM_Zone_55N'
    WGS__1972_UTM__ZONE__55_S='WGS_1972_UTM_Zone_55S'
    WGS__1972_UTM__ZONE__56_N='WGS_1972_UTM_Zone_56N'
    WGS__1972_UTM__ZONE__56_S='WGS_1972_UTM_Zone_56S'
    WGS__1972_UTM__ZONE__57_N='WGS_1972_UTM_Zone_57N'
    WGS__1972_UTM__ZONE__57_S='WGS_1972_UTM_Zone_57S'
    WGS__1972_UTM__ZONE__58_N='WGS_1972_UTM_Zone_58N'
    WGS__1972_UTM__ZONE__58_S='WGS_1972_UTM_Zone_58S'
    WGS__1972_UTM__ZONE__59_N='WGS_1972_UTM_Zone_59N'
    WGS__1972_UTM__ZONE__59_S='WGS_1972_UTM_Zone_59S'
    WGS__1972_UTM__ZONE__5_N='WGS_1972_UTM_Zone_5N'
    WGS__1972_UTM__ZONE__5_S='WGS_1972_UTM_Zone_5S'
    WGS__1972_UTM__ZONE__60_N='WGS_1972_UTM_Zone_60N'
    WGS__1972_UTM__ZONE__60_S='WGS_1972_UTM_Zone_60S'
    WGS__1972_UTM__ZONE__6_N='WGS_1972_UTM_Zone_6N'
    WGS__1972_UTM__ZONE__6_S='WGS_1972_UTM_Zone_6S'
    WGS__1972_UTM__ZONE__7_N='WGS_1972_UTM_Zone_7N'
    WGS__1972_UTM__ZONE__7_S='WGS_1972_UTM_Zone_7S'
    WGS__1972_UTM__ZONE__8_N='WGS_1972_UTM_Zone_8N'
    WGS__1972_UTM__ZONE__8_S='WGS_1972_UTM_Zone_8S'
    WGS__1972_UTM__ZONE__9_N='WGS_1972_UTM_Zone_9N'
    WGS__1972_UTM__ZONE__9_S='WGS_1972_UTM_Zone_9S'
    WGS__1984_UTM__ZONE__10_N='WGS_1984_UTM_Zone_10N'
    WGS__1984_UTM__ZONE__10_S='WGS_1984_UTM_Zone_10S'
    WGS__1984_UTM__ZONE__11_N='WGS_1984_UTM_Zone_11N'
    WGS__1984_UTM__ZONE__11_S='WGS_1984_UTM_Zone_11S'
    WGS__1984_UTM__ZONE__12_N='WGS_1984_UTM_Zone_12N'
    WGS__1984_UTM__ZONE__12_S='WGS_1984_UTM_Zone_12S'
    WGS__1984_UTM__ZONE__13_N='WGS_1984_UTM_Zone_13N'
    WGS__1984_UTM__ZONE__13_S='WGS_1984_UTM_Zone_13S'
    WGS__1984_UTM__ZONE__14_N='WGS_1984_UTM_Zone_14N'
    WGS__1984_UTM__ZONE__14_S='WGS_1984_UTM_Zone_14S'
    WGS__1984_UTM__ZONE__15_N='WGS_1984_UTM_Zone_15N'
    WGS__1984_UTM__ZONE__15_S='WGS_1984_UTM_Zone_15S'
    WGS__1984_UTM__ZONE__16_N='WGS_1984_UTM_Zone_16N'
    WGS__1984_UTM__ZONE__16_S='WGS_1984_UTM_Zone_16S'
    WGS__1984_UTM__ZONE__17_N='WGS_1984_UTM_Zone_17N'
    WGS__1984_UTM__ZONE__17_S='WGS_1984_UTM_Zone_17S'
    WGS__1984_UTM__ZONE__18_N='WGS_1984_UTM_Zone_18N'
    WGS__1984_UTM__ZONE__18_S='WGS_1984_UTM_Zone_18S'
    WGS__1984_UTM__ZONE__19_N='WGS_1984_UTM_Zone_19N'
    WGS__1984_UTM__ZONE__19_S='WGS_1984_UTM_Zone_19S'
    WGS__1984_UTM__ZONE__1_N='WGS_1984_UTM_Zone_1N'
    WGS__1984_UTM__ZONE__1_S='WGS_1984_UTM_Zone_1S'
    WGS__1984_UTM__ZONE__20_N='WGS_1984_UTM_Zone_20N'
    WGS__1984_UTM__ZONE__20_S='WGS_1984_UTM_Zone_20S'
    WGS__1984_UTM__ZONE__21_N='WGS_1984_UTM_Zone_21N'
    WGS__1984_UTM__ZONE__21_S='WGS_1984_UTM_Zone_21S'
    WGS__1984_UTM__ZONE__22_N='WGS_1984_UTM_Zone_22N'
    WGS__1984_UTM__ZONE__22_S='WGS_1984_UTM_Zone_22S'
    WGS__1984_UTM__ZONE__23_N='WGS_1984_UTM_Zone_23N'
    WGS__1984_UTM__ZONE__23_S='WGS_1984_UTM_Zone_23S'
    WGS__1984_UTM__ZONE__24_N='WGS_1984_UTM_Zone_24N'
    WGS__1984_UTM__ZONE__24_S='WGS_1984_UTM_Zone_24S'
    WGS__1984_UTM__ZONE__25_N='WGS_1984_UTM_Zone_25N'
    WGS__1984_UTM__ZONE__25_S='WGS_1984_UTM_Zone_25S'
    WGS__1984_UTM__ZONE__26_N='WGS_1984_UTM_Zone_26N'
    WGS__1984_UTM__ZONE__26_S='WGS_1984_UTM_Zone_26S'
    WGS__1984_UTM__ZONE__27_N='WGS_1984_UTM_Zone_27N'
    WGS__1984_UTM__ZONE__27_S='WGS_1984_UTM_Zone_27S'
    WGS__1984_UTM__ZONE__28_N='WGS_1984_UTM_Zone_28N'
    WGS__1984_UTM__ZONE__28_S='WGS_1984_UTM_Zone_28S'
    WGS__1984_UTM__ZONE__29_N='WGS_1984_UTM_Zone_29N'
    WGS__1984_UTM__ZONE__29_S='WGS_1984_UTM_Zone_29S'
    WGS__1984_UTM__ZONE__2_N='WGS_1984_UTM_Zone_2N'
    WGS__1984_UTM__ZONE__2_S='WGS_1984_UTM_Zone_2S'
    WGS__1984_UTM__ZONE__30_N='WGS_1984_UTM_Zone_30N'
    WGS__1984_UTM__ZONE__30_S='WGS_1984_UTM_Zone_30S'
    WGS__1984_UTM__ZONE__31_N='WGS_1984_UTM_Zone_31N'
    WGS__1984_UTM__ZONE__31_S='WGS_1984_UTM_Zone_31S'
    WGS__1984_UTM__ZONE__32_N='WGS_1984_UTM_Zone_32N'
    WGS__1984_UTM__ZONE__32_S='WGS_1984_UTM_Zone_32S'
    WGS__1984_UTM__ZONE__33_N='WGS_1984_UTM_Zone_33N'
    WGS__1984_UTM__ZONE__33_S='WGS_1984_UTM_Zone_33S'
    WGS__1984_UTM__ZONE__34_N='WGS_1984_UTM_Zone_34N'
    WGS__1984_UTM__ZONE__34_S='WGS_1984_UTM_Zone_34S'
    WGS__1984_UTM__ZONE__35_N='WGS_1984_UTM_Zone_35N'
    WGS__1984_UTM__ZONE__35_S='WGS_1984_UTM_Zone_35S'
    WGS__1984_UTM__ZONE__36_N='WGS_1984_UTM_Zone_36N'
    WGS__1984_UTM__ZONE__36_S='WGS_1984_UTM_Zone_36S'
    WGS__1984_UTM__ZONE__37_N='WGS_1984_UTM_Zone_37N'
    WGS__1984_UTM__ZONE__37_S='WGS_1984_UTM_Zone_37S'
    WGS__1984_UTM__ZONE__38_N='WGS_1984_UTM_Zone_38N'
    WGS__1984_UTM__ZONE__38_S='WGS_1984_UTM_Zone_38S'
    WGS__1984_UTM__ZONE__39_N='WGS_1984_UTM_Zone_39N'
    WGS__1984_UTM__ZONE__39_S='WGS_1984_UTM_Zone_39S'
    WGS__1984_UTM__ZONE__3_N='WGS_1984_UTM_Zone_3N'
    WGS__1984_UTM__ZONE__3_S='WGS_1984_UTM_Zone_3S'
    WGS__1984_UTM__ZONE__40_N='WGS_1984_UTM_Zone_40N'
    WGS__1984_UTM__ZONE__40_S='WGS_1984_UTM_Zone_40S'
    WGS__1984_UTM__ZONE__41_N='WGS_1984_UTM_Zone_41N'
    WGS__1984_UTM__ZONE__41_S='WGS_1984_UTM_Zone_41S'
    WGS__1984_UTM__ZONE__42_N='WGS_1984_UTM_Zone_42N'
    WGS__1984_UTM__ZONE__42_S='WGS_1984_UTM_Zone_42S'
    WGS__1984_UTM__ZONE__43_N='WGS_1984_UTM_Zone_43N'
    WGS__1984_UTM__ZONE__43_S='WGS_1984_UTM_Zone_43S'
    WGS__1984_UTM__ZONE__44_N='WGS_1984_UTM_Zone_44N'
    WGS__1984_UTM__ZONE__44_S='WGS_1984_UTM_Zone_44S'
    WGS__1984_UTM__ZONE__45_N='WGS_1984_UTM_Zone_45N'
    WGS__1984_UTM__ZONE__45_S='WGS_1984_UTM_Zone_45S'
    WGS__1984_UTM__ZONE__46_N='WGS_1984_UTM_Zone_46N'
    WGS__1984_UTM__ZONE__46_S='WGS_1984_UTM_Zone_46S'
    WGS__1984_UTM__ZONE__47_N='WGS_1984_UTM_Zone_47N'
    WGS__1984_UTM__ZONE__47_S='WGS_1984_UTM_Zone_47S'
    WGS__1984_UTM__ZONE__48_N='WGS_1984_UTM_Zone_48N'
    WGS__1984_UTM__ZONE__48_S='WGS_1984_UTM_Zone_48S'
    WGS__1984_UTM__ZONE__49_N='WGS_1984_UTM_Zone_49N'
    WGS__1984_UTM__ZONE__49_S='WGS_1984_UTM_Zone_49S'
    WGS__1984_UTM__ZONE__4_N='WGS_1984_UTM_Zone_4N'
    WGS__1984_UTM__ZONE__4_S='WGS_1984_UTM_Zone_4S'
    WGS__1984_UTM__ZONE__50_N='WGS_1984_UTM_Zone_50N'
    WGS__1984_UTM__ZONE__50_S='WGS_1984_UTM_Zone_50S'
    WGS__1984_UTM__ZONE__51_N='WGS_1984_UTM_Zone_51N'
    WGS__1984_UTM__ZONE__51_S='WGS_1984_UTM_Zone_51S'
    WGS__1984_UTM__ZONE__52_N='WGS_1984_UTM_Zone_52N'
    WGS__1984_UTM__ZONE__52_S='WGS_1984_UTM_Zone_52S'
    WGS__1984_UTM__ZONE__53_N='WGS_1984_UTM_Zone_53N'
    WGS__1984_UTM__ZONE__53_S='WGS_1984_UTM_Zone_53S'
    WGS__1984_UTM__ZONE__54_N='WGS_1984_UTM_Zone_54N'
    WGS__1984_UTM__ZONE__54_S='WGS_1984_UTM_Zone_54S'
    WGS__1984_UTM__ZONE__55_N='WGS_1984_UTM_Zone_55N'
    WGS__1984_UTM__ZONE__55_S='WGS_1984_UTM_Zone_55S'
    WGS__1984_UTM__ZONE__56_N='WGS_1984_UTM_Zone_56N'
    WGS__1984_UTM__ZONE__56_S='WGS_1984_UTM_Zone_56S'
    WGS__1984_UTM__ZONE__57_N='WGS_1984_UTM_Zone_57N'
    WGS__1984_UTM__ZONE__57_S='WGS_1984_UTM_Zone_57S'
    WGS__1984_UTM__ZONE__58_N='WGS_1984_UTM_Zone_58N'
    WGS__1984_UTM__ZONE__58_S='WGS_1984_UTM_Zone_58S'
    WGS__1984_UTM__ZONE__59_N='WGS_1984_UTM_Zone_59N'
    WGS__1984_UTM__ZONE__59_S='WGS_1984_UTM_Zone_59S'
    WGS__1984_UTM__ZONE__5_N='WGS_1984_UTM_Zone_5N'
    WGS__1984_UTM__ZONE__5_S='WGS_1984_UTM_Zone_5S'
    WGS__1984_UTM__ZONE__60_N='WGS_1984_UTM_Zone_60N'
    WGS__1984_UTM__ZONE__60_S='WGS_1984_UTM_Zone_60S'
    WGS__1984_UTM__ZONE__6_N='WGS_1984_UTM_Zone_6N'
    WGS__1984_UTM__ZONE__6_S='WGS_1984_UTM_Zone_6S'
    WGS__1984_UTM__ZONE__7_N='WGS_1984_UTM_Zone_7N'
    WGS__1984_UTM__ZONE__7_S='WGS_1984_UTM_Zone_7S'
    WGS__1984_UTM__ZONE__8_N='WGS_1984_UTM_Zone_8N'
    WGS__1984_UTM__ZONE__8_S='WGS_1984_UTM_Zone_8S'
    WGS__1984_UTM__ZONE__9_N='WGS_1984_UTM_Zone_9N'
    WGS__1984_UTM__ZONE__9_S='WGS_1984_UTM_Zone_9S'
    WORLD__AITOFF='World_Aitoff'
    WORLD__BEHRMANN='World_Behrmann'
    WORLD__BONNE='World_Bonne'
    WORLD__CRASTER__PARABOLIC='World_Craster_Parabolic'
    WORLD__CYLINDRICAL__EQUAL__AREA='World_Cylindrical_Equal_Area'
    WORLD__ECKERT_I='World_Eckert_I'
    WORLD__ECKERT_II='World_Eckert_II'
    WORLD__ECKERT_III='World_Eckert_III'
    WORLD__ECKERT_IV='World_Eckert_IV'
    WORLD__ECKERT_V='World_Eckert_V'
    WORLD__ECKERT_VI='World_Eckert_VI'
    WORLD__EQUIDISTANT__CONIC='World_Equidistant_Conic'
    WORLD__EQUIDISTANT__CYLINDRICAL='World_Equidistant_Cylindrical'
    WORLD__FLAT__POLAR__QUARTIC='World_Flat_Polar_Quartic'
    WORLD__GALL__STEREOGRAPHIC='World_Gall_Stereographic'
    WORLD__HAMMER__AITOFF='World_Hammer_Aitoff'
    WORLD__LOXIMUTHAL='World_Loximuthal'
    WORLD__MERCATOR='World_Mercator'
    WORLD__MILLER__CYLINDRICAL='World_Miller_Cylindrical'
    WORLD__MOLLWEIDE='World_Mollweide'
    WORLD__PLATE__CARREE='World_Plate_Carree'
    WORLD__POLYCONIC='World_Polyconic'
    WORLD__QUARTIC__AUTHALIC='World_Quartic_Authalic'
    WORLD__ROBINSON='World_Robinson'
    WORLD__SINUSOIDAL='World_Sinusoidal'
    SPHERE__AITOFF='Sphere_Aitoff'
    SPHERE__BEHRMANN='Sphere_Behrmann'
    SPHERE__BONNE='Sphere_Bonne'
    SPHERE__CRASTER__PARABOLIC='Sphere_Craster_Parabolic'
    SPHERE__CYLINDRICAL__EQUAL__AREA='Sphere_Cylindrical_Equal_Area'
    SPHERE__ECKERT_I='Sphere_Eckert_I'
    SPHERE__ECKERT_II='Sphere_Eckert_II'
    SPHERE__ECKERT_III='Sphere_Eckert_III'
    SPHERE__ECKERT_IV='Sphere_Eckert_IV'
    SPHERE__ECKERT_V='Sphere_Eckert_V'
    SPHERE__ECKERT_VI='Sphere_Eckert_VI'
    SPHERE__EQUIDISTANT__CONIC='Sphere_Equidistant_Conic'
    SPHERE__EQUIDISTANT__CYLINDRICAL='Sphere_Equidistant_Cylindrical'
    SPHERE__FLAT__POLAR__QUARTIC='Sphere_Flat_Polar_Quartic'
    SPHERE__GALL__STEREOGRAPHIC='Sphere_Gall_Stereographic'
    SPHERE__HAMMER__AITOFF='Sphere_Hammer_Aitoff'
    SPHERE__LOXIMUTHAL='Sphere_Loximuthal'
    SPHERE__MERCATOR='Sphere_Mercator'
    SPHERE__MILLER__CYLINDRICAL='Sphere_Miller_Cylindrical'
    SPHERE__MOLLWEIDE='Sphere_Mollweide'
    SPHERE__PLATE__CARREE='Sphere_Plate_Carree'
    SPHERE__POLYCONIC='Sphere_Polyconic'
    SPHERE__QUARTIC__AUTHALIC='Sphere_Quartic_Authalic'
    SPHERE__ROBINSON='Sphere_Robinson'
    SPHERE__SINUSOIDAL='Sphere_Sinusoidal'
    SPHERE__TIMES='Sphere_Times'
    SPHERE__VAN_DER__GRINTEN_I='Sphere_Van_der_Grinten_I'
    SPHERE__VERTICAL__PERSPECTIVE='Sphere_Vertical_Perspective'
    SPHERE__WINKEL_I='Sphere_Winkel_I'
    SPHERE__WINKEL_II='Sphere_Winkel_II'
    SPHERE__WINKEL__TRIPEL_NGS='Sphere_Winkel_Tripel_NGS'
    THE__WORLD__FROM__SPACE='The_World_From_Space'
    WORLD__TIMES='World_Times'
    WORLD__VAN_DER__GRINTEN_I='World_Van_der_Grinten_I'
    WORLD__VERTICAL__PERSPECTIVE='World_Vertical_Perspective'
    WORLD__WINKEL_I='World_Winkel_I'
    WORLD__WINKEL_II='World_Winkel_II'
    WORLD__WINKEL__TRIPEL_NGS='World_Winkel_Tripel_NGS'


class lengthUnits(str, Enum):
    METER='meter'
    NANOMETER='nanometer'
    MICROMETER='micrometer'
    MICRON='micron'
    MILLIMETER='millimeter'
    CENTIMETER='centimeter'
    DECIMETER='decimeter'
    DEKAMETER='dekameter'
    HECTOMETER='hectometer'
    KILOMETER='kilometer'
    MEGAMETER='megameter'
    ANGSTROM='angstrom'
    INCH='inch'
    FOOT_US='Foot_US'
    FOOT='foot'
    FOOT__GOLD__COAST='Foot_Gold_Coast'
    FATHOM='fathom'
    NAUTICAL_MILE='nauticalMile'
    YARD='yard'
    YARD__INDIAN='Yard_Indian'
    LINK__CLARKE='Link_Clarke'
    YARD__SEARS='Yard_Sears'
    MILE='mile'


class orderType(str, Enum):
    ALLOW_FIRST='allowFirst'
    DENY_FIRST='denyFirst'


class otherUnitType(str, Enum):
    ACRE='acre'
    AMPERE='ampere'
    AMPERE_PER_METER='amperePerMeter'
    AMPERE_PER_METER_SQUARED='amperePerMeterSquared'
    AMPERE_PER_SQUARE_METER='amperePerSquareMeter'
    ARE='are'
    ATMOSPHERE='atmosphere'
    BAR='bar'
    BECQUEREL='becquerel'
    BRITISH_THERMAL_UNIT='britishThermalUnit'
    BUSHEL='bushel'
    BUSHEL_PER_ACRE='bushelPerAcre'
    BUSHELS_PER_ACRE='bushelsPerAcre'
    CALORIE='calorie'
    CANDELA='candela'
    CANDELA_PER_METER_SQUARED='candelaPerMeterSquared'
    CANDELA_PER_SQUARE_METER='candelaPerSquareMeter'
    CELSIUS='celsius'
    CENTIMETER_CUBED='centimeterCubed'
    CENTIMETER_PER_SECOND='centimeterPerSecond'
    CENTIMETER_PER_YEAR='centimeterPerYear'
    CENTIMETER_SQUARED='centimeterSquared'
    CENTIMETERS_PER_SECOND='centimetersPerSecond'
    CENTISECOND='centisecond'
    COULOMB='coulomb'
    CUBIC_CENTIMETERS_PER_CUBIC_CENTIMETERS='cubicCentimetersPerCubicCentimeters'
    CUBIC_FEET_PER_SECOND='cubicFeetPerSecond'
    CUBIC_INCH='cubicInch'
    CUBIC_METER='cubicMeter'
    CUBIC_METER_PER_KILOGRAM='cubicMeterPerKilogram'
    CUBIC_METERS_PER_SECOND='cubicMetersPerSecond'
    CUBIC_MICROMETERS_PER_GRAM='cubicMicrometersPerGram'
    DECIBAR='decibar'
    DECISECOND='decisecond'
    DEKASECOND='dekasecond'
    DIMENSIONLESS='dimensionless'
    EQUIVALENT_PER_LITER='equivalentPerLiter'
    FAHRENHEIT='fahrenheit'
    FARAD='farad'
    FEET_PER_DAY='feetPerDay'
    FEET_PER_HOUR='feetPerHour'
    FEET_PER_SECOND='feetPerSecond'
    FEET_SQUARED_PER_DAY='feetSquaredPerDay'
    FOOT_CUBED_PER_SECOND='footCubedPerSecond'
    FOOT_PER_DAY='footPerDay'
    FOOT_PER_HOUR='footPerHour'
    FOOT_PER_SECOND='footPerSecond'
    FOOT_POUND='footPound'
    FOOT_SQUARED='footSquared'
    FOOT_SQUARED_PER_DAY='footSquaredPerDay'
    GALLON='gallon'
    GRAM_PER_CENTIMETER_CUBED='gramPerCentimeterCubed'
    GRAM_PER_CENTIMETER_SQUARED_PER_SECOND='gramPerCentimeterSquaredPerSecond'
    GRAM_PER_DAY_PER_HECTARE='gramPerDayPerHectare'
    GRAM_PER_DAY_PER_LITER='gramPerDayPerLiter'
    GRAM_PER_GRAM='gramPerGram'
    GRAM_PER_LITER='gramPerLiter'
    GRAM_PER_METER_SQUARED='gramPerMeterSquared'
    GRAM_PER_METER_SQUARED_PER_DAY='gramPerMeterSquaredPerDay'
    GRAM_PER_METER_SQUARED_PER_YEAR='gramPerMeterSquaredPerYear'
    GRAM_PER_MILLILITER='gramPerMilliliter'
    GRAM_PER_YEAR='gramPerYear'
    GRAM_PERCENTIMETER_SQUARED='gramPercentimeterSquared'
    GRAMS_PER_CENTIMETER_SQUARED_PER_SECOND='gramsPerCentimeterSquaredPerSecond'
    GRAMS_PER_CUBIC_CENTIMETER='gramsPerCubicCentimeter'
    GRAMS_PER_GRAM='gramsPerGram'
    GRAMS_PER_HECTARE_PER_DAY='gramsPerHectarePerDay'
    GRAMS_PER_LITER='gramsPerLiter'
    GRAMS_PER_LITER_PER_DAY='gramsPerLiterPerDay'
    GRAMS_PER_METER_SQUARED_PER_YEAR='gramsPerMeterSquaredPerYear'
    GRAMS_PER_MILLILITER='gramsPerMilliliter'
    GRAMS_PER_SQUARE_METER='gramsPerSquareMeter'
    GRAMS_PER_YEAR='gramsPerYear'
    GRAY='gray'
    HECTARE='hectare'
    HECTOPASCAL='hectopascal'
    HECTOSECOND='hectosecond'
    HENRY='henry'
    HERTZ='hertz'
    HOUR='hour'
    INCH_CUBED='inchCubed'
    INCH_PER_HOUR='inchPerHour'
    INVERSE_CENTIMETER='inverseCentimeter'
    INVERSE_METER='inverseMeter'
    JOULE='joule'
    KATAL='katal'
    KELVIN='kelvin'
    KILOGRAM_PER_CUBIC_METER='kilogramPerCubicMeter'
    KILOGRAM_PER_HECTARE='kilogramPerHectare'
    KILOGRAM_PER_HECTARE_PER_YEAR='kilogramPerHectarePerYear'
    KILOGRAM_PER_METER_CUBED='kilogramPerMeterCubed'
    KILOGRAM_PER_METER_SQUARED='kilogramPerMeterSquared'
    KILOGRAM_PER_METER_SQUARED_PER_DAY='kilogramPerMeterSquaredPerDay'
    KILOGRAM_PER_METER_SQUARED_PER_SECOND='kilogramPerMeterSquaredPerSecond'
    KILOGRAM_PER_METER_SQUARED_PER_YEAR='kilogramPerMeterSquaredPerYear'
    KILOGRAM_PER_SECOND='kilogramPerSecond'
    KILOGRAMS_PER_HECTARE='kilogramsPerHectare'
    KILOGRAMS_PER_HECTARE_PER_YEAR='kilogramsPerHectarePerYear'
    KILOGRAMS_PER_METER_SQUARED_PER_SECOND='kilogramsPerMeterSquaredPerSecond'
    KILOGRAMS_PER_METER_SQUARED_PER_YEAR='kilogramsPerMeterSquaredPerYear'
    KILOGRAMS_PER_SECOND='kilogramsPerSecond'
    KILOGRAMS_PER_SQUARE_METER='kilogramsPerSquareMeter'
    KILOHERTZ='kilohertz'
    KILOLITER='kiloliter'
    KILOMETER_PER_HOUR='kilometerPerHour'
    KILOMETER_SQUARED='kilometerSquared'
    KILOMETERS_PER_HOUR='kilometersPerHour'
    KILOPASCAL='kilopascal'
    KILOSECOND='kilosecond'
    KILOVOLT='kilovolt'
    KILOWATT='kilowatt'
    KILOWATT_PER_METER_SQUARED='kilowattPerMeterSquared'
    KNOT='knot'
    KNOTS='knots'
    LANGLEY='langley'
    LANGLEY_PER_DAY='langleyPerDay'
    LITER='liter'
    LITER_PER_HECTARE='literPerHectare'
    LITER_PER_LITER='literPerLiter'
    LITER_PER_METER_SQUARED='literPerMeterSquared'
    LITER_PER_SECOND='literPerSecond'
    LITERS_PER_HECTARE='litersPerHectare'
    LITERS_PER_SECOND='litersPerSecond'
    LITERS_PER_SQUARE_METER='litersPerSquareMeter'
    LUMEN='lumen'
    LUX='lux'
    MEGAGRAM_PER_METER_CUBED='megagramPerMeterCubed'
    MEGAHERTZ='megahertz'
    MEGAJOULE_PER_METER_SQUARED_PER_DAY='megajoulePerMeterSquaredPerDay'
    MEGAPASCAL='megapascal'
    MEGASECOND='megasecond'
    MEGAVOLT='megavolt'
    MEGAWATT='megawatt'
    METER_CUBED='meterCubed'
    METER_CUBED_PER_HECTARE='meterCubedPerHectare'
    METER_CUBED_PER_KILOGRAM='meterCubedPerKilogram'
    METER_CUBED_PER_METER_CUBED='meterCubedPerMeterCubed'
    METER_CUBED_PER_METER_SQUARED='meterCubedPerMeterSquared'
    METER_CUBED_PER_SECOND='meterCubedPerSecond'
    METER_PER_DAY='meterPerDay'
    METER_PER_GRAM='meterPerGram'
    METER_PER_SECOND='meterPerSecond'
    METER_PER_SECOND_SQUARED='meterPerSecondSquared'
    METER_SQUARED='meterSquared'
    METER_SQUARED_PER_DAY='meterSquaredPerDay'
    METER_SQUARED_PER_HECTARE='meterSquaredPerHectare'
    METER_SQUARED_PER_KILOGRAM='meterSquaredPerKilogram'
    METER_SQUARED_PER_SECOND='meterSquaredPerSecond'
    METERS_PER_DAY='metersPerDay'
    METERS_PER_GRAM='metersPerGram'
    METERS_PER_SECOND='metersPerSecond'
    METERS_PER_SECOND_SQUARED='metersPerSecondSquared'
    METERS_SQUARED_PER_DAY='metersSquaredPerDay'
    METERS_SQUARED_PER_SECOND='metersSquaredPerSecond'
    MICROEQUIVALENT_PER_LITER='microequivalentPerLiter'
    MICROGRAM_PER_GRAM='microgramPerGram'
    MICROGRAM_PER_GRAM_PER_DAY='microgramPerGramPerDay'
    MICROGRAM_PER_GRAM_PER_HOUR='microgramPerGramPerHour'
    MICROGRAM_PER_GRAM_PER_WEEK='microgramPerGramPerWeek'
    MICROGRAM_PER_LITER='microgramPerLiter'
    MICROGRAMS_PER_GRAM='microgramsPerGram'
    MICROGRAMS_PER_LITER='microgramsPerLiter'
    MICROLITER='microliter'
    MICROLITER_PER_LITER='microliterPerLiter'
    MICROMETER_CUBED_PER_GRAM='micrometerCubedPerGram'
    MICROMOLE_PER_CENTIMETER_SQUARED_PER_SECOND='micromolePerCentimeterSquaredPerSecond'
    MICROMOLE_PER_GRAM='micromolePerGram'
    MICROMOLE_PER_GRAM_PER_DAY='micromolePerGramPerDay'
    MICROMOLE_PER_GRAM_PER_HOUR='micromolePerGramPerHour'
    MICROMOLE_PER_GRAM_PER_SECOND='micromolePerGramPerSecond'
    MICROMOLE_PER_KILOGRAM='micromolePerKilogram'
    MICROMOLE_PER_LITER='micromolePerLiter'
    MICROMOLE_PER_METER_SQUARED_PER_SECOND='micromolePerMeterSquaredPerSecond'
    MICROMOLE_PER_MOLE='micromolePerMole'
    MICROSECOND='microsecond'
    MICROWATT_PER_CENTIMETER_SQUARED_PER_NANOMETER='microwattPerCentimeterSquaredPerNanometer'
    MICROWATT_PER_CENTIMETER_SQUARED_PER_NANOMETER_PER_STERADIAN='microwattPerCentimeterSquaredPerNanometerPerSteradian'
    MICROWATT_PER_CENTIMETER_SQUARED_PER_STERADIAN='microwattPerCentimeterSquaredPerSteradian'
    MILE_PER_HOUR='milePerHour'
    MILE_PER_MINUTE='milePerMinute'
    MILE_PER_SECOND='milePerSecond'
    MILE_SQUARED='mileSquared'
    MILES_PER_HOUR='milesPerHour'
    MILES_PER_MINUTE='milesPerMinute'
    MILES_PER_SECOND='milesPerSecond'
    MILLI_GRAMS_PER_MILLI_LITER='milliGramsPerMilliLiter'
    MILLIBAR='millibar'
    MILLIEQUIVALENT_PER_LITER='milliequivalentPerLiter'
    MILLIGRAM_PER_KILOGRAM='milligramPerKilogram'
    MILLIGRAM_PER_LITER='milligramPerLiter'
    MILLIGRAM_PER_METER_CUBED='milligramPerMeterCubed'
    MILLIGRAM_PER_METER_CUBED_PER_DAY='milligramPerMeterCubedPerDay'
    MILLIGRAM_PER_METER_SQUARED='milligramPerMeterSquared'
    MILLIGRAM_PER_METER_SQUARED_PER_DAY='milligramPerMeterSquaredPerDay'
    MILLIGRAM_PER_MILLILITER='milligramPerMilliliter'
    MILLIGRAMS_PER_CUBIC_METER='milligramsPerCubicMeter'
    MILLIGRAMS_PER_LITER='milligramsPerLiter'
    MILLIGRAMS_PER_SQUARE_METER='milligramsPerSquareMeter'
    MILLIHERTZ='millihertz'
    MILLILITER='milliliter'
    MILLILITER_PER_LITER='milliliterPerLiter'
    MILLIMETER_PER_DAY='millimeterPerDay'
    MILLIMETER_PER_SECOND='millimeterPerSecond'
    MILLIMETER_SQUARED='millimeterSquared'
    MILLIMETERS_PER_SECOND='millimetersPerSecond'
    MILLIMOLE_PER_GRAM='millimolePerGram'
    MILLIMOLE_PER_KILOGRAM='millimolePerKilogram'
    MILLIMOLE_PER_LITER='millimolePerLiter'
    MILLIMOLE_PER_METER_CUBED='millimolePerMeterCubed'
    MILLIMOLE_PER_MOLE='millimolePerMole'
    MILLIMOLES_PER_GRAM='millimolesPerGram'
    MILLISECOND='millisecond'
    MILLIVOLT='millivolt'
    MILLIWATT='milliwatt'
    MINUTE='minute'
    MOLALITY='molality'
    MOLARITY='molarity'
    MOLE='mole'
    MOLE_PER_CUBIC_METER='molePerCubicMeter'
    MOLE_PER_GRAM='molePerGram'
    MOLE_PER_KILOGRAM='molePerKilogram'
    MOLE_PER_KILOGRAM_1='molePerKilogram'
    MOLE_PER_KILOGRAM_PER_SECOND='molePerKilogramPerSecond'
    MOLE_PER_LITER='molePerLiter'
    MOLE_PER_METER_CUBED='molePerMeterCubed'
    MOLE_PER_METER_SQUARED_PER_SECOND='molePerMeterSquaredPerSecond'
    MOLE_PER_MOLE='molePerMole'
    MOLES_PER_GRAM='molesPerGram'
    MOLES_PER_KILOGRAM='molesPerKilogram'
    MOLES_PER_KILOGRAM_PER_SECOND='molesPerKilogramPerSecond'
    NANOGRAM_PER_GRAM='nanogramPerGram'
    NANOGRAM_PER_GRAM_PER_HOUR='nanogramPerGramPerHour'
    NANOLITER_PER_LITER='nanoliterPerLiter'
    NANOMOLE_PER_GRAM_PER_DAY='nanomolePerGramPerDay'
    NANOMOLE_PER_GRAM_PER_HOUR='nanomolePerGramPerHour'
    NANOMOLE_PER_GRAM_PER_SECOND='nanomolePerGramPerSecond'
    NANOMOLE_PER_KILOGRAM='nanomolePerKilogram'
    NANOMOLE_PER_LITER='nanomolePerLiter'
    NANOMOLE_PER_MOLE='nanomolePerMole'
    NANOMOLES_PER_GRAM_PER_SECOND='nanomolesPerGramPerSecond'
    NANOSECOND='nanosecond'
    NEWTON='newton'
    NOMINAL_DAY='nominalDay'
    NOMINAL_HOUR='nominalHour'
    NOMINAL_LEAP_YEAR='nominalLeapYear'
    NOMINAL_MINUTE='nominalMinute'
    NOMINAL_WEEK='nominalWeek'
    NOMINAL_YEAR='nominalYear'
    NUMBER='number'
    NUMBER_PER_GRAM='numberPerGram'
    NUMBER_PER_HECTARE='numberPerHectare'
    NUMBER_PER_KILOMETER_SQUARED='numberPerKilometerSquared'
    NUMBER_PER_LITER='numberPerLiter'
    NUMBER_PER_METER_CUBED='numberPerMeterCubed'
    NUMBER_PER_METER_SQUARED='numberPerMeterSquared'
    NUMBER_PER_MILLILITER='numberPerMilliliter'
    OHM='ohm'
    OHM_METER='ohmMeter'
    PASCAL='pascal'
    PERCENT='percent'
    PERMIL='permil'
    PINT='pint'
    POUND_PER_ACRE='poundPerAcre'
    POUND_PER_INCH_SQUARED='poundPerInchSquared'
    POUNDS_PER_SQUARE_INCH='poundsPerSquareInch'
    QUART='quart'
    SECOND='second'
    SIEMEN='siemen'
    SIEMENS='siemens'
    SIEMENS_PER_CENTIMETER='siemensPerCentimeter'
    SIEMENS_PER_METER='siemensPerMeter'
    SIEVERT='sievert'
    SQUARE_CENTIMETERS='squareCentimeters'
    SQUARE_FOOT='squareFoot'
    SQUARE_KILOMETERS='squareKilometers'
    SQUARE_METER='squareMeter'
    SQUARE_METER_PER_KILOGRAM='squareMeterPerKilogram'
    SQUARE_MILE='squareMile'
    SQUARE_MILLIMETERS='squareMillimeters'
    SQUARE_YARD='squareYard'
    TESLA='tesla'
    TONNE_PER_HECTARE='tonnePerHectare'
    TONNE_PER_YEAR='tonnePerYear'
    TONNES_PER_YEAR='tonnesPerYear'
    VOLT='volt'
    WATT='watt'
    WATT_PER_METER_SQUARED='wattPerMeterSquared'
    WATT_PER_METER_SQUARED_PER_NANOMETER='wattPerMeterSquaredPerNanometer'
    WATT_PER_METER_SQUARED_PER_NANOMETER_PER_STERADIAN='wattPerMeterSquaredPerNanometerPerSteradian'
    WATT_PER_METER_SQUARED_PER_STERADIAN='wattPerMeterSquaredPerSteradian'
    WAVE_NUMBER='waveNumber'
    WEBER='weber'
    YARD_PER_SECOND='yardPerSecond'
    YARD_SQUARED='yardSquared'
    YARDS_PER_SECOND='yardsPerSecond'


class parentOccurencesType(str, Enum):
    _0='0'
    _1='1'


class parentOccurencesType58(str, Enum):
    _0='0'
    _1='1'


class parentOccurencesType63(str, Enum):
    _0='0'
    _1='1'


class permissionType(str, Enum):
    READ='read'
    WRITE='write'
    CHANGE_PERMISSION='changePermission'
    ALL='all'


class pointInPixelType(str, Enum):
    UPPER_LEFT='upperLeft'
    UPPER_RIGHT='upperRight'
    LOWER_RIGHT='lowerRight'
    LOWER_LEFT='lowerLeft'
    CENTER='center'


class pointInPixelType67(str, Enum):
    UPPER_LEFT='upperLeft'
    UPPER_RIGHT='upperRight'
    LOWER_RIGHT='lowerRight'
    LOWER_LEFT='lowerLeft'
    CENTER='center'


class rasterOriginType(str, Enum):
    UPPER_LEFT='Upper Left'
    LOWER_LEFT='Lower Left'
    UPPER_RIGHT='Upper Right'
    LOWER_RIGHT='Lower Right'


class relationshipTypeType(str, Enum):
    IDENTIFYING='identifying'
    NONIDENTIFYING='non-identifying'


class relationshipTypeType56(str, Enum):
    IDENTIFYING='identifying'
    NONIDENTIFYING='non-identifying'


class relationshipTypeType61(str, Enum):
    IDENTIFYING='identifying'
    NONIDENTIFYING='non-identifying'


class rowColumnOrientationType(str, Enum):
    COLUMN='column'
    ROW='row'


class eml(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('packageId', 'xs:string', 0, 0, {'use': 'required'}),
        MemberSpec_('system', 'res:SystemType', 0, 0, {'use': 'required'}),
        MemberSpec_('scope', 'res:ScopeType', 0, 1, {'use': 'optional'}),
        MemberSpec_('lang', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('access', 'AccessType', 0, 1, {'minOccurs': '0', 'name': 'access', 'type': 'AccessType'}, None),
        MemberSpec_('dataset', 'DatasetType', 0, 0, {'name': 'dataset', 'type': 'DatasetType'}, 1),
        MemberSpec_('citation', 'CitationType', 0, 0, {'name': 'citation', 'type': 'CitationType'}, 1),
        MemberSpec_('software', 'SoftwareType', 0, 0, {'name': 'software', 'type': 'SoftwareType'}, 1),
        MemberSpec_('protocol', 'ProtocolType', 0, 0, {'name': 'protocol', 'type': 'ProtocolType'}, 1),
        MemberSpec_('annotations', 'annotationsType', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'annotations', 'type': 'annotationsType'}, None),
        MemberSpec_('additionalMetadata', 'additionalMetadataType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'additionalMetadata', 'type': 'additionalMetadataType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, packageId=None, system=None, scope='system', lang=None, access=None, dataset=None, citation=None, software=None, protocol=None, annotations=None, additionalMetadata=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.packageId = _cast(None, packageId)
        self.packageId_nsprefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.scope = _cast(None, scope)
        self.scope_nsprefix_ = None
        self.lang = _cast(None, lang)
        self.lang_nsprefix_ = None
        self.access = access
        self.access_nsprefix_ = None
        self.dataset = dataset
        self.dataset_nsprefix_ = None
        self.citation = citation
        self.citation_nsprefix_ = None
        self.software = software
        self.software_nsprefix_ = None
        self.protocol = protocol
        self.protocol_nsprefix_ = None
        self.annotations = annotations
        self.annotations_nsprefix_ = None
        if additionalMetadata is None:
            self.additionalMetadata = []
        else:
            self.additionalMetadata = additionalMetadata
        self.additionalMetadata_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, eml)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if eml.subclass:
            return eml.subclass(*args_, **kwargs_)
        else:
            return eml(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_access(self):
        return self.access
    def set_access(self, access):
        self.access = access
    def get_dataset(self):
        return self.dataset
    def set_dataset(self, dataset):
        self.dataset = dataset
    def get_citation(self):
        return self.citation
    def set_citation(self, citation):
        self.citation = citation
    def get_software(self):
        return self.software
    def set_software(self, software):
        self.software = software
    def get_protocol(self):
        return self.protocol
    def set_protocol(self, protocol):
        self.protocol = protocol
    def get_annotations(self):
        return self.annotations
    def set_annotations(self, annotations):
        self.annotations = annotations
    def get_additionalMetadata(self):
        return self.additionalMetadata
    def set_additionalMetadata(self, additionalMetadata):
        self.additionalMetadata = additionalMetadata
    def add_additionalMetadata(self, value):
        self.additionalMetadata.append(value)
    def insert_additionalMetadata_at(self, index, value):
        self.additionalMetadata.insert(index, value)
    def replace_additionalMetadata_at(self, index, value):
        self.additionalMetadata[index] = value
    def get_packageId(self):
        return self.packageId
    def set_packageId(self, packageId):
        self.packageId = packageId
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_scope(self):
        return self.scope
    def set_scope(self, scope):
        self.scope = scope
    def get_lang(self):
        return self.lang
    def set_lang(self, lang):
        self.lang = lang
    def validate_SystemType(self, value):
        # Validate type res:SystemType, a restriction on xs:string.
        pass
    def validate_ScopeType(self, value):
        # Validate type res:ScopeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['system', 'document']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ScopeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.access is not None or
            self.dataset is not None or
            self.citation is not None or
            self.software is not None or
            self.protocol is not None or
            self.annotations is not None or
            self.additionalMetadata
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:acc="https://eml.ecoinformatics.org/access-2.2.0"  xmlns:ds="https://eml.ecoinformatics.org/dataset-2.2.0"  xmlns:cit="https://eml.ecoinformatics.org/literature-2.2.0"  xmlns:sw="https://eml.ecoinformatics.org/software-2.2.0"  xmlns:pro="https://eml.ecoinformatics.org/protocol-2.2.0"  xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='eml', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('eml')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'eml':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='eml')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='eml', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='eml'):
        if self.packageId is not None and 'packageId' not in already_processed:
            already_processed.add('packageId')
            outfile.write(' packageId=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.packageId), input_name='packageId')), ))
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
        if self.scope != "system" and 'scope' not in already_processed:
            already_processed.add('scope')
            outfile.write(' scope=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.scope), input_name='scope')), ))
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' xml:lang=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lang), input_name='lang')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:acc="https://eml.ecoinformatics.org/access-2.2.0"  xmlns:ds="https://eml.ecoinformatics.org/dataset-2.2.0"  xmlns:cit="https://eml.ecoinformatics.org/literature-2.2.0"  xmlns:sw="https://eml.ecoinformatics.org/software-2.2.0"  xmlns:pro="https://eml.ecoinformatics.org/protocol-2.2.0"  xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='eml', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.access is not None:
            namespaceprefix_ = self.access_nsprefix_ + ':' if (UseCapturedNS_ and self.access_nsprefix_) else ''
            self.access.export(outfile, level, namespaceprefix_, namespacedef_='', name_='access', pretty_print=pretty_print)
        if self.dataset is not None:
            namespaceprefix_ = self.dataset_nsprefix_ + ':' if (UseCapturedNS_ and self.dataset_nsprefix_) else ''
            self.dataset.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataset', pretty_print=pretty_print)
        if self.citation is not None:
            namespaceprefix_ = self.citation_nsprefix_ + ':' if (UseCapturedNS_ and self.citation_nsprefix_) else ''
            self.citation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='citation', pretty_print=pretty_print)
        if self.software is not None:
            namespaceprefix_ = self.software_nsprefix_ + ':' if (UseCapturedNS_ and self.software_nsprefix_) else ''
            self.software.export(outfile, level, namespaceprefix_, namespacedef_='', name_='software', pretty_print=pretty_print)
        if self.protocol is not None:
            namespaceprefix_ = self.protocol_nsprefix_ + ':' if (UseCapturedNS_ and self.protocol_nsprefix_) else ''
            self.protocol.export(outfile, level, namespaceprefix_, namespacedef_='', name_='protocol', pretty_print=pretty_print)
        if self.annotations is not None:
            namespaceprefix_ = self.annotations_nsprefix_ + ':' if (UseCapturedNS_ and self.annotations_nsprefix_) else ''
            self.annotations.export(outfile, level, namespaceprefix_, namespacedef_='', name_='annotations', pretty_print=pretty_print)
        for additionalMetadata_ in self.additionalMetadata:
            namespaceprefix_ = self.additionalMetadata_nsprefix_ + ':' if (UseCapturedNS_ and self.additionalMetadata_nsprefix_) else ''
            additionalMetadata_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='additionalMetadata', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('packageId', node)
        if value is not None and 'packageId' not in already_processed:
            already_processed.add('packageId')
            self.packageId = value
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
        value = find_attr_value_('scope', node)
        if value is not None and 'scope' not in already_processed:
            already_processed.add('scope')
            self.scope = value
            self.validate_ScopeType(self.scope)    # validate type ScopeType
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'access':
            obj_ = AccessType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.access = obj_
            obj_.original_tagname_ = 'access'
        elif nodeName_ == 'dataset':
            obj_ = DatasetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dataset = obj_
            obj_.original_tagname_ = 'dataset'
        elif nodeName_ == 'citation':
            obj_ = CitationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.citation = obj_
            obj_.original_tagname_ = 'citation'
        elif nodeName_ == 'software':
            obj_ = SoftwareType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.software = obj_
            obj_.original_tagname_ = 'software'
        elif nodeName_ == 'protocol':
            obj_ = ProtocolType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.protocol = obj_
            obj_.original_tagname_ = 'protocol'
        elif nodeName_ == 'annotations':
            obj_ = annotationsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.annotations = obj_
            obj_.original_tagname_ = 'annotations'
        elif nodeName_ == 'additionalMetadata':
            obj_ = additionalMetadataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.additionalMetadata.append(obj_)
            obj_.original_tagname_ = 'additionalMetadata'
# end class eml


class moduleDocs(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('moduleName', 'xs:string', 0, 0, {'form': 'qualified', 'name': 'moduleName', 'type': 'xs:string'}, None),
        MemberSpec_('moduleDescription', 'TextType', 0, 0, {'form': 'qualified', 'name': 'moduleDescription', 'type': 'TextType'}, None),
        MemberSpec_('recommendedUsage', 'xs:string', 0, 0, {'form': 'qualified', 'name': 'recommendedUsage', 'type': 'xs:string'}, None),
        MemberSpec_('standAlone', 'xs:string', 0, 0, {'form': 'qualified', 'name': 'standAlone', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, moduleName=None, moduleDescription=None, recommendedUsage=None, standAlone=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.moduleName = moduleName
        self.moduleName_nsprefix_ = None
        self.moduleDescription = moduleDescription
        self.moduleDescription_nsprefix_ = None
        self.recommendedUsage = recommendedUsage
        self.recommendedUsage_nsprefix_ = None
        self.standAlone = standAlone
        self.standAlone_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, moduleDocs)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if moduleDocs.subclass:
            return moduleDocs.subclass(*args_, **kwargs_)
        else:
            return moduleDocs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_moduleName(self):
        return self.moduleName
    def set_moduleName(self, moduleName):
        self.moduleName = moduleName
    def get_moduleDescription(self):
        return self.moduleDescription
    def set_moduleDescription(self, moduleDescription):
        self.moduleDescription = moduleDescription
    def get_recommendedUsage(self):
        return self.recommendedUsage
    def set_recommendedUsage(self, recommendedUsage):
        self.recommendedUsage = recommendedUsage
    def get_standAlone(self):
        return self.standAlone
    def set_standAlone(self, standAlone):
        self.standAlone = standAlone
    def hasContent_(self):
        if (
            self.moduleName is not None or
            self.moduleDescription is not None or
            self.recommendedUsage is not None or
            self.standAlone is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0"  xmlns:txt="https://eml.ecoinformatics.org/text-2.2.0" ', name_='moduleDocs', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('moduleDocs')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'moduleDocs':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='moduleDocs')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='moduleDocs', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='moduleDocs'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0"  xmlns:txt="https://eml.ecoinformatics.org/text-2.2.0" ', name_='moduleDocs', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.moduleName is not None:
            namespaceprefix_ = self.moduleName_nsprefix_ + ':' if (UseCapturedNS_ and self.moduleName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smoduleName>%s</%smoduleName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.moduleName), input_name='moduleName')), namespaceprefix_ , eol_))
        if self.moduleDescription is not None:
            namespaceprefix_ = self.moduleDescription_nsprefix_ + ':' if (UseCapturedNS_ and self.moduleDescription_nsprefix_) else ''
            self.moduleDescription.export(outfile, level, namespaceprefix_, namespacedef_='', name_='moduleDescription', pretty_print=pretty_print)
        if self.recommendedUsage is not None:
            namespaceprefix_ = self.recommendedUsage_nsprefix_ + ':' if (UseCapturedNS_ and self.recommendedUsage_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srecommendedUsage>%s</%srecommendedUsage>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.recommendedUsage), input_name='recommendedUsage')), namespaceprefix_ , eol_))
        if self.standAlone is not None:
            namespaceprefix_ = self.standAlone_nsprefix_ + ':' if (UseCapturedNS_ and self.standAlone_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstandAlone>%s</%sstandAlone>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.standAlone), input_name='standAlone')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'moduleName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'moduleName')
            value_ = self.gds_validate_string(value_, node, 'moduleName')
            self.moduleName = value_
            self.moduleName_nsprefix_ = child_.prefix
        elif nodeName_ == 'moduleDescription':
            obj_ = TextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.moduleDescription = obj_
            obj_.original_tagname_ = 'moduleDescription'
        elif nodeName_ == 'recommendedUsage':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'recommendedUsage')
            value_ = self.gds_validate_string(value_, node, 'recommendedUsage')
            self.recommendedUsage = value_
            self.recommendedUsage_nsprefix_ = child_.prefix
        elif nodeName_ == 'standAlone':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'standAlone')
            value_ = self.gds_validate_string(value_, node, 'standAlone')
            self.standAlone = value_
            self.standAlone_nsprefix_ = child_.prefix
# end class moduleDocs


class TextType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('lang', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('section', 'SectionType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'section', 'type': 'SectionType'}, 2),
        MemberSpec_('para', 'ParagraphType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'para', 'type': 'ParagraphType'}, 2),
        MemberSpec_('markdown', 'markdownType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'markdown', 'type': 'markdownType'}, 2),
        MemberSpec_('valueOf_', [], 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, lang=None, section=None, para=None, markdown=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.lang = _cast(None, lang)
        self.lang_nsprefix_ = None
        if section is None:
            self.section = []
        else:
            self.section = section
        self.section_nsprefix_ = None
        if para is None:
            self.para = []
        else:
            self.para = para
        self.para_nsprefix_ = None
        if markdown is None:
            self.markdown = []
        else:
            self.markdown = markdown
        self.markdown_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TextType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TextType.subclass:
            return TextType.subclass(*args_, **kwargs_)
        else:
            return TextType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_section(self):
        return self.section
    def set_section(self, section):
        self.section = section
    def add_section(self, value):
        self.section.append(value)
    def insert_section_at(self, index, value):
        self.section.insert(index, value)
    def replace_section_at(self, index, value):
        self.section[index] = value
    def get_para(self):
        return self.para
    def set_para(self, para):
        self.para = para
    def add_para(self, value):
        self.para.append(value)
    def insert_para_at(self, index, value):
        self.para.insert(index, value)
    def replace_para_at(self, index, value):
        self.para[index] = value
    def get_markdown(self):
        return self.markdown
    def set_markdown(self, markdown):
        self.markdown = markdown
    def add_markdown(self, value):
        self.markdown.append(value)
    def insert_markdown_at(self, index, value):
        self.markdown.insert(index, value)
    def replace_markdown_at(self, index, value):
        self.markdown[index] = value
    def get_lang(self):
        return self.lang
    def set_lang(self, lang):
        self.lang = lang
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.section or
            self.para or
            self.markdown or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='TextType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TextType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TextType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TextType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            # self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TextType', pretty_print=pretty_print)
            # ajout fromsubclass_=True pour eviter la redondance de la balise !!! je ne sais trop pourquoi ???
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TextType', fromsubclass_=True, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TextType'):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' xml:lang=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lang), input_name='lang')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='TextType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for section_ in self.section:
            namespaceprefix_ = self.section_nsprefix_ + ':' if (UseCapturedNS_ and self.section_nsprefix_) else ''
            section_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='section', pretty_print=pretty_print)
        for para_ in self.para:
            namespaceprefix_ = self.para_nsprefix_ + ':' if (UseCapturedNS_ and self.para_nsprefix_) else ''
            para_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='para', pretty_print=pretty_print)
        for markdown_ in self.markdown:
            namespaceprefix_ = self.markdown_nsprefix_ + ':' if (UseCapturedNS_ and self.markdown_nsprefix_) else ''
            markdown_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='markdown', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'section':
            obj_ = SectionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'section', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_section'):
              self.add_section(obj_.value)
            elif hasattr(self, 'set_section'):
              self.set_section(obj_.value)
        elif nodeName_ == 'para':
            obj_ = ParagraphType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'para', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_para'):
              self.add_para(obj_.value)
            elif hasattr(self, 'set_para'):
              self.set_para(obj_.value)
        elif nodeName_ == 'markdown':
            obj_ = markdownType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'markdown', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_markdown'):
              self.add_markdown(obj_.value)
            elif hasattr(self, 'set_markdown'):
              self.set_markdown(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class TextType


class ParagraphType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('lang', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('value', 'i18nString', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'value', 'type': 'i18nString'}, 3),
        MemberSpec_('itemizedlist', 'ListType', 1, 1, {'name': 'itemizedlist', 'type': 'ListType'}, 3),
        MemberSpec_('orderedlist', 'ListType', 1, 1, {'name': 'orderedlist', 'type': 'ListType'}, 3),
        MemberSpec_('emphasis', 'emphasisType', 1, 1, {'name': 'emphasis', 'type': 'emphasisType'}, 3),
        MemberSpec_('subscript', 'SubSuperScriptType', 1, 1, {'name': 'subscript', 'type': 'SubSuperScriptType'}, 3),
        MemberSpec_('superscript', 'SubSuperScriptType', 1, 1, {'name': 'superscript', 'type': 'SubSuperScriptType'}, 3),
        MemberSpec_('literalLayout', 'literalLayoutType', 1, 1, {'name': 'literalLayout', 'type': 'literalLayoutType'}, 3),
        MemberSpec_('ulink', 'ulinkType', 1, 1, {'minOccurs': '0', 'name': 'ulink', 'type': 'ulinkType'}, 3),
        MemberSpec_('valueOf_', [], 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, lang=None, value=None, itemizedlist=None, orderedlist=None, emphasis=None, subscript=None, superscript=None, literalLayout=None, ulink=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.lang = _cast(None, lang)
        self.lang_nsprefix_ = None
        if value is None:
            self.value = []
        else:
            self.value = value
        self.value_nsprefix_ = None
        if itemizedlist is None:
            self.itemizedlist = []
        else:
            self.itemizedlist = itemizedlist
        self.itemizedlist_nsprefix_ = None
        if orderedlist is None:
            self.orderedlist = []
        else:
            self.orderedlist = orderedlist
        self.orderedlist_nsprefix_ = None
        if emphasis is None:
            self.emphasis = []
        else:
            self.emphasis = emphasis
        self.emphasis_nsprefix_ = None
        if subscript is None:
            self.subscript = []
        else:
            self.subscript = subscript
        self.subscript_nsprefix_ = None
        if superscript is None:
            self.superscript = []
        else:
            self.superscript = superscript
        self.superscript_nsprefix_ = None
        if literalLayout is None:
            self.literalLayout = []
        else:
            self.literalLayout = literalLayout
        self.literalLayout_nsprefix_ = None
        if ulink is None:
            self.ulink = []
        else:
            self.ulink = ulink
        self.ulink_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ParagraphType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ParagraphType.subclass:
            return ParagraphType.subclass(*args_, **kwargs_)
        else:
            return ParagraphType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def add_value(self, value):
        self.value.append(value)
    def insert_value_at(self, index, value):
        self.value.insert(index, value)
    def replace_value_at(self, index, value):
        self.value[index] = value
    def get_itemizedlist(self):
        return self.itemizedlist
    def set_itemizedlist(self, itemizedlist):
        self.itemizedlist = itemizedlist
    def add_itemizedlist(self, value):
        self.itemizedlist.append(value)
    def insert_itemizedlist_at(self, index, value):
        self.itemizedlist.insert(index, value)
    def replace_itemizedlist_at(self, index, value):
        self.itemizedlist[index] = value
    def get_orderedlist(self):
        return self.orderedlist
    def set_orderedlist(self, orderedlist):
        self.orderedlist = orderedlist
    def add_orderedlist(self, value):
        self.orderedlist.append(value)
    def insert_orderedlist_at(self, index, value):
        self.orderedlist.insert(index, value)
    def replace_orderedlist_at(self, index, value):
        self.orderedlist[index] = value
    def get_emphasis(self):
        return self.emphasis
    def set_emphasis(self, emphasis):
        self.emphasis = emphasis
    def add_emphasis(self, value):
        self.emphasis.append(value)
    def insert_emphasis_at(self, index, value):
        self.emphasis.insert(index, value)
    def replace_emphasis_at(self, index, value):
        self.emphasis[index] = value
    def get_subscript(self):
        return self.subscript
    def set_subscript(self, subscript):
        self.subscript = subscript
    def add_subscript(self, value):
        self.subscript.append(value)
    def insert_subscript_at(self, index, value):
        self.subscript.insert(index, value)
    def replace_subscript_at(self, index, value):
        self.subscript[index] = value
    def get_superscript(self):
        return self.superscript
    def set_superscript(self, superscript):
        self.superscript = superscript
    def add_superscript(self, value):
        self.superscript.append(value)
    def insert_superscript_at(self, index, value):
        self.superscript.insert(index, value)
    def replace_superscript_at(self, index, value):
        self.superscript[index] = value
    def get_literalLayout(self):
        return self.literalLayout
    def set_literalLayout(self, literalLayout):
        self.literalLayout = literalLayout
    def add_literalLayout(self, value):
        self.literalLayout.append(value)
    def insert_literalLayout_at(self, index, value):
        self.literalLayout.insert(index, value)
    def replace_literalLayout_at(self, index, value):
        self.literalLayout[index] = value
    def get_ulink(self):
        return self.ulink
    def set_ulink(self, ulink):
        self.ulink = ulink
    def add_ulink(self, value):
        self.ulink.append(value)
    def insert_ulink_at(self, index, value):
        self.ulink.insert(index, value)
    def replace_ulink_at(self, index, value):
        self.ulink[index] = value
    def get_lang(self):
        return self.lang
    def set_lang(self, lang):
        self.lang = lang
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.value or
            self.itemizedlist or
            self.orderedlist or
            self.emphasis or
            self.subscript or
            self.superscript or
            self.literalLayout or
            self.ulink or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='ParagraphType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ParagraphType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ParagraphType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ParagraphType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ParagraphType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ParagraphType'):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' xml:lang=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lang), input_name='lang')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='ParagraphType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for value_ in self.value:
            namespaceprefix_ = self.value_nsprefix_ + ':' if (UseCapturedNS_ and self.value_nsprefix_) else ''
            value_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='value', pretty_print=pretty_print)
        for itemizedlist_ in self.itemizedlist:
            namespaceprefix_ = self.itemizedlist_nsprefix_ + ':' if (UseCapturedNS_ and self.itemizedlist_nsprefix_) else ''
            itemizedlist_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='itemizedlist', pretty_print=pretty_print)
        for orderedlist_ in self.orderedlist:
            namespaceprefix_ = self.orderedlist_nsprefix_ + ':' if (UseCapturedNS_ and self.orderedlist_nsprefix_) else ''
            orderedlist_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='orderedlist', pretty_print=pretty_print)
        for emphasis_ in self.emphasis:
            namespaceprefix_ = self.emphasis_nsprefix_ + ':' if (UseCapturedNS_ and self.emphasis_nsprefix_) else ''
            emphasis_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='emphasis', pretty_print=pretty_print)
        for subscript_ in self.subscript:
            namespaceprefix_ = self.subscript_nsprefix_ + ':' if (UseCapturedNS_ and self.subscript_nsprefix_) else ''
            subscript_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subscript', pretty_print=pretty_print)
        for superscript_ in self.superscript:
            namespaceprefix_ = self.superscript_nsprefix_ + ':' if (UseCapturedNS_ and self.superscript_nsprefix_) else ''
            superscript_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='superscript', pretty_print=pretty_print)
        for literalLayout_ in self.literalLayout:
            namespaceprefix_ = self.literalLayout_nsprefix_ + ':' if (UseCapturedNS_ and self.literalLayout_nsprefix_) else ''
            literalLayout_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='literalLayout', pretty_print=pretty_print)
        for ulink_ in self.ulink:
            namespaceprefix_ = self.ulink_nsprefix_ + ':' if (UseCapturedNS_ and self.ulink_nsprefix_) else ''
            ulink_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ulink', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'value':
            obj_ = i18nString.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'value', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_value'):
              self.add_value(obj_.value)
            elif hasattr(self, 'set_value'):
              self.set_value(obj_.value)
        elif nodeName_ == 'itemizedlist':
            obj_ = ListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'itemizedlist', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_itemizedlist'):
              self.add_itemizedlist(obj_.value)
            elif hasattr(self, 'set_itemizedlist'):
              self.set_itemizedlist(obj_.value)
        elif nodeName_ == 'orderedlist':
            obj_ = ListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'orderedlist', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_orderedlist'):
              self.add_orderedlist(obj_.value)
            elif hasattr(self, 'set_orderedlist'):
              self.set_orderedlist(obj_.value)
        elif nodeName_ == 'emphasis':
            obj_ = emphasisType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'emphasis', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_emphasis'):
              self.add_emphasis(obj_.value)
            elif hasattr(self, 'set_emphasis'):
              self.set_emphasis(obj_.value)
        elif nodeName_ == 'subscript':
            obj_ = SubSuperScriptType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'subscript', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_subscript'):
              self.add_subscript(obj_.value)
            elif hasattr(self, 'set_subscript'):
              self.set_subscript(obj_.value)
        elif nodeName_ == 'superscript':
            obj_ = SubSuperScriptType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'superscript', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_superscript'):
              self.add_superscript(obj_.value)
            elif hasattr(self, 'set_superscript'):
              self.set_superscript(obj_.value)
        elif nodeName_ == 'literalLayout':
            obj_ = literalLayoutType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'literalLayout', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_literalLayout'):
              self.add_literalLayout(obj_.value)
            elif hasattr(self, 'set_literalLayout'):
              self.set_literalLayout(obj_.value)
        elif nodeName_ == 'ulink':
            obj_ = ulinkType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'ulink', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_ulink'):
              self.add_ulink(obj_.value)
            elif hasattr(self, 'set_ulink'):
              self.set_ulink(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class ParagraphType


class SectionType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('lang', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('title', 'i18nString', 0, 1, {'minOccurs': '0', 'name': 'title', 'type': 'i18nString'}, None),
        MemberSpec_('para', 'ParagraphType', 1, 0, {'name': 'para', 'type': 'ParagraphType'}, 4),
        MemberSpec_('section', 'SectionType', 1, 0, {'name': 'section', 'type': 'SectionType'}, 4),
    ]
    subclass = None
    superclass = None
    def __init__(self, lang=None, title=None, para=None, section=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.lang = _cast(None, lang)
        self.lang_nsprefix_ = None
        self.title = title
        self.title_nsprefix_ = None
        if para is None:
            self.para = []
        else:
            self.para = para
        self.para_nsprefix_ = None
        if section is None:
            self.section = []
        else:
            self.section = section
        self.section_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SectionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SectionType.subclass:
            return SectionType.subclass(*args_, **kwargs_)
        else:
            return SectionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_para(self):
        return self.para
    def set_para(self, para):
        self.para = para
    def add_para(self, value):
        self.para.append(value)
    def insert_para_at(self, index, value):
        self.para.insert(index, value)
    def replace_para_at(self, index, value):
        self.para[index] = value
    def get_section(self):
        return self.section
    def set_section(self, section):
        self.section = section
    def add_section(self, value):
        self.section.append(value)
    def insert_section_at(self, index, value):
        self.section.insert(index, value)
    def replace_section_at(self, index, value):
        self.section[index] = value
    def get_lang(self):
        return self.lang
    def set_lang(self, lang):
        self.lang = lang
    def hasContent_(self):
        if (
            self.title is not None or
            self.para or
            self.section
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='SectionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SectionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SectionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SectionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SectionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SectionType'):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' xml:lang=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lang), input_name='lang')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='SectionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.title is not None:
            namespaceprefix_ = self.title_nsprefix_ + ':' if (UseCapturedNS_ and self.title_nsprefix_) else ''
            self.title.export(outfile, level, namespaceprefix_, namespacedef_='', name_='title', pretty_print=pretty_print)
        for para_ in self.para:
            namespaceprefix_ = self.para_nsprefix_ + ':' if (UseCapturedNS_ and self.para_nsprefix_) else ''
            para_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='para', pretty_print=pretty_print)
        for section_ in self.section:
            namespaceprefix_ = self.section_nsprefix_ + ':' if (UseCapturedNS_ and self.section_nsprefix_) else ''
            section_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='section', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'title':
            obj_ = i18nString.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.title = obj_
            obj_.original_tagname_ = 'title'
        elif nodeName_ == 'para':
            obj_ = ParagraphType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.para.append(obj_)
            obj_.original_tagname_ = 'para'
        elif nodeName_ == 'section':
            obj_ = SectionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.section.append(obj_)
            obj_.original_tagname_ = 'section'
# end class SectionType


class ListType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('listitem', 'listitemType', 1, 0, {'maxOccurs': 'unbounded', 'minOccurs': '1', 'name': 'listitem', 'type': 'listitemType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, listitem=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if listitem is None:
            self.listitem = []
        else:
            self.listitem = listitem
        self.listitem_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ListType.subclass:
            return ListType.subclass(*args_, **kwargs_)
        else:
            return ListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_listitem(self):
        return self.listitem
    def set_listitem(self, listitem):
        self.listitem = listitem
    def add_listitem(self, value):
        self.listitem.append(value)
    def insert_listitem_at(self, index, value):
        self.listitem.insert(index, value)
    def replace_listitem_at(self, index, value):
        self.listitem[index] = value
    def hasContent_(self):
        if (
            self.listitem
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='ListType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ListType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ListType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ListType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ListType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='ListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for listitem_ in self.listitem:
            namespaceprefix_ = self.listitem_nsprefix_ + ':' if (UseCapturedNS_ and self.listitem_nsprefix_) else ''
            listitem_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='listitem', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'listitem':
            obj_ = listitemType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.listitem.append(obj_)
            obj_.original_tagname_ = 'listitem'
# end class ListType


class SubSuperScriptType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('lang', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('value', 'i18nString', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'value', 'type': 'i18nString'}, 5),
        MemberSpec_('subscript', 'SubSuperScriptType', 1, 1, {'name': 'subscript', 'type': 'SubSuperScriptType'}, 5),
        MemberSpec_('superscript', 'SubSuperScriptType', 1, 1, {'name': 'superscript', 'type': 'SubSuperScriptType'}, 5),
        MemberSpec_('valueOf_', [], 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, lang=None, value=None, subscript=None, superscript=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.lang = _cast(None, lang)
        self.lang_nsprefix_ = None
        if value is None:
            self.value = []
        else:
            self.value = value
        self.value_nsprefix_ = None
        if subscript is None:
            self.subscript = []
        else:
            self.subscript = subscript
        self.subscript_nsprefix_ = None
        if superscript is None:
            self.superscript = []
        else:
            self.superscript = superscript
        self.superscript_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SubSuperScriptType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SubSuperScriptType.subclass:
            return SubSuperScriptType.subclass(*args_, **kwargs_)
        else:
            return SubSuperScriptType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def add_value(self, value):
        self.value.append(value)
    def insert_value_at(self, index, value):
        self.value.insert(index, value)
    def replace_value_at(self, index, value):
        self.value[index] = value
    def get_subscript(self):
        return self.subscript
    def set_subscript(self, subscript):
        self.subscript = subscript
    def add_subscript(self, value):
        self.subscript.append(value)
    def insert_subscript_at(self, index, value):
        self.subscript.insert(index, value)
    def replace_subscript_at(self, index, value):
        self.subscript[index] = value
    def get_superscript(self):
        return self.superscript
    def set_superscript(self, superscript):
        self.superscript = superscript
    def add_superscript(self, value):
        self.superscript.append(value)
    def insert_superscript_at(self, index, value):
        self.superscript.insert(index, value)
    def replace_superscript_at(self, index, value):
        self.superscript[index] = value
    def get_lang(self):
        return self.lang
    def set_lang(self, lang):
        self.lang = lang
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.value or
            self.subscript or
            self.superscript or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='SubSuperScriptType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SubSuperScriptType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SubSuperScriptType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SubSuperScriptType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SubSuperScriptType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SubSuperScriptType'):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' xml:lang=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lang), input_name='lang')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='SubSuperScriptType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for value_ in self.value:
            namespaceprefix_ = self.value_nsprefix_ + ':' if (UseCapturedNS_ and self.value_nsprefix_) else ''
            value_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='value', pretty_print=pretty_print)
        for subscript_ in self.subscript:
            namespaceprefix_ = self.subscript_nsprefix_ + ':' if (UseCapturedNS_ and self.subscript_nsprefix_) else ''
            subscript_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subscript', pretty_print=pretty_print)
        for superscript_ in self.superscript:
            namespaceprefix_ = self.superscript_nsprefix_ + ':' if (UseCapturedNS_ and self.superscript_nsprefix_) else ''
            superscript_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='superscript', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'value':
            obj_ = i18nString.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'value', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_value'):
              self.add_value(obj_.value)
            elif hasattr(self, 'set_value'):
              self.set_value(obj_.value)
        elif nodeName_ == 'subscript':
            obj_ = SubSuperScriptType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'subscript', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_subscript'):
              self.add_subscript(obj_.value)
            elif hasattr(self, 'set_subscript'):
              self.set_subscript(obj_.value)
        elif nodeName_ == 'superscript':
            obj_ = SubSuperScriptType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'superscript', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_superscript'):
              self.add_superscript(obj_.value)
            elif hasattr(self, 'set_superscript'):
              self.set_superscript(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class SubSuperScriptType


class i18nString(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('lang', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, lang=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.lang = _cast(None, lang)
        self.lang_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, i18nString)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if i18nString.subclass:
            return i18nString.subclass(*args_, **kwargs_)
        else:
            return i18nString(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_lang(self):
        return self.lang
    def set_lang(self, lang):
        self.lang = lang
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='i18nString', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('i18nString')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'i18nString':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='i18nString')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='i18nString', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='i18nString'):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' xml:lang=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lang), input_name='lang')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='i18nString', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class i18nString


class DistributionType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'IDType', 0, 1, {'use': 'optional'}),
        MemberSpec_('system', 'SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('scope', 'ScopeType', 0, 1, {'use': 'optional'}),
        MemberSpec_('online', 'OnlineType', 0, 0, {'name': 'online', 'type': 'OnlineType'}, 7),
        MemberSpec_('offline', 'OfflineType', 0, 0, {'name': 'offline', 'type': 'OfflineType'}, 7),
        MemberSpec_('inline', 'InlineType', 0, 0, {'name': 'inline', 'type': 'InlineType'}, 7),
        MemberSpec_('references', 'referencesType2', 0, 0, {'name': 'references', 'type': 'referencesType2'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, system=None, scope='document', online=None, offline=None, inline=None, references=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.scope = _cast(None, scope)
        self.scope_nsprefix_ = None
        self.online = online
        self.online_nsprefix_ = None
        self.offline = offline
        self.offline_nsprefix_ = None
        self.inline = inline
        self.inline_nsprefix_ = None
        self.references = references
        self.references_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DistributionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DistributionType.subclass:
            return DistributionType.subclass(*args_, **kwargs_)
        else:
            return DistributionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_online(self):
        return self.online
    def set_online(self, online):
        self.online = online
    def get_offline(self):
        return self.offline
    def set_offline(self, offline):
        self.offline = offline
    def get_inline(self):
        return self.inline
    def set_inline(self, inline):
        self.inline = inline
    def get_references(self):
        return self.references
    def set_references(self, references):
        self.references = references
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_scope(self):
        return self.scope
    def set_scope(self, scope):
        self.scope = scope
    def validate_IDType(self, value):
        # Validate type IDType, a restriction on xs:string.
        pass
    def validate_SystemType(self, value):
        # Validate type SystemType, a restriction on xs:string.
        pass
    def validate_ScopeType(self, value):
        # Validate type ScopeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['system', 'document']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ScopeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.online is not None or
            self.offline is not None or
            self.inline is not None or
            self.references is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='DistributionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DistributionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DistributionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DistributionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DistributionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DistributionType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
        if self.scope != "document" and 'scope' not in already_processed:
            already_processed.add('scope')
            outfile.write(' scope=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.scope), input_name='scope')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='DistributionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.online is not None:
            namespaceprefix_ = self.online_nsprefix_ + ':' if (UseCapturedNS_ and self.online_nsprefix_) else ''
            self.online.export(outfile, level, namespaceprefix_, namespacedef_='', name_='online', pretty_print=pretty_print)
        if self.offline is not None:
            namespaceprefix_ = self.offline_nsprefix_ + ':' if (UseCapturedNS_ and self.offline_nsprefix_) else ''
            self.offline.export(outfile, level, namespaceprefix_, namespacedef_='', name_='offline', pretty_print=pretty_print)
        if self.inline is not None:
            namespaceprefix_ = self.inline_nsprefix_ + ':' if (UseCapturedNS_ and self.inline_nsprefix_) else ''
            self.inline.export(outfile, level, namespaceprefix_, namespacedef_='', name_='inline', pretty_print=pretty_print)
        if self.references is not None:
            namespaceprefix_ = self.references_nsprefix_ + ':' if (UseCapturedNS_ and self.references_nsprefix_) else ''
            self.references.export(outfile, level, namespaceprefix_, namespacedef_='', name_='references', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_IDType(self.id)    # validate type IDType
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
        value = find_attr_value_('scope', node)
        if value is not None and 'scope' not in already_processed:
            already_processed.add('scope')
            self.scope = value
            self.validate_ScopeType(self.scope)    # validate type ScopeType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'online':
            obj_ = OnlineType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.online = obj_
            obj_.original_tagname_ = 'online'
        elif nodeName_ == 'offline':
            obj_ = OfflineType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.offline = obj_
            obj_.original_tagname_ = 'offline'
        elif nodeName_ == 'inline':
            obj_ = InlineType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.inline = obj_
            obj_.original_tagname_ = 'inline'
        elif nodeName_ == 'references':
            obj_ = referencesType2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.references = obj_
            obj_.original_tagname_ = 'references'
# end class DistributionType


class ConnectionDefinitionType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'IDType', 0, 1, {'use': 'optional'}),
        MemberSpec_('system', 'SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('scope', 'ScopeType', 0, 1, {'use': 'optional'}),
        MemberSpec_('schemeName', 'schemeNameType', 0, 0, {'name': 'schemeName', 'type': 'schemeNameType'}, 8),
        MemberSpec_('description', 'TextType', 0, 0, {'name': 'description', 'type': 'TextType'}, 8),
        MemberSpec_('parameterDefinition', 'parameterDefinitionType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'parameterDefinition', 'type': 'parameterDefinitionType'}, 8),
        MemberSpec_('references', 'referencesType3', 0, 0, {'name': 'references', 'type': 'referencesType3'}, 8),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, system=None, scope='document', schemeName=None, description=None, parameterDefinition=None, references=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.scope = _cast(None, scope)
        self.scope_nsprefix_ = None
        self.schemeName = schemeName
        self.schemeName_nsprefix_ = None
        self.description = description
        self.description_nsprefix_ = None
        if parameterDefinition is None:
            self.parameterDefinition = []
        else:
            self.parameterDefinition = parameterDefinition
        self.parameterDefinition_nsprefix_ = None
        self.references = references
        self.references_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConnectionDefinitionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConnectionDefinitionType.subclass:
            return ConnectionDefinitionType.subclass(*args_, **kwargs_)
        else:
            return ConnectionDefinitionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_schemeName(self):
        return self.schemeName
    def set_schemeName(self, schemeName):
        self.schemeName = schemeName
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_parameterDefinition(self):
        return self.parameterDefinition
    def set_parameterDefinition(self, parameterDefinition):
        self.parameterDefinition = parameterDefinition
    def add_parameterDefinition(self, value):
        self.parameterDefinition.append(value)
    def insert_parameterDefinition_at(self, index, value):
        self.parameterDefinition.insert(index, value)
    def replace_parameterDefinition_at(self, index, value):
        self.parameterDefinition[index] = value
    def get_references(self):
        return self.references
    def set_references(self, references):
        self.references = references
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_scope(self):
        return self.scope
    def set_scope(self, scope):
        self.scope = scope
    def validate_IDType(self, value):
        # Validate type IDType, a restriction on xs:string.
        pass
    def validate_SystemType(self, value):
        # Validate type SystemType, a restriction on xs:string.
        pass
    def validate_ScopeType(self, value):
        # Validate type ScopeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['system', 'document']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ScopeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.schemeName is not None or
            self.description is not None or
            self.parameterDefinition or
            self.references is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0"  xmlns:txt="https://eml.ecoinformatics.org/text-2.2.0" ', name_='ConnectionDefinitionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ConnectionDefinitionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ConnectionDefinitionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ConnectionDefinitionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ConnectionDefinitionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ConnectionDefinitionType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
        if self.scope != "document" and 'scope' not in already_processed:
            already_processed.add('scope')
            outfile.write(' scope=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.scope), input_name='scope')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0"  xmlns:txt="https://eml.ecoinformatics.org/text-2.2.0" ', name_='ConnectionDefinitionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.schemeName is not None:
            namespaceprefix_ = self.schemeName_nsprefix_ + ':' if (UseCapturedNS_ and self.schemeName_nsprefix_) else ''
            self.schemeName.export(outfile, level, namespaceprefix_, namespacedef_='', name_='schemeName', pretty_print=pretty_print)
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            self.description.export(outfile, level, namespaceprefix_, namespacedef_='', name_='description', pretty_print=pretty_print)
        for parameterDefinition_ in self.parameterDefinition:
            namespaceprefix_ = self.parameterDefinition_nsprefix_ + ':' if (UseCapturedNS_ and self.parameterDefinition_nsprefix_) else ''
            parameterDefinition_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='parameterDefinition', pretty_print=pretty_print)
        if self.references is not None:
            namespaceprefix_ = self.references_nsprefix_ + ':' if (UseCapturedNS_ and self.references_nsprefix_) else ''
            self.references.export(outfile, level, namespaceprefix_, namespacedef_='', name_='references', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_IDType(self.id)    # validate type IDType
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
        value = find_attr_value_('scope', node)
        if value is not None and 'scope' not in already_processed:
            already_processed.add('scope')
            self.scope = value
            self.validate_ScopeType(self.scope)    # validate type ScopeType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'schemeName':
            obj_ = schemeNameType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.schemeName = obj_
            obj_.original_tagname_ = 'schemeName'
        elif nodeName_ == 'description':
            obj_ = TextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.description = obj_
            obj_.original_tagname_ = 'description'
        elif nodeName_ == 'parameterDefinition':
            obj_ = parameterDefinitionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.parameterDefinition.append(obj_)
            obj_.original_tagname_ = 'parameterDefinition'
        elif nodeName_ == 'references':
            obj_ = referencesType3.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.references = obj_
            obj_.original_tagname_ = 'references'
# end class ConnectionDefinitionType


class InlineType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('__ANY__', '__ANY__', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'processContents': 'lax'}, None),
        MemberSpec_('valueOf_', [], 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InlineType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InlineType.subclass:
            return InlineType.subclass(*args_, **kwargs_)
        else:
            return InlineType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.anytypeobjs_ or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='InlineType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InlineType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'InlineType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InlineType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='InlineType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='InlineType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='InlineType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if not fromsubclass_:
            for obj_ in self.anytypeobjs_:
                showIndent(outfile, level, pretty_print)
                outfile.write(obj_)
                outfile.write('\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == '':
            obj_ = __ANY__.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class InlineType


class OfflineType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('mediumName', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'mediumName', 'type': 'xs:string'}, None),
        MemberSpec_('mediumDensity', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'mediumDensity', 'type': 'xs:string'}, None),
        MemberSpec_('mediumDensityUnits', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'mediumDensityUnits', 'type': 'xs:string'}, None),
        MemberSpec_('mediumVolume', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'mediumVolume', 'type': 'xs:string'}, None),
        MemberSpec_('mediumFormat', ['NonEmptyStringType', 'xs:string'], 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'mediumFormat', 'type': 'xs:string'}, None),
        MemberSpec_('mediumNote', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'mediumNote', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, mediumName=None, mediumDensity=None, mediumDensityUnits=None, mediumVolume=None, mediumFormat=None, mediumNote=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.mediumName = mediumName
        self.validate_NonEmptyStringType(self.mediumName)
        self.mediumName_nsprefix_ = None
        self.mediumDensity = mediumDensity
        self.validate_NonEmptyStringType(self.mediumDensity)
        self.mediumDensity_nsprefix_ = None
        self.mediumDensityUnits = mediumDensityUnits
        self.validate_NonEmptyStringType(self.mediumDensityUnits)
        self.mediumDensityUnits_nsprefix_ = None
        self.mediumVolume = mediumVolume
        self.validate_NonEmptyStringType(self.mediumVolume)
        self.mediumVolume_nsprefix_ = None
        if mediumFormat is None:
            self.mediumFormat = []
        else:
            self.mediumFormat = mediumFormat
        self.mediumFormat_nsprefix_ = None
        self.mediumNote = mediumNote
        self.validate_NonEmptyStringType(self.mediumNote)
        self.mediumNote_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OfflineType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OfflineType.subclass:
            return OfflineType.subclass(*args_, **kwargs_)
        else:
            return OfflineType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_mediumName(self):
        return self.mediumName
    def set_mediumName(self, mediumName):
        self.mediumName = mediumName
    def get_mediumDensity(self):
        return self.mediumDensity
    def set_mediumDensity(self, mediumDensity):
        self.mediumDensity = mediumDensity
    def get_mediumDensityUnits(self):
        return self.mediumDensityUnits
    def set_mediumDensityUnits(self, mediumDensityUnits):
        self.mediumDensityUnits = mediumDensityUnits
    def get_mediumVolume(self):
        return self.mediumVolume
    def set_mediumVolume(self, mediumVolume):
        self.mediumVolume = mediumVolume
    def get_mediumFormat(self):
        return self.mediumFormat
    def set_mediumFormat(self, mediumFormat):
        self.mediumFormat = mediumFormat
    def add_mediumFormat(self, value):
        self.mediumFormat.append(value)
    def insert_mediumFormat_at(self, index, value):
        self.mediumFormat.insert(index, value)
    def replace_mediumFormat_at(self, index, value):
        self.mediumFormat[index] = value
    def get_mediumNote(self):
        return self.mediumNote
    def set_mediumNote(self, mediumNote):
        self.mediumNote = mediumNote
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def hasContent_(self):
        if (
            self.mediumName is not None or
            self.mediumDensity is not None or
            self.mediumDensityUnits is not None or
            self.mediumVolume is not None or
            self.mediumFormat or
            self.mediumNote is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='OfflineType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OfflineType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'OfflineType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OfflineType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='OfflineType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='OfflineType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='OfflineType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.mediumName is not None:
            namespaceprefix_ = self.mediumName_nsprefix_ + ':' if (UseCapturedNS_ and self.mediumName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smediumName>%s</%smediumName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.mediumName), input_name='mediumName')), namespaceprefix_ , eol_))
        if self.mediumDensity is not None:
            namespaceprefix_ = self.mediumDensity_nsprefix_ + ':' if (UseCapturedNS_ and self.mediumDensity_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smediumDensity>%s</%smediumDensity>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.mediumDensity), input_name='mediumDensity')), namespaceprefix_ , eol_))
        if self.mediumDensityUnits is not None:
            namespaceprefix_ = self.mediumDensityUnits_nsprefix_ + ':' if (UseCapturedNS_ and self.mediumDensityUnits_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smediumDensityUnits>%s</%smediumDensityUnits>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.mediumDensityUnits), input_name='mediumDensityUnits')), namespaceprefix_ , eol_))
        if self.mediumVolume is not None:
            namespaceprefix_ = self.mediumVolume_nsprefix_ + ':' if (UseCapturedNS_ and self.mediumVolume_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smediumVolume>%s</%smediumVolume>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.mediumVolume), input_name='mediumVolume')), namespaceprefix_ , eol_))
        for mediumFormat_ in self.mediumFormat:
            namespaceprefix_ = self.mediumFormat_nsprefix_ + ':' if (UseCapturedNS_ and self.mediumFormat_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smediumFormat>%s</%smediumFormat>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(mediumFormat_), input_name='mediumFormat')), namespaceprefix_ , eol_))
        if self.mediumNote is not None:
            namespaceprefix_ = self.mediumNote_nsprefix_ + ':' if (UseCapturedNS_ and self.mediumNote_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smediumNote>%s</%smediumNote>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.mediumNote), input_name='mediumNote')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'mediumName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'mediumName')
            value_ = self.gds_validate_string(value_, node, 'mediumName')
            self.mediumName = value_
            self.mediumName_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.mediumName)
        elif nodeName_ == 'mediumDensity':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'mediumDensity')
            value_ = self.gds_validate_string(value_, node, 'mediumDensity')
            self.mediumDensity = value_
            self.mediumDensity_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.mediumDensity)
        elif nodeName_ == 'mediumDensityUnits':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'mediumDensityUnits')
            value_ = self.gds_validate_string(value_, node, 'mediumDensityUnits')
            self.mediumDensityUnits = value_
            self.mediumDensityUnits_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.mediumDensityUnits)
        elif nodeName_ == 'mediumVolume':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'mediumVolume')
            value_ = self.gds_validate_string(value_, node, 'mediumVolume')
            self.mediumVolume = value_
            self.mediumVolume_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.mediumVolume)
        elif nodeName_ == 'mediumFormat':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'mediumFormat')
            value_ = self.gds_validate_string(value_, node, 'mediumFormat')
            self.mediumFormat.append(value_)
            self.mediumFormat_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.mediumFormat[-1])
        elif nodeName_ == 'mediumNote':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'mediumNote')
            value_ = self.gds_validate_string(value_, node, 'mediumNote')
            self.mediumNote = value_
            self.mediumNote_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.mediumNote)
# end class OfflineType


class OnlineType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('onlineDescription', 'i18nNonEmptyStringType', 0, 1, {'minOccurs': '0', 'name': 'onlineDescription', 'type': 'i18nNonEmptyStringType'}, None),
        MemberSpec_('url', 'UrlType', 0, 0, {'name': 'url', 'type': 'UrlType'}, 9),
        MemberSpec_('connection', 'ConnectionType', 0, 0, {'name': 'connection', 'type': 'ConnectionType'}, 9),
        MemberSpec_('connectionDefinition', 'ConnectionDefinitionType', 0, 0, {'name': 'connectionDefinition', 'type': 'ConnectionDefinitionType'}, 9),
    ]
    subclass = None
    superclass = None
    def __init__(self, onlineDescription=None, url=None, connection=None, connectionDefinition=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.onlineDescription = onlineDescription
        self.onlineDescription_nsprefix_ = None
        self.url = url
        self.url_nsprefix_ = None
        self.connection = connection
        self.connection_nsprefix_ = None
        self.connectionDefinition = connectionDefinition
        self.connectionDefinition_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OnlineType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OnlineType.subclass:
            return OnlineType.subclass(*args_, **kwargs_)
        else:
            return OnlineType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_onlineDescription(self):
        return self.onlineDescription
    def set_onlineDescription(self, onlineDescription):
        self.onlineDescription = onlineDescription
    def get_url(self):
        return self.url
    def set_url(self, url):
        self.url = url
    def get_connection(self):
        return self.connection
    def set_connection(self, connection):
        self.connection = connection
    def get_connectionDefinition(self):
        return self.connectionDefinition
    def set_connectionDefinition(self, connectionDefinition):
        self.connectionDefinition = connectionDefinition
    def hasContent_(self):
        if (
            self.onlineDescription is not None or
            self.url is not None or
            self.connection is not None or
            self.connectionDefinition is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='OnlineType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OnlineType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'OnlineType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OnlineType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='OnlineType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='OnlineType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='OnlineType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.onlineDescription is not None:
            namespaceprefix_ = self.onlineDescription_nsprefix_ + ':' if (UseCapturedNS_ and self.onlineDescription_nsprefix_) else ''
            self.onlineDescription.export(outfile, level, namespaceprefix_, namespacedef_='', name_='onlineDescription', pretty_print=pretty_print)
        if self.url is not None:
            namespaceprefix_ = self.url_nsprefix_ + ':' if (UseCapturedNS_ and self.url_nsprefix_) else ''
            self.url.export(outfile, level, namespaceprefix_, namespacedef_='', name_='url', pretty_print=pretty_print)
        if self.connection is not None:
            namespaceprefix_ = self.connection_nsprefix_ + ':' if (UseCapturedNS_ and self.connection_nsprefix_) else ''
            self.connection.export(outfile, level, namespaceprefix_, namespacedef_='', name_='connection', pretty_print=pretty_print)
        if self.connectionDefinition is not None:
            namespaceprefix_ = self.connectionDefinition_nsprefix_ + ':' if (UseCapturedNS_ and self.connectionDefinition_nsprefix_) else ''
            self.connectionDefinition.export(outfile, level, namespaceprefix_, namespacedef_='', name_='connectionDefinition', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'onlineDescription':
            class_obj_ = self.get_class_obj_(child_, i18nNonEmptyStringType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.onlineDescription = obj_
            obj_.original_tagname_ = 'onlineDescription'
        elif nodeName_ == 'url':
            obj_ = UrlType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.url = obj_
            obj_.original_tagname_ = 'url'
        elif nodeName_ == 'connection':
            obj_ = ConnectionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.connection = obj_
            obj_.original_tagname_ = 'connection'
        elif nodeName_ == 'connectionDefinition':
            obj_ = ConnectionDefinitionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.connectionDefinition = obj_
            obj_.original_tagname_ = 'connectionDefinition'
# end class OnlineType


class UrlType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('function', 'FunctionType', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:anyURI', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, function='download', valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.function = _cast(None, function)
        self.function_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UrlType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UrlType.subclass:
            return UrlType.subclass(*args_, **kwargs_)
        else:
            return UrlType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_function(self):
        return self.function
    def set_function(self, function):
        self.function = function
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_FunctionType(self, value):
        # Validate type FunctionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['download', 'information']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on FunctionType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='UrlType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('UrlType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'UrlType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UrlType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='UrlType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='UrlType'):
        if self.function != "download" and 'function' not in already_processed:
            already_processed.add('function')
            outfile.write(' function=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.function), input_name='function')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='UrlType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('function', node)
        if value is not None and 'function' not in already_processed:
            already_processed.add('function')
            self.function = value
            self.validate_FunctionType(self.function)    # validate type FunctionType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class UrlType


class ConnectionType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'IDType', 0, 1, {'use': 'optional'}),
        MemberSpec_('system', 'SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('scope', 'ScopeType', 0, 1, {'use': 'optional'}),
        MemberSpec_('connectionDefinition', 'ConnectionDefinitionType', 0, 0, {'name': 'connectionDefinition', 'type': 'ConnectionDefinitionType'}, 10),
        MemberSpec_('parameter', 'parameterType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'parameter', 'type': 'parameterType'}, 10),
        MemberSpec_('references', 'referencesType4', 0, 0, {'name': 'references', 'type': 'referencesType4'}, 10),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, system=None, scope='document', connectionDefinition=None, parameter=None, references=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.scope = _cast(None, scope)
        self.scope_nsprefix_ = None
        self.connectionDefinition = connectionDefinition
        self.connectionDefinition_nsprefix_ = None
        if parameter is None:
            self.parameter = []
        else:
            self.parameter = parameter
        self.parameter_nsprefix_ = None
        self.references = references
        self.references_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConnectionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConnectionType.subclass:
            return ConnectionType.subclass(*args_, **kwargs_)
        else:
            return ConnectionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_connectionDefinition(self):
        return self.connectionDefinition
    def set_connectionDefinition(self, connectionDefinition):
        self.connectionDefinition = connectionDefinition
    def get_parameter(self):
        return self.parameter
    def set_parameter(self, parameter):
        self.parameter = parameter
    def add_parameter(self, value):
        self.parameter.append(value)
    def insert_parameter_at(self, index, value):
        self.parameter.insert(index, value)
    def replace_parameter_at(self, index, value):
        self.parameter[index] = value
    def get_references(self):
        return self.references
    def set_references(self, references):
        self.references = references
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_scope(self):
        return self.scope
    def set_scope(self, scope):
        self.scope = scope
    def validate_IDType(self, value):
        # Validate type IDType, a restriction on xs:string.
        pass
    def validate_SystemType(self, value):
        # Validate type SystemType, a restriction on xs:string.
        pass
    def validate_ScopeType(self, value):
        # Validate type ScopeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['system', 'document']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ScopeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.connectionDefinition is not None or
            self.parameter or
            self.references is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='ConnectionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ConnectionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ConnectionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ConnectionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ConnectionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ConnectionType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
        if self.scope != "document" and 'scope' not in already_processed:
            already_processed.add('scope')
            outfile.write(' scope=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.scope), input_name='scope')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='ConnectionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.connectionDefinition is not None:
            namespaceprefix_ = self.connectionDefinition_nsprefix_ + ':' if (UseCapturedNS_ and self.connectionDefinition_nsprefix_) else ''
            self.connectionDefinition.export(outfile, level, namespaceprefix_, namespacedef_='', name_='connectionDefinition', pretty_print=pretty_print)
        for parameter_ in self.parameter:
            namespaceprefix_ = self.parameter_nsprefix_ + ':' if (UseCapturedNS_ and self.parameter_nsprefix_) else ''
            parameter_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='parameter', pretty_print=pretty_print)
        if self.references is not None:
            namespaceprefix_ = self.references_nsprefix_ + ':' if (UseCapturedNS_ and self.references_nsprefix_) else ''
            self.references.export(outfile, level, namespaceprefix_, namespacedef_='', name_='references', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_IDType(self.id)    # validate type IDType
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
        value = find_attr_value_('scope', node)
        if value is not None and 'scope' not in already_processed:
            already_processed.add('scope')
            self.scope = value
            self.validate_ScopeType(self.scope)    # validate type ScopeType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'connectionDefinition':
            obj_ = ConnectionDefinitionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.connectionDefinition = obj_
            obj_.original_tagname_ = 'connectionDefinition'
        elif nodeName_ == 'parameter':
            obj_ = parameterType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.parameter.append(obj_)
            obj_.original_tagname_ = 'parameter'
        elif nodeName_ == 'references':
            obj_ = referencesType4.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.references = obj_
            obj_.original_tagname_ = 'references'
# end class ConnectionType


class i18nNonEmptyStringType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('lang', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('value', 'valueType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'value', 'type': 'valueType'}, None),
        MemberSpec_('valueOf_', [], 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, lang=None, value=None, valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.lang = _cast(None, lang)
        self.lang_nsprefix_ = None
        if value is None:
            self.value = []
        else:
            self.value = value
        self.value_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, i18nNonEmptyStringType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if i18nNonEmptyStringType.subclass:
            return i18nNonEmptyStringType.subclass(*args_, **kwargs_)
        else:
            return i18nNonEmptyStringType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def add_value(self, value):
        self.value.append(value)
    def insert_value_at(self, index, value):
        self.value.insert(index, value)
    def replace_value_at(self, index, value):
        self.value[index] = value
    def get_lang(self):
        return self.lang
    def set_lang(self, lang):
        self.lang = lang
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.value or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='i18nNonEmptyStringType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('i18nNonEmptyStringType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'i18nNonEmptyStringType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='i18nNonEmptyStringType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='i18nNonEmptyStringType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='i18nNonEmptyStringType'):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' xml:lang=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lang), input_name='lang')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='i18nNonEmptyStringType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for value_ in self.value:
            namespaceprefix_ = self.value_nsprefix_ + ':' if (UseCapturedNS_ and self.value_nsprefix_) else ''
            value_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='value', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'value':
            obj_ = valueType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'value', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_value'):
              self.add_value(obj_.value)
            elif hasattr(self, 'set_value'):
              self.set_value(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class i18nNonEmptyStringType


class LicenseType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('licenseName', ['NonEmptyStringType', 'xs:string'], 0, 0, {'minOccurs': '1', 'name': 'licenseName', 'type': 'xs:string'}, None),
        MemberSpec_('url', 'xs:anyURI', 0, 1, {'minOccurs': '0', 'name': 'url', 'type': 'xs:anyURI'}, None),
        MemberSpec_('identifier', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'identifier', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, licenseName=None, url=None, identifier=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.licenseName = licenseName
        self.validate_NonEmptyStringType(self.licenseName)
        self.licenseName_nsprefix_ = None
        self.url = url
        self.url_nsprefix_ = None
        self.identifier = identifier
        self.validate_NonEmptyStringType(self.identifier)
        self.identifier_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LicenseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LicenseType.subclass:
            return LicenseType.subclass(*args_, **kwargs_)
        else:
            return LicenseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_licenseName(self):
        return self.licenseName
    def set_licenseName(self, licenseName):
        self.licenseName = licenseName
    def get_url(self):
        return self.url
    def set_url(self, url):
        self.url = url
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def hasContent_(self):
        if (
            self.licenseName is not None or
            self.url is not None or
            self.identifier is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='LicenseType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LicenseType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LicenseType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LicenseType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LicenseType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LicenseType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='LicenseType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.licenseName is not None:
            namespaceprefix_ = self.licenseName_nsprefix_ + ':' if (UseCapturedNS_ and self.licenseName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slicenseName>%s</%slicenseName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.licenseName), input_name='licenseName')), namespaceprefix_ , eol_))
        if self.url is not None:
            namespaceprefix_ = self.url_nsprefix_ + ':' if (UseCapturedNS_ and self.url_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%surl>%s</%surl>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.url), input_name='url')), namespaceprefix_ , eol_))
        if self.identifier is not None:
            namespaceprefix_ = self.identifier_nsprefix_ + ':' if (UseCapturedNS_ and self.identifier_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sidentifier>%s</%sidentifier>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.identifier), input_name='identifier')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'licenseName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'licenseName')
            value_ = self.gds_validate_string(value_, node, 'licenseName')
            self.licenseName = value_
            self.licenseName_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.licenseName)
        elif nodeName_ == 'url':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'url')
            value_ = self.gds_validate_string(value_, node, 'url')
            self.url = value_
            self.url_nsprefix_ = child_.prefix
        elif nodeName_ == 'identifier':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'identifier')
            value_ = self.gds_validate_string(value_, node, 'identifier')
            self.identifier = value_
            self.identifier_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.identifier)
# end class LicenseType


class ResponsibleParty(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'res:IDType', 0, 1, {'use': 'optional'}),
        MemberSpec_('system', 'res:SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('scope', 'res:ScopeType', 0, 1, {'use': 'optional'}),
        MemberSpec_('individualName', 'Person', 1, 0, {'name': 'individualName', 'type': 'Person'}, 12),
        MemberSpec_('organizationName', 'i18nNonEmptyStringType', 1, 0, {'name': 'organizationName', 'type': 'i18nNonEmptyStringType'}, 12),
        MemberSpec_('positionName', 'i18nNonEmptyStringType', 1, 0, {'name': 'positionName', 'type': 'i18nNonEmptyStringType'}, 12),
        MemberSpec_('address', 'Address', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'address', 'type': 'Address'}, None),
        MemberSpec_('phone', 'phoneType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'phone', 'type': 'phoneType'}, None),
        MemberSpec_('electronicMailAddress', 'i18nNonEmptyStringType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'electronicMailAddress', 'type': 'i18nNonEmptyStringType'}, None),
        MemberSpec_('onlineUrl', 'xs:anyURI', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'onlineUrl', 'type': 'xs:anyURI'}, None),
        MemberSpec_('userId', 'userIdType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'userId', 'type': 'userIdType'}, None),
        MemberSpec_('references', 'referencesType5', 0, 0, {'name': 'references', 'type': 'referencesType5'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, system=None, scope='document', individualName=None, organizationName=None, positionName=None, address=None, phone=None, electronicMailAddress=None, onlineUrl=None, userId=None, references=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.scope = _cast(None, scope)
        self.scope_nsprefix_ = None
        if individualName is None:
            self.individualName = []
        else:
            self.individualName = individualName
        self.individualName_nsprefix_ = None
        if organizationName is None:
            self.organizationName = []
        else:
            self.organizationName = organizationName
        self.organizationName_nsprefix_ = None
        if positionName is None:
            self.positionName = []
        else:
            self.positionName = positionName
        self.positionName_nsprefix_ = None
        if address is None:
            self.address = []
        else:
            self.address = address
        self.address_nsprefix_ = None
        if phone is None:
            self.phone = []
        else:
            self.phone = phone
        self.phone_nsprefix_ = None
        if electronicMailAddress is None:
            self.electronicMailAddress = []
        else:
            self.electronicMailAddress = electronicMailAddress
        self.electronicMailAddress_nsprefix_ = None
        if onlineUrl is None:
            self.onlineUrl = []
        else:
            self.onlineUrl = onlineUrl
        self.onlineUrl_nsprefix_ = None
        if userId is None:
            self.userId = []
        else:
            self.userId = userId
        self.userId_nsprefix_ = None
        self.references = references
        self.references_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ResponsibleParty)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ResponsibleParty.subclass:
            return ResponsibleParty.subclass(*args_, **kwargs_)
        else:
            return ResponsibleParty(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_individualName(self):
        return self.individualName
    def set_individualName(self, individualName):
        self.individualName = individualName
    def add_individualName(self, value):
        self.individualName.append(value)
    def insert_individualName_at(self, index, value):
        self.individualName.insert(index, value)
    def replace_individualName_at(self, index, value):
        self.individualName[index] = value
    def get_organizationName(self):
        return self.organizationName
    def set_organizationName(self, organizationName):
        self.organizationName = organizationName
    def add_organizationName(self, value):
        self.organizationName.append(value)
    def insert_organizationName_at(self, index, value):
        self.organizationName.insert(index, value)
    def replace_organizationName_at(self, index, value):
        self.organizationName[index] = value
    def get_positionName(self):
        return self.positionName
    def set_positionName(self, positionName):
        self.positionName = positionName
    def add_positionName(self, value):
        self.positionName.append(value)
    def insert_positionName_at(self, index, value):
        self.positionName.insert(index, value)
    def replace_positionName_at(self, index, value):
        self.positionName[index] = value
    def get_address(self):
        return self.address
    def set_address(self, address):
        self.address = address
    def add_address(self, value):
        self.address.append(value)
    def insert_address_at(self, index, value):
        self.address.insert(index, value)
    def replace_address_at(self, index, value):
        self.address[index] = value
    def get_phone(self):
        return self.phone
    def set_phone(self, phone):
        self.phone = phone
    def add_phone(self, value):
        self.phone.append(value)
    def insert_phone_at(self, index, value):
        self.phone.insert(index, value)
    def replace_phone_at(self, index, value):
        self.phone[index] = value
    def get_electronicMailAddress(self):
        return self.electronicMailAddress
    def set_electronicMailAddress(self, electronicMailAddress):
        self.electronicMailAddress = electronicMailAddress
    def add_electronicMailAddress(self, value):
        self.electronicMailAddress.append(value)
    def insert_electronicMailAddress_at(self, index, value):
        self.electronicMailAddress.insert(index, value)
    def replace_electronicMailAddress_at(self, index, value):
        self.electronicMailAddress[index] = value
    def get_onlineUrl(self):
        return self.onlineUrl
    def set_onlineUrl(self, onlineUrl):
        self.onlineUrl = onlineUrl
    def add_onlineUrl(self, value):
        self.onlineUrl.append(value)
    def insert_onlineUrl_at(self, index, value):
        self.onlineUrl.insert(index, value)
    def replace_onlineUrl_at(self, index, value):
        self.onlineUrl[index] = value
    def get_userId(self):
        return self.userId
    def set_userId(self, userId):
        self.userId = userId
    def add_userId(self, value):
        self.userId.append(value)
    def insert_userId_at(self, index, value):
        self.userId.insert(index, value)
    def replace_userId_at(self, index, value):
        self.userId[index] = value
    def get_references(self):
        return self.references
    def set_references(self, references):
        self.references = references
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_scope(self):
        return self.scope
    def set_scope(self, scope):
        self.scope = scope
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_IDType(self, value):
        # Validate type res:IDType, a restriction on xs:string.
        pass
    def validate_SystemType(self, value):
        # Validate type res:SystemType, a restriction on xs:string.
        pass
    def validate_ScopeType(self, value):
        # Validate type res:ScopeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['system', 'document']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ScopeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.individualName or
            self.organizationName or
            self.positionName or
            self.address or
            self.phone or
            self.electronicMailAddress or
            self.onlineUrl or
            self.userId or
            self.references is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0"  xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='ResponsibleParty', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ResponsibleParty')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ResponsibleParty':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ResponsibleParty')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ResponsibleParty', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ResponsibleParty'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
        if self.scope != "document" and 'scope' not in already_processed:
            already_processed.add('scope')
            outfile.write(' scope=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.scope), input_name='scope')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0"  xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='ResponsibleParty', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for individualName_ in self.individualName:
            namespaceprefix_ = self.individualName_nsprefix_ + ':' if (UseCapturedNS_ and self.individualName_nsprefix_) else ''
            individualName_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='individualName', pretty_print=pretty_print)
        for organizationName_ in self.organizationName:
            namespaceprefix_ = self.organizationName_nsprefix_ + ':' if (UseCapturedNS_ and self.organizationName_nsprefix_) else ''
            organizationName_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='organizationName', pretty_print=pretty_print)
        for positionName_ in self.positionName:
            namespaceprefix_ = self.positionName_nsprefix_ + ':' if (UseCapturedNS_ and self.positionName_nsprefix_) else ''
            positionName_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='positionName', pretty_print=pretty_print)
        for address_ in self.address:
            namespaceprefix_ = self.address_nsprefix_ + ':' if (UseCapturedNS_ and self.address_nsprefix_) else ''
            address_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='address', pretty_print=pretty_print)
        for phone_ in self.phone:
            namespaceprefix_ = self.phone_nsprefix_ + ':' if (UseCapturedNS_ and self.phone_nsprefix_) else ''
            phone_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='phone', pretty_print=pretty_print)
        for electronicMailAddress_ in self.electronicMailAddress:
            namespaceprefix_ = self.electronicMailAddress_nsprefix_ + ':' if (UseCapturedNS_ and self.electronicMailAddress_nsprefix_) else ''
            electronicMailAddress_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='electronicMailAddress', pretty_print=pretty_print)
        for onlineUrl_ in self.onlineUrl:
            namespaceprefix_ = self.onlineUrl_nsprefix_ + ':' if (UseCapturedNS_ and self.onlineUrl_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sonlineUrl>%s</%sonlineUrl>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(onlineUrl_), input_name='onlineUrl')), namespaceprefix_ , eol_))
        for userId_ in self.userId:
            namespaceprefix_ = self.userId_nsprefix_ + ':' if (UseCapturedNS_ and self.userId_nsprefix_) else ''
            userId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userId', pretty_print=pretty_print)
        if self.references is not None:
            namespaceprefix_ = self.references_nsprefix_ + ':' if (UseCapturedNS_ and self.references_nsprefix_) else ''
            self.references.export(outfile, level, namespaceprefix_, namespacedef_='', name_='references', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_IDType(self.id)    # validate type IDType
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
        value = find_attr_value_('scope', node)
        if value is not None and 'scope' not in already_processed:
            already_processed.add('scope')
            self.scope = value
            self.validate_ScopeType(self.scope)    # validate type ScopeType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'individualName':
            obj_ = Person.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.individualName.append(obj_)
            obj_.original_tagname_ = 'individualName'
        elif nodeName_ == 'organizationName':
            class_obj_ = self.get_class_obj_(child_, i18nNonEmptyStringType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.organizationName.append(obj_)
            obj_.original_tagname_ = 'organizationName'
        elif nodeName_ == 'positionName':
            class_obj_ = self.get_class_obj_(child_, i18nNonEmptyStringType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.positionName.append(obj_)
            obj_.original_tagname_ = 'positionName'
        elif nodeName_ == 'address':
            obj_ = Address.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.address.append(obj_)
            obj_.original_tagname_ = 'address'
        elif nodeName_ == 'phone':
            obj_ = phoneType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.phone.append(obj_)
            obj_.original_tagname_ = 'phone'
        elif nodeName_ == 'electronicMailAddress':
            class_obj_ = self.get_class_obj_(child_, i18nNonEmptyStringType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.electronicMailAddress.append(obj_)
            obj_.original_tagname_ = 'electronicMailAddress'
        elif nodeName_ == 'onlineUrl':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'onlineUrl')
            value_ = self.gds_validate_string(value_, node, 'onlineUrl')
            self.onlineUrl.append(value_)
            self.onlineUrl_nsprefix_ = child_.prefix
        elif nodeName_ == 'userId':
            obj_ = userIdType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userId.append(obj_)
            obj_.original_tagname_ = 'userId'
        elif nodeName_ == 'references':
            obj_ = referencesType5.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.references = obj_
            obj_.original_tagname_ = 'references'
# end class ResponsibleParty


class Person(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('salutation', 'i18nNonEmptyStringType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'salutation', 'type': 'i18nNonEmptyStringType'}, None),
        MemberSpec_('givenName', 'i18nNonEmptyStringType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'givenName', 'type': 'i18nNonEmptyStringType'}, None),
        MemberSpec_('surName', 'i18nNonEmptyStringType', 0, 0, {'name': 'surName', 'type': 'i18nNonEmptyStringType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, salutation=None, givenName=None, surName=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if salutation is None:
            self.salutation = []
        else:
            self.salutation = salutation
        self.salutation_nsprefix_ = None
        if givenName is None:
            self.givenName = []
        else:
            self.givenName = givenName
        self.givenName_nsprefix_ = None
        self.surName = surName
        self.surName_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Person)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Person.subclass:
            return Person.subclass(*args_, **kwargs_)
        else:
            return Person(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_salutation(self):
        return self.salutation
    def set_salutation(self, salutation):
        self.salutation = salutation
    def add_salutation(self, value):
        self.salutation.append(value)
    def insert_salutation_at(self, index, value):
        self.salutation.insert(index, value)
    def replace_salutation_at(self, index, value):
        self.salutation[index] = value
    def get_givenName(self):
        return self.givenName
    def set_givenName(self, givenName):
        self.givenName = givenName
    def add_givenName(self, value):
        self.givenName.append(value)
    def insert_givenName_at(self, index, value):
        self.givenName.insert(index, value)
    def replace_givenName_at(self, index, value):
        self.givenName[index] = value
    def get_surName(self):
        return self.surName
    def set_surName(self, surName):
        self.surName = surName
    def hasContent_(self):
        if (
            self.salutation or
            self.givenName or
            self.surName is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='Person', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Person')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Person':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Person')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Person', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Person'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='Person', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for salutation_ in self.salutation:
            namespaceprefix_ = self.salutation_nsprefix_ + ':' if (UseCapturedNS_ and self.salutation_nsprefix_) else ''
            salutation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='salutation', pretty_print=pretty_print)
        for givenName_ in self.givenName:
            namespaceprefix_ = self.givenName_nsprefix_ + ':' if (UseCapturedNS_ and self.givenName_nsprefix_) else ''
            givenName_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='givenName', pretty_print=pretty_print)
        if self.surName is not None:
            namespaceprefix_ = self.surName_nsprefix_ + ':' if (UseCapturedNS_ and self.surName_nsprefix_) else ''
            self.surName.export(outfile, level, namespaceprefix_, namespacedef_='', name_='surName', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'salutation':
            class_obj_ = self.get_class_obj_(child_, i18nNonEmptyStringType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.salutation.append(obj_)
            obj_.original_tagname_ = 'salutation'
        elif nodeName_ == 'givenName':
            class_obj_ = self.get_class_obj_(child_, i18nNonEmptyStringType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.givenName.append(obj_)
            obj_.original_tagname_ = 'givenName'
        elif nodeName_ == 'surName':
            class_obj_ = self.get_class_obj_(child_, i18nNonEmptyStringType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.surName = obj_
            obj_.original_tagname_ = 'surName'
# end class Person


class Address(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'res:IDType', 0, 1, {'use': 'optional'}),
        MemberSpec_('system', 'res:SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('scope', 'res:ScopeType', 0, 1, {'use': 'optional'}),
        MemberSpec_('deliveryPoint', 'i18nNonEmptyStringType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'deliveryPoint', 'type': 'i18nNonEmptyStringType'}, 13),
        MemberSpec_('city', 'i18nNonEmptyStringType', 0, 1, {'minOccurs': '0', 'name': 'city', 'type': 'i18nNonEmptyStringType'}, 13),
        MemberSpec_('administrativeArea', 'i18nNonEmptyStringType', 0, 1, {'minOccurs': '0', 'name': 'administrativeArea', 'type': 'i18nNonEmptyStringType'}, 13),
        MemberSpec_('postalCode', 'i18nNonEmptyStringType', 0, 1, {'minOccurs': '0', 'name': 'postalCode', 'type': 'i18nNonEmptyStringType'}, 13),
        MemberSpec_('country', 'i18nNonEmptyStringType', 0, 1, {'minOccurs': '0', 'name': 'country', 'type': 'i18nNonEmptyStringType'}, 13),
        MemberSpec_('references', 'referencesType6', 0, 0, {'name': 'references', 'type': 'referencesType6'}, 13),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, system=None, scope='document', deliveryPoint=None, city=None, administrativeArea=None, postalCode=None, country=None, references=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.scope = _cast(None, scope)
        self.scope_nsprefix_ = None
        if deliveryPoint is None:
            self.deliveryPoint = []
        else:
            self.deliveryPoint = deliveryPoint
        self.deliveryPoint_nsprefix_ = None
        self.city = city
        self.city_nsprefix_ = None
        self.administrativeArea = administrativeArea
        self.administrativeArea_nsprefix_ = None
        self.postalCode = postalCode
        self.postalCode_nsprefix_ = None
        self.country = country
        self.country_nsprefix_ = None
        self.references = references
        self.references_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Address)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Address.subclass:
            return Address.subclass(*args_, **kwargs_)
        else:
            return Address(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_deliveryPoint(self):
        return self.deliveryPoint
    def set_deliveryPoint(self, deliveryPoint):
        self.deliveryPoint = deliveryPoint
    def add_deliveryPoint(self, value):
        self.deliveryPoint.append(value)
    def insert_deliveryPoint_at(self, index, value):
        self.deliveryPoint.insert(index, value)
    def replace_deliveryPoint_at(self, index, value):
        self.deliveryPoint[index] = value
    def get_city(self):
        return self.city
    def set_city(self, city):
        self.city = city
    def get_administrativeArea(self):
        return self.administrativeArea
    def set_administrativeArea(self, administrativeArea):
        self.administrativeArea = administrativeArea
    def get_postalCode(self):
        return self.postalCode
    def set_postalCode(self, postalCode):
        self.postalCode = postalCode
    def get_country(self):
        return self.country
    def set_country(self, country):
        self.country = country
    def get_references(self):
        return self.references
    def set_references(self, references):
        self.references = references
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_scope(self):
        return self.scope
    def set_scope(self, scope):
        self.scope = scope
    def validate_IDType(self, value):
        # Validate type res:IDType, a restriction on xs:string.
        pass
    def validate_SystemType(self, value):
        # Validate type res:SystemType, a restriction on xs:string.
        pass
    def validate_ScopeType(self, value):
        # Validate type res:ScopeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['system', 'document']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ScopeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.deliveryPoint or
            self.city is not None or
            self.administrativeArea is not None or
            self.postalCode is not None or
            self.country is not None or
            self.references is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='Address', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Address')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Address':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Address')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Address', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Address'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
        if self.scope != "document" and 'scope' not in already_processed:
            already_processed.add('scope')
            outfile.write(' scope=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.scope), input_name='scope')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='Address', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for deliveryPoint_ in self.deliveryPoint:
            namespaceprefix_ = self.deliveryPoint_nsprefix_ + ':' if (UseCapturedNS_ and self.deliveryPoint_nsprefix_) else ''
            deliveryPoint_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='deliveryPoint', pretty_print=pretty_print)
        if self.city is not None:
            namespaceprefix_ = self.city_nsprefix_ + ':' if (UseCapturedNS_ and self.city_nsprefix_) else ''
            self.city.export(outfile, level, namespaceprefix_, namespacedef_='', name_='city', pretty_print=pretty_print)
        if self.administrativeArea is not None:
            namespaceprefix_ = self.administrativeArea_nsprefix_ + ':' if (UseCapturedNS_ and self.administrativeArea_nsprefix_) else ''
            self.administrativeArea.export(outfile, level, namespaceprefix_, namespacedef_='', name_='administrativeArea', pretty_print=pretty_print)
        if self.postalCode is not None:
            namespaceprefix_ = self.postalCode_nsprefix_ + ':' if (UseCapturedNS_ and self.postalCode_nsprefix_) else ''
            self.postalCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='postalCode', pretty_print=pretty_print)
        if self.country is not None:
            namespaceprefix_ = self.country_nsprefix_ + ':' if (UseCapturedNS_ and self.country_nsprefix_) else ''
            self.country.export(outfile, level, namespaceprefix_, namespacedef_='', name_='country', pretty_print=pretty_print)
        if self.references is not None:
            namespaceprefix_ = self.references_nsprefix_ + ':' if (UseCapturedNS_ and self.references_nsprefix_) else ''
            self.references.export(outfile, level, namespaceprefix_, namespacedef_='', name_='references', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_IDType(self.id)    # validate type IDType
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
        value = find_attr_value_('scope', node)
        if value is not None and 'scope' not in already_processed:
            already_processed.add('scope')
            self.scope = value
            self.validate_ScopeType(self.scope)    # validate type ScopeType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'deliveryPoint':
            class_obj_ = self.get_class_obj_(child_, i18nNonEmptyStringType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.deliveryPoint.append(obj_)
            obj_.original_tagname_ = 'deliveryPoint'
        elif nodeName_ == 'city':
            class_obj_ = self.get_class_obj_(child_, i18nNonEmptyStringType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.city = obj_
            obj_.original_tagname_ = 'city'
        elif nodeName_ == 'administrativeArea':
            class_obj_ = self.get_class_obj_(child_, i18nNonEmptyStringType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.administrativeArea = obj_
            obj_.original_tagname_ = 'administrativeArea'
        elif nodeName_ == 'postalCode':
            class_obj_ = self.get_class_obj_(child_, i18nNonEmptyStringType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.postalCode = obj_
            obj_.original_tagname_ = 'postalCode'
        elif nodeName_ == 'country':
            class_obj_ = self.get_class_obj_(child_, i18nNonEmptyStringType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.country = obj_
            obj_.original_tagname_ = 'country'
        elif nodeName_ == 'references':
            obj_ = referencesType6.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.references = obj_
            obj_.original_tagname_ = 'references'
# end class Address


class Coverage(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'res:IDType', 0, 1, {'use': 'optional'}),
        MemberSpec_('system', 'res:SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('scope', 'res:ScopeType', 0, 1, {'use': 'optional'}),
        MemberSpec_('geographicCoverage', 'GeographicCoverage', 1, 0, {'name': 'geographicCoverage', 'type': 'GeographicCoverage'}, 15),
        MemberSpec_('temporalCoverage', 'temporalCoverageType', 1, 0, {'name': 'temporalCoverage', 'type': 'temporalCoverageType'}, 15),
        MemberSpec_('taxonomicCoverage', 'taxonomicCoverageType', 1, 0, {'name': 'taxonomicCoverage', 'type': 'taxonomicCoverageType'}, 15),
        MemberSpec_('references', 'referencesType7', 0, 0, {'name': 'references', 'type': 'referencesType7'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, system=None, scope='document', geographicCoverage=None, temporalCoverage=None, taxonomicCoverage=None, references=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.scope = _cast(None, scope)
        self.scope_nsprefix_ = None
        if geographicCoverage is None:
            self.geographicCoverage = []
        else:
            self.geographicCoverage = geographicCoverage
        self.geographicCoverage_nsprefix_ = None
        if temporalCoverage is None:
            self.temporalCoverage = []
        else:
            self.temporalCoverage = temporalCoverage
        self.temporalCoverage_nsprefix_ = None
        if taxonomicCoverage is None:
            self.taxonomicCoverage = []
        else:
            self.taxonomicCoverage = taxonomicCoverage
        self.taxonomicCoverage_nsprefix_ = None
        self.references = references
        self.references_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Coverage)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Coverage.subclass:
            return Coverage.subclass(*args_, **kwargs_)
        else:
            return Coverage(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_geographicCoverage(self):
        return self.geographicCoverage
    def set_geographicCoverage(self, geographicCoverage):
        self.geographicCoverage = geographicCoverage
    def add_geographicCoverage(self, value):
        self.geographicCoverage.append(value)
    def insert_geographicCoverage_at(self, index, value):
        self.geographicCoverage.insert(index, value)
    def replace_geographicCoverage_at(self, index, value):
        self.geographicCoverage[index] = value
    def get_temporalCoverage(self):
        return self.temporalCoverage
    def set_temporalCoverage(self, temporalCoverage):
        self.temporalCoverage = temporalCoverage
    def add_temporalCoverage(self, value):
        self.temporalCoverage.append(value)
    def insert_temporalCoverage_at(self, index, value):
        self.temporalCoverage.insert(index, value)
    def replace_temporalCoverage_at(self, index, value):
        self.temporalCoverage[index] = value
    def get_taxonomicCoverage(self):
        return self.taxonomicCoverage
    def set_taxonomicCoverage(self, taxonomicCoverage):
        self.taxonomicCoverage = taxonomicCoverage
    def add_taxonomicCoverage(self, value):
        self.taxonomicCoverage.append(value)
    def insert_taxonomicCoverage_at(self, index, value):
        self.taxonomicCoverage.insert(index, value)
    def replace_taxonomicCoverage_at(self, index, value):
        self.taxonomicCoverage[index] = value
    def get_references(self):
        return self.references
    def set_references(self, references):
        self.references = references
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_scope(self):
        return self.scope
    def set_scope(self, scope):
        self.scope = scope
    def validate_IDType(self, value):
        # Validate type res:IDType, a restriction on xs:string.
        pass
    def validate_SystemType(self, value):
        # Validate type res:SystemType, a restriction on xs:string.
        pass
    def validate_ScopeType(self, value):
        # Validate type res:ScopeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['system', 'document']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ScopeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.geographicCoverage or
            self.temporalCoverage or
            self.taxonomicCoverage or
            self.references is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='Coverage', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Coverage')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Coverage':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Coverage')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Coverage', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Coverage'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
        if self.scope != "document" and 'scope' not in already_processed:
            already_processed.add('scope')
            outfile.write(' scope=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.scope), input_name='scope')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='Coverage', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for geographicCoverage_ in self.geographicCoverage:
            namespaceprefix_ = self.geographicCoverage_nsprefix_ + ':' if (UseCapturedNS_ and self.geographicCoverage_nsprefix_) else ''
            geographicCoverage_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='geographicCoverage', pretty_print=pretty_print)
        for temporalCoverage_ in self.temporalCoverage:
            namespaceprefix_ = self.temporalCoverage_nsprefix_ + ':' if (UseCapturedNS_ and self.temporalCoverage_nsprefix_) else ''
            temporalCoverage_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='temporalCoverage', pretty_print=pretty_print)
        for taxonomicCoverage_ in self.taxonomicCoverage:
            namespaceprefix_ = self.taxonomicCoverage_nsprefix_ + ':' if (UseCapturedNS_ and self.taxonomicCoverage_nsprefix_) else ''
            taxonomicCoverage_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='taxonomicCoverage', pretty_print=pretty_print)
        if self.references is not None:
            namespaceprefix_ = self.references_nsprefix_ + ':' if (UseCapturedNS_ and self.references_nsprefix_) else ''
            self.references.export(outfile, level, namespaceprefix_, namespacedef_='', name_='references', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_IDType(self.id)    # validate type IDType
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
        value = find_attr_value_('scope', node)
        if value is not None and 'scope' not in already_processed:
            already_processed.add('scope')
            self.scope = value
            self.validate_ScopeType(self.scope)    # validate type ScopeType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'geographicCoverage':
            obj_ = GeographicCoverage.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.geographicCoverage.append(obj_)
            obj_.original_tagname_ = 'geographicCoverage'
        elif nodeName_ == 'temporalCoverage':
            obj_ = temporalCoverageType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.temporalCoverage.append(obj_)
            obj_.original_tagname_ = 'temporalCoverage'
        elif nodeName_ == 'taxonomicCoverage':
            obj_ = taxonomicCoverageType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.taxonomicCoverage.append(obj_)
            obj_.original_tagname_ = 'taxonomicCoverage'
        elif nodeName_ == 'references':
            obj_ = referencesType7.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.references = obj_
            obj_.original_tagname_ = 'references'
# end class Coverage


class TemporalCoverage(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'res:IDType', 0, 1, {'use': 'optional'}),
        MemberSpec_('singleDateTime', 'SingleDateTimeType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'singleDateTime', 'type': 'SingleDateTimeType'}, 17),
        MemberSpec_('rangeOfDates', 'rangeOfDatesType', 0, 0, {'name': 'rangeOfDates', 'type': 'rangeOfDatesType'}, 17),
        MemberSpec_('references', 'referencesType8', 0, 0, {'name': 'references', 'type': 'referencesType8'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, singleDateTime=None, rangeOfDates=None, references=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        if singleDateTime is None:
            self.singleDateTime = []
        else:
            self.singleDateTime = singleDateTime
        self.singleDateTime_nsprefix_ = None
        self.rangeOfDates = rangeOfDates
        self.rangeOfDates_nsprefix_ = None
        self.references = references
        self.references_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TemporalCoverage)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TemporalCoverage.subclass:
            return TemporalCoverage.subclass(*args_, **kwargs_)
        else:
            return TemporalCoverage(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_singleDateTime(self):
        return self.singleDateTime
    def set_singleDateTime(self, singleDateTime):
        self.singleDateTime = singleDateTime
    def add_singleDateTime(self, value):
        self.singleDateTime.append(value)
    def insert_singleDateTime_at(self, index, value):
        self.singleDateTime.insert(index, value)
    def replace_singleDateTime_at(self, index, value):
        self.singleDateTime[index] = value
    def get_rangeOfDates(self):
        return self.rangeOfDates
    def set_rangeOfDates(self, rangeOfDates):
        self.rangeOfDates = rangeOfDates
    def get_references(self):
        return self.references
    def set_references(self, references):
        self.references = references
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_IDType(self, value):
        # Validate type res:IDType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.singleDateTime or
            self.rangeOfDates is not None or
            self.references is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='TemporalCoverage', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TemporalCoverage')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TemporalCoverage':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TemporalCoverage')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TemporalCoverage', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TemporalCoverage'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='TemporalCoverage', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for singleDateTime_ in self.singleDateTime:
            namespaceprefix_ = self.singleDateTime_nsprefix_ + ':' if (UseCapturedNS_ and self.singleDateTime_nsprefix_) else ''
            singleDateTime_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='singleDateTime', pretty_print=pretty_print)
        if self.rangeOfDates is not None:
            namespaceprefix_ = self.rangeOfDates_nsprefix_ + ':' if (UseCapturedNS_ and self.rangeOfDates_nsprefix_) else ''
            self.rangeOfDates.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rangeOfDates', pretty_print=pretty_print)
        if self.references is not None:
            namespaceprefix_ = self.references_nsprefix_ + ':' if (UseCapturedNS_ and self.references_nsprefix_) else ''
            self.references.export(outfile, level, namespaceprefix_, namespacedef_='', name_='references', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_IDType(self.id)    # validate type IDType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'singleDateTime':
            obj_ = SingleDateTimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.singleDateTime.append(obj_)
            obj_.original_tagname_ = 'singleDateTime'
        elif nodeName_ == 'rangeOfDates':
            obj_ = rangeOfDatesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rangeOfDates = obj_
            obj_.original_tagname_ = 'rangeOfDates'
        elif nodeName_ == 'references':
            obj_ = referencesType8.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.references = obj_
            obj_.original_tagname_ = 'references'
# end class TemporalCoverage


class SingleDateTimeType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('calendarDate', 'yearDate', 0, 0, {'name': 'calendarDate', 'type': 'xs:string'}, 18),
        MemberSpec_('time', 'xs:time', 0, 1, {'minOccurs': '0', 'name': 'time', 'type': 'xs:time'}, 18),
        MemberSpec_('alternativeTimeScale', 'alternativeTimeScaleType', 0, 0, {'name': 'alternativeTimeScale', 'type': 'alternativeTimeScaleType'}, 18),
    ]
    subclass = None
    superclass = None
    def __init__(self, calendarDate=None, time=None, alternativeTimeScale=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.calendarDate = calendarDate
        self.validate_yearDate(self.calendarDate)
        self.calendarDate_nsprefix_ = None
        if isinstance(time, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(time, '%H:%M:%S').time()
        else:
            initvalue_ = time
        self.time = initvalue_
        self.time_nsprefix_ = None
        self.alternativeTimeScale = alternativeTimeScale
        self.alternativeTimeScale_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SingleDateTimeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SingleDateTimeType.subclass:
            return SingleDateTimeType.subclass(*args_, **kwargs_)
        else:
            return SingleDateTimeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_calendarDate(self):
        return self.calendarDate
    def set_calendarDate(self, calendarDate):
        self.calendarDate = calendarDate
    def get_time(self):
        return self.time
    def set_time(self, time):
        self.time = time
    def get_alternativeTimeScale(self):
        return self.alternativeTimeScale
    def set_alternativeTimeScale(self, alternativeTimeScale):
        self.alternativeTimeScale = alternativeTimeScale
    def validate_yearDate(self, value):
        result = True
        # Validate type yearDate, a restriction on None.
        pass
        return result
    def hasContent_(self):
        if (
            self.calendarDate is not None or
            self.time is not None or
            self.alternativeTimeScale is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='SingleDateTimeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SingleDateTimeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SingleDateTimeType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SingleDateTimeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SingleDateTimeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SingleDateTimeType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='SingleDateTimeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.calendarDate is not None:
            namespaceprefix_ = self.calendarDate_nsprefix_ + ':' if (UseCapturedNS_ and self.calendarDate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scalendarDate>%s</%scalendarDate>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.calendarDate), input_name='calendarDate')), namespaceprefix_ , eol_))
        if self.time is not None:
            namespaceprefix_ = self.time_nsprefix_ + ':' if (UseCapturedNS_ and self.time_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stime>%s</%stime>%s' % (namespaceprefix_ , self.gds_format_time(self.time, input_name='time'), namespaceprefix_ , eol_))
        if self.alternativeTimeScale is not None:
            namespaceprefix_ = self.alternativeTimeScale_nsprefix_ + ':' if (UseCapturedNS_ and self.alternativeTimeScale_nsprefix_) else ''
            self.alternativeTimeScale.export(outfile, level, namespaceprefix_, namespacedef_='', name_='alternativeTimeScale', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'calendarDate':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'calendarDate')
            value_ = self.gds_validate_string(value_, node, 'calendarDate')
            self.calendarDate = value_
            self.calendarDate_nsprefix_ = child_.prefix
            # validate type yearDate
            self.validate_yearDate(self.calendarDate)
        elif nodeName_ == 'time':
            sval_ = child_.text
            dval_ = self.gds_parse_time(sval_)
            self.time = dval_
            self.time_nsprefix_ = child_.prefix
        elif nodeName_ == 'alternativeTimeScale':
            obj_ = alternativeTimeScaleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.alternativeTimeScale = obj_
            obj_.original_tagname_ = 'alternativeTimeScale'
# end class SingleDateTimeType


class GeographicCoverage(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'res:IDType', 0, 1, {'use': 'optional'}),
        MemberSpec_('system', 'res:SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('scope', 'res:ScopeType', 0, 1, {'use': 'optional'}),
        MemberSpec_('geographicDescription', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'geographicDescription', 'type': 'xs:string'}, 19),
        MemberSpec_('boundingCoordinates', 'boundingCoordinatesType', 0, 0, {'name': 'boundingCoordinates', 'type': 'boundingCoordinatesType'}, 19),
        MemberSpec_('datasetGPolygon', 'datasetGPolygonType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'datasetGPolygon', 'type': 'datasetGPolygonType'}, 19),
        MemberSpec_('references', 'referencesType9', 0, 0, {'name': 'references', 'type': 'referencesType9'}, 19),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, system=None, scope='document', geographicDescription=None, boundingCoordinates=None, datasetGPolygon=None, references=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.scope = _cast(None, scope)
        self.scope_nsprefix_ = None
        self.geographicDescription = geographicDescription
        self.validate_NonEmptyStringType(self.geographicDescription)
        self.geographicDescription_nsprefix_ = None
        self.boundingCoordinates = boundingCoordinates
        self.boundingCoordinates_nsprefix_ = None
        if datasetGPolygon is None:
            self.datasetGPolygon = []
        else:
            self.datasetGPolygon = datasetGPolygon
        self.datasetGPolygon_nsprefix_ = None
        self.references = references
        self.references_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GeographicCoverage)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeographicCoverage.subclass:
            return GeographicCoverage.subclass(*args_, **kwargs_)
        else:
            return GeographicCoverage(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_geographicDescription(self):
        return self.geographicDescription
    def set_geographicDescription(self, geographicDescription):
        self.geographicDescription = geographicDescription
    def get_boundingCoordinates(self):
        return self.boundingCoordinates
    def set_boundingCoordinates(self, boundingCoordinates):
        self.boundingCoordinates = boundingCoordinates
    def get_datasetGPolygon(self):
        return self.datasetGPolygon
    def set_datasetGPolygon(self, datasetGPolygon):
        self.datasetGPolygon = datasetGPolygon
    def add_datasetGPolygon(self, value):
        self.datasetGPolygon.append(value)
    def insert_datasetGPolygon_at(self, index, value):
        self.datasetGPolygon.insert(index, value)
    def replace_datasetGPolygon_at(self, index, value):
        self.datasetGPolygon[index] = value
    def get_references(self):
        return self.references
    def set_references(self, references):
        self.references = references
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_scope(self):
        return self.scope
    def set_scope(self, scope):
        self.scope = scope
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def validate_IDType(self, value):
        # Validate type res:IDType, a restriction on xs:string.
        pass
    def validate_SystemType(self, value):
        # Validate type res:SystemType, a restriction on xs:string.
        pass
    def validate_ScopeType(self, value):
        # Validate type res:ScopeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['system', 'document']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ScopeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.geographicDescription is not None or
            self.boundingCoordinates is not None or
            self.datasetGPolygon or
            self.references is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='GeographicCoverage', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GeographicCoverage')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'GeographicCoverage':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GeographicCoverage')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GeographicCoverage', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GeographicCoverage'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
        if self.scope != "document" and 'scope' not in already_processed:
            already_processed.add('scope')
            outfile.write(' scope=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.scope), input_name='scope')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='GeographicCoverage', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.geographicDescription is not None:
            namespaceprefix_ = self.geographicDescription_nsprefix_ + ':' if (UseCapturedNS_ and self.geographicDescription_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgeographicDescription>%s</%sgeographicDescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.geographicDescription), input_name='geographicDescription')), namespaceprefix_ , eol_))
        if self.boundingCoordinates is not None:
            namespaceprefix_ = self.boundingCoordinates_nsprefix_ + ':' if (UseCapturedNS_ and self.boundingCoordinates_nsprefix_) else ''
            self.boundingCoordinates.export(outfile, level, namespaceprefix_, namespacedef_='', name_='boundingCoordinates', pretty_print=pretty_print)
        for datasetGPolygon_ in self.datasetGPolygon:
            namespaceprefix_ = self.datasetGPolygon_nsprefix_ + ':' if (UseCapturedNS_ and self.datasetGPolygon_nsprefix_) else ''
            datasetGPolygon_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='datasetGPolygon', pretty_print=pretty_print)
        if self.references is not None:
            namespaceprefix_ = self.references_nsprefix_ + ':' if (UseCapturedNS_ and self.references_nsprefix_) else ''
            self.references.export(outfile, level, namespaceprefix_, namespacedef_='', name_='references', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_IDType(self.id)    # validate type IDType
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
        value = find_attr_value_('scope', node)
        if value is not None and 'scope' not in already_processed:
            already_processed.add('scope')
            self.scope = value
            self.validate_ScopeType(self.scope)    # validate type ScopeType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'geographicDescription':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'geographicDescription')
            value_ = self.gds_validate_string(value_, node, 'geographicDescription')
            self.geographicDescription = value_
            self.geographicDescription_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.geographicDescription)
        elif nodeName_ == 'boundingCoordinates':
            obj_ = boundingCoordinatesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.boundingCoordinates = obj_
            obj_.original_tagname_ = 'boundingCoordinates'
        elif nodeName_ == 'datasetGPolygon':
            obj_ = datasetGPolygonType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.datasetGPolygon.append(obj_)
            obj_.original_tagname_ = 'datasetGPolygon'
        elif nodeName_ == 'references':
            obj_ = referencesType9.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.references = obj_
            obj_.original_tagname_ = 'references'
# end class GeographicCoverage


class GRingPointType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('gRingLatitude', ['gRingLatitudeType', 'xs:decimal'], 0, 0, {'name': 'gRingLatitude', 'type': 'xs:decimal'}, None),
        MemberSpec_('gRingLongitude', ['gRingLongitudeType', 'xs:decimal'], 0, 0, {'name': 'gRingLongitude', 'type': 'xs:decimal'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, gRingLatitude=None, gRingLongitude=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.gRingLatitude = gRingLatitude
        self.validate_gRingLatitudeType(self.gRingLatitude)
        self.gRingLatitude_nsprefix_ = None
        self.gRingLongitude = gRingLongitude
        self.validate_gRingLongitudeType(self.gRingLongitude)
        self.gRingLongitude_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GRingPointType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GRingPointType.subclass:
            return GRingPointType.subclass(*args_, **kwargs_)
        else:
            return GRingPointType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_gRingLatitude(self):
        return self.gRingLatitude
    def set_gRingLatitude(self, gRingLatitude):
        self.gRingLatitude = gRingLatitude
    def get_gRingLongitude(self):
        return self.gRingLongitude
    def set_gRingLongitude(self, gRingLongitude):
        self.gRingLongitude = gRingLongitude
    def validate_gRingLatitudeType(self, value):
        result = True
        # Validate type gRingLatitudeType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value < -90.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on gRingLatitudeType' % {"value": value, "lineno": lineno} )
                result = False
            if value > 90.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on gRingLatitudeType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_gRingLongitudeType(self, value):
        result = True
        # Validate type gRingLongitudeType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value < -180.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on gRingLongitudeType' % {"value": value, "lineno": lineno} )
                result = False
            if value > 180.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on gRingLongitudeType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.gRingLatitude is not None or
            self.gRingLongitude is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='GRingPointType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GRingPointType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'GRingPointType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GRingPointType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GRingPointType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GRingPointType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='GRingPointType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.gRingLatitude is not None:
            namespaceprefix_ = self.gRingLatitude_nsprefix_ + ':' if (UseCapturedNS_ and self.gRingLatitude_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgRingLatitude>%s</%sgRingLatitude>%s' % (namespaceprefix_ , self.gds_format_decimal(self.gRingLatitude, input_name='gRingLatitude'), namespaceprefix_ , eol_))
        if self.gRingLongitude is not None:
            namespaceprefix_ = self.gRingLongitude_nsprefix_ + ':' if (UseCapturedNS_ and self.gRingLongitude_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgRingLongitude>%s</%sgRingLongitude>%s' % (namespaceprefix_ , self.gds_format_decimal(self.gRingLongitude, input_name='gRingLongitude'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'gRingLatitude' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'gRingLatitude')
            fval_ = self.gds_validate_decimal(fval_, node, 'gRingLatitude')
            self.gRingLatitude = fval_
            self.gRingLatitude_nsprefix_ = child_.prefix
            # validate type gRingLatitudeType
            self.validate_gRingLatitudeType(self.gRingLatitude)
        elif nodeName_ == 'gRingLongitude' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'gRingLongitude')
            fval_ = self.gds_validate_decimal(fval_, node, 'gRingLongitude')
            self.gRingLongitude = fval_
            self.gRingLongitude_nsprefix_ = child_.prefix
            # validate type gRingLongitudeType
            self.validate_gRingLongitudeType(self.gRingLongitude)
# end class GRingPointType


class TaxonomicCoverage(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'res:IDType', 0, 1, {'use': 'optional'}),
        MemberSpec_('taxonomicSystem', 'taxonomicSystemType', 0, 1, {'minOccurs': '0', 'name': 'taxonomicSystem', 'type': 'taxonomicSystemType'}, 20),
        MemberSpec_('generalTaxonomicCoverage', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'generalTaxonomicCoverage', 'type': 'xs:string'}, 20),
        MemberSpec_('taxonomicClassification', 'TaxonomicClassificationType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'taxonomicClassification', 'type': 'TaxonomicClassificationType'}, 20),
        MemberSpec_('references', 'referencesType10', 0, 0, {'name': 'references', 'type': 'referencesType10'}, 20),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, taxonomicSystem=None, generalTaxonomicCoverage=None, taxonomicClassification=None, references=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.taxonomicSystem = taxonomicSystem
        self.taxonomicSystem_nsprefix_ = None
        self.generalTaxonomicCoverage = generalTaxonomicCoverage
        self.validate_NonEmptyStringType(self.generalTaxonomicCoverage)
        self.generalTaxonomicCoverage_nsprefix_ = None
        if taxonomicClassification is None:
            self.taxonomicClassification = []
        else:
            self.taxonomicClassification = taxonomicClassification
        self.taxonomicClassification_nsprefix_ = None
        self.references = references
        self.references_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TaxonomicCoverage)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TaxonomicCoverage.subclass:
            return TaxonomicCoverage.subclass(*args_, **kwargs_)
        else:
            return TaxonomicCoverage(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_taxonomicSystem(self):
        return self.taxonomicSystem
    def set_taxonomicSystem(self, taxonomicSystem):
        self.taxonomicSystem = taxonomicSystem
    def get_generalTaxonomicCoverage(self):
        return self.generalTaxonomicCoverage
    def set_generalTaxonomicCoverage(self, generalTaxonomicCoverage):
        self.generalTaxonomicCoverage = generalTaxonomicCoverage
    def get_taxonomicClassification(self):
        return self.taxonomicClassification
    def set_taxonomicClassification(self, taxonomicClassification):
        self.taxonomicClassification = taxonomicClassification
    def add_taxonomicClassification(self, value):
        self.taxonomicClassification.append(value)
    def insert_taxonomicClassification_at(self, index, value):
        self.taxonomicClassification.insert(index, value)
    def replace_taxonomicClassification_at(self, index, value):
        self.taxonomicClassification[index] = value
    def get_references(self):
        return self.references
    def set_references(self, references):
        self.references = references
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def validate_IDType(self, value):
        # Validate type res:IDType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.taxonomicSystem is not None or
            self.generalTaxonomicCoverage is not None or
            self.taxonomicClassification or
            self.references is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0"  xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='TaxonomicCoverage', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TaxonomicCoverage')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TaxonomicCoverage':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TaxonomicCoverage')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TaxonomicCoverage', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TaxonomicCoverage'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0"  xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='TaxonomicCoverage', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.taxonomicSystem is not None:
            namespaceprefix_ = self.taxonomicSystem_nsprefix_ + ':' if (UseCapturedNS_ and self.taxonomicSystem_nsprefix_) else ''
            self.taxonomicSystem.export(outfile, level, namespaceprefix_, namespacedef_='', name_='taxonomicSystem', pretty_print=pretty_print)
        if self.generalTaxonomicCoverage is not None:
            namespaceprefix_ = self.generalTaxonomicCoverage_nsprefix_ + ':' if (UseCapturedNS_ and self.generalTaxonomicCoverage_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgeneralTaxonomicCoverage>%s</%sgeneralTaxonomicCoverage>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.generalTaxonomicCoverage), input_name='generalTaxonomicCoverage')), namespaceprefix_ , eol_))
        for taxonomicClassification_ in self.taxonomicClassification:
            namespaceprefix_ = self.taxonomicClassification_nsprefix_ + ':' if (UseCapturedNS_ and self.taxonomicClassification_nsprefix_) else ''
            taxonomicClassification_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='taxonomicClassification', pretty_print=pretty_print)
        if self.references is not None:
            namespaceprefix_ = self.references_nsprefix_ + ':' if (UseCapturedNS_ and self.references_nsprefix_) else ''
            self.references.export(outfile, level, namespaceprefix_, namespacedef_='', name_='references', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_IDType(self.id)    # validate type IDType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'taxonomicSystem':
            obj_ = taxonomicSystemType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.taxonomicSystem = obj_
            obj_.original_tagname_ = 'taxonomicSystem'
        elif nodeName_ == 'generalTaxonomicCoverage':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'generalTaxonomicCoverage')
            value_ = self.gds_validate_string(value_, node, 'generalTaxonomicCoverage')
            self.generalTaxonomicCoverage = value_
            self.generalTaxonomicCoverage_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.generalTaxonomicCoverage)
        elif nodeName_ == 'taxonomicClassification':
            obj_ = TaxonomicClassificationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.taxonomicClassification.append(obj_)
            obj_.original_tagname_ = 'taxonomicClassification'
        elif nodeName_ == 'references':
            obj_ = referencesType10.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.references = obj_
            obj_.original_tagname_ = 'references'
# end class TaxonomicCoverage


class TaxonomicClassificationType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'res:IDType', 0, 1, {'use': 'optional'}),
        MemberSpec_('taxonRankName', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'taxonRankName', 'type': 'xs:string'}, None),
        MemberSpec_('taxonRankValue', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'taxonRankValue', 'type': 'xs:string'}, None),
        MemberSpec_('commonName', ['NonEmptyStringType', 'xs:string'], 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'commonName', 'type': 'xs:string'}, None),
        MemberSpec_('taxonId', 'taxonIdType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'taxonId', 'type': 'taxonIdType'}, None),
        MemberSpec_('taxonomicClassification', 'TaxonomicClassificationType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'taxonomicClassification', 'type': 'TaxonomicClassificationType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, taxonRankName=None, taxonRankValue=None, commonName=None, taxonId=None, taxonomicClassification=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.taxonRankName = taxonRankName
        self.validate_NonEmptyStringType(self.taxonRankName)
        self.taxonRankName_nsprefix_ = None
        self.taxonRankValue = taxonRankValue
        self.validate_NonEmptyStringType(self.taxonRankValue)
        self.taxonRankValue_nsprefix_ = None
        if commonName is None:
            self.commonName = []
        else:
            self.commonName = commonName
        self.commonName_nsprefix_ = None
        if taxonId is None:
            self.taxonId = []
        else:
            self.taxonId = taxonId
        self.taxonId_nsprefix_ = None
        if taxonomicClassification is None:
            self.taxonomicClassification = []
        else:
            self.taxonomicClassification = taxonomicClassification
        self.taxonomicClassification_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TaxonomicClassificationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TaxonomicClassificationType.subclass:
            return TaxonomicClassificationType.subclass(*args_, **kwargs_)
        else:
            return TaxonomicClassificationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_taxonRankName(self):
        return self.taxonRankName
    def set_taxonRankName(self, taxonRankName):
        self.taxonRankName = taxonRankName
    def get_taxonRankValue(self):
        return self.taxonRankValue
    def set_taxonRankValue(self, taxonRankValue):
        self.taxonRankValue = taxonRankValue
    def get_commonName(self):
        return self.commonName
    def set_commonName(self, commonName):
        self.commonName = commonName
    def add_commonName(self, value):
        self.commonName.append(value)
    def insert_commonName_at(self, index, value):
        self.commonName.insert(index, value)
    def replace_commonName_at(self, index, value):
        self.commonName[index] = value
    def get_taxonId(self):
        return self.taxonId
    def set_taxonId(self, taxonId):
        self.taxonId = taxonId
    def add_taxonId(self, value):
        self.taxonId.append(value)
    def insert_taxonId_at(self, index, value):
        self.taxonId.insert(index, value)
    def replace_taxonId_at(self, index, value):
        self.taxonId[index] = value
    def get_taxonomicClassification(self):
        return self.taxonomicClassification
    def set_taxonomicClassification(self, taxonomicClassification):
        self.taxonomicClassification = taxonomicClassification
    def add_taxonomicClassification(self, value):
        self.taxonomicClassification.append(value)
    def insert_taxonomicClassification_at(self, index, value):
        self.taxonomicClassification.insert(index, value)
    def replace_taxonomicClassification_at(self, index, value):
        self.taxonomicClassification[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def validate_IDType(self, value):
        # Validate type res:IDType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.taxonRankName is not None or
            self.taxonRankValue is not None or
            self.commonName or
            self.taxonId or
            self.taxonomicClassification
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='TaxonomicClassificationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TaxonomicClassificationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TaxonomicClassificationType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TaxonomicClassificationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TaxonomicClassificationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TaxonomicClassificationType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='TaxonomicClassificationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.taxonRankName is not None:
            namespaceprefix_ = self.taxonRankName_nsprefix_ + ':' if (UseCapturedNS_ and self.taxonRankName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%staxonRankName>%s</%staxonRankName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.taxonRankName), input_name='taxonRankName')), namespaceprefix_ , eol_))
        if self.taxonRankValue is not None:
            namespaceprefix_ = self.taxonRankValue_nsprefix_ + ':' if (UseCapturedNS_ and self.taxonRankValue_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%staxonRankValue>%s</%staxonRankValue>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.taxonRankValue), input_name='taxonRankValue')), namespaceprefix_ , eol_))
        for commonName_ in self.commonName:
            namespaceprefix_ = self.commonName_nsprefix_ + ':' if (UseCapturedNS_ and self.commonName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scommonName>%s</%scommonName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(commonName_), input_name='commonName')), namespaceprefix_ , eol_))
        for taxonId_ in self.taxonId:
            namespaceprefix_ = self.taxonId_nsprefix_ + ':' if (UseCapturedNS_ and self.taxonId_nsprefix_) else ''
            taxonId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='taxonId', pretty_print=pretty_print)
        for taxonomicClassification_ in self.taxonomicClassification:
            namespaceprefix_ = self.taxonomicClassification_nsprefix_ + ':' if (UseCapturedNS_ and self.taxonomicClassification_nsprefix_) else ''
            taxonomicClassification_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='taxonomicClassification', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_IDType(self.id)    # validate type IDType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'taxonRankName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'taxonRankName')
            value_ = self.gds_validate_string(value_, node, 'taxonRankName')
            self.taxonRankName = value_
            self.taxonRankName_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.taxonRankName)
        elif nodeName_ == 'taxonRankValue':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'taxonRankValue')
            value_ = self.gds_validate_string(value_, node, 'taxonRankValue')
            self.taxonRankValue = value_
            self.taxonRankValue_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.taxonRankValue)
        elif nodeName_ == 'commonName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'commonName')
            value_ = self.gds_validate_string(value_, node, 'commonName')
            self.commonName.append(value_)
            self.commonName_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.commonName[-1])
        elif nodeName_ == 'taxonId':
            obj_ = taxonIdType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.taxonId.append(obj_)
            obj_.original_tagname_ = 'taxonId'
        elif nodeName_ == 'taxonomicClassification':
            obj_ = TaxonomicClassificationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.taxonomicClassification.append(obj_)
            obj_.original_tagname_ = 'taxonomicClassification'
# end class TaxonomicClassificationType


class CitationType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'res:IDType', 0, 1, {'use': 'optional'}),
        MemberSpec_('system', 'res:SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('scope', 'res:ScopeType', 0, 1, {'use': 'optional'}),
        MemberSpec_('alternateIdentifier', 'alternateIdentifierType11', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'alternateIdentifier', 'type': 'alternateIdentifierType11'}, 21),
        MemberSpec_('shortName', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'shortName', 'type': 'xs:string'}, 21),
        MemberSpec_('title', 'i18nNonEmptyStringType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'title', 'type': 'i18nNonEmptyStringType'}, 21),
        MemberSpec_('creator', 'ResponsibleParty', 1, 0, {'maxOccurs': 'unbounded', 'name': 'creator', 'type': 'ResponsibleParty'}, 21),
        MemberSpec_('metadataProvider', 'ResponsibleParty', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'metadataProvider', 'type': 'ResponsibleParty'}, 21),
        MemberSpec_('associatedParty', 'associatedPartyType12', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'associatedParty', 'type': 'associatedPartyType12'}, 21),
        MemberSpec_('pubDate', 'yearDate', 0, 1, {'minOccurs': '0', 'name': 'pubDate', 'type': 'xs:string'}, 21),
        MemberSpec_('language', 'i18nNonEmptyStringType', 0, 1, {'minOccurs': '0', 'name': 'language', 'type': 'i18nNonEmptyStringType'}, 21),
        MemberSpec_('series', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'series', 'type': 'xs:string'}, 21),
        MemberSpec_('abstract', 'TextType', 0, 1, {'minOccurs': '0', 'name': 'abstract', 'type': 'TextType'}, 21),
        MemberSpec_('keywordSet', 'keywordSetType13', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'keywordSet', 'type': 'keywordSetType13'}, 21),
        MemberSpec_('additionalInfo', 'TextType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'additionalInfo', 'type': 'TextType'}, 21),
        MemberSpec_('intellectualRights', 'TextType', 0, 1, {'minOccurs': '0', 'name': 'intellectualRights', 'type': 'TextType'}, 21),
        MemberSpec_('licensed', 'LicenseType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'licensed', 'type': 'LicenseType'}, 21),
        MemberSpec_('distribution', 'DistributionType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'distribution', 'type': 'DistributionType'}, 21),
        MemberSpec_('coverage', 'Coverage', 0, 1, {'minOccurs': '0', 'name': 'coverage', 'type': 'Coverage'}, 21),
        MemberSpec_('annotation', 'SemanticAnnotation', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'annotation', 'type': 'SemanticAnnotation'}, 21),
        MemberSpec_('contact', 'ResponsibleParty', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'contact', 'type': 'ResponsibleParty'}, 21),
        MemberSpec_('article', 'Article', 0, 0, {'name': 'article', 'type': 'Article'}, 22),
        MemberSpec_('book', 'Book', 0, 0, {'name': 'book', 'type': 'Book'}, 22),
        MemberSpec_('chapter', 'Chapter', 0, 0, {'name': 'chapter', 'type': 'Chapter'}, 22),
        MemberSpec_('editedBook', 'Book', 0, 0, {'name': 'editedBook', 'type': 'Book'}, 22),
        MemberSpec_('manuscript', 'Manuscript', 0, 0, {'name': 'manuscript', 'type': 'Manuscript'}, 22),
        MemberSpec_('report', 'Report', 0, 0, {'name': 'report', 'type': 'Report'}, 22),
        MemberSpec_('thesis', 'Thesis', 0, 0, {'name': 'thesis', 'type': 'Thesis'}, 22),
        MemberSpec_('conferenceProceedings', 'ConferenceProceedings', 0, 0, {'name': 'conferenceProceedings', 'type': 'ConferenceProceedings'}, 22),
        MemberSpec_('personalCommunication', 'PersonalCommunication', 0, 0, {'name': 'personalCommunication', 'type': 'PersonalCommunication'}, 22),
        MemberSpec_('map', 'Map', 0, 0, {'name': 'map', 'type': 'Map'}, 22),
        MemberSpec_('generic', 'Generic', 0, 0, {'name': 'generic', 'type': 'Generic'}, 22),
        MemberSpec_('audioVisual', 'AudioVisual', 0, 0, {'name': 'audioVisual', 'type': 'AudioVisual'}, 22),
        MemberSpec_('presentation', 'Presentation', 0, 0, {'name': 'presentation', 'type': 'Presentation'}, 22),
        MemberSpec_('bibtex', 'xs:string', 0, 0, {'name': 'bibtex', 'type': 'xs:string'}, None),
        MemberSpec_('references', 'referencesType15', 0, 0, {'name': 'references', 'type': 'referencesType15'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, system=None, scope='document', alternateIdentifier=None, shortName=None, title=None, creator=None, metadataProvider=None, associatedParty=None, pubDate=None, language=None, series=None, abstract=None, keywordSet=None, additionalInfo=None, intellectualRights=None, licensed=None, distribution=None, coverage=None, annotation=None, contact=None, article=None, book=None, chapter=None, editedBook=None, manuscript=None, report=None, thesis=None, conferenceProceedings=None, personalCommunication=None, map=None, generic=None, audioVisual=None, presentation=None, bibtex=None, references=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.scope = _cast(None, scope)
        self.scope_nsprefix_ = None
        if alternateIdentifier is None:
            self.alternateIdentifier = []
        else:
            self.alternateIdentifier = alternateIdentifier
        self.alternateIdentifier_nsprefix_ = None
        self.shortName = shortName
        self.validate_NonEmptyStringType(self.shortName)
        self.shortName_nsprefix_ = None
        if title is None:
            self.title = []
        else:
            self.title = title
        self.title_nsprefix_ = None
        if creator is None:
            self.creator = []
        else:
            self.creator = creator
        self.creator_nsprefix_ = None
        if metadataProvider is None:
            self.metadataProvider = []
        else:
            self.metadataProvider = metadataProvider
        self.metadataProvider_nsprefix_ = None
        if associatedParty is None:
            self.associatedParty = []
        else:
            self.associatedParty = associatedParty
        self.associatedParty_nsprefix_ = None
        self.pubDate = pubDate
        self.validate_yearDate(self.pubDate)
        self.pubDate_nsprefix_ = None
        self.language = language
        self.language_nsprefix_ = None
        self.series = series
        self.validate_NonEmptyStringType(self.series)
        self.series_nsprefix_ = None
        self.abstract = abstract
        self.abstract_nsprefix_ = None
        if keywordSet is None:
            self.keywordSet = []
        else:
            self.keywordSet = keywordSet
        self.keywordSet_nsprefix_ = None
        if additionalInfo is None:
            self.additionalInfo = []
        else:
            self.additionalInfo = additionalInfo
        self.additionalInfo_nsprefix_ = None
        self.intellectualRights = intellectualRights
        self.intellectualRights_nsprefix_ = None
        if licensed is None:
            self.licensed = []
        else:
            self.licensed = licensed
        self.licensed_nsprefix_ = None
        if distribution is None:
            self.distribution = []
        else:
            self.distribution = distribution
        self.distribution_nsprefix_ = None
        self.coverage = coverage
        self.coverage_nsprefix_ = None
        if annotation is None:
            self.annotation = []
        else:
            self.annotation = annotation
        self.annotation_nsprefix_ = None
        if contact is None:
            self.contact = []
        else:
            self.contact = contact
        self.contact_nsprefix_ = None
        self.article = article
        self.article_nsprefix_ = None
        self.book = book
        self.book_nsprefix_ = None
        self.chapter = chapter
        self.chapter_nsprefix_ = None
        self.editedBook = editedBook
        self.editedBook_nsprefix_ = None
        self.manuscript = manuscript
        self.manuscript_nsprefix_ = None
        self.report = report
        self.report_nsprefix_ = None
        self.thesis = thesis
        self.thesis_nsprefix_ = None
        self.conferenceProceedings = conferenceProceedings
        self.conferenceProceedings_nsprefix_ = None
        self.personalCommunication = personalCommunication
        self.personalCommunication_nsprefix_ = None
        self.map = map
        self.map_nsprefix_ = None
        self.generic = generic
        self.generic_nsprefix_ = None
        self.audioVisual = audioVisual
        self.audioVisual_nsprefix_ = None
        self.presentation = presentation
        self.presentation_nsprefix_ = None
        self.bibtex = bibtex
        self.bibtex_nsprefix_ = None
        self.references = references
        self.references_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CitationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CitationType.subclass:
            return CitationType.subclass(*args_, **kwargs_)
        else:
            return CitationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_alternateIdentifier(self):
        return self.alternateIdentifier
    def set_alternateIdentifier(self, alternateIdentifier):
        self.alternateIdentifier = alternateIdentifier
    def add_alternateIdentifier(self, value):
        self.alternateIdentifier.append(value)
    def insert_alternateIdentifier_at(self, index, value):
        self.alternateIdentifier.insert(index, value)
    def replace_alternateIdentifier_at(self, index, value):
        self.alternateIdentifier[index] = value
    def get_shortName(self):
        return self.shortName
    def set_shortName(self, shortName):
        self.shortName = shortName
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def add_title(self, value):
        self.title.append(value)
    def insert_title_at(self, index, value):
        self.title.insert(index, value)
    def replace_title_at(self, index, value):
        self.title[index] = value
    def get_creator(self):
        return self.creator
    def set_creator(self, creator):
        self.creator = creator
    def add_creator(self, value):
        self.creator.append(value)
    def insert_creator_at(self, index, value):
        self.creator.insert(index, value)
    def replace_creator_at(self, index, value):
        self.creator[index] = value
    def get_metadataProvider(self):
        return self.metadataProvider
    def set_metadataProvider(self, metadataProvider):
        self.metadataProvider = metadataProvider
    def add_metadataProvider(self, value):
        self.metadataProvider.append(value)
    def insert_metadataProvider_at(self, index, value):
        self.metadataProvider.insert(index, value)
    def replace_metadataProvider_at(self, index, value):
        self.metadataProvider[index] = value
    def get_associatedParty(self):
        return self.associatedParty
    def set_associatedParty(self, associatedParty):
        self.associatedParty = associatedParty
    def add_associatedParty(self, value):
        self.associatedParty.append(value)
    def insert_associatedParty_at(self, index, value):
        self.associatedParty.insert(index, value)
    def replace_associatedParty_at(self, index, value):
        self.associatedParty[index] = value
    def get_pubDate(self):
        return self.pubDate
    def set_pubDate(self, pubDate):
        self.pubDate = pubDate
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_series(self):
        return self.series
    def set_series(self, series):
        self.series = series
    def get_abstract(self):
        return self.abstract
    def set_abstract(self, abstract):
        self.abstract = abstract
    def get_keywordSet(self):
        return self.keywordSet
    def set_keywordSet(self, keywordSet):
        self.keywordSet = keywordSet
    def add_keywordSet(self, value):
        self.keywordSet.append(value)
    def insert_keywordSet_at(self, index, value):
        self.keywordSet.insert(index, value)
    def replace_keywordSet_at(self, index, value):
        self.keywordSet[index] = value
    def get_additionalInfo(self):
        return self.additionalInfo
    def set_additionalInfo(self, additionalInfo):
        self.additionalInfo = additionalInfo
    def add_additionalInfo(self, value):
        self.additionalInfo.append(value)
    def insert_additionalInfo_at(self, index, value):
        self.additionalInfo.insert(index, value)
    def replace_additionalInfo_at(self, index, value):
        self.additionalInfo[index] = value
    def get_intellectualRights(self):
        return self.intellectualRights
    def set_intellectualRights(self, intellectualRights):
        self.intellectualRights = intellectualRights
    def get_licensed(self):
        return self.licensed
    def set_licensed(self, licensed):
        self.licensed = licensed
    def add_licensed(self, value):
        self.licensed.append(value)
    def insert_licensed_at(self, index, value):
        self.licensed.insert(index, value)
    def replace_licensed_at(self, index, value):
        self.licensed[index] = value
    def get_distribution(self):
        return self.distribution
    def set_distribution(self, distribution):
        self.distribution = distribution
    def add_distribution(self, value):
        self.distribution.append(value)
    def insert_distribution_at(self, index, value):
        self.distribution.insert(index, value)
    def replace_distribution_at(self, index, value):
        self.distribution[index] = value
    def get_coverage(self):
        return self.coverage
    def set_coverage(self, coverage):
        self.coverage = coverage
    def get_annotation(self):
        return self.annotation
    def set_annotation(self, annotation):
        self.annotation = annotation
    def add_annotation(self, value):
        self.annotation.append(value)
    def insert_annotation_at(self, index, value):
        self.annotation.insert(index, value)
    def replace_annotation_at(self, index, value):
        self.annotation[index] = value
    def get_contact(self):
        return self.contact
    def set_contact(self, contact):
        self.contact = contact
    def add_contact(self, value):
        self.contact.append(value)
    def insert_contact_at(self, index, value):
        self.contact.insert(index, value)
    def replace_contact_at(self, index, value):
        self.contact[index] = value
    def get_article(self):
        return self.article
    def set_article(self, article):
        self.article = article
    def get_book(self):
        return self.book
    def set_book(self, book):
        self.book = book
    def get_chapter(self):
        return self.chapter
    def set_chapter(self, chapter):
        self.chapter = chapter
    def get_editedBook(self):
        return self.editedBook
    def set_editedBook(self, editedBook):
        self.editedBook = editedBook
    def get_manuscript(self):
        return self.manuscript
    def set_manuscript(self, manuscript):
        self.manuscript = manuscript
    def get_report(self):
        return self.report
    def set_report(self, report):
        self.report = report
    def get_thesis(self):
        return self.thesis
    def set_thesis(self, thesis):
        self.thesis = thesis
    def get_conferenceProceedings(self):
        return self.conferenceProceedings
    def set_conferenceProceedings(self, conferenceProceedings):
        self.conferenceProceedings = conferenceProceedings
    def get_personalCommunication(self):
        return self.personalCommunication
    def set_personalCommunication(self, personalCommunication):
        self.personalCommunication = personalCommunication
    def get_map(self):
        return self.map
    def set_map(self, map):
        self.map = map
    def get_generic(self):
        return self.generic
    def set_generic(self, generic):
        self.generic = generic
    def get_audioVisual(self):
        return self.audioVisual
    def set_audioVisual(self, audioVisual):
        self.audioVisual = audioVisual
    def get_presentation(self):
        return self.presentation
    def set_presentation(self, presentation):
        self.presentation = presentation
    def get_bibtex(self):
        return self.bibtex
    def set_bibtex(self, bibtex):
        self.bibtex = bibtex
    def get_references(self):
        return self.references
    def set_references(self, references):
        self.references = references
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_scope(self):
        return self.scope
    def set_scope(self, scope):
        self.scope = scope
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def validate_yearDate(self, value):
        result = True
        # Validate type yearDate, a restriction on None.
        pass
        return result
    def validate_IDType(self, value):
        # Validate type res:IDType, a restriction on xs:string.
        pass
    def validate_SystemType(self, value):
        # Validate type res:SystemType, a restriction on xs:string.
        pass
    def validate_ScopeType(self, value):
        # Validate type res:ScopeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['system', 'document']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ScopeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.alternateIdentifier or
            self.shortName is not None or
            self.title or
            self.creator or
            self.metadataProvider or
            self.associatedParty or
            self.pubDate is not None or
            self.language is not None or
            self.series is not None or
            self.abstract is not None or
            self.keywordSet or
            self.additionalInfo or
            self.intellectualRights is not None or
            self.licensed or
            self.distribution or
            self.coverage is not None or
            self.annotation or
            self.contact or
            self.article is not None or
            self.book is not None or
            self.chapter is not None or
            self.editedBook is not None or
            self.manuscript is not None or
            self.report is not None or
            self.thesis is not None or
            self.conferenceProceedings is not None or
            self.personalCommunication is not None or
            self.map is not None or
            self.generic is not None or
            self.audioVisual is not None or
            self.presentation is not None or
            self.bibtex is not None or
            self.references is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0"  xmlns:rp="https://eml.ecoinformatics.org/party-2.2.0"  xmlns:txt="https://eml.ecoinformatics.org/text-2.2.0"  xmlns:cov="https://eml.ecoinformatics.org/coverage-2.2.0"  xmlns:sem="https://eml.ecoinformatics.org/semantics-2.2.0" ', name_='CitationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CitationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CitationType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CitationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CitationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CitationType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
        if self.scope != "document" and 'scope' not in already_processed:
            already_processed.add('scope')
            outfile.write(' scope=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.scope), input_name='scope')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0"  xmlns:rp="https://eml.ecoinformatics.org/party-2.2.0"  xmlns:txt="https://eml.ecoinformatics.org/text-2.2.0"  xmlns:cov="https://eml.ecoinformatics.org/coverage-2.2.0"  xmlns:sem="https://eml.ecoinformatics.org/semantics-2.2.0" ', name_='CitationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for alternateIdentifier_ in self.alternateIdentifier:
            namespaceprefix_ = self.alternateIdentifier_nsprefix_ + ':' if (UseCapturedNS_ and self.alternateIdentifier_nsprefix_) else ''
            alternateIdentifier_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='alternateIdentifier', pretty_print=pretty_print)
        if self.shortName is not None:
            namespaceprefix_ = self.shortName_nsprefix_ + ':' if (UseCapturedNS_ and self.shortName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sshortName>%s</%sshortName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.shortName), input_name='shortName')), namespaceprefix_ , eol_))
        for title_ in self.title:
            namespaceprefix_ = self.title_nsprefix_ + ':' if (UseCapturedNS_ and self.title_nsprefix_) else ''
            title_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='title', pretty_print=pretty_print)
        for creator_ in self.creator:
            namespaceprefix_ = self.creator_nsprefix_ + ':' if (UseCapturedNS_ and self.creator_nsprefix_) else ''
            creator_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='creator', pretty_print=pretty_print)
        for metadataProvider_ in self.metadataProvider:
            namespaceprefix_ = self.metadataProvider_nsprefix_ + ':' if (UseCapturedNS_ and self.metadataProvider_nsprefix_) else ''
            metadataProvider_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='metadataProvider', pretty_print=pretty_print)
        for associatedParty_ in self.associatedParty:
            namespaceprefix_ = self.associatedParty_nsprefix_ + ':' if (UseCapturedNS_ and self.associatedParty_nsprefix_) else ''
            associatedParty_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='associatedParty', pretty_print=pretty_print)
        if self.pubDate is not None:
            namespaceprefix_ = self.pubDate_nsprefix_ + ':' if (UseCapturedNS_ and self.pubDate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spubDate>%s</%spubDate>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pubDate), input_name='pubDate')), namespaceprefix_ , eol_))
        if self.language is not None:
            namespaceprefix_ = self.language_nsprefix_ + ':' if (UseCapturedNS_ and self.language_nsprefix_) else ''
            self.language.export(outfile, level, namespaceprefix_, namespacedef_='', name_='language', pretty_print=pretty_print)
        if self.series is not None:
            namespaceprefix_ = self.series_nsprefix_ + ':' if (UseCapturedNS_ and self.series_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sseries>%s</%sseries>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.series), input_name='series')), namespaceprefix_ , eol_))
        if self.abstract is not None:
            namespaceprefix_ = self.abstract_nsprefix_ + ':' if (UseCapturedNS_ and self.abstract_nsprefix_) else ''
            self.abstract.export(outfile, level, namespaceprefix_, namespacedef_='', name_='abstract', pretty_print=pretty_print)
        for keywordSet_ in self.keywordSet:
            namespaceprefix_ = self.keywordSet_nsprefix_ + ':' if (UseCapturedNS_ and self.keywordSet_nsprefix_) else ''
            keywordSet_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='keywordSet', pretty_print=pretty_print)
        for additionalInfo_ in self.additionalInfo:
            namespaceprefix_ = self.additionalInfo_nsprefix_ + ':' if (UseCapturedNS_ and self.additionalInfo_nsprefix_) else ''
            additionalInfo_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='additionalInfo', pretty_print=pretty_print)
        if self.intellectualRights is not None:
            namespaceprefix_ = self.intellectualRights_nsprefix_ + ':' if (UseCapturedNS_ and self.intellectualRights_nsprefix_) else ''
            self.intellectualRights.export(outfile, level, namespaceprefix_, namespacedef_='', name_='intellectualRights', pretty_print=pretty_print)
        for licensed_ in self.licensed:
            namespaceprefix_ = self.licensed_nsprefix_ + ':' if (UseCapturedNS_ and self.licensed_nsprefix_) else ''
            licensed_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='licensed', pretty_print=pretty_print)
        for distribution_ in self.distribution:
            namespaceprefix_ = self.distribution_nsprefix_ + ':' if (UseCapturedNS_ and self.distribution_nsprefix_) else ''
            distribution_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='distribution', pretty_print=pretty_print)
        if self.coverage is not None:
            namespaceprefix_ = self.coverage_nsprefix_ + ':' if (UseCapturedNS_ and self.coverage_nsprefix_) else ''
            self.coverage.export(outfile, level, namespaceprefix_, namespacedef_='', name_='coverage', pretty_print=pretty_print)
        for annotation_ in self.annotation:
            namespaceprefix_ = self.annotation_nsprefix_ + ':' if (UseCapturedNS_ and self.annotation_nsprefix_) else ''
            annotation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='annotation', pretty_print=pretty_print)
        for contact_ in self.contact:
            namespaceprefix_ = self.contact_nsprefix_ + ':' if (UseCapturedNS_ and self.contact_nsprefix_) else ''
            contact_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='contact', pretty_print=pretty_print)
        if self.article is not None:
            namespaceprefix_ = self.article_nsprefix_ + ':' if (UseCapturedNS_ and self.article_nsprefix_) else ''
            self.article.export(outfile, level, namespaceprefix_, namespacedef_='', name_='article', pretty_print=pretty_print)
        if self.book is not None:
            namespaceprefix_ = self.book_nsprefix_ + ':' if (UseCapturedNS_ and self.book_nsprefix_) else ''
            self.book.export(outfile, level, namespaceprefix_, namespacedef_='', name_='book', pretty_print=pretty_print)
        if self.chapter is not None:
            namespaceprefix_ = self.chapter_nsprefix_ + ':' if (UseCapturedNS_ and self.chapter_nsprefix_) else ''
            self.chapter.export(outfile, level, namespaceprefix_, namespacedef_='', name_='chapter', pretty_print=pretty_print)
        if self.editedBook is not None:
            namespaceprefix_ = self.editedBook_nsprefix_ + ':' if (UseCapturedNS_ and self.editedBook_nsprefix_) else ''
            self.editedBook.export(outfile, level, namespaceprefix_, namespacedef_='', name_='editedBook', pretty_print=pretty_print)
        if self.manuscript is not None:
            namespaceprefix_ = self.manuscript_nsprefix_ + ':' if (UseCapturedNS_ and self.manuscript_nsprefix_) else ''
            self.manuscript.export(outfile, level, namespaceprefix_, namespacedef_='', name_='manuscript', pretty_print=pretty_print)
        if self.report is not None:
            namespaceprefix_ = self.report_nsprefix_ + ':' if (UseCapturedNS_ and self.report_nsprefix_) else ''
            self.report.export(outfile, level, namespaceprefix_, namespacedef_='', name_='report', pretty_print=pretty_print)
        if self.thesis is not None:
            namespaceprefix_ = self.thesis_nsprefix_ + ':' if (UseCapturedNS_ and self.thesis_nsprefix_) else ''
            self.thesis.export(outfile, level, namespaceprefix_, namespacedef_='', name_='thesis', pretty_print=pretty_print)
        if self.conferenceProceedings is not None:
            namespaceprefix_ = self.conferenceProceedings_nsprefix_ + ':' if (UseCapturedNS_ and self.conferenceProceedings_nsprefix_) else ''
            self.conferenceProceedings.export(outfile, level, namespaceprefix_, namespacedef_='', name_='conferenceProceedings', pretty_print=pretty_print)
        if self.personalCommunication is not None:
            namespaceprefix_ = self.personalCommunication_nsprefix_ + ':' if (UseCapturedNS_ and self.personalCommunication_nsprefix_) else ''
            self.personalCommunication.export(outfile, level, namespaceprefix_, namespacedef_='', name_='personalCommunication', pretty_print=pretty_print)
        if self.map is not None:
            namespaceprefix_ = self.map_nsprefix_ + ':' if (UseCapturedNS_ and self.map_nsprefix_) else ''
            self.map.export(outfile, level, namespaceprefix_, namespacedef_='', name_='map', pretty_print=pretty_print)
        if self.generic is not None:
            namespaceprefix_ = self.generic_nsprefix_ + ':' if (UseCapturedNS_ and self.generic_nsprefix_) else ''
            self.generic.export(outfile, level, namespaceprefix_, namespacedef_='', name_='generic', pretty_print=pretty_print)
        if self.audioVisual is not None:
            namespaceprefix_ = self.audioVisual_nsprefix_ + ':' if (UseCapturedNS_ and self.audioVisual_nsprefix_) else ''
            self.audioVisual.export(outfile, level, namespaceprefix_, namespacedef_='', name_='audioVisual', pretty_print=pretty_print)
        if self.presentation is not None:
            namespaceprefix_ = self.presentation_nsprefix_ + ':' if (UseCapturedNS_ and self.presentation_nsprefix_) else ''
            self.presentation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='presentation', pretty_print=pretty_print)
        if self.bibtex is not None:
            namespaceprefix_ = self.bibtex_nsprefix_ + ':' if (UseCapturedNS_ and self.bibtex_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbibtex>%s</%sbibtex>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.bibtex), input_name='bibtex')), namespaceprefix_ , eol_))
        if self.references is not None:
            namespaceprefix_ = self.references_nsprefix_ + ':' if (UseCapturedNS_ and self.references_nsprefix_) else ''
            self.references.export(outfile, level, namespaceprefix_, namespacedef_='', name_='references', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_IDType(self.id)    # validate type IDType
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
        value = find_attr_value_('scope', node)
        if value is not None and 'scope' not in already_processed:
            already_processed.add('scope')
            self.scope = value
            self.validate_ScopeType(self.scope)    # validate type ScopeType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'alternateIdentifier':
            obj_ = alternateIdentifierType11.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.alternateIdentifier.append(obj_)
            obj_.original_tagname_ = 'alternateIdentifier'
        elif nodeName_ == 'shortName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'shortName')
            value_ = self.gds_validate_string(value_, node, 'shortName')
            self.shortName = value_
            self.shortName_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.shortName)
        elif nodeName_ == 'title':
            class_obj_ = self.get_class_obj_(child_, i18nNonEmptyStringType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.title.append(obj_)
            obj_.original_tagname_ = 'title'
        elif nodeName_ == 'creator':
            class_obj_ = self.get_class_obj_(child_, ResponsibleParty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.creator.append(obj_)
            obj_.original_tagname_ = 'creator'
        elif nodeName_ == 'metadataProvider':
            class_obj_ = self.get_class_obj_(child_, ResponsibleParty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.metadataProvider.append(obj_)
            obj_.original_tagname_ = 'metadataProvider'
        elif nodeName_ == 'associatedParty':
            obj_ = associatedPartyType12.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.associatedParty.append(obj_)
            obj_.original_tagname_ = 'associatedParty'
        elif nodeName_ == 'pubDate':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'pubDate')
            value_ = self.gds_validate_string(value_, node, 'pubDate')
            self.pubDate = value_
            self.pubDate_nsprefix_ = child_.prefix
            # validate type yearDate
            self.validate_yearDate(self.pubDate)
        elif nodeName_ == 'language':
            class_obj_ = self.get_class_obj_(child_, i18nNonEmptyStringType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.language = obj_
            obj_.original_tagname_ = 'language'
        elif nodeName_ == 'series':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'series')
            value_ = self.gds_validate_string(value_, node, 'series')
            self.series = value_
            self.series_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.series)
        elif nodeName_ == 'abstract':
            obj_ = TextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.abstract = obj_
            obj_.original_tagname_ = 'abstract'
        elif nodeName_ == 'keywordSet':
            obj_ = keywordSetType13.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.keywordSet.append(obj_)
            obj_.original_tagname_ = 'keywordSet'
        elif nodeName_ == 'additionalInfo':
            obj_ = TextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.additionalInfo.append(obj_)
            obj_.original_tagname_ = 'additionalInfo'
        elif nodeName_ == 'intellectualRights':
            obj_ = TextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.intellectualRights = obj_
            obj_.original_tagname_ = 'intellectualRights'
        elif nodeName_ == 'licensed':
            obj_ = LicenseType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.licensed.append(obj_)
            obj_.original_tagname_ = 'licensed'
        elif nodeName_ == 'distribution':
            obj_ = DistributionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.distribution.append(obj_)
            obj_.original_tagname_ = 'distribution'
        elif nodeName_ == 'coverage':
            obj_ = Coverage.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.coverage = obj_
            obj_.original_tagname_ = 'coverage'
        elif nodeName_ == 'annotation':
            class_obj_ = self.get_class_obj_(child_, SemanticAnnotation)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.annotation.append(obj_)
            obj_.original_tagname_ = 'annotation'
        elif nodeName_ == 'contact':
            class_obj_ = self.get_class_obj_(child_, ResponsibleParty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.contact.append(obj_)
            obj_.original_tagname_ = 'contact'
        elif nodeName_ == 'article':
            obj_ = Article.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.article = obj_
            obj_.original_tagname_ = 'article'
        elif nodeName_ == 'book':
            class_obj_ = self.get_class_obj_(child_, Book)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.book = obj_
            obj_.original_tagname_ = 'book'
        elif nodeName_ == 'chapter':
            class_obj_ = self.get_class_obj_(child_, Chapter)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.chapter = obj_
            obj_.original_tagname_ = 'chapter'
        elif nodeName_ == 'editedBook':
            class_obj_ = self.get_class_obj_(child_, Book)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.editedBook = obj_
            obj_.original_tagname_ = 'editedBook'
        elif nodeName_ == 'manuscript':
            obj_ = Manuscript.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.manuscript = obj_
            obj_.original_tagname_ = 'manuscript'
        elif nodeName_ == 'report':
            obj_ = Report.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.report = obj_
            obj_.original_tagname_ = 'report'
        elif nodeName_ == 'thesis':
            obj_ = Thesis.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.thesis = obj_
            obj_.original_tagname_ = 'thesis'
        elif nodeName_ == 'conferenceProceedings':
            obj_ = ConferenceProceedings.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.conferenceProceedings = obj_
            obj_.original_tagname_ = 'conferenceProceedings'
        elif nodeName_ == 'personalCommunication':
            obj_ = PersonalCommunication.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.personalCommunication = obj_
            obj_.original_tagname_ = 'personalCommunication'
        elif nodeName_ == 'map':
            obj_ = Map.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.map = obj_
            obj_.original_tagname_ = 'map'
        elif nodeName_ == 'generic':
            obj_ = Generic.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.generic = obj_
            obj_.original_tagname_ = 'generic'
        elif nodeName_ == 'audioVisual':
            obj_ = AudioVisual.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.audioVisual = obj_
            obj_.original_tagname_ = 'audioVisual'
        elif nodeName_ == 'presentation':
            obj_ = Presentation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.presentation = obj_
            obj_.original_tagname_ = 'presentation'
        elif nodeName_ == 'bibtex':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'bibtex')
            value_ = self.gds_validate_string(value_, node, 'bibtex')
            self.bibtex = value_
            self.bibtex_nsprefix_ = child_.prefix
        elif nodeName_ == 'references':
            obj_ = referencesType15.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.references = obj_
            obj_.original_tagname_ = 'references'
# end class CitationType


class Article(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('journal', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'journal', 'type': 'xs:string'}, None),
        MemberSpec_('volume', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'volume', 'type': 'xs:string'}, None),
        MemberSpec_('issue', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'issue', 'type': 'xs:string'}, None),
        MemberSpec_('pageRange', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'pageRange', 'type': 'xs:string'}, None),
        MemberSpec_('publisher', 'ResponsibleParty', 0, 1, {'minOccurs': '0', 'name': 'publisher', 'type': 'ResponsibleParty'}, None),
        MemberSpec_('publicationPlace', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'publicationPlace', 'type': 'xs:string'}, None),
        MemberSpec_('ISSN', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'ISSN', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, journal=None, volume=None, issue=None, pageRange=None, publisher=None, publicationPlace=None, ISSN=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.journal = journal
        self.validate_NonEmptyStringType(self.journal)
        self.journal_nsprefix_ = None
        self.volume = volume
        self.validate_NonEmptyStringType(self.volume)
        self.volume_nsprefix_ = None
        self.issue = issue
        self.validate_NonEmptyStringType(self.issue)
        self.issue_nsprefix_ = None
        self.pageRange = pageRange
        self.validate_NonEmptyStringType(self.pageRange)
        self.pageRange_nsprefix_ = None
        self.publisher = publisher
        self.publisher_nsprefix_ = None
        self.publicationPlace = publicationPlace
        self.validate_NonEmptyStringType(self.publicationPlace)
        self.publicationPlace_nsprefix_ = None
        self.ISSN = ISSN
        self.validate_NonEmptyStringType(self.ISSN)
        self.ISSN_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Article)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Article.subclass:
            return Article.subclass(*args_, **kwargs_)
        else:
            return Article(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_journal(self):
        return self.journal
    def set_journal(self, journal):
        self.journal = journal
    def get_volume(self):
        return self.volume
    def set_volume(self, volume):
        self.volume = volume
    def get_issue(self):
        return self.issue
    def set_issue(self, issue):
        self.issue = issue
    def get_pageRange(self):
        return self.pageRange
    def set_pageRange(self, pageRange):
        self.pageRange = pageRange
    def get_publisher(self):
        return self.publisher
    def set_publisher(self, publisher):
        self.publisher = publisher
    def get_publicationPlace(self):
        return self.publicationPlace
    def set_publicationPlace(self, publicationPlace):
        self.publicationPlace = publicationPlace
    def get_ISSN(self):
        return self.ISSN
    def set_ISSN(self, ISSN):
        self.ISSN = ISSN
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def hasContent_(self):
        if (
            self.journal is not None or
            self.volume is not None or
            self.issue is not None or
            self.pageRange is not None or
            self.publisher is not None or
            self.publicationPlace is not None or
            self.ISSN is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:rp="https://eml.ecoinformatics.org/party-2.2.0" ', name_='Article', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Article')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Article':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Article')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Article', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Article'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:rp="https://eml.ecoinformatics.org/party-2.2.0" ', name_='Article', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.journal is not None:
            namespaceprefix_ = self.journal_nsprefix_ + ':' if (UseCapturedNS_ and self.journal_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sjournal>%s</%sjournal>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.journal), input_name='journal')), namespaceprefix_ , eol_))
        if self.volume is not None:
            namespaceprefix_ = self.volume_nsprefix_ + ':' if (UseCapturedNS_ and self.volume_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svolume>%s</%svolume>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.volume), input_name='volume')), namespaceprefix_ , eol_))
        if self.issue is not None:
            namespaceprefix_ = self.issue_nsprefix_ + ':' if (UseCapturedNS_ and self.issue_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sissue>%s</%sissue>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.issue), input_name='issue')), namespaceprefix_ , eol_))
        if self.pageRange is not None:
            namespaceprefix_ = self.pageRange_nsprefix_ + ':' if (UseCapturedNS_ and self.pageRange_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spageRange>%s</%spageRange>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pageRange), input_name='pageRange')), namespaceprefix_ , eol_))
        if self.publisher is not None:
            namespaceprefix_ = self.publisher_nsprefix_ + ':' if (UseCapturedNS_ and self.publisher_nsprefix_) else ''
            self.publisher.export(outfile, level, namespaceprefix_, namespacedef_='', name_='publisher', pretty_print=pretty_print)
        if self.publicationPlace is not None:
            namespaceprefix_ = self.publicationPlace_nsprefix_ + ':' if (UseCapturedNS_ and self.publicationPlace_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spublicationPlace>%s</%spublicationPlace>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.publicationPlace), input_name='publicationPlace')), namespaceprefix_ , eol_))
        if self.ISSN is not None:
            namespaceprefix_ = self.ISSN_nsprefix_ + ':' if (UseCapturedNS_ and self.ISSN_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sISSN>%s</%sISSN>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ISSN), input_name='ISSN')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'journal':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'journal')
            value_ = self.gds_validate_string(value_, node, 'journal')
            self.journal = value_
            self.journal_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.journal)
        elif nodeName_ == 'volume':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'volume')
            value_ = self.gds_validate_string(value_, node, 'volume')
            self.volume = value_
            self.volume_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.volume)
        elif nodeName_ == 'issue':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'issue')
            value_ = self.gds_validate_string(value_, node, 'issue')
            self.issue = value_
            self.issue_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.issue)
        elif nodeName_ == 'pageRange':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'pageRange')
            value_ = self.gds_validate_string(value_, node, 'pageRange')
            self.pageRange = value_
            self.pageRange_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.pageRange)
        elif nodeName_ == 'publisher':
            class_obj_ = self.get_class_obj_(child_, ResponsibleParty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.publisher = obj_
            obj_.original_tagname_ = 'publisher'
        elif nodeName_ == 'publicationPlace':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'publicationPlace')
            value_ = self.gds_validate_string(value_, node, 'publicationPlace')
            self.publicationPlace = value_
            self.publicationPlace_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.publicationPlace)
        elif nodeName_ == 'ISSN':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ISSN')
            value_ = self.gds_validate_string(value_, node, 'ISSN')
            self.ISSN = value_
            self.ISSN_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.ISSN)
# end class Article


class Book(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('publisher', 'ResponsibleParty', 0, 0, {'name': 'publisher', 'type': 'ResponsibleParty'}, None),
        MemberSpec_('publicationPlace', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'publicationPlace', 'type': 'xs:string'}, None),
        MemberSpec_('edition', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'edition', 'type': 'xs:string'}, None),
        MemberSpec_('volume', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'volume', 'type': 'xs:string'}, None),
        MemberSpec_('numberOfVolumes', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'numberOfVolumes', 'type': 'xs:string'}, None),
        MemberSpec_('totalPages', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'totalPages', 'type': 'xs:string'}, None),
        MemberSpec_('totalFigures', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'totalFigures', 'type': 'xs:string'}, None),
        MemberSpec_('totalTables', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'totalTables', 'type': 'xs:string'}, None),
        MemberSpec_('ISBN', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'ISBN', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, publisher=None, publicationPlace=None, edition=None, volume=None, numberOfVolumes=None, totalPages=None, totalFigures=None, totalTables=None, ISBN=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.publisher = publisher
        self.publisher_nsprefix_ = None
        self.publicationPlace = publicationPlace
        self.validate_NonEmptyStringType(self.publicationPlace)
        self.publicationPlace_nsprefix_ = None
        self.edition = edition
        self.validate_NonEmptyStringType(self.edition)
        self.edition_nsprefix_ = None
        self.volume = volume
        self.validate_NonEmptyStringType(self.volume)
        self.volume_nsprefix_ = None
        self.numberOfVolumes = numberOfVolumes
        self.validate_NonEmptyStringType(self.numberOfVolumes)
        self.numberOfVolumes_nsprefix_ = None
        self.totalPages = totalPages
        self.validate_NonEmptyStringType(self.totalPages)
        self.totalPages_nsprefix_ = None
        self.totalFigures = totalFigures
        self.validate_NonEmptyStringType(self.totalFigures)
        self.totalFigures_nsprefix_ = None
        self.totalTables = totalTables
        self.validate_NonEmptyStringType(self.totalTables)
        self.totalTables_nsprefix_ = None
        self.ISBN = ISBN
        self.validate_NonEmptyStringType(self.ISBN)
        self.ISBN_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Book)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Book.subclass:
            return Book.subclass(*args_, **kwargs_)
        else:
            return Book(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_publisher(self):
        return self.publisher
    def set_publisher(self, publisher):
        self.publisher = publisher
    def get_publicationPlace(self):
        return self.publicationPlace
    def set_publicationPlace(self, publicationPlace):
        self.publicationPlace = publicationPlace
    def get_edition(self):
        return self.edition
    def set_edition(self, edition):
        self.edition = edition
    def get_volume(self):
        return self.volume
    def set_volume(self, volume):
        self.volume = volume
    def get_numberOfVolumes(self):
        return self.numberOfVolumes
    def set_numberOfVolumes(self, numberOfVolumes):
        self.numberOfVolumes = numberOfVolumes
    def get_totalPages(self):
        return self.totalPages
    def set_totalPages(self, totalPages):
        self.totalPages = totalPages
    def get_totalFigures(self):
        return self.totalFigures
    def set_totalFigures(self, totalFigures):
        self.totalFigures = totalFigures
    def get_totalTables(self):
        return self.totalTables
    def set_totalTables(self, totalTables):
        self.totalTables = totalTables
    def get_ISBN(self):
        return self.ISBN
    def set_ISBN(self, ISBN):
        self.ISBN = ISBN
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def hasContent_(self):
        if (
            self.publisher is not None or
            self.publicationPlace is not None or
            self.edition is not None or
            self.volume is not None or
            self.numberOfVolumes is not None or
            self.totalPages is not None or
            self.totalFigures is not None or
            self.totalTables is not None or
            self.ISBN is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:rp="https://eml.ecoinformatics.org/party-2.2.0"  xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='Book', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Book')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Book':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Book')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Book', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Book'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:rp="https://eml.ecoinformatics.org/party-2.2.0"  xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='Book', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.publisher is not None:
            namespaceprefix_ = self.publisher_nsprefix_ + ':' if (UseCapturedNS_ and self.publisher_nsprefix_) else ''
            self.publisher.export(outfile, level, namespaceprefix_, namespacedef_='', name_='publisher', pretty_print=pretty_print)
        if self.publicationPlace is not None:
            namespaceprefix_ = self.publicationPlace_nsprefix_ + ':' if (UseCapturedNS_ and self.publicationPlace_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spublicationPlace>%s</%spublicationPlace>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.publicationPlace), input_name='publicationPlace')), namespaceprefix_ , eol_))
        if self.edition is not None:
            namespaceprefix_ = self.edition_nsprefix_ + ':' if (UseCapturedNS_ and self.edition_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sedition>%s</%sedition>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.edition), input_name='edition')), namespaceprefix_ , eol_))
        if self.volume is not None:
            namespaceprefix_ = self.volume_nsprefix_ + ':' if (UseCapturedNS_ and self.volume_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svolume>%s</%svolume>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.volume), input_name='volume')), namespaceprefix_ , eol_))
        if self.numberOfVolumes is not None:
            namespaceprefix_ = self.numberOfVolumes_nsprefix_ + ':' if (UseCapturedNS_ and self.numberOfVolumes_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snumberOfVolumes>%s</%snumberOfVolumes>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.numberOfVolumes), input_name='numberOfVolumes')), namespaceprefix_ , eol_))
        if self.totalPages is not None:
            namespaceprefix_ = self.totalPages_nsprefix_ + ':' if (UseCapturedNS_ and self.totalPages_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stotalPages>%s</%stotalPages>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.totalPages), input_name='totalPages')), namespaceprefix_ , eol_))
        if self.totalFigures is not None:
            namespaceprefix_ = self.totalFigures_nsprefix_ + ':' if (UseCapturedNS_ and self.totalFigures_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stotalFigures>%s</%stotalFigures>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.totalFigures), input_name='totalFigures')), namespaceprefix_ , eol_))
        if self.totalTables is not None:
            namespaceprefix_ = self.totalTables_nsprefix_ + ':' if (UseCapturedNS_ and self.totalTables_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stotalTables>%s</%stotalTables>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.totalTables), input_name='totalTables')), namespaceprefix_ , eol_))
        if self.ISBN is not None:
            namespaceprefix_ = self.ISBN_nsprefix_ + ':' if (UseCapturedNS_ and self.ISBN_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sISBN>%s</%sISBN>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ISBN), input_name='ISBN')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'publisher':
            class_obj_ = self.get_class_obj_(child_, ResponsibleParty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.publisher = obj_
            obj_.original_tagname_ = 'publisher'
        elif nodeName_ == 'publicationPlace':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'publicationPlace')
            value_ = self.gds_validate_string(value_, node, 'publicationPlace')
            self.publicationPlace = value_
            self.publicationPlace_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.publicationPlace)
        elif nodeName_ == 'edition':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'edition')
            value_ = self.gds_validate_string(value_, node, 'edition')
            self.edition = value_
            self.edition_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.edition)
        elif nodeName_ == 'volume':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'volume')
            value_ = self.gds_validate_string(value_, node, 'volume')
            self.volume = value_
            self.volume_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.volume)
        elif nodeName_ == 'numberOfVolumes':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'numberOfVolumes')
            value_ = self.gds_validate_string(value_, node, 'numberOfVolumes')
            self.numberOfVolumes = value_
            self.numberOfVolumes_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.numberOfVolumes)
        elif nodeName_ == 'totalPages':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'totalPages')
            value_ = self.gds_validate_string(value_, node, 'totalPages')
            self.totalPages = value_
            self.totalPages_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.totalPages)
        elif nodeName_ == 'totalFigures':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'totalFigures')
            value_ = self.gds_validate_string(value_, node, 'totalFigures')
            self.totalFigures = value_
            self.totalFigures_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.totalFigures)
        elif nodeName_ == 'totalTables':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'totalTables')
            value_ = self.gds_validate_string(value_, node, 'totalTables')
            self.totalTables = value_
            self.totalTables_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.totalTables)
        elif nodeName_ == 'ISBN':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ISBN')
            value_ = self.gds_validate_string(value_, node, 'ISBN')
            self.ISBN = value_
            self.ISBN_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.ISBN)
# end class Book


class Chapter(Book):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('chapterNumber', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'chapterNumber', 'type': 'xs:string'}, None),
        MemberSpec_('editor', 'ResponsibleParty', 1, 0, {'maxOccurs': 'unbounded', 'name': 'editor', 'type': 'ResponsibleParty'}, None),
        MemberSpec_('bookTitle', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'bookTitle', 'type': 'xs:string'}, None),
        MemberSpec_('pageRange', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'pageRange', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = Book
    def __init__(self, publisher=None, publicationPlace=None, edition=None, volume=None, numberOfVolumes=None, totalPages=None, totalFigures=None, totalTables=None, ISBN=None, chapterNumber=None, editor=None, bookTitle=None, pageRange=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Chapter, self).__init__(publisher, publicationPlace, edition, volume, numberOfVolumes, totalPages, totalFigures, totalTables, ISBN, extensiontype_,  **kwargs_)
        self.chapterNumber = chapterNumber
        self.validate_NonEmptyStringType(self.chapterNumber)
        self.chapterNumber_nsprefix_ = None
        if editor is None:
            self.editor = []
        else:
            self.editor = editor
        self.editor_nsprefix_ = None
        self.bookTitle = bookTitle
        self.validate_NonEmptyStringType(self.bookTitle)
        self.bookTitle_nsprefix_ = None
        self.pageRange = pageRange
        self.validate_NonEmptyStringType(self.pageRange)
        self.pageRange_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Chapter)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Chapter.subclass:
            return Chapter.subclass(*args_, **kwargs_)
        else:
            return Chapter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_chapterNumber(self):
        return self.chapterNumber
    def set_chapterNumber(self, chapterNumber):
        self.chapterNumber = chapterNumber
    def get_editor(self):
        return self.editor
    def set_editor(self, editor):
        self.editor = editor
    def add_editor(self, value):
        self.editor.append(value)
    def insert_editor_at(self, index, value):
        self.editor.insert(index, value)
    def replace_editor_at(self, index, value):
        self.editor[index] = value
    def get_bookTitle(self):
        return self.bookTitle
    def set_bookTitle(self, bookTitle):
        self.bookTitle = bookTitle
    def get_pageRange(self):
        return self.pageRange
    def set_pageRange(self, pageRange):
        self.pageRange = pageRange
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def hasContent_(self):
        if (
            self.chapterNumber is not None or
            self.editor or
            self.bookTitle is not None or
            self.pageRange is not None or
            super(Chapter, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:rp="https://eml.ecoinformatics.org/party-2.2.0" ', name_='Chapter', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Chapter')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Chapter':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Chapter')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Chapter', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Chapter'):
        super(Chapter, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Chapter')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:rp="https://eml.ecoinformatics.org/party-2.2.0" ', name_='Chapter', fromsubclass_=False, pretty_print=True):
        super(Chapter, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.chapterNumber is not None:
            namespaceprefix_ = self.chapterNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.chapterNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%schapterNumber>%s</%schapterNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.chapterNumber), input_name='chapterNumber')), namespaceprefix_ , eol_))
        for editor_ in self.editor:
            namespaceprefix_ = self.editor_nsprefix_ + ':' if (UseCapturedNS_ and self.editor_nsprefix_) else ''
            editor_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='editor', pretty_print=pretty_print)
        if self.bookTitle is not None:
            namespaceprefix_ = self.bookTitle_nsprefix_ + ':' if (UseCapturedNS_ and self.bookTitle_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbookTitle>%s</%sbookTitle>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.bookTitle), input_name='bookTitle')), namespaceprefix_ , eol_))
        if self.pageRange is not None:
            namespaceprefix_ = self.pageRange_nsprefix_ + ':' if (UseCapturedNS_ and self.pageRange_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spageRange>%s</%spageRange>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pageRange), input_name='pageRange')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(Chapter, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'chapterNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'chapterNumber')
            value_ = self.gds_validate_string(value_, node, 'chapterNumber')
            self.chapterNumber = value_
            self.chapterNumber_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.chapterNumber)
        elif nodeName_ == 'editor':
            class_obj_ = self.get_class_obj_(child_, ResponsibleParty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.editor.append(obj_)
            obj_.original_tagname_ = 'editor'
        elif nodeName_ == 'bookTitle':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'bookTitle')
            value_ = self.gds_validate_string(value_, node, 'bookTitle')
            self.bookTitle = value_
            self.bookTitle_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.bookTitle)
        elif nodeName_ == 'pageRange':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'pageRange')
            value_ = self.gds_validate_string(value_, node, 'pageRange')
            self.pageRange = value_
            self.pageRange_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.pageRange)
        super(Chapter, self).buildChildren(child_, node, nodeName_, True)
# end class Chapter


class ConferenceProceedings(Chapter):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('conferenceName', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'conferenceName', 'type': 'xs:string'}, None),
        MemberSpec_('conferenceDate', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'conferenceDate', 'type': 'xs:string'}, None),
        MemberSpec_('conferenceLocation', 'Address', 0, 1, {'minOccurs': '0', 'name': 'conferenceLocation', 'type': 'Address'}, None),
    ]
    subclass = None
    superclass = Chapter
    def __init__(self, publisher=None, publicationPlace=None, edition=None, volume=None, numberOfVolumes=None, totalPages=None, totalFigures=None, totalTables=None, ISBN=None, chapterNumber=None, editor=None, bookTitle=None, pageRange=None, conferenceName=None, conferenceDate=None, conferenceLocation=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ConferenceProceedings, self).__init__(publisher, publicationPlace, edition, volume, numberOfVolumes, totalPages, totalFigures, totalTables, ISBN, chapterNumber, editor, bookTitle, pageRange,  **kwargs_)
        self.conferenceName = conferenceName
        self.validate_NonEmptyStringType(self.conferenceName)
        self.conferenceName_nsprefix_ = None
        self.conferenceDate = conferenceDate
        self.validate_NonEmptyStringType(self.conferenceDate)
        self.conferenceDate_nsprefix_ = None
        self.conferenceLocation = conferenceLocation
        self.conferenceLocation_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConferenceProceedings)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConferenceProceedings.subclass:
            return ConferenceProceedings.subclass(*args_, **kwargs_)
        else:
            return ConferenceProceedings(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_conferenceName(self):
        return self.conferenceName
    def set_conferenceName(self, conferenceName):
        self.conferenceName = conferenceName
    def get_conferenceDate(self):
        return self.conferenceDate
    def set_conferenceDate(self, conferenceDate):
        self.conferenceDate = conferenceDate
    def get_conferenceLocation(self):
        return self.conferenceLocation
    def set_conferenceLocation(self, conferenceLocation):
        self.conferenceLocation = conferenceLocation
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def hasContent_(self):
        if (
            self.conferenceName is not None or
            self.conferenceDate is not None or
            self.conferenceLocation is not None or
            super(ConferenceProceedings, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:rp="https://eml.ecoinformatics.org/party-2.2.0" ', name_='ConferenceProceedings', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ConferenceProceedings')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ConferenceProceedings':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ConferenceProceedings')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ConferenceProceedings', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ConferenceProceedings'):
        super(ConferenceProceedings, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ConferenceProceedings')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:rp="https://eml.ecoinformatics.org/party-2.2.0" ', name_='ConferenceProceedings', fromsubclass_=False, pretty_print=True):
        super(ConferenceProceedings, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.conferenceName is not None:
            namespaceprefix_ = self.conferenceName_nsprefix_ + ':' if (UseCapturedNS_ and self.conferenceName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sconferenceName>%s</%sconferenceName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.conferenceName), input_name='conferenceName')), namespaceprefix_ , eol_))
        if self.conferenceDate is not None:
            namespaceprefix_ = self.conferenceDate_nsprefix_ + ':' if (UseCapturedNS_ and self.conferenceDate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sconferenceDate>%s</%sconferenceDate>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.conferenceDate), input_name='conferenceDate')), namespaceprefix_ , eol_))
        if self.conferenceLocation is not None:
            namespaceprefix_ = self.conferenceLocation_nsprefix_ + ':' if (UseCapturedNS_ and self.conferenceLocation_nsprefix_) else ''
            self.conferenceLocation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='conferenceLocation', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ConferenceProceedings, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'conferenceName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'conferenceName')
            value_ = self.gds_validate_string(value_, node, 'conferenceName')
            self.conferenceName = value_
            self.conferenceName_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.conferenceName)
        elif nodeName_ == 'conferenceDate':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'conferenceDate')
            value_ = self.gds_validate_string(value_, node, 'conferenceDate')
            self.conferenceDate = value_
            self.conferenceDate_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.conferenceDate)
        elif nodeName_ == 'conferenceLocation':
            obj_ = Address.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.conferenceLocation = obj_
            obj_.original_tagname_ = 'conferenceLocation'
        super(ConferenceProceedings, self).buildChildren(child_, node, nodeName_, True)
# end class ConferenceProceedings


class Manuscript(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('institution', 'ResponsibleParty', 1, 0, {'maxOccurs': 'unbounded', 'name': 'institution', 'type': 'ResponsibleParty'}, None),
        MemberSpec_('totalPages', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'totalPages', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, institution=None, totalPages=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if institution is None:
            self.institution = []
        else:
            self.institution = institution
        self.institution_nsprefix_ = None
        self.totalPages = totalPages
        self.validate_NonEmptyStringType(self.totalPages)
        self.totalPages_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Manuscript)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Manuscript.subclass:
            return Manuscript.subclass(*args_, **kwargs_)
        else:
            return Manuscript(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_institution(self):
        return self.institution
    def set_institution(self, institution):
        self.institution = institution
    def add_institution(self, value):
        self.institution.append(value)
    def insert_institution_at(self, index, value):
        self.institution.insert(index, value)
    def replace_institution_at(self, index, value):
        self.institution[index] = value
    def get_totalPages(self):
        return self.totalPages
    def set_totalPages(self, totalPages):
        self.totalPages = totalPages
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def hasContent_(self):
        if (
            self.institution or
            self.totalPages is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:rp="https://eml.ecoinformatics.org/party-2.2.0"  xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='Manuscript', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Manuscript')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Manuscript':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Manuscript')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Manuscript', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Manuscript'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:rp="https://eml.ecoinformatics.org/party-2.2.0"  xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='Manuscript', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for institution_ in self.institution:
            namespaceprefix_ = self.institution_nsprefix_ + ':' if (UseCapturedNS_ and self.institution_nsprefix_) else ''
            institution_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='institution', pretty_print=pretty_print)
        if self.totalPages is not None:
            namespaceprefix_ = self.totalPages_nsprefix_ + ':' if (UseCapturedNS_ and self.totalPages_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stotalPages>%s</%stotalPages>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.totalPages), input_name='totalPages')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'institution':
            class_obj_ = self.get_class_obj_(child_, ResponsibleParty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.institution.append(obj_)
            obj_.original_tagname_ = 'institution'
        elif nodeName_ == 'totalPages':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'totalPages')
            value_ = self.gds_validate_string(value_, node, 'totalPages')
            self.totalPages = value_
            self.totalPages_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.totalPages)
# end class Manuscript


class Report(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('reportNumber', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'reportNumber', 'type': 'xs:string'}, None),
        MemberSpec_('publisher', 'ResponsibleParty', 0, 1, {'minOccurs': '0', 'name': 'publisher', 'type': 'ResponsibleParty'}, None),
        MemberSpec_('publicationPlace', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'publicationPlace', 'type': 'xs:string'}, None),
        MemberSpec_('totalPages', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'totalPages', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, reportNumber=None, publisher=None, publicationPlace=None, totalPages=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.reportNumber = reportNumber
        self.validate_NonEmptyStringType(self.reportNumber)
        self.reportNumber_nsprefix_ = None
        self.publisher = publisher
        self.publisher_nsprefix_ = None
        self.publicationPlace = publicationPlace
        self.validate_NonEmptyStringType(self.publicationPlace)
        self.publicationPlace_nsprefix_ = None
        self.totalPages = totalPages
        self.validate_NonEmptyStringType(self.totalPages)
        self.totalPages_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Report)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Report.subclass:
            return Report.subclass(*args_, **kwargs_)
        else:
            return Report(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_reportNumber(self):
        return self.reportNumber
    def set_reportNumber(self, reportNumber):
        self.reportNumber = reportNumber
    def get_publisher(self):
        return self.publisher
    def set_publisher(self, publisher):
        self.publisher = publisher
    def get_publicationPlace(self):
        return self.publicationPlace
    def set_publicationPlace(self, publicationPlace):
        self.publicationPlace = publicationPlace
    def get_totalPages(self):
        return self.totalPages
    def set_totalPages(self, totalPages):
        self.totalPages = totalPages
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def hasContent_(self):
        if (
            self.reportNumber is not None or
            self.publisher is not None or
            self.publicationPlace is not None or
            self.totalPages is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:rp="https://eml.ecoinformatics.org/party-2.2.0" ', name_='Report', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Report')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Report':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Report')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Report', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Report'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:rp="https://eml.ecoinformatics.org/party-2.2.0" ', name_='Report', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.reportNumber is not None:
            namespaceprefix_ = self.reportNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.reportNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sreportNumber>%s</%sreportNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.reportNumber), input_name='reportNumber')), namespaceprefix_ , eol_))
        if self.publisher is not None:
            namespaceprefix_ = self.publisher_nsprefix_ + ':' if (UseCapturedNS_ and self.publisher_nsprefix_) else ''
            self.publisher.export(outfile, level, namespaceprefix_, namespacedef_='', name_='publisher', pretty_print=pretty_print)
        if self.publicationPlace is not None:
            namespaceprefix_ = self.publicationPlace_nsprefix_ + ':' if (UseCapturedNS_ and self.publicationPlace_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spublicationPlace>%s</%spublicationPlace>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.publicationPlace), input_name='publicationPlace')), namespaceprefix_ , eol_))
        if self.totalPages is not None:
            namespaceprefix_ = self.totalPages_nsprefix_ + ':' if (UseCapturedNS_ and self.totalPages_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stotalPages>%s</%stotalPages>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.totalPages), input_name='totalPages')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'reportNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'reportNumber')
            value_ = self.gds_validate_string(value_, node, 'reportNumber')
            self.reportNumber = value_
            self.reportNumber_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.reportNumber)
        elif nodeName_ == 'publisher':
            class_obj_ = self.get_class_obj_(child_, ResponsibleParty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.publisher = obj_
            obj_.original_tagname_ = 'publisher'
        elif nodeName_ == 'publicationPlace':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'publicationPlace')
            value_ = self.gds_validate_string(value_, node, 'publicationPlace')
            self.publicationPlace = value_
            self.publicationPlace_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.publicationPlace)
        elif nodeName_ == 'totalPages':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'totalPages')
            value_ = self.gds_validate_string(value_, node, 'totalPages')
            self.totalPages = value_
            self.totalPages_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.totalPages)
# end class Report


class PersonalCommunication(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('publisher', 'ResponsibleParty', 0, 1, {'minOccurs': '0', 'name': 'publisher', 'type': 'ResponsibleParty'}, None),
        MemberSpec_('publicationPlace', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'publicationPlace', 'type': 'xs:string'}, None),
        MemberSpec_('communicationType', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'communicationType', 'type': 'xs:string'}, None),
        MemberSpec_('recipient', 'ResponsibleParty', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'recipient', 'type': 'ResponsibleParty'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, publisher=None, publicationPlace=None, communicationType=None, recipient=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.publisher = publisher
        self.publisher_nsprefix_ = None
        self.publicationPlace = publicationPlace
        self.validate_NonEmptyStringType(self.publicationPlace)
        self.publicationPlace_nsprefix_ = None
        self.communicationType = communicationType
        self.validate_NonEmptyStringType(self.communicationType)
        self.communicationType_nsprefix_ = None
        if recipient is None:
            self.recipient = []
        else:
            self.recipient = recipient
        self.recipient_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PersonalCommunication)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PersonalCommunication.subclass:
            return PersonalCommunication.subclass(*args_, **kwargs_)
        else:
            return PersonalCommunication(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_publisher(self):
        return self.publisher
    def set_publisher(self, publisher):
        self.publisher = publisher
    def get_publicationPlace(self):
        return self.publicationPlace
    def set_publicationPlace(self, publicationPlace):
        self.publicationPlace = publicationPlace
    def get_communicationType(self):
        return self.communicationType
    def set_communicationType(self, communicationType):
        self.communicationType = communicationType
    def get_recipient(self):
        return self.recipient
    def set_recipient(self, recipient):
        self.recipient = recipient
    def add_recipient(self, value):
        self.recipient.append(value)
    def insert_recipient_at(self, index, value):
        self.recipient.insert(index, value)
    def replace_recipient_at(self, index, value):
        self.recipient[index] = value
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def hasContent_(self):
        if (
            self.publisher is not None or
            self.publicationPlace is not None or
            self.communicationType is not None or
            self.recipient
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:rp="https://eml.ecoinformatics.org/party-2.2.0"  xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='PersonalCommunication', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PersonalCommunication')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PersonalCommunication':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PersonalCommunication')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PersonalCommunication', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PersonalCommunication'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:rp="https://eml.ecoinformatics.org/party-2.2.0"  xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='PersonalCommunication', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.publisher is not None:
            namespaceprefix_ = self.publisher_nsprefix_ + ':' if (UseCapturedNS_ and self.publisher_nsprefix_) else ''
            self.publisher.export(outfile, level, namespaceprefix_, namespacedef_='', name_='publisher', pretty_print=pretty_print)
        if self.publicationPlace is not None:
            namespaceprefix_ = self.publicationPlace_nsprefix_ + ':' if (UseCapturedNS_ and self.publicationPlace_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spublicationPlace>%s</%spublicationPlace>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.publicationPlace), input_name='publicationPlace')), namespaceprefix_ , eol_))
        if self.communicationType is not None:
            namespaceprefix_ = self.communicationType_nsprefix_ + ':' if (UseCapturedNS_ and self.communicationType_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scommunicationType>%s</%scommunicationType>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.communicationType), input_name='communicationType')), namespaceprefix_ , eol_))
        for recipient_ in self.recipient:
            namespaceprefix_ = self.recipient_nsprefix_ + ':' if (UseCapturedNS_ and self.recipient_nsprefix_) else ''
            recipient_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='recipient', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'publisher':
            class_obj_ = self.get_class_obj_(child_, ResponsibleParty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.publisher = obj_
            obj_.original_tagname_ = 'publisher'
        elif nodeName_ == 'publicationPlace':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'publicationPlace')
            value_ = self.gds_validate_string(value_, node, 'publicationPlace')
            self.publicationPlace = value_
            self.publicationPlace_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.publicationPlace)
        elif nodeName_ == 'communicationType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'communicationType')
            value_ = self.gds_validate_string(value_, node, 'communicationType')
            self.communicationType = value_
            self.communicationType_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.communicationType)
        elif nodeName_ == 'recipient':
            class_obj_ = self.get_class_obj_(child_, ResponsibleParty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.recipient.append(obj_)
            obj_.original_tagname_ = 'recipient'
# end class PersonalCommunication


class Map(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('publisher', 'ResponsibleParty', 0, 1, {'minOccurs': '0', 'name': 'publisher', 'type': 'ResponsibleParty'}, None),
        MemberSpec_('edition', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'edition', 'type': 'xs:string'}, None),
        MemberSpec_('geographicCoverage', 'GeographicCoverage', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'geographicCoverage', 'type': 'GeographicCoverage'}, None),
        MemberSpec_('scale', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'scale', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, publisher=None, edition=None, geographicCoverage=None, scale=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.publisher = publisher
        self.publisher_nsprefix_ = None
        self.edition = edition
        self.validate_NonEmptyStringType(self.edition)
        self.edition_nsprefix_ = None
        if geographicCoverage is None:
            self.geographicCoverage = []
        else:
            self.geographicCoverage = geographicCoverage
        self.geographicCoverage_nsprefix_ = None
        self.scale = scale
        self.validate_NonEmptyStringType(self.scale)
        self.scale_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Map)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Map.subclass:
            return Map.subclass(*args_, **kwargs_)
        else:
            return Map(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_publisher(self):
        return self.publisher
    def set_publisher(self, publisher):
        self.publisher = publisher
    def get_edition(self):
        return self.edition
    def set_edition(self, edition):
        self.edition = edition
    def get_geographicCoverage(self):
        return self.geographicCoverage
    def set_geographicCoverage(self, geographicCoverage):
        self.geographicCoverage = geographicCoverage
    def add_geographicCoverage(self, value):
        self.geographicCoverage.append(value)
    def insert_geographicCoverage_at(self, index, value):
        self.geographicCoverage.insert(index, value)
    def replace_geographicCoverage_at(self, index, value):
        self.geographicCoverage[index] = value
    def get_scale(self):
        return self.scale
    def set_scale(self, scale):
        self.scale = scale
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def hasContent_(self):
        if (
            self.publisher is not None or
            self.edition is not None or
            self.geographicCoverage or
            self.scale is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:rp="https://eml.ecoinformatics.org/party-2.2.0"  xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:cov="https://eml.ecoinformatics.org/coverage-2.2.0" ', name_='Map', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Map')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Map':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Map')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Map', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Map'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:rp="https://eml.ecoinformatics.org/party-2.2.0"  xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:cov="https://eml.ecoinformatics.org/coverage-2.2.0" ', name_='Map', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.publisher is not None:
            namespaceprefix_ = self.publisher_nsprefix_ + ':' if (UseCapturedNS_ and self.publisher_nsprefix_) else ''
            self.publisher.export(outfile, level, namespaceprefix_, namespacedef_='', name_='publisher', pretty_print=pretty_print)
        if self.edition is not None:
            namespaceprefix_ = self.edition_nsprefix_ + ':' if (UseCapturedNS_ and self.edition_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sedition>%s</%sedition>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.edition), input_name='edition')), namespaceprefix_ , eol_))
        for geographicCoverage_ in self.geographicCoverage:
            namespaceprefix_ = self.geographicCoverage_nsprefix_ + ':' if (UseCapturedNS_ and self.geographicCoverage_nsprefix_) else ''
            geographicCoverage_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='geographicCoverage', pretty_print=pretty_print)
        if self.scale is not None:
            namespaceprefix_ = self.scale_nsprefix_ + ':' if (UseCapturedNS_ and self.scale_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sscale>%s</%sscale>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.scale), input_name='scale')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'publisher':
            class_obj_ = self.get_class_obj_(child_, ResponsibleParty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.publisher = obj_
            obj_.original_tagname_ = 'publisher'
        elif nodeName_ == 'edition':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'edition')
            value_ = self.gds_validate_string(value_, node, 'edition')
            self.edition = value_
            self.edition_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.edition)
        elif nodeName_ == 'geographicCoverage':
            obj_ = GeographicCoverage.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.geographicCoverage.append(obj_)
            obj_.original_tagname_ = 'geographicCoverage'
        elif nodeName_ == 'scale':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'scale')
            value_ = self.gds_validate_string(value_, node, 'scale')
            self.scale = value_
            self.scale_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.scale)
# end class Map


class AudioVisual(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('publisher', 'ResponsibleParty', 0, 0, {'name': 'publisher', 'type': 'ResponsibleParty'}, None),
        MemberSpec_('publicationPlace', ['NonEmptyStringType', 'xs:string'], 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'publicationPlace', 'type': 'xs:string'}, None),
        MemberSpec_('performer', 'ResponsibleParty', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'performer', 'type': 'ResponsibleParty'}, None),
        MemberSpec_('ISBN', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'ISBN', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, publisher=None, publicationPlace=None, performer=None, ISBN=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.publisher = publisher
        self.publisher_nsprefix_ = None
        if publicationPlace is None:
            self.publicationPlace = []
        else:
            self.publicationPlace = publicationPlace
        self.publicationPlace_nsprefix_ = None
        if performer is None:
            self.performer = []
        else:
            self.performer = performer
        self.performer_nsprefix_ = None
        self.ISBN = ISBN
        self.validate_NonEmptyStringType(self.ISBN)
        self.ISBN_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AudioVisual)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AudioVisual.subclass:
            return AudioVisual.subclass(*args_, **kwargs_)
        else:
            return AudioVisual(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_publisher(self):
        return self.publisher
    def set_publisher(self, publisher):
        self.publisher = publisher
    def get_publicationPlace(self):
        return self.publicationPlace
    def set_publicationPlace(self, publicationPlace):
        self.publicationPlace = publicationPlace
    def add_publicationPlace(self, value):
        self.publicationPlace.append(value)
    def insert_publicationPlace_at(self, index, value):
        self.publicationPlace.insert(index, value)
    def replace_publicationPlace_at(self, index, value):
        self.publicationPlace[index] = value
    def get_performer(self):
        return self.performer
    def set_performer(self, performer):
        self.performer = performer
    def add_performer(self, value):
        self.performer.append(value)
    def insert_performer_at(self, index, value):
        self.performer.insert(index, value)
    def replace_performer_at(self, index, value):
        self.performer[index] = value
    def get_ISBN(self):
        return self.ISBN
    def set_ISBN(self, ISBN):
        self.ISBN = ISBN
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def hasContent_(self):
        if (
            self.publisher is not None or
            self.publicationPlace or
            self.performer or
            self.ISBN is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:rp="https://eml.ecoinformatics.org/party-2.2.0"  xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='AudioVisual', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AudioVisual')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AudioVisual':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AudioVisual')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AudioVisual', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AudioVisual'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:rp="https://eml.ecoinformatics.org/party-2.2.0"  xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='AudioVisual', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.publisher is not None:
            namespaceprefix_ = self.publisher_nsprefix_ + ':' if (UseCapturedNS_ and self.publisher_nsprefix_) else ''
            self.publisher.export(outfile, level, namespaceprefix_, namespacedef_='', name_='publisher', pretty_print=pretty_print)
        for publicationPlace_ in self.publicationPlace:
            namespaceprefix_ = self.publicationPlace_nsprefix_ + ':' if (UseCapturedNS_ and self.publicationPlace_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spublicationPlace>%s</%spublicationPlace>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(publicationPlace_), input_name='publicationPlace')), namespaceprefix_ , eol_))
        for performer_ in self.performer:
            namespaceprefix_ = self.performer_nsprefix_ + ':' if (UseCapturedNS_ and self.performer_nsprefix_) else ''
            performer_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='performer', pretty_print=pretty_print)
        if self.ISBN is not None:
            namespaceprefix_ = self.ISBN_nsprefix_ + ':' if (UseCapturedNS_ and self.ISBN_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sISBN>%s</%sISBN>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ISBN), input_name='ISBN')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'publisher':
            class_obj_ = self.get_class_obj_(child_, ResponsibleParty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.publisher = obj_
            obj_.original_tagname_ = 'publisher'
        elif nodeName_ == 'publicationPlace':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'publicationPlace')
            value_ = self.gds_validate_string(value_, node, 'publicationPlace')
            self.publicationPlace.append(value_)
            self.publicationPlace_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.publicationPlace[-1])
        elif nodeName_ == 'performer':
            class_obj_ = self.get_class_obj_(child_, ResponsibleParty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.performer.append(obj_)
            obj_.original_tagname_ = 'performer'
        elif nodeName_ == 'ISBN':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ISBN')
            value_ = self.gds_validate_string(value_, node, 'ISBN')
            self.ISBN = value_
            self.ISBN_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.ISBN)
# end class AudioVisual


class Generic(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('publisher', 'ResponsibleParty', 0, 0, {'name': 'publisher', 'type': 'ResponsibleParty'}, None),
        MemberSpec_('publicationPlace', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'publicationPlace', 'type': 'xs:string'}, None),
        MemberSpec_('referenceType', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'referenceType', 'type': 'xs:string'}, None),
        MemberSpec_('volume', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'volume', 'type': 'xs:string'}, None),
        MemberSpec_('numberOfVolumes', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'numberOfVolumes', 'type': 'xs:string'}, None),
        MemberSpec_('totalPages', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'totalPages', 'type': 'xs:string'}, None),
        MemberSpec_('totalFigures', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'totalFigures', 'type': 'xs:string'}, None),
        MemberSpec_('totalTables', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'totalTables', 'type': 'xs:string'}, None),
        MemberSpec_('edition', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'edition', 'type': 'xs:string'}, None),
        MemberSpec_('originalPublication', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'originalPublication', 'type': 'xs:string'}, None),
        MemberSpec_('reprintEdition', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'reprintEdition', 'type': 'xs:string'}, None),
        MemberSpec_('reviewedItem', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'reviewedItem', 'type': 'xs:string'}, None),
        MemberSpec_('ISBN', ['NonEmptyStringType', 'xs:string'], 0, 1, {'name': 'ISBN', 'type': 'xs:string'}, 23),
        MemberSpec_('ISSN', ['NonEmptyStringType', 'xs:string'], 0, 1, {'name': 'ISSN', 'type': 'xs:string'}, 23),
    ]
    subclass = None
    superclass = None
    def __init__(self, publisher=None, publicationPlace=None, referenceType=None, volume=None, numberOfVolumes=None, totalPages=None, totalFigures=None, totalTables=None, edition=None, originalPublication=None, reprintEdition=None, reviewedItem=None, ISBN=None, ISSN=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.publisher = publisher
        self.publisher_nsprefix_ = None
        self.publicationPlace = publicationPlace
        self.validate_NonEmptyStringType(self.publicationPlace)
        self.publicationPlace_nsprefix_ = None
        self.referenceType = referenceType
        self.referenceType_nsprefix_ = None
        self.volume = volume
        self.validate_NonEmptyStringType(self.volume)
        self.volume_nsprefix_ = None
        self.numberOfVolumes = numberOfVolumes
        self.validate_NonEmptyStringType(self.numberOfVolumes)
        self.numberOfVolumes_nsprefix_ = None
        self.totalPages = totalPages
        self.validate_NonEmptyStringType(self.totalPages)
        self.totalPages_nsprefix_ = None
        self.totalFigures = totalFigures
        self.validate_NonEmptyStringType(self.totalFigures)
        self.totalFigures_nsprefix_ = None
        self.totalTables = totalTables
        self.validate_NonEmptyStringType(self.totalTables)
        self.totalTables_nsprefix_ = None
        self.edition = edition
        self.validate_NonEmptyStringType(self.edition)
        self.edition_nsprefix_ = None
        self.originalPublication = originalPublication
        self.validate_NonEmptyStringType(self.originalPublication)
        self.originalPublication_nsprefix_ = None
        self.reprintEdition = reprintEdition
        self.validate_NonEmptyStringType(self.reprintEdition)
        self.reprintEdition_nsprefix_ = None
        self.reviewedItem = reviewedItem
        self.validate_NonEmptyStringType(self.reviewedItem)
        self.reviewedItem_nsprefix_ = None
        self.ISBN = ISBN
        self.validate_NonEmptyStringType(self.ISBN)
        self.ISBN_nsprefix_ = None
        self.ISSN = ISSN
        self.validate_NonEmptyStringType(self.ISSN)
        self.ISSN_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Generic)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Generic.subclass:
            return Generic.subclass(*args_, **kwargs_)
        else:
            return Generic(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_publisher(self):
        return self.publisher
    def set_publisher(self, publisher):
        self.publisher = publisher
    def get_publicationPlace(self):
        return self.publicationPlace
    def set_publicationPlace(self, publicationPlace):
        self.publicationPlace = publicationPlace
    def get_referenceType(self):
        return self.referenceType
    def set_referenceType(self, referenceType):
        self.referenceType = referenceType
    def get_volume(self):
        return self.volume
    def set_volume(self, volume):
        self.volume = volume
    def get_numberOfVolumes(self):
        return self.numberOfVolumes
    def set_numberOfVolumes(self, numberOfVolumes):
        self.numberOfVolumes = numberOfVolumes
    def get_totalPages(self):
        return self.totalPages
    def set_totalPages(self, totalPages):
        self.totalPages = totalPages
    def get_totalFigures(self):
        return self.totalFigures
    def set_totalFigures(self, totalFigures):
        self.totalFigures = totalFigures
    def get_totalTables(self):
        return self.totalTables
    def set_totalTables(self, totalTables):
        self.totalTables = totalTables
    def get_edition(self):
        return self.edition
    def set_edition(self, edition):
        self.edition = edition
    def get_originalPublication(self):
        return self.originalPublication
    def set_originalPublication(self, originalPublication):
        self.originalPublication = originalPublication
    def get_reprintEdition(self):
        return self.reprintEdition
    def set_reprintEdition(self, reprintEdition):
        self.reprintEdition = reprintEdition
    def get_reviewedItem(self):
        return self.reviewedItem
    def set_reviewedItem(self, reviewedItem):
        self.reviewedItem = reviewedItem
    def get_ISBN(self):
        return self.ISBN
    def set_ISBN(self, ISBN):
        self.ISBN = ISBN
    def get_ISSN(self):
        return self.ISSN
    def set_ISSN(self, ISSN):
        self.ISSN = ISSN
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def hasContent_(self):
        if (
            self.publisher is not None or
            self.publicationPlace is not None or
            self.referenceType is not None or
            self.volume is not None or
            self.numberOfVolumes is not None or
            self.totalPages is not None or
            self.totalFigures is not None or
            self.totalTables is not None or
            self.edition is not None or
            self.originalPublication is not None or
            self.reprintEdition is not None or
            self.reviewedItem is not None or
            self.ISBN is not None or
            self.ISSN is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:rp="https://eml.ecoinformatics.org/party-2.2.0"  xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='Generic', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Generic')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Generic':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Generic')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Generic', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Generic'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:rp="https://eml.ecoinformatics.org/party-2.2.0"  xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='Generic', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.publisher is not None:
            namespaceprefix_ = self.publisher_nsprefix_ + ':' if (UseCapturedNS_ and self.publisher_nsprefix_) else ''
            self.publisher.export(outfile, level, namespaceprefix_, namespacedef_='', name_='publisher', pretty_print=pretty_print)
        if self.publicationPlace is not None:
            namespaceprefix_ = self.publicationPlace_nsprefix_ + ':' if (UseCapturedNS_ and self.publicationPlace_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spublicationPlace>%s</%spublicationPlace>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.publicationPlace), input_name='publicationPlace')), namespaceprefix_ , eol_))
        if self.referenceType is not None:
            namespaceprefix_ = self.referenceType_nsprefix_ + ':' if (UseCapturedNS_ and self.referenceType_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sreferenceType>%s</%sreferenceType>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.referenceType), input_name='referenceType')), namespaceprefix_ , eol_))
        if self.volume is not None:
            namespaceprefix_ = self.volume_nsprefix_ + ':' if (UseCapturedNS_ and self.volume_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svolume>%s</%svolume>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.volume), input_name='volume')), namespaceprefix_ , eol_))
        if self.numberOfVolumes is not None:
            namespaceprefix_ = self.numberOfVolumes_nsprefix_ + ':' if (UseCapturedNS_ and self.numberOfVolumes_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snumberOfVolumes>%s</%snumberOfVolumes>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.numberOfVolumes), input_name='numberOfVolumes')), namespaceprefix_ , eol_))
        if self.totalPages is not None:
            namespaceprefix_ = self.totalPages_nsprefix_ + ':' if (UseCapturedNS_ and self.totalPages_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stotalPages>%s</%stotalPages>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.totalPages), input_name='totalPages')), namespaceprefix_ , eol_))
        if self.totalFigures is not None:
            namespaceprefix_ = self.totalFigures_nsprefix_ + ':' if (UseCapturedNS_ and self.totalFigures_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stotalFigures>%s</%stotalFigures>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.totalFigures), input_name='totalFigures')), namespaceprefix_ , eol_))
        if self.totalTables is not None:
            namespaceprefix_ = self.totalTables_nsprefix_ + ':' if (UseCapturedNS_ and self.totalTables_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stotalTables>%s</%stotalTables>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.totalTables), input_name='totalTables')), namespaceprefix_ , eol_))
        if self.edition is not None:
            namespaceprefix_ = self.edition_nsprefix_ + ':' if (UseCapturedNS_ and self.edition_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sedition>%s</%sedition>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.edition), input_name='edition')), namespaceprefix_ , eol_))
        if self.originalPublication is not None:
            namespaceprefix_ = self.originalPublication_nsprefix_ + ':' if (UseCapturedNS_ and self.originalPublication_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soriginalPublication>%s</%soriginalPublication>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.originalPublication), input_name='originalPublication')), namespaceprefix_ , eol_))
        if self.reprintEdition is not None:
            namespaceprefix_ = self.reprintEdition_nsprefix_ + ':' if (UseCapturedNS_ and self.reprintEdition_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sreprintEdition>%s</%sreprintEdition>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.reprintEdition), input_name='reprintEdition')), namespaceprefix_ , eol_))
        if self.reviewedItem is not None:
            namespaceprefix_ = self.reviewedItem_nsprefix_ + ':' if (UseCapturedNS_ and self.reviewedItem_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sreviewedItem>%s</%sreviewedItem>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.reviewedItem), input_name='reviewedItem')), namespaceprefix_ , eol_))
        if self.ISBN is not None:
            namespaceprefix_ = self.ISBN_nsprefix_ + ':' if (UseCapturedNS_ and self.ISBN_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sISBN>%s</%sISBN>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ISBN), input_name='ISBN')), namespaceprefix_ , eol_))
        if self.ISSN is not None:
            namespaceprefix_ = self.ISSN_nsprefix_ + ':' if (UseCapturedNS_ and self.ISSN_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sISSN>%s</%sISSN>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ISSN), input_name='ISSN')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'publisher':
            class_obj_ = self.get_class_obj_(child_, ResponsibleParty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.publisher = obj_
            obj_.original_tagname_ = 'publisher'
        elif nodeName_ == 'publicationPlace':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'publicationPlace')
            value_ = self.gds_validate_string(value_, node, 'publicationPlace')
            self.publicationPlace = value_
            self.publicationPlace_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.publicationPlace)
        elif nodeName_ == 'referenceType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'referenceType')
            value_ = self.gds_validate_string(value_, node, 'referenceType')
            self.referenceType = value_
            self.referenceType_nsprefix_ = child_.prefix
        elif nodeName_ == 'volume':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'volume')
            value_ = self.gds_validate_string(value_, node, 'volume')
            self.volume = value_
            self.volume_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.volume)
        elif nodeName_ == 'numberOfVolumes':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'numberOfVolumes')
            value_ = self.gds_validate_string(value_, node, 'numberOfVolumes')
            self.numberOfVolumes = value_
            self.numberOfVolumes_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.numberOfVolumes)
        elif nodeName_ == 'totalPages':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'totalPages')
            value_ = self.gds_validate_string(value_, node, 'totalPages')
            self.totalPages = value_
            self.totalPages_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.totalPages)
        elif nodeName_ == 'totalFigures':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'totalFigures')
            value_ = self.gds_validate_string(value_, node, 'totalFigures')
            self.totalFigures = value_
            self.totalFigures_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.totalFigures)
        elif nodeName_ == 'totalTables':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'totalTables')
            value_ = self.gds_validate_string(value_, node, 'totalTables')
            self.totalTables = value_
            self.totalTables_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.totalTables)
        elif nodeName_ == 'edition':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'edition')
            value_ = self.gds_validate_string(value_, node, 'edition')
            self.edition = value_
            self.edition_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.edition)
        elif nodeName_ == 'originalPublication':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'originalPublication')
            value_ = self.gds_validate_string(value_, node, 'originalPublication')
            self.originalPublication = value_
            self.originalPublication_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.originalPublication)
        elif nodeName_ == 'reprintEdition':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'reprintEdition')
            value_ = self.gds_validate_string(value_, node, 'reprintEdition')
            self.reprintEdition = value_
            self.reprintEdition_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.reprintEdition)
        elif nodeName_ == 'reviewedItem':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'reviewedItem')
            value_ = self.gds_validate_string(value_, node, 'reviewedItem')
            self.reviewedItem = value_
            self.reviewedItem_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.reviewedItem)
        elif nodeName_ == 'ISBN':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ISBN')
            value_ = self.gds_validate_string(value_, node, 'ISBN')
            self.ISBN = value_
            self.ISBN_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.ISBN)
        elif nodeName_ == 'ISSN':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ISSN')
            value_ = self.gds_validate_string(value_, node, 'ISSN')
            self.ISSN = value_
            self.ISSN_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.ISSN)
# end class Generic


class referenceType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, referenceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if referenceType.subclass:
            return referenceType.subclass(*args_, **kwargs_)
        else:
            return referenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referenceType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('referenceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'referenceType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='referenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='referenceType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='referenceType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referenceType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class referenceType


class Thesis(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('degree', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'degree', 'type': 'xs:string'}, None),
        MemberSpec_('institution', 'ResponsibleParty', 0, 0, {'name': 'institution', 'type': 'ResponsibleParty'}, None),
        MemberSpec_('totalPages', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'totalPages', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, degree=None, institution=None, totalPages=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.degree = degree
        self.validate_NonEmptyStringType(self.degree)
        self.degree_nsprefix_ = None
        self.institution = institution
        self.institution_nsprefix_ = None
        self.totalPages = totalPages
        self.validate_NonEmptyStringType(self.totalPages)
        self.totalPages_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Thesis)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Thesis.subclass:
            return Thesis.subclass(*args_, **kwargs_)
        else:
            return Thesis(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_degree(self):
        return self.degree
    def set_degree(self, degree):
        self.degree = degree
    def get_institution(self):
        return self.institution
    def set_institution(self, institution):
        self.institution = institution
    def get_totalPages(self):
        return self.totalPages
    def set_totalPages(self, totalPages):
        self.totalPages = totalPages
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def hasContent_(self):
        if (
            self.degree is not None or
            self.institution is not None or
            self.totalPages is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:rp="https://eml.ecoinformatics.org/party-2.2.0" ', name_='Thesis', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Thesis')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Thesis':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Thesis')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Thesis', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Thesis'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:rp="https://eml.ecoinformatics.org/party-2.2.0" ', name_='Thesis', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.degree is not None:
            namespaceprefix_ = self.degree_nsprefix_ + ':' if (UseCapturedNS_ and self.degree_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdegree>%s</%sdegree>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.degree), input_name='degree')), namespaceprefix_ , eol_))
        if self.institution is not None:
            namespaceprefix_ = self.institution_nsprefix_ + ':' if (UseCapturedNS_ and self.institution_nsprefix_) else ''
            self.institution.export(outfile, level, namespaceprefix_, namespacedef_='', name_='institution', pretty_print=pretty_print)
        if self.totalPages is not None:
            namespaceprefix_ = self.totalPages_nsprefix_ + ':' if (UseCapturedNS_ and self.totalPages_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stotalPages>%s</%stotalPages>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.totalPages), input_name='totalPages')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'degree':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'degree')
            value_ = self.gds_validate_string(value_, node, 'degree')
            self.degree = value_
            self.degree_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.degree)
        elif nodeName_ == 'institution':
            class_obj_ = self.get_class_obj_(child_, ResponsibleParty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.institution = obj_
            obj_.original_tagname_ = 'institution'
        elif nodeName_ == 'totalPages':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'totalPages')
            value_ = self.gds_validate_string(value_, node, 'totalPages')
            self.totalPages = value_
            self.totalPages_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.totalPages)
# end class Thesis


class Presentation(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('conferenceName', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'conferenceName', 'type': 'xs:string'}, None),
        MemberSpec_('conferenceDate', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'conferenceDate', 'type': 'xs:string'}, None),
        MemberSpec_('conferenceLocation', 'Address', 0, 1, {'minOccurs': '0', 'name': 'conferenceLocation', 'type': 'Address'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, conferenceName=None, conferenceDate=None, conferenceLocation=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.conferenceName = conferenceName
        self.validate_NonEmptyStringType(self.conferenceName)
        self.conferenceName_nsprefix_ = None
        self.conferenceDate = conferenceDate
        self.validate_NonEmptyStringType(self.conferenceDate)
        self.conferenceDate_nsprefix_ = None
        self.conferenceLocation = conferenceLocation
        self.conferenceLocation_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Presentation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Presentation.subclass:
            return Presentation.subclass(*args_, **kwargs_)
        else:
            return Presentation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_conferenceName(self):
        return self.conferenceName
    def set_conferenceName(self, conferenceName):
        self.conferenceName = conferenceName
    def get_conferenceDate(self):
        return self.conferenceDate
    def set_conferenceDate(self, conferenceDate):
        self.conferenceDate = conferenceDate
    def get_conferenceLocation(self):
        return self.conferenceLocation
    def set_conferenceLocation(self, conferenceLocation):
        self.conferenceLocation = conferenceLocation
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def hasContent_(self):
        if (
            self.conferenceName is not None or
            self.conferenceDate is not None or
            self.conferenceLocation is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:rp="https://eml.ecoinformatics.org/party-2.2.0" ', name_='Presentation', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Presentation')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Presentation':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Presentation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Presentation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Presentation'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:rp="https://eml.ecoinformatics.org/party-2.2.0" ', name_='Presentation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.conferenceName is not None:
            namespaceprefix_ = self.conferenceName_nsprefix_ + ':' if (UseCapturedNS_ and self.conferenceName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sconferenceName>%s</%sconferenceName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.conferenceName), input_name='conferenceName')), namespaceprefix_ , eol_))
        if self.conferenceDate is not None:
            namespaceprefix_ = self.conferenceDate_nsprefix_ + ':' if (UseCapturedNS_ and self.conferenceDate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sconferenceDate>%s</%sconferenceDate>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.conferenceDate), input_name='conferenceDate')), namespaceprefix_ , eol_))
        if self.conferenceLocation is not None:
            namespaceprefix_ = self.conferenceLocation_nsprefix_ + ':' if (UseCapturedNS_ and self.conferenceLocation_nsprefix_) else ''
            self.conferenceLocation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='conferenceLocation', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'conferenceName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'conferenceName')
            value_ = self.gds_validate_string(value_, node, 'conferenceName')
            self.conferenceName = value_
            self.conferenceName_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.conferenceName)
        elif nodeName_ == 'conferenceDate':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'conferenceDate')
            value_ = self.gds_validate_string(value_, node, 'conferenceDate')
            self.conferenceDate = value_
            self.conferenceDate_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.conferenceDate)
        elif nodeName_ == 'conferenceLocation':
            obj_ = Address.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.conferenceLocation = obj_
            obj_.original_tagname_ = 'conferenceLocation'
# end class Presentation


class CitationListType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('citation', 'CitationType', 1, 0, {'name': 'citation', 'type': 'CitationType'}, 24),
        MemberSpec_('bibtex', 'xs:string', 1, 0, {'name': 'bibtex', 'type': 'xs:string'}, 24),
    ]
    subclass = None
    superclass = None
    def __init__(self, citation=None, bibtex=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if citation is None:
            self.citation = []
        else:
            self.citation = citation
        self.citation_nsprefix_ = None
        if bibtex is None:
            self.bibtex = []
        else:
            self.bibtex = bibtex
        self.bibtex_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CitationListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CitationListType.subclass:
            return CitationListType.subclass(*args_, **kwargs_)
        else:
            return CitationListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_citation(self):
        return self.citation
    def set_citation(self, citation):
        self.citation = citation
    def add_citation(self, value):
        self.citation.append(value)
    def insert_citation_at(self, index, value):
        self.citation.insert(index, value)
    def replace_citation_at(self, index, value):
        self.citation[index] = value
    def get_bibtex(self):
        return self.bibtex
    def set_bibtex(self, bibtex):
        self.bibtex = bibtex
    def add_bibtex(self, value):
        self.bibtex.append(value)
    def insert_bibtex_at(self, index, value):
        self.bibtex.insert(index, value)
    def replace_bibtex_at(self, index, value):
        self.bibtex[index] = value
    def hasContent_(self):
        if (
            self.citation or
            self.bibtex
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='CitationListType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CitationListType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CitationListType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CitationListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CitationListType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CitationListType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='CitationListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for citation_ in self.citation:
            namespaceprefix_ = self.citation_nsprefix_ + ':' if (UseCapturedNS_ and self.citation_nsprefix_) else ''
            citation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='citation', pretty_print=pretty_print)
        for bibtex_ in self.bibtex:
            namespaceprefix_ = self.bibtex_nsprefix_ + ':' if (UseCapturedNS_ and self.bibtex_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbibtex>%s</%sbibtex>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(bibtex_), input_name='bibtex')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'citation':
            obj_ = CitationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.citation.append(obj_)
            obj_.original_tagname_ = 'citation'
        elif nodeName_ == 'bibtex':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'bibtex')
            value_ = self.gds_validate_string(value_, node, 'bibtex')
            self.bibtex.append(value_)
            self.bibtex_nsprefix_ = child_.prefix
# end class CitationListType


class AccessType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'res:IDType', 0, 1, {'use': 'optional'}),
        MemberSpec_('system', 'res:SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('scope', 'res:ScopeType', 0, 1, {'use': 'optional'}),
        MemberSpec_('order', 'orderType', 0, 1, {'use': 'optional'}),
        MemberSpec_('authSystem', 'xs:string', 0, 0, {'use': 'required'}),
        MemberSpec_('allow', 'AccessRule', 1, 0, {'name': 'allow', 'type': 'AccessRule'}, 26),
        MemberSpec_('deny', 'AccessRule', 1, 0, {'name': 'deny', 'type': 'AccessRule'}, 26),
        MemberSpec_('references', 'referencesType16', 0, 0, {'name': 'references', 'type': 'referencesType16'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, system=None, scope='document', order='allowFirst', authSystem=None, allow=None, deny=None, references=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.scope = _cast(None, scope)
        self.scope_nsprefix_ = None
        self.order = _cast(None, order)
        self.order_nsprefix_ = None
        self.authSystem = _cast(None, authSystem)
        self.authSystem_nsprefix_ = None
        if allow is None:
            self.allow = []
        else:
            self.allow = allow
        self.allow_nsprefix_ = None
        if deny is None:
            self.deny = []
        else:
            self.deny = deny
        self.deny_nsprefix_ = None
        self.references = references
        self.references_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AccessType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AccessType.subclass:
            return AccessType.subclass(*args_, **kwargs_)
        else:
            return AccessType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_allow(self):
        return self.allow
    def set_allow(self, allow):
        self.allow = allow
    def add_allow(self, value):
        self.allow.append(value)
    def insert_allow_at(self, index, value):
        self.allow.insert(index, value)
    def replace_allow_at(self, index, value):
        self.allow[index] = value
    def get_deny(self):
        return self.deny
    def set_deny(self, deny):
        self.deny = deny
    def add_deny(self, value):
        self.deny.append(value)
    def insert_deny_at(self, index, value):
        self.deny.insert(index, value)
    def replace_deny_at(self, index, value):
        self.deny[index] = value
    def get_references(self):
        return self.references
    def set_references(self, references):
        self.references = references
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_scope(self):
        return self.scope
    def set_scope(self, scope):
        self.scope = scope
    def get_order(self):
        return self.order
    def set_order(self, order):
        self.order = order
    def get_authSystem(self):
        return self.authSystem
    def set_authSystem(self, authSystem):
        self.authSystem = authSystem
    def validate_IDType(self, value):
        # Validate type res:IDType, a restriction on xs:string.
        pass
    def validate_SystemType(self, value):
        # Validate type res:SystemType, a restriction on xs:string.
        pass
    def validate_ScopeType(self, value):
        # Validate type res:ScopeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['system', 'document']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ScopeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_orderType(self, value):
        # Validate type orderType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['allowFirst', 'denyFirst']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on orderType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.allow or
            self.deny or
            self.references is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='AccessType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AccessType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AccessType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AccessType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AccessType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AccessType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
        if self.scope != "document" and 'scope' not in already_processed:
            already_processed.add('scope')
            outfile.write(' scope=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.scope), input_name='scope')), ))
        if self.order != "allowFirst" and 'order' not in already_processed:
            already_processed.add('order')
            outfile.write(' order=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.order), input_name='order')), ))
        if self.authSystem is not None and 'authSystem' not in already_processed:
            already_processed.add('authSystem')
            outfile.write(' authSystem=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.authSystem), input_name='authSystem')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='AccessType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for allow_ in self.allow:
            namespaceprefix_ = self.allow_nsprefix_ + ':' if (UseCapturedNS_ and self.allow_nsprefix_) else ''
            allow_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='allow', pretty_print=pretty_print)
        for deny_ in self.deny:
            namespaceprefix_ = self.deny_nsprefix_ + ':' if (UseCapturedNS_ and self.deny_nsprefix_) else ''
            deny_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='deny', pretty_print=pretty_print)
        if self.references is not None:
            namespaceprefix_ = self.references_nsprefix_ + ':' if (UseCapturedNS_ and self.references_nsprefix_) else ''
            self.references.export(outfile, level, namespaceprefix_, namespacedef_='', name_='references', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_IDType(self.id)    # validate type IDType
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
        value = find_attr_value_('scope', node)
        if value is not None and 'scope' not in already_processed:
            already_processed.add('scope')
            self.scope = value
            self.validate_ScopeType(self.scope)    # validate type ScopeType
        value = find_attr_value_('order', node)
        if value is not None and 'order' not in already_processed:
            already_processed.add('order')
            self.order = value
            self.validate_orderType(self.order)    # validate type orderType
        value = find_attr_value_('authSystem', node)
        if value is not None and 'authSystem' not in already_processed:
            already_processed.add('authSystem')
            self.authSystem = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'allow':
            obj_ = AccessRule.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.allow.append(obj_)
            obj_.original_tagname_ = 'allow'
        elif nodeName_ == 'deny':
            obj_ = AccessRule.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.deny.append(obj_)
            obj_.original_tagname_ = 'deny'
        elif nodeName_ == 'references':
            obj_ = referencesType16.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.references = obj_
            obj_.original_tagname_ = 'references'
# end class AccessType


class AccessRule(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('principal', ['NonEmptyStringType', 'xs:string'], 1, 0, {'maxOccurs': 'unbounded', 'name': 'principal', 'type': 'xs:string'}, None),
        MemberSpec_('permission', ['permissionType', 'xs:string'], 1, 0, {'maxOccurs': 'unbounded', 'name': 'permission', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, principal=None, permission=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if principal is None:
            self.principal = []
        else:
            self.principal = principal
        self.principal_nsprefix_ = None
        if permission is None:
            self.permission = []
        else:
            self.permission = permission
        self.permission_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AccessRule)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AccessRule.subclass:
            return AccessRule.subclass(*args_, **kwargs_)
        else:
            return AccessRule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_principal(self):
        return self.principal
    def set_principal(self, principal):
        self.principal = principal
    def add_principal(self, value):
        self.principal.append(value)
    def insert_principal_at(self, index, value):
        self.principal.insert(index, value)
    def replace_principal_at(self, index, value):
        self.principal[index] = value
    def get_permission(self):
        return self.permission
    def set_permission(self, permission):
        self.permission = permission
    def add_permission(self, value):
        self.permission.append(value)
    def insert_permission_at(self, index, value):
        self.permission.insert(index, value)
    def replace_permission_at(self, index, value):
        self.permission[index] = value
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def validate_permissionType(self, value):
        result = True
        # Validate type permissionType, a restriction on xs:string.
        pass
        return result
    def hasContent_(self):
        if (
            self.principal or
            self.permission
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='AccessRule', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AccessRule')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AccessRule':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AccessRule')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AccessRule', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AccessRule'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='AccessRule', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for principal_ in self.principal:
            namespaceprefix_ = self.principal_nsprefix_ + ':' if (UseCapturedNS_ and self.principal_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprincipal>%s</%sprincipal>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(principal_), input_name='principal')), namespaceprefix_ , eol_))
        for permission_ in self.permission:
            namespaceprefix_ = self.permission_nsprefix_ + ':' if (UseCapturedNS_ and self.permission_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spermission>%s</%spermission>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(permission_), input_name='permission')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'principal':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'principal')
            value_ = self.gds_validate_string(value_, node, 'principal')
            self.principal.append(value_)
            self.principal_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.principal[-1])
        elif nodeName_ == 'permission':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'permission')
            value_ = self.gds_validate_string(value_, node, 'permission')
            self.permission.append(value_)
            self.permission_nsprefix_ = child_.prefix
            # validate type permissionType
            self.validate_permissionType(self.permission[-1])
# end class AccessRule


class ResearchProjectType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'res:IDType', 0, 1, {'use': 'optional'}),
        MemberSpec_('system', 'res:SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('scope', 'res:ScopeType', 0, 1, {'use': 'optional'}),
        MemberSpec_('title', ['NonEmptyStringType', 'xs:string'], 1, 0, {'maxOccurs': 'unbounded', 'name': 'title', 'type': 'xs:string'}, 27),
        MemberSpec_('personnel', 'personnelType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'personnel', 'type': 'personnelType'}, 27),
        MemberSpec_('abstract', 'TextType', 0, 1, {'minOccurs': '0', 'name': 'abstract', 'type': 'TextType'}, 27),
        MemberSpec_('funding', 'TextType', 0, 1, {'minOccurs': '0', 'name': 'funding', 'type': 'TextType'}, 27),
        MemberSpec_('award', 'AwardType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'award', 'type': 'AwardType'}, 27),
        MemberSpec_('studyAreaDescription', 'studyAreaDescriptionType', 0, 1, {'minOccurs': '0', 'name': 'studyAreaDescription', 'type': 'studyAreaDescriptionType'}, 27),
        MemberSpec_('designDescription', 'designDescriptionType', 0, 1, {'minOccurs': '0', 'name': 'designDescription', 'type': 'designDescriptionType'}, 27),
        MemberSpec_('relatedProject', 'ResearchProjectType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'relatedProject', 'type': 'ResearchProjectType'}, 27),
        MemberSpec_('references', 'referencesType17', 0, 0, {'name': 'references', 'type': 'referencesType17'}, 27),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, system=None, scope='document', title=None, personnel=None, abstract=None, funding=None, award=None, studyAreaDescription=None, designDescription=None, relatedProject=None, references=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.scope = _cast(None, scope)
        self.scope_nsprefix_ = None
        if title is None:
            self.title = []
        else:
            self.title = title
        self.title_nsprefix_ = None
        if personnel is None:
            self.personnel = []
        else:
            self.personnel = personnel
        self.personnel_nsprefix_ = None
        self.abstract = abstract
        self.abstract_nsprefix_ = None
        self.funding = funding
        self.funding_nsprefix_ = None
        if award is None:
            self.award = []
        else:
            self.award = award
        self.award_nsprefix_ = None
        self.studyAreaDescription = studyAreaDescription
        self.studyAreaDescription_nsprefix_ = None
        self.designDescription = designDescription
        self.designDescription_nsprefix_ = None
        if relatedProject is None:
            self.relatedProject = []
        else:
            self.relatedProject = relatedProject
        self.relatedProject_nsprefix_ = None
        self.references = references
        self.references_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ResearchProjectType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ResearchProjectType.subclass:
            return ResearchProjectType.subclass(*args_, **kwargs_)
        else:
            return ResearchProjectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def add_title(self, value):
        self.title.append(value)
    def insert_title_at(self, index, value):
        self.title.insert(index, value)
    def replace_title_at(self, index, value):
        self.title[index] = value
    def get_personnel(self):
        return self.personnel
    def set_personnel(self, personnel):
        self.personnel = personnel
    def add_personnel(self, value):
        self.personnel.append(value)
    def insert_personnel_at(self, index, value):
        self.personnel.insert(index, value)
    def replace_personnel_at(self, index, value):
        self.personnel[index] = value
    def get_abstract(self):
        return self.abstract
    def set_abstract(self, abstract):
        self.abstract = abstract
    def get_funding(self):
        return self.funding
    def set_funding(self, funding):
        self.funding = funding
    def get_award(self):
        return self.award
    def set_award(self, award):
        self.award = award
    def add_award(self, value):
        self.award.append(value)
    def insert_award_at(self, index, value):
        self.award.insert(index, value)
    def replace_award_at(self, index, value):
        self.award[index] = value
    def get_studyAreaDescription(self):
        return self.studyAreaDescription
    def set_studyAreaDescription(self, studyAreaDescription):
        self.studyAreaDescription = studyAreaDescription
    def get_designDescription(self):
        return self.designDescription
    def set_designDescription(self, designDescription):
        self.designDescription = designDescription
    def get_relatedProject(self):
        return self.relatedProject
    def set_relatedProject(self, relatedProject):
        self.relatedProject = relatedProject
    def add_relatedProject(self, value):
        self.relatedProject.append(value)
    def insert_relatedProject_at(self, index, value):
        self.relatedProject.insert(index, value)
    def replace_relatedProject_at(self, index, value):
        self.relatedProject[index] = value
    def get_references(self):
        return self.references
    def set_references(self, references):
        self.references = references
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_scope(self):
        return self.scope
    def set_scope(self, scope):
        self.scope = scope
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def validate_IDType(self, value):
        # Validate type res:IDType, a restriction on xs:string.
        pass
    def validate_SystemType(self, value):
        # Validate type res:SystemType, a restriction on xs:string.
        pass
    def validate_ScopeType(self, value):
        # Validate type res:ScopeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['system', 'document']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ScopeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.title or
            self.personnel or
            self.abstract is not None or
            self.funding is not None or
            self.award or
            self.studyAreaDescription is not None or
            self.designDescription is not None or
            self.relatedProject or
            self.references is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:None="https://eml.ecoinformatics.org/view-2.2.0"  xmlns:txt="https://eml.ecoinformatics.org/text-2.2.0" ', name_='ResearchProjectType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ResearchProjectType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ResearchProjectType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ResearchProjectType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ResearchProjectType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ResearchProjectType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
        if self.scope != "document" and 'scope' not in already_processed:
            already_processed.add('scope')
            outfile.write(' scope=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.scope), input_name='scope')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:None="https://eml.ecoinformatics.org/view-2.2.0"  xmlns:txt="https://eml.ecoinformatics.org/text-2.2.0" ', name_='ResearchProjectType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for title_ in self.title:
            namespaceprefix_ = self.title_nsprefix_ + ':' if (UseCapturedNS_ and self.title_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stitle>%s</%stitle>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(title_), input_name='title')), namespaceprefix_ , eol_))
        for personnel_ in self.personnel:
            namespaceprefix_ = self.personnel_nsprefix_ + ':' if (UseCapturedNS_ and self.personnel_nsprefix_) else ''
            personnel_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='personnel', pretty_print=pretty_print)
        if self.abstract is not None:
            namespaceprefix_ = self.abstract_nsprefix_ + ':' if (UseCapturedNS_ and self.abstract_nsprefix_) else ''
            self.abstract.export(outfile, level, namespaceprefix_, namespacedef_='', name_='abstract', pretty_print=pretty_print)
        if self.funding is not None:
            namespaceprefix_ = self.funding_nsprefix_ + ':' if (UseCapturedNS_ and self.funding_nsprefix_) else ''
            self.funding.export(outfile, level, namespaceprefix_, namespacedef_='', name_='funding', pretty_print=pretty_print)
        for award_ in self.award:
            namespaceprefix_ = self.award_nsprefix_ + ':' if (UseCapturedNS_ and self.award_nsprefix_) else ''
            award_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='award', pretty_print=pretty_print)
        if self.studyAreaDescription is not None:
            namespaceprefix_ = self.studyAreaDescription_nsprefix_ + ':' if (UseCapturedNS_ and self.studyAreaDescription_nsprefix_) else ''
            self.studyAreaDescription.export(outfile, level, namespaceprefix_, namespacedef_='', name_='studyAreaDescription', pretty_print=pretty_print)
        if self.designDescription is not None:
            namespaceprefix_ = self.designDescription_nsprefix_ + ':' if (UseCapturedNS_ and self.designDescription_nsprefix_) else ''
            self.designDescription.export(outfile, level, namespaceprefix_, namespacedef_='', name_='designDescription', pretty_print=pretty_print)
        for relatedProject_ in self.relatedProject:
            namespaceprefix_ = self.relatedProject_nsprefix_ + ':' if (UseCapturedNS_ and self.relatedProject_nsprefix_) else ''
            relatedProject_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='relatedProject', pretty_print=pretty_print)
        if self.references is not None:
            namespaceprefix_ = self.references_nsprefix_ + ':' if (UseCapturedNS_ and self.references_nsprefix_) else ''
            self.references.export(outfile, level, namespaceprefix_, namespacedef_='', name_='references', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_IDType(self.id)    # validate type IDType
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
        value = find_attr_value_('scope', node)
        if value is not None and 'scope' not in already_processed:
            already_processed.add('scope')
            self.scope = value
            self.validate_ScopeType(self.scope)    # validate type ScopeType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'title':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'title')
            value_ = self.gds_validate_string(value_, node, 'title')
            self.title.append(value_)
            self.title_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.title[-1])
        elif nodeName_ == 'personnel':
            obj_ = personnelType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.personnel.append(obj_)
            obj_.original_tagname_ = 'personnel'
        elif nodeName_ == 'abstract':
            obj_ = TextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.abstract = obj_
            obj_.original_tagname_ = 'abstract'
        elif nodeName_ == 'funding':
            obj_ = TextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.funding = obj_
            obj_.original_tagname_ = 'funding'
        elif nodeName_ == 'award':
            obj_ = AwardType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.award.append(obj_)
            obj_.original_tagname_ = 'award'
        elif nodeName_ == 'studyAreaDescription':
            obj_ = studyAreaDescriptionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.studyAreaDescription = obj_
            obj_.original_tagname_ = 'studyAreaDescription'
        elif nodeName_ == 'designDescription':
            obj_ = designDescriptionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.designDescription = obj_
            obj_.original_tagname_ = 'designDescription'
        elif nodeName_ == 'relatedProject':
            obj_ = ResearchProjectType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.relatedProject.append(obj_)
            obj_.original_tagname_ = 'relatedProject'
        elif nodeName_ == 'references':
            obj_ = referencesType17.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.references = obj_
            obj_.original_tagname_ = 'references'
# end class ResearchProjectType


class AwardType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('funderName', 'i18nNonEmptyStringType', 0, 0, {'maxOccurs': '1', 'minOccurs': '1', 'name': 'funderName', 'type': 'i18nNonEmptyStringType'}, None),
        MemberSpec_('funderIdentifier', 'i18nNonEmptyStringType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'funderIdentifier', 'type': 'i18nNonEmptyStringType'}, None),
        MemberSpec_('awardNumber', 'i18nNonEmptyStringType', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'awardNumber', 'type': 'i18nNonEmptyStringType'}, None),
        MemberSpec_('title', 'i18nNonEmptyStringType', 0, 0, {'maxOccurs': '1', 'minOccurs': '1', 'name': 'title', 'type': 'i18nNonEmptyStringType'}, None),
        MemberSpec_('awardUrl', 'i18nNonEmptyStringType', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'awardUrl', 'type': 'i18nNonEmptyStringType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, funderName=None, funderIdentifier=None, awardNumber=None, title=None, awardUrl=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.funderName = funderName
        self.funderName_nsprefix_ = None
        if funderIdentifier is None:
            self.funderIdentifier = []
        else:
            self.funderIdentifier = funderIdentifier
        self.funderIdentifier_nsprefix_ = None
        self.awardNumber = awardNumber
        self.awardNumber_nsprefix_ = None
        self.title = title
        self.title_nsprefix_ = None
        self.awardUrl = awardUrl
        self.awardUrl_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AwardType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AwardType.subclass:
            return AwardType.subclass(*args_, **kwargs_)
        else:
            return AwardType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_funderName(self):
        return self.funderName
    def set_funderName(self, funderName):
        self.funderName = funderName
    def get_funderIdentifier(self):
        return self.funderIdentifier
    def set_funderIdentifier(self, funderIdentifier):
        self.funderIdentifier = funderIdentifier
    def add_funderIdentifier(self, value):
        self.funderIdentifier.append(value)
    def insert_funderIdentifier_at(self, index, value):
        self.funderIdentifier.insert(index, value)
    def replace_funderIdentifier_at(self, index, value):
        self.funderIdentifier[index] = value
    def get_awardNumber(self):
        return self.awardNumber
    def set_awardNumber(self, awardNumber):
        self.awardNumber = awardNumber
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_awardUrl(self):
        return self.awardUrl
    def set_awardUrl(self, awardUrl):
        self.awardUrl = awardUrl
    def hasContent_(self):
        if (
            self.funderName is not None or
            self.funderIdentifier or
            self.awardNumber is not None or
            self.title is not None or
            self.awardUrl is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='AwardType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AwardType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AwardType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AwardType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AwardType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AwardType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='AwardType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.funderName is not None:
            namespaceprefix_ = self.funderName_nsprefix_ + ':' if (UseCapturedNS_ and self.funderName_nsprefix_) else ''
            self.funderName.export(outfile, level, namespaceprefix_, namespacedef_='', name_='funderName', pretty_print=pretty_print)
        for funderIdentifier_ in self.funderIdentifier:
            namespaceprefix_ = self.funderIdentifier_nsprefix_ + ':' if (UseCapturedNS_ and self.funderIdentifier_nsprefix_) else ''
            funderIdentifier_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='funderIdentifier', pretty_print=pretty_print)
        if self.awardNumber is not None:
            namespaceprefix_ = self.awardNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.awardNumber_nsprefix_) else ''
            self.awardNumber.export(outfile, level, namespaceprefix_, namespacedef_='', name_='awardNumber', pretty_print=pretty_print)
        if self.title is not None:
            namespaceprefix_ = self.title_nsprefix_ + ':' if (UseCapturedNS_ and self.title_nsprefix_) else ''
            self.title.export(outfile, level, namespaceprefix_, namespacedef_='', name_='title', pretty_print=pretty_print)
        if self.awardUrl is not None:
            namespaceprefix_ = self.awardUrl_nsprefix_ + ':' if (UseCapturedNS_ and self.awardUrl_nsprefix_) else ''
            self.awardUrl.export(outfile, level, namespaceprefix_, namespacedef_='', name_='awardUrl', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'funderName':
            class_obj_ = self.get_class_obj_(child_, i18nNonEmptyStringType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.funderName = obj_
            obj_.original_tagname_ = 'funderName'
        elif nodeName_ == 'funderIdentifier':
            class_obj_ = self.get_class_obj_(child_, i18nNonEmptyStringType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.funderIdentifier.append(obj_)
            obj_.original_tagname_ = 'funderIdentifier'
        elif nodeName_ == 'awardNumber':
            class_obj_ = self.get_class_obj_(child_, i18nNonEmptyStringType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.awardNumber = obj_
            obj_.original_tagname_ = 'awardNumber'
        elif nodeName_ == 'title':
            class_obj_ = self.get_class_obj_(child_, i18nNonEmptyStringType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.title = obj_
            obj_.original_tagname_ = 'title'
        elif nodeName_ == 'awardUrl':
            class_obj_ = self.get_class_obj_(child_, i18nNonEmptyStringType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.awardUrl = obj_
            obj_.original_tagname_ = 'awardUrl'
# end class AwardType


class SemanticAnnotation(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'res:IDType', 0, 1, {'use': 'optional'}),
        MemberSpec_('system', 'res:SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('scope', 'res:ScopeType', 0, 1, {'use': 'optional'}),
        MemberSpec_('propertyURI', 'propertyURIType', 0, 0, {'maxOccurs': '1', 'minOccurs': '1', 'name': 'propertyURI', 'type': 'propertyURIType'}, None),
        MemberSpec_('valueURI', 'valueURIType', 0, 0, {'maxOccurs': '1', 'minOccurs': '1', 'name': 'valueURI', 'type': 'valueURIType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, system=None, scope='document', propertyURI=None, valueURI=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.scope = _cast(None, scope)
        self.scope_nsprefix_ = None
        self.propertyURI = propertyURI
        self.propertyURI_nsprefix_ = None
        self.valueURI = valueURI
        self.valueURI_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SemanticAnnotation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SemanticAnnotation.subclass:
            return SemanticAnnotation.subclass(*args_, **kwargs_)
        else:
            return SemanticAnnotation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_propertyURI(self):
        return self.propertyURI
    def set_propertyURI(self, propertyURI):
        self.propertyURI = propertyURI
    def get_valueURI(self):
        return self.valueURI
    def set_valueURI(self, valueURI):
        self.valueURI = valueURI
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_scope(self):
        return self.scope
    def set_scope(self, scope):
        self.scope = scope
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_IDType(self, value):
        # Validate type res:IDType, a restriction on xs:string.
        pass
    def validate_SystemType(self, value):
        # Validate type res:SystemType, a restriction on xs:string.
        pass
    def validate_ScopeType(self, value):
        # Validate type res:ScopeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['system', 'document']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ScopeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.propertyURI is not None or
            self.valueURI is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='SemanticAnnotation', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SemanticAnnotation')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SemanticAnnotation':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SemanticAnnotation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SemanticAnnotation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SemanticAnnotation'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
        if self.scope != "document" and 'scope' not in already_processed:
            already_processed.add('scope')
            outfile.write(' scope=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.scope), input_name='scope')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='SemanticAnnotation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.propertyURI is not None:
            namespaceprefix_ = self.propertyURI_nsprefix_ + ':' if (UseCapturedNS_ and self.propertyURI_nsprefix_) else ''
            self.propertyURI.export(outfile, level, namespaceprefix_, namespacedef_='', name_='propertyURI', pretty_print=pretty_print)
        if self.valueURI is not None:
            namespaceprefix_ = self.valueURI_nsprefix_ + ':' if (UseCapturedNS_ and self.valueURI_nsprefix_) else ''
            self.valueURI.export(outfile, level, namespaceprefix_, namespacedef_='', name_='valueURI', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_IDType(self.id)    # validate type IDType
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
        value = find_attr_value_('scope', node)
        if value is not None and 'scope' not in already_processed:
            already_processed.add('scope')
            self.scope = value
            self.validate_ScopeType(self.scope)    # validate type ScopeType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'propertyURI':
            obj_ = propertyURIType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.propertyURI = obj_
            obj_.original_tagname_ = 'propertyURI'
        elif nodeName_ == 'valueURI':
            obj_ = valueURIType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.valueURI = obj_
            obj_.original_tagname_ = 'valueURI'
# end class SemanticAnnotation


class DatasetType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'res:IDType', 0, 1, {'use': 'optional'}),
        MemberSpec_('system', 'res:SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('scope', 'res:ScopeType', 0, 1, {'use': 'optional'}),
        MemberSpec_('alternateIdentifier', 'alternateIdentifierType18', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'alternateIdentifier', 'type': 'alternateIdentifierType18'}, 28),
        MemberSpec_('shortName', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'shortName', 'type': 'xs:string'}, 28),
        MemberSpec_('title', 'i18nNonEmptyStringType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'title', 'type': 'i18nNonEmptyStringType'}, 28),
        MemberSpec_('creator', 'ResponsibleParty', 1, 0, {'maxOccurs': 'unbounded', 'name': 'creator', 'type': 'ResponsibleParty'}, 28),
        MemberSpec_('metadataProvider', 'ResponsibleParty', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'metadataProvider', 'type': 'ResponsibleParty'}, 28),
        MemberSpec_('associatedParty', 'associatedPartyType19', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'associatedParty', 'type': 'associatedPartyType19'}, 28),
        MemberSpec_('pubDate', 'yearDate', 0, 1, {'minOccurs': '0', 'name': 'pubDate', 'type': 'xs:string'}, 28),
        MemberSpec_('language', 'i18nNonEmptyStringType', 0, 1, {'minOccurs': '0', 'name': 'language', 'type': 'i18nNonEmptyStringType'}, 28),
        MemberSpec_('series', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'series', 'type': 'xs:string'}, 28),
        MemberSpec_('abstract', 'TextType', 0, 1, {'minOccurs': '0', 'name': 'abstract', 'type': 'TextType'}, 28),
        MemberSpec_('keywordSet', 'keywordSetType20', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'keywordSet', 'type': 'keywordSetType20'}, 28),
        MemberSpec_('additionalInfo', 'TextType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'additionalInfo', 'type': 'TextType'}, 28),
        MemberSpec_('intellectualRights', 'TextType', 0, 1, {'minOccurs': '0', 'name': 'intellectualRights', 'type': 'TextType'}, 28),
        MemberSpec_('licensed', 'LicenseType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'licensed', 'type': 'LicenseType'}, 28),
        MemberSpec_('distribution', 'DistributionType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'distribution', 'type': 'DistributionType'}, 28),
        MemberSpec_('coverage', 'Coverage', 0, 1, {'minOccurs': '0', 'name': 'coverage', 'type': 'Coverage'}, 28),
        MemberSpec_('annotation', 'SemanticAnnotation', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'annotation', 'type': 'SemanticAnnotation'}, 28),
        MemberSpec_('purpose', 'TextType', 0, 1, {'minOccurs': '0', 'name': 'purpose', 'type': 'TextType'}, 28),
        MemberSpec_('introduction', 'TextType', 0, 1, {'minOccurs': '0', 'name': 'introduction', 'type': 'TextType'}, 28),
        MemberSpec_('gettingStarted', 'TextType', 0, 1, {'minOccurs': '0', 'name': 'gettingStarted', 'type': 'TextType'}, 28),
        MemberSpec_('acknowledgements', 'TextType', 0, 1, {'minOccurs': '0', 'name': 'acknowledgements', 'type': 'TextType'}, 28),
        MemberSpec_('maintenance', 'MaintenanceType', 0, 1, {'minOccurs': '0', 'name': 'maintenance', 'type': 'MaintenanceType'}, 28),
        MemberSpec_('contact', 'ResponsibleParty', 1, 0, {'maxOccurs': 'unbounded', 'name': 'contact', 'type': 'ResponsibleParty'}, 28),
        MemberSpec_('publisher', 'ResponsibleParty', 0, 1, {'minOccurs': '0', 'name': 'publisher', 'type': 'ResponsibleParty'}, 28),
        MemberSpec_('pubPlace', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'pubPlace', 'type': 'xs:string'}, 28),
        MemberSpec_('methods', 'MethodsType', 0, 1, {'minOccurs': '0', 'name': 'methods', 'type': 'MethodsType'}, 28),
        MemberSpec_('project', 'ResearchProjectType', 0, 1, {'minOccurs': '0', 'name': 'project', 'type': 'ResearchProjectType'}, 28),
        MemberSpec_('dataTable', 'DataTableType', 1, 1, {'name': 'dataTable', 'type': 'DataTableType'}, 29),
        MemberSpec_('spatialRaster', 'SpatialRasterType', 1, 1, {'name': 'spatialRaster', 'type': 'SpatialRasterType'}, 29),
        MemberSpec_('spatialVector', 'SpatialVectorType', 1, 1, {'name': 'spatialVector', 'type': 'SpatialVectorType'}, 29),
        MemberSpec_('storedProcedure', 'StoredProcedureType', 1, 1, {'name': 'storedProcedure', 'type': 'StoredProcedureType'}, 29),
        MemberSpec_('view', 'ViewType', 1, 1, {'name': 'view', 'type': 'ViewType'}, 29),
        MemberSpec_('otherEntity', 'OtherEntityType', 1, 1, {'name': 'otherEntity', 'type': 'OtherEntityType'}, 29),
        MemberSpec_('referencePublication', 'CitationType', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'referencePublication', 'type': 'CitationType'}, None),
        MemberSpec_('usageCitation', 'CitationType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'usageCitation', 'type': 'CitationType'}, None),
        MemberSpec_('literatureCited', 'CitationListType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'literatureCited', 'type': 'CitationListType'}, None),
        MemberSpec_('references', 'referencesType22', 0, 0, {'name': 'references', 'type': 'referencesType22'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, system=None, scope='document', alternateIdentifier=None, shortName=None, title=None, creator=None, metadataProvider=None, associatedParty=None, pubDate=None, language=None, series=None, abstract=None, keywordSet=None, additionalInfo=None, intellectualRights=None, licensed=None, distribution=None, coverage=None, annotation=None, purpose=None, introduction=None, gettingStarted=None, acknowledgements=None, maintenance=None, contact=None, publisher=None, pubPlace=None, methods=None, project=None, dataTable=None, spatialRaster=None, spatialVector=None, storedProcedure=None, view=None, otherEntity=None, referencePublication=None, usageCitation=None, literatureCited=None, references=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.scope = _cast(None, scope)
        self.scope_nsprefix_ = None
        if alternateIdentifier is None:
            self.alternateIdentifier = []
        else:
            self.alternateIdentifier = alternateIdentifier
        self.alternateIdentifier_nsprefix_ = None
        self.shortName = shortName
        self.validate_NonEmptyStringType(self.shortName)
        self.shortName_nsprefix_ = None
        if title is None:
            self.title = []
        else:
            self.title = title
        self.title_nsprefix_ = None
        if creator is None:
            self.creator = []
        else:
            self.creator = creator
        self.creator_nsprefix_ = None
        if metadataProvider is None:
            self.metadataProvider = []
        else:
            self.metadataProvider = metadataProvider
        self.metadataProvider_nsprefix_ = None
        if associatedParty is None:
            self.associatedParty = []
        else:
            self.associatedParty = associatedParty
        self.associatedParty_nsprefix_ = None
        self.pubDate = pubDate
        self.validate_yearDate(self.pubDate)
        self.pubDate_nsprefix_ = None
        self.language = language
        self.language_nsprefix_ = None
        self.series = series
        self.validate_NonEmptyStringType(self.series)
        self.series_nsprefix_ = None
        self.abstract = abstract
        self.abstract_nsprefix_ = None
        if keywordSet is None:
            self.keywordSet = []
        else:
            self.keywordSet = keywordSet
        self.keywordSet_nsprefix_ = None
        if additionalInfo is None:
            self.additionalInfo = []
        else:
            self.additionalInfo = additionalInfo
        self.additionalInfo_nsprefix_ = None
        self.intellectualRights = intellectualRights
        self.intellectualRights_nsprefix_ = None
        if licensed is None:
            self.licensed = []
        else:
            self.licensed = licensed
        self.licensed_nsprefix_ = None
        if distribution is None:
            self.distribution = []
        else:
            self.distribution = distribution
        self.distribution_nsprefix_ = None
        self.coverage = coverage
        self.coverage_nsprefix_ = None
        if annotation is None:
            self.annotation = []
        else:
            self.annotation = annotation
        self.annotation_nsprefix_ = None
        self.purpose = purpose
        self.purpose_nsprefix_ = None
        self.introduction = introduction
        self.introduction_nsprefix_ = None
        self.gettingStarted = gettingStarted
        self.gettingStarted_nsprefix_ = None
        self.acknowledgements = acknowledgements
        self.acknowledgements_nsprefix_ = None
        self.maintenance = maintenance
        self.maintenance_nsprefix_ = None
        if contact is None:
            self.contact = []
        else:
            self.contact = contact
        self.contact_nsprefix_ = None
        self.publisher = publisher
        self.publisher_nsprefix_ = None
        self.pubPlace = pubPlace
        self.validate_NonEmptyStringType(self.pubPlace)
        self.pubPlace_nsprefix_ = None
        self.methods = methods
        self.methods_nsprefix_ = None
        self.project = project
        self.project_nsprefix_ = None
        if dataTable is None:
            self.dataTable = []
        else:
            self.dataTable = dataTable
        self.dataTable_nsprefix_ = None
        if spatialRaster is None:
            self.spatialRaster = []
        else:
            self.spatialRaster = spatialRaster
        self.spatialRaster_nsprefix_ = None
        if spatialVector is None:
            self.spatialVector = []
        else:
            self.spatialVector = spatialVector
        self.spatialVector_nsprefix_ = None
        if storedProcedure is None:
            self.storedProcedure = []
        else:
            self.storedProcedure = storedProcedure
        self.storedProcedure_nsprefix_ = None
        if view is None:
            self.view = []
        else:
            self.view = view
        self.view_nsprefix_ = None
        if otherEntity is None:
            self.otherEntity = []
        else:
            self.otherEntity = otherEntity
        self.otherEntity_nsprefix_ = None
        self.referencePublication = referencePublication
        self.referencePublication_nsprefix_ = None
        if usageCitation is None:
            self.usageCitation = []
        else:
            self.usageCitation = usageCitation
        self.usageCitation_nsprefix_ = None
        if literatureCited is None:
            self.literatureCited = []
        else:
            self.literatureCited = literatureCited
        self.literatureCited_nsprefix_ = None
        self.references = references
        self.references_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DatasetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DatasetType.subclass:
            return DatasetType.subclass(*args_, **kwargs_)
        else:
            return DatasetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_alternateIdentifier(self):
        return self.alternateIdentifier
    def set_alternateIdentifier(self, alternateIdentifier):
        self.alternateIdentifier = alternateIdentifier
    def add_alternateIdentifier(self, value):
        self.alternateIdentifier.append(value)
    def insert_alternateIdentifier_at(self, index, value):
        self.alternateIdentifier.insert(index, value)
    def replace_alternateIdentifier_at(self, index, value):
        self.alternateIdentifier[index] = value
    def get_shortName(self):
        return self.shortName
    def set_shortName(self, shortName):
        self.shortName = shortName
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def add_title(self, value):
        self.title.append(value)
    def insert_title_at(self, index, value):
        self.title.insert(index, value)
    def replace_title_at(self, index, value):
        self.title[index] = value
    def get_creator(self):
        return self.creator
    def set_creator(self, creator):
        self.creator = creator
    def add_creator(self, value):
        self.creator.append(value)
    def insert_creator_at(self, index, value):
        self.creator.insert(index, value)
    def replace_creator_at(self, index, value):
        self.creator[index] = value
    def get_metadataProvider(self):
        return self.metadataProvider
    def set_metadataProvider(self, metadataProvider):
        self.metadataProvider = metadataProvider
    def add_metadataProvider(self, value):
        self.metadataProvider.append(value)
    def insert_metadataProvider_at(self, index, value):
        self.metadataProvider.insert(index, value)
    def replace_metadataProvider_at(self, index, value):
        self.metadataProvider[index] = value
    def get_associatedParty(self):
        return self.associatedParty
    def set_associatedParty(self, associatedParty):
        self.associatedParty = associatedParty
    def add_associatedParty(self, value):
        self.associatedParty.append(value)
    def insert_associatedParty_at(self, index, value):
        self.associatedParty.insert(index, value)
    def replace_associatedParty_at(self, index, value):
        self.associatedParty[index] = value
    def get_pubDate(self):
        return self.pubDate
    def set_pubDate(self, pubDate):
        self.pubDate = pubDate
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_series(self):
        return self.series
    def set_series(self, series):
        self.series = series
    def get_abstract(self):
        return self.abstract
    def set_abstract(self, abstract):
        self.abstract = abstract
    def get_keywordSet(self):
        return self.keywordSet
    def set_keywordSet(self, keywordSet):
        self.keywordSet = keywordSet
    def add_keywordSet(self, value):
        self.keywordSet.append(value)
    def insert_keywordSet_at(self, index, value):
        self.keywordSet.insert(index, value)
    def replace_keywordSet_at(self, index, value):
        self.keywordSet[index] = value
    def get_additionalInfo(self):
        return self.additionalInfo
    def set_additionalInfo(self, additionalInfo):
        self.additionalInfo = additionalInfo
    def add_additionalInfo(self, value):
        self.additionalInfo.append(value)
    def insert_additionalInfo_at(self, index, value):
        self.additionalInfo.insert(index, value)
    def replace_additionalInfo_at(self, index, value):
        self.additionalInfo[index] = value
    def get_intellectualRights(self):
        return self.intellectualRights
    def set_intellectualRights(self, intellectualRights):
        self.intellectualRights = intellectualRights
    def get_licensed(self):
        return self.licensed
    def set_licensed(self, licensed):
        self.licensed = licensed
    def add_licensed(self, value):
        self.licensed.append(value)
    def insert_licensed_at(self, index, value):
        self.licensed.insert(index, value)
    def replace_licensed_at(self, index, value):
        self.licensed[index] = value
    def get_distribution(self):
        return self.distribution
    def set_distribution(self, distribution):
        self.distribution = distribution
    def add_distribution(self, value):
        self.distribution.append(value)
    def insert_distribution_at(self, index, value):
        self.distribution.insert(index, value)
    def replace_distribution_at(self, index, value):
        self.distribution[index] = value
    def get_coverage(self):
        return self.coverage
    def set_coverage(self, coverage):
        self.coverage = coverage
    def get_annotation(self):
        return self.annotation
    def set_annotation(self, annotation):
        self.annotation = annotation
    def add_annotation(self, value):
        self.annotation.append(value)
    def insert_annotation_at(self, index, value):
        self.annotation.insert(index, value)
    def replace_annotation_at(self, index, value):
        self.annotation[index] = value
    def get_purpose(self):
        return self.purpose
    def set_purpose(self, purpose):
        self.purpose = purpose
    def get_introduction(self):
        return self.introduction
    def set_introduction(self, introduction):
        self.introduction = introduction
    def get_gettingStarted(self):
        return self.gettingStarted
    def set_gettingStarted(self, gettingStarted):
        self.gettingStarted = gettingStarted
    def get_acknowledgements(self):
        return self.acknowledgements
    def set_acknowledgements(self, acknowledgements):
        self.acknowledgements = acknowledgements
    def get_maintenance(self):
        return self.maintenance
    def set_maintenance(self, maintenance):
        self.maintenance = maintenance
    def get_contact(self):
        return self.contact
    def set_contact(self, contact):
        self.contact = contact
    def add_contact(self, value):
        self.contact.append(value)
    def insert_contact_at(self, index, value):
        self.contact.insert(index, value)
    def replace_contact_at(self, index, value):
        self.contact[index] = value
    def get_publisher(self):
        return self.publisher
    def set_publisher(self, publisher):
        self.publisher = publisher
    def get_pubPlace(self):
        return self.pubPlace
    def set_pubPlace(self, pubPlace):
        self.pubPlace = pubPlace
    def get_methods(self):
        return self.methods
    def set_methods(self, methods):
        self.methods = methods
    def get_project(self):
        return self.project
    def set_project(self, project):
        self.project = project
    def get_dataTable(self):
        return self.dataTable
    def set_dataTable(self, dataTable):
        self.dataTable = dataTable
    def add_dataTable(self, value):
        self.dataTable.append(value)
    def insert_dataTable_at(self, index, value):
        self.dataTable.insert(index, value)
    def replace_dataTable_at(self, index, value):
        self.dataTable[index] = value
    def get_spatialRaster(self):
        return self.spatialRaster
    def set_spatialRaster(self, spatialRaster):
        self.spatialRaster = spatialRaster
    def add_spatialRaster(self, value):
        self.spatialRaster.append(value)
    def insert_spatialRaster_at(self, index, value):
        self.spatialRaster.insert(index, value)
    def replace_spatialRaster_at(self, index, value):
        self.spatialRaster[index] = value
    def get_spatialVector(self):
        return self.spatialVector
    def set_spatialVector(self, spatialVector):
        self.spatialVector = spatialVector
    def add_spatialVector(self, value):
        self.spatialVector.append(value)
    def insert_spatialVector_at(self, index, value):
        self.spatialVector.insert(index, value)
    def replace_spatialVector_at(self, index, value):
        self.spatialVector[index] = value
    def get_storedProcedure(self):
        return self.storedProcedure
    def set_storedProcedure(self, storedProcedure):
        self.storedProcedure = storedProcedure
    def add_storedProcedure(self, value):
        self.storedProcedure.append(value)
    def insert_storedProcedure_at(self, index, value):
        self.storedProcedure.insert(index, value)
    def replace_storedProcedure_at(self, index, value):
        self.storedProcedure[index] = value
    def get_view(self):
        return self.view
    def set_view(self, view):
        self.view = view
    def add_view(self, value):
        self.view.append(value)
    def insert_view_at(self, index, value):
        self.view.insert(index, value)
    def replace_view_at(self, index, value):
        self.view[index] = value
    def get_otherEntity(self):
        return self.otherEntity
    def set_otherEntity(self, otherEntity):
        self.otherEntity = otherEntity
    def add_otherEntity(self, value):
        self.otherEntity.append(value)
    def insert_otherEntity_at(self, index, value):
        self.otherEntity.insert(index, value)
    def replace_otherEntity_at(self, index, value):
        self.otherEntity[index] = value
    def get_referencePublication(self):
        return self.referencePublication
    def set_referencePublication(self, referencePublication):
        self.referencePublication = referencePublication
    def get_usageCitation(self):
        return self.usageCitation
    def set_usageCitation(self, usageCitation):
        self.usageCitation = usageCitation
    def add_usageCitation(self, value):
        self.usageCitation.append(value)
    def insert_usageCitation_at(self, index, value):
        self.usageCitation.insert(index, value)
    def replace_usageCitation_at(self, index, value):
        self.usageCitation[index] = value
    def get_literatureCited(self):
        return self.literatureCited
    def set_literatureCited(self, literatureCited):
        self.literatureCited = literatureCited
    def add_literatureCited(self, value):
        self.literatureCited.append(value)
    def insert_literatureCited_at(self, index, value):
        self.literatureCited.insert(index, value)
    def replace_literatureCited_at(self, index, value):
        self.literatureCited[index] = value
    def get_references(self):
        return self.references
    def set_references(self, references):
        self.references = references
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_scope(self):
        return self.scope
    def set_scope(self, scope):
        self.scope = scope
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def validate_yearDate(self, value):
        result = True
        # Validate type yearDate, a restriction on None.
        pass
        return result
    def validate_IDType(self, value):
        # Validate type res:IDType, a restriction on xs:string.
        pass
    def validate_SystemType(self, value):
        # Validate type res:SystemType, a restriction on xs:string.
        pass
    def validate_ScopeType(self, value):
        # Validate type res:ScopeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['system', 'document']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ScopeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.alternateIdentifier or
            self.shortName is not None or
            self.title or
            self.creator or
            self.metadataProvider or
            self.associatedParty or
            self.pubDate is not None or
            self.language is not None or
            self.series is not None or
            self.abstract is not None or
            self.keywordSet or
            self.additionalInfo or
            self.intellectualRights is not None or
            self.licensed or
            self.distribution or
            self.coverage is not None or
            self.annotation or
            self.purpose is not None or
            self.introduction is not None or
            self.gettingStarted is not None or
            self.acknowledgements is not None or
            self.maintenance is not None or
            self.contact or
            self.publisher is not None or
            self.pubPlace is not None or
            self.methods is not None or
            self.project is not None or
            self.dataTable or
            self.spatialRaster or
            self.spatialVector or
            self.storedProcedure or
            self.view or
            self.otherEntity or
            self.referencePublication is not None or
            self.usageCitation or
            self.literatureCited or
            self.references is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0"  xmlns:rp="https://eml.ecoinformatics.org/party-2.2.0"  xmlns:txt="https://eml.ecoinformatics.org/text-2.2.0"  xmlns:cov="https://eml.ecoinformatics.org/coverage-2.2.0"  xmlns:sem="https://eml.ecoinformatics.org/semantics-2.2.0"  xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:md="https://eml.ecoinformatics.org/methods-2.2.0"  xmlns:proj="https://eml.ecoinformatics.org/project-2.2.0"  xmlns:dat="https://eml.ecoinformatics.org/dataTable-2.2.0"  xmlns:sr="https://eml.ecoinformatics.org/spatialRaster-2.2.0"  xmlns:sv="https://eml.ecoinformatics.org/spatialVector-2.2.0"  xmlns:sp="https://eml.ecoinformatics.org/storedProcedure-2.2.0"  xmlns:v="https://eml.ecoinformatics.org/view-2.2.0"  xmlns:ent="https://eml.ecoinformatics.org/entity-2.2.0"  xmlns:cit="https://eml.ecoinformatics.org/literature-2.2.0" ', name_='DatasetType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DatasetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DatasetType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DatasetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DatasetType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DatasetType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
        if self.scope != "document" and 'scope' not in already_processed:
            already_processed.add('scope')
            outfile.write(' scope=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.scope), input_name='scope')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0"  xmlns:rp="https://eml.ecoinformatics.org/party-2.2.0"  xmlns:txt="https://eml.ecoinformatics.org/text-2.2.0"  xmlns:cov="https://eml.ecoinformatics.org/coverage-2.2.0"  xmlns:sem="https://eml.ecoinformatics.org/semantics-2.2.0"  xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:md="https://eml.ecoinformatics.org/methods-2.2.0"  xmlns:proj="https://eml.ecoinformatics.org/project-2.2.0"  xmlns:dat="https://eml.ecoinformatics.org/dataTable-2.2.0"  xmlns:sr="https://eml.ecoinformatics.org/spatialRaster-2.2.0"  xmlns:sv="https://eml.ecoinformatics.org/spatialVector-2.2.0"  xmlns:sp="https://eml.ecoinformatics.org/storedProcedure-2.2.0"  xmlns:v="https://eml.ecoinformatics.org/view-2.2.0"  xmlns:ent="https://eml.ecoinformatics.org/entity-2.2.0"  xmlns:cit="https://eml.ecoinformatics.org/literature-2.2.0" ', name_='DatasetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for alternateIdentifier_ in self.alternateIdentifier:
            namespaceprefix_ = self.alternateIdentifier_nsprefix_ + ':' if (UseCapturedNS_ and self.alternateIdentifier_nsprefix_) else ''
            alternateIdentifier_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='alternateIdentifier', pretty_print=pretty_print)
        if self.shortName is not None:
            namespaceprefix_ = self.shortName_nsprefix_ + ':' if (UseCapturedNS_ and self.shortName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sshortName>%s</%sshortName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.shortName), input_name='shortName')), namespaceprefix_ , eol_))
        for title_ in self.title:
            namespaceprefix_ = self.title_nsprefix_ + ':' if (UseCapturedNS_ and self.title_nsprefix_) else ''
            title_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='title', pretty_print=pretty_print)
        for creator_ in self.creator:
            namespaceprefix_ = self.creator_nsprefix_ + ':' if (UseCapturedNS_ and self.creator_nsprefix_) else ''
            creator_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='creator', pretty_print=pretty_print)
        for metadataProvider_ in self.metadataProvider:
            namespaceprefix_ = self.metadataProvider_nsprefix_ + ':' if (UseCapturedNS_ and self.metadataProvider_nsprefix_) else ''
            metadataProvider_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='metadataProvider', pretty_print=pretty_print)
        for associatedParty_ in self.associatedParty:
            namespaceprefix_ = self.associatedParty_nsprefix_ + ':' if (UseCapturedNS_ and self.associatedParty_nsprefix_) else ''
            associatedParty_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='associatedParty', pretty_print=pretty_print)
        if self.pubDate is not None:
            namespaceprefix_ = self.pubDate_nsprefix_ + ':' if (UseCapturedNS_ and self.pubDate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spubDate>%s</%spubDate>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pubDate), input_name='pubDate')), namespaceprefix_ , eol_))
        if self.language is not None:
            namespaceprefix_ = self.language_nsprefix_ + ':' if (UseCapturedNS_ and self.language_nsprefix_) else ''
            self.language.export(outfile, level, namespaceprefix_, namespacedef_='', name_='language', pretty_print=pretty_print)
        if self.series is not None:
            namespaceprefix_ = self.series_nsprefix_ + ':' if (UseCapturedNS_ and self.series_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sseries>%s</%sseries>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.series), input_name='series')), namespaceprefix_ , eol_))
        if self.abstract is not None:
            namespaceprefix_ = self.abstract_nsprefix_ + ':' if (UseCapturedNS_ and self.abstract_nsprefix_) else ''
            self.abstract.export(outfile, level, namespaceprefix_, namespacedef_='', name_='abstract', pretty_print=pretty_print)
        for keywordSet_ in self.keywordSet:
            namespaceprefix_ = self.keywordSet_nsprefix_ + ':' if (UseCapturedNS_ and self.keywordSet_nsprefix_) else ''
            keywordSet_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='keywordSet', pretty_print=pretty_print)
        for additionalInfo_ in self.additionalInfo:
            namespaceprefix_ = self.additionalInfo_nsprefix_ + ':' if (UseCapturedNS_ and self.additionalInfo_nsprefix_) else ''
            additionalInfo_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='additionalInfo', pretty_print=pretty_print)
        if self.intellectualRights is not None:
            namespaceprefix_ = self.intellectualRights_nsprefix_ + ':' if (UseCapturedNS_ and self.intellectualRights_nsprefix_) else ''
            self.intellectualRights.export(outfile, level, namespaceprefix_, namespacedef_='', name_='intellectualRights', pretty_print=pretty_print)
        for licensed_ in self.licensed:
            namespaceprefix_ = self.licensed_nsprefix_ + ':' if (UseCapturedNS_ and self.licensed_nsprefix_) else ''
            licensed_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='licensed', pretty_print=pretty_print)
        for distribution_ in self.distribution:
            namespaceprefix_ = self.distribution_nsprefix_ + ':' if (UseCapturedNS_ and self.distribution_nsprefix_) else ''
            distribution_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='distribution', pretty_print=pretty_print)
        if self.coverage is not None:
            namespaceprefix_ = self.coverage_nsprefix_ + ':' if (UseCapturedNS_ and self.coverage_nsprefix_) else ''
            self.coverage.export(outfile, level, namespaceprefix_, namespacedef_='', name_='coverage', pretty_print=pretty_print)
        for annotation_ in self.annotation:
            namespaceprefix_ = self.annotation_nsprefix_ + ':' if (UseCapturedNS_ and self.annotation_nsprefix_) else ''
            annotation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='annotation', pretty_print=pretty_print)
        if self.purpose is not None:
            namespaceprefix_ = self.purpose_nsprefix_ + ':' if (UseCapturedNS_ and self.purpose_nsprefix_) else ''
            self.purpose.export(outfile, level, namespaceprefix_, namespacedef_='', name_='purpose', pretty_print=pretty_print)
        if self.introduction is not None:
            namespaceprefix_ = self.introduction_nsprefix_ + ':' if (UseCapturedNS_ and self.introduction_nsprefix_) else ''
            self.introduction.export(outfile, level, namespaceprefix_, namespacedef_='', name_='introduction', pretty_print=pretty_print)
        if self.gettingStarted is not None:
            namespaceprefix_ = self.gettingStarted_nsprefix_ + ':' if (UseCapturedNS_ and self.gettingStarted_nsprefix_) else ''
            self.gettingStarted.export(outfile, level, namespaceprefix_, namespacedef_='', name_='gettingStarted', pretty_print=pretty_print)
        if self.acknowledgements is not None:
            namespaceprefix_ = self.acknowledgements_nsprefix_ + ':' if (UseCapturedNS_ and self.acknowledgements_nsprefix_) else ''
            self.acknowledgements.export(outfile, level, namespaceprefix_, namespacedef_='', name_='acknowledgements', pretty_print=pretty_print)
        if self.maintenance is not None:
            namespaceprefix_ = self.maintenance_nsprefix_ + ':' if (UseCapturedNS_ and self.maintenance_nsprefix_) else ''
            self.maintenance.export(outfile, level, namespaceprefix_, namespacedef_='', name_='maintenance', pretty_print=pretty_print)
        for contact_ in self.contact:
            namespaceprefix_ = self.contact_nsprefix_ + ':' if (UseCapturedNS_ and self.contact_nsprefix_) else ''
            contact_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='contact', pretty_print=pretty_print)
        if self.publisher is not None:
            namespaceprefix_ = self.publisher_nsprefix_ + ':' if (UseCapturedNS_ and self.publisher_nsprefix_) else ''
            self.publisher.export(outfile, level, namespaceprefix_, namespacedef_='', name_='publisher', pretty_print=pretty_print)
        if self.pubPlace is not None:
            namespaceprefix_ = self.pubPlace_nsprefix_ + ':' if (UseCapturedNS_ and self.pubPlace_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spubPlace>%s</%spubPlace>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pubPlace), input_name='pubPlace')), namespaceprefix_ , eol_))
        if self.methods is not None:
            namespaceprefix_ = self.methods_nsprefix_ + ':' if (UseCapturedNS_ and self.methods_nsprefix_) else ''
            self.methods.export(outfile, level, namespaceprefix_, namespacedef_='', name_='methods', pretty_print=pretty_print)
        if self.project is not None:
            namespaceprefix_ = self.project_nsprefix_ + ':' if (UseCapturedNS_ and self.project_nsprefix_) else ''
            self.project.export(outfile, level, namespaceprefix_, namespacedef_='', name_='project', pretty_print=pretty_print)
        for dataTable_ in self.dataTable:
            namespaceprefix_ = self.dataTable_nsprefix_ + ':' if (UseCapturedNS_ and self.dataTable_nsprefix_) else ''
            dataTable_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataTable', pretty_print=pretty_print)
        for spatialRaster_ in self.spatialRaster:
            namespaceprefix_ = self.spatialRaster_nsprefix_ + ':' if (UseCapturedNS_ and self.spatialRaster_nsprefix_) else ''
            spatialRaster_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='spatialRaster', pretty_print=pretty_print)
        for spatialVector_ in self.spatialVector:
            namespaceprefix_ = self.spatialVector_nsprefix_ + ':' if (UseCapturedNS_ and self.spatialVector_nsprefix_) else ''
            spatialVector_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='spatialVector', pretty_print=pretty_print)
        for storedProcedure_ in self.storedProcedure:
            namespaceprefix_ = self.storedProcedure_nsprefix_ + ':' if (UseCapturedNS_ and self.storedProcedure_nsprefix_) else ''
            storedProcedure_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='storedProcedure', pretty_print=pretty_print)
        for view_ in self.view:
            namespaceprefix_ = self.view_nsprefix_ + ':' if (UseCapturedNS_ and self.view_nsprefix_) else ''
            view_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='view', pretty_print=pretty_print)
        for otherEntity_ in self.otherEntity:
            namespaceprefix_ = self.otherEntity_nsprefix_ + ':' if (UseCapturedNS_ and self.otherEntity_nsprefix_) else ''
            otherEntity_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='otherEntity', pretty_print=pretty_print)
        if self.referencePublication is not None:
            namespaceprefix_ = self.referencePublication_nsprefix_ + ':' if (UseCapturedNS_ and self.referencePublication_nsprefix_) else ''
            self.referencePublication.export(outfile, level, namespaceprefix_, namespacedef_='', name_='referencePublication', pretty_print=pretty_print)
        for usageCitation_ in self.usageCitation:
            namespaceprefix_ = self.usageCitation_nsprefix_ + ':' if (UseCapturedNS_ and self.usageCitation_nsprefix_) else ''
            usageCitation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='usageCitation', pretty_print=pretty_print)
        for literatureCited_ in self.literatureCited:
            namespaceprefix_ = self.literatureCited_nsprefix_ + ':' if (UseCapturedNS_ and self.literatureCited_nsprefix_) else ''
            literatureCited_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='literatureCited', pretty_print=pretty_print)
        if self.references is not None:
            namespaceprefix_ = self.references_nsprefix_ + ':' if (UseCapturedNS_ and self.references_nsprefix_) else ''
            self.references.export(outfile, level, namespaceprefix_, namespacedef_='', name_='references', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_IDType(self.id)    # validate type IDType
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
        value = find_attr_value_('scope', node)
        if value is not None and 'scope' not in already_processed:
            already_processed.add('scope')
            self.scope = value
            self.validate_ScopeType(self.scope)    # validate type ScopeType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'alternateIdentifier':
            obj_ = alternateIdentifierType18.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.alternateIdentifier.append(obj_)
            obj_.original_tagname_ = 'alternateIdentifier'
        elif nodeName_ == 'shortName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'shortName')
            value_ = self.gds_validate_string(value_, node, 'shortName')
            self.shortName = value_
            self.shortName_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.shortName)
        elif nodeName_ == 'title':
            class_obj_ = self.get_class_obj_(child_, i18nNonEmptyStringType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.title.append(obj_)
            obj_.original_tagname_ = 'title'
        elif nodeName_ == 'creator':
            class_obj_ = self.get_class_obj_(child_, ResponsibleParty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.creator.append(obj_)
            obj_.original_tagname_ = 'creator'
        elif nodeName_ == 'metadataProvider':
            class_obj_ = self.get_class_obj_(child_, ResponsibleParty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.metadataProvider.append(obj_)
            obj_.original_tagname_ = 'metadataProvider'
        elif nodeName_ == 'associatedParty':
            obj_ = associatedPartyType19.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.associatedParty.append(obj_)
            obj_.original_tagname_ = 'associatedParty'
        elif nodeName_ == 'pubDate':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'pubDate')
            value_ = self.gds_validate_string(value_, node, 'pubDate')
            self.pubDate = value_
            self.pubDate_nsprefix_ = child_.prefix
            # validate type yearDate
            self.validate_yearDate(self.pubDate)
        elif nodeName_ == 'language':
            class_obj_ = self.get_class_obj_(child_, i18nNonEmptyStringType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.language = obj_
            obj_.original_tagname_ = 'language'
        elif nodeName_ == 'series':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'series')
            value_ = self.gds_validate_string(value_, node, 'series')
            self.series = value_
            self.series_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.series)
        elif nodeName_ == 'abstract':
            obj_ = TextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.abstract = obj_
            obj_.original_tagname_ = 'abstract'
        elif nodeName_ == 'keywordSet':
            obj_ = keywordSetType20.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.keywordSet.append(obj_)
            obj_.original_tagname_ = 'keywordSet'
        elif nodeName_ == 'additionalInfo':
            obj_ = TextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.additionalInfo.append(obj_)
            obj_.original_tagname_ = 'additionalInfo'
        elif nodeName_ == 'intellectualRights':
            obj_ = TextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.intellectualRights = obj_
            obj_.original_tagname_ = 'intellectualRights'
        elif nodeName_ == 'licensed':
            obj_ = LicenseType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.licensed.append(obj_)
            obj_.original_tagname_ = 'licensed'
        elif nodeName_ == 'distribution':
            obj_ = DistributionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.distribution.append(obj_)
            obj_.original_tagname_ = 'distribution'
        elif nodeName_ == 'coverage':
            obj_ = Coverage.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.coverage = obj_
            obj_.original_tagname_ = 'coverage'
        elif nodeName_ == 'annotation':
            class_obj_ = self.get_class_obj_(child_, SemanticAnnotation)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.annotation.append(obj_)
            obj_.original_tagname_ = 'annotation'
        elif nodeName_ == 'purpose':
            obj_ = TextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.purpose = obj_
            obj_.original_tagname_ = 'purpose'
        elif nodeName_ == 'introduction':
            obj_ = TextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.introduction = obj_
            obj_.original_tagname_ = 'introduction'
        elif nodeName_ == 'gettingStarted':
            obj_ = TextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.gettingStarted = obj_
            obj_.original_tagname_ = 'gettingStarted'
        elif nodeName_ == 'acknowledgements':
            obj_ = TextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.acknowledgements = obj_
            obj_.original_tagname_ = 'acknowledgements'
        elif nodeName_ == 'maintenance':
            obj_ = MaintenanceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.maintenance = obj_
            obj_.original_tagname_ = 'maintenance'
        elif nodeName_ == 'contact':
            class_obj_ = self.get_class_obj_(child_, ResponsibleParty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.contact.append(obj_)
            obj_.original_tagname_ = 'contact'
        elif nodeName_ == 'publisher':
            class_obj_ = self.get_class_obj_(child_, ResponsibleParty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.publisher = obj_
            obj_.original_tagname_ = 'publisher'
        elif nodeName_ == 'pubPlace':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'pubPlace')
            value_ = self.gds_validate_string(value_, node, 'pubPlace')
            self.pubPlace = value_
            self.pubPlace_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.pubPlace)
        elif nodeName_ == 'methods':
            obj_ = MethodsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.methods = obj_
            obj_.original_tagname_ = 'methods'
        elif nodeName_ == 'project':
            obj_ = ResearchProjectType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.project = obj_
            obj_.original_tagname_ = 'project'
        elif nodeName_ == 'dataTable':
            obj_ = DataTableType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dataTable.append(obj_)
            obj_.original_tagname_ = 'dataTable'
        elif nodeName_ == 'spatialRaster':
            obj_ = SpatialRasterType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.spatialRaster.append(obj_)
            obj_.original_tagname_ = 'spatialRaster'
        elif nodeName_ == 'spatialVector':
            obj_ = SpatialVectorType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.spatialVector.append(obj_)
            obj_.original_tagname_ = 'spatialVector'
        elif nodeName_ == 'storedProcedure':
            obj_ = StoredProcedureType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.storedProcedure.append(obj_)
            obj_.original_tagname_ = 'storedProcedure'
        elif nodeName_ == 'view':
            obj_ = ViewType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.view.append(obj_)
            obj_.original_tagname_ = 'view'
        elif nodeName_ == 'otherEntity':
            obj_ = OtherEntityType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.otherEntity.append(obj_)
            obj_.original_tagname_ = 'otherEntity'
        elif nodeName_ == 'referencePublication':
            obj_ = CitationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.referencePublication = obj_
            obj_.original_tagname_ = 'referencePublication'
        elif nodeName_ == 'usageCitation':
            obj_ = CitationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.usageCitation.append(obj_)
            obj_.original_tagname_ = 'usageCitation'
        elif nodeName_ == 'literatureCited':
            obj_ = CitationListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.literatureCited.append(obj_)
            obj_.original_tagname_ = 'literatureCited'
        elif nodeName_ == 'references':
            obj_ = referencesType22.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.references = obj_
            obj_.original_tagname_ = 'references'
# end class DatasetType


class MaintenanceType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('description', 'TextType', 0, 0, {'name': 'description', 'type': 'TextType'}, None),
        MemberSpec_('maintenanceUpdateFrequency', ['MaintUpFreqType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'maintenanceUpdateFrequency', 'type': 'xs:string'}, None),
        MemberSpec_('changeHistory', 'changeHistoryType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'changeHistory', 'type': 'changeHistoryType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, description=None, maintenanceUpdateFrequency=None, changeHistory=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.description = description
        self.description_nsprefix_ = None
        self.maintenanceUpdateFrequency = maintenanceUpdateFrequency
        self.validate_MaintUpFreqType(self.maintenanceUpdateFrequency)
        self.maintenanceUpdateFrequency_nsprefix_ = None
        if changeHistory is None:
            self.changeHistory = []
        else:
            self.changeHistory = changeHistory
        self.changeHistory_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MaintenanceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MaintenanceType.subclass:
            return MaintenanceType.subclass(*args_, **kwargs_)
        else:
            return MaintenanceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_maintenanceUpdateFrequency(self):
        return self.maintenanceUpdateFrequency
    def set_maintenanceUpdateFrequency(self, maintenanceUpdateFrequency):
        self.maintenanceUpdateFrequency = maintenanceUpdateFrequency
    def get_changeHistory(self):
        return self.changeHistory
    def set_changeHistory(self, changeHistory):
        self.changeHistory = changeHistory
    def add_changeHistory(self, value):
        self.changeHistory.append(value)
    def insert_changeHistory_at(self, index, value):
        self.changeHistory.insert(index, value)
    def replace_changeHistory_at(self, index, value):
        self.changeHistory[index] = value
    def validate_MaintUpFreqType(self, value):
        result = True
        # Validate type MaintUpFreqType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['annually', 'asNeeded', 'biannually', 'continually', 'daily', 'irregular', 'monthly', 'notPlanned', 'weekly', 'unknown', 'unkown', 'otherMaintenancePeriod']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on MaintUpFreqType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.description is not None or
            self.maintenanceUpdateFrequency is not None or
            self.changeHistory
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:txt="https://eml.ecoinformatics.org/text-2.2.0"  xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='MaintenanceType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MaintenanceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MaintenanceType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MaintenanceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MaintenanceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MaintenanceType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:txt="https://eml.ecoinformatics.org/text-2.2.0"  xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='MaintenanceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            self.description.export(outfile, level, namespaceprefix_, namespacedef_='', name_='description', pretty_print=pretty_print)
        if self.maintenanceUpdateFrequency is not None:
            namespaceprefix_ = self.maintenanceUpdateFrequency_nsprefix_ + ':' if (UseCapturedNS_ and self.maintenanceUpdateFrequency_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smaintenanceUpdateFrequency>%s</%smaintenanceUpdateFrequency>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.maintenanceUpdateFrequency), input_name='maintenanceUpdateFrequency')), namespaceprefix_ , eol_))
        for changeHistory_ in self.changeHistory:
            namespaceprefix_ = self.changeHistory_nsprefix_ + ':' if (UseCapturedNS_ and self.changeHistory_nsprefix_) else ''
            changeHistory_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='changeHistory', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'description':
            obj_ = TextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.description = obj_
            obj_.original_tagname_ = 'description'
        elif nodeName_ == 'maintenanceUpdateFrequency':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'maintenanceUpdateFrequency')
            value_ = self.gds_validate_string(value_, node, 'maintenanceUpdateFrequency')
            self.maintenanceUpdateFrequency = value_
            self.maintenanceUpdateFrequency_nsprefix_ = child_.prefix
            # validate type MaintUpFreqType
            self.validate_MaintUpFreqType(self.maintenanceUpdateFrequency)
        elif nodeName_ == 'changeHistory':
            obj_ = changeHistoryType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.changeHistory.append(obj_)
            obj_.original_tagname_ = 'changeHistory'
# end class MaintenanceType


class OtherEntityType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'res:IDType', 0, 1, {'use': 'optional'}),
        MemberSpec_('system', 'res:SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('scope', 'res:ScopeType', 0, 1, {'use': 'optional'}),
        MemberSpec_('alternateIdentifier', 'alternateIdentifierType23', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'alternateIdentifier', 'type': 'alternateIdentifierType23'}, 30),
        MemberSpec_('entityName', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'entityName', 'type': 'xs:string'}, 30),
        MemberSpec_('entityDescription', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'entityDescription', 'type': 'xs:string'}, 30),
        MemberSpec_('physical', 'PhysicalType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'physical', 'type': 'PhysicalType'}, 30),
        MemberSpec_('coverage', 'Coverage', 0, 1, {'minOccurs': '0', 'name': 'coverage', 'type': 'Coverage'}, 30),
        MemberSpec_('methods', 'MethodsType', 0, 1, {'minOccurs': '0', 'name': 'methods', 'type': 'MethodsType'}, 30),
        MemberSpec_('additionalInfo', 'TextType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'additionalInfo', 'type': 'TextType'}, 30),
        MemberSpec_('annotation', 'SemanticAnnotation', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'annotation', 'type': 'SemanticAnnotation'}, 30),
        MemberSpec_('attributeList', 'AttributeListType', 0, 1, {'minOccurs': '0', 'name': 'attributeList', 'type': 'AttributeListType'}, 30),
        MemberSpec_('constraint', 'ConstraintType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'constraint', 'type': 'ConstraintType'}, 30),
        MemberSpec_('entityType', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'entityType', 'type': 'xs:string'}, 30),
        MemberSpec_('references', 'referencesType24', 0, 0, {'name': 'references', 'type': 'referencesType24'}, 30),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, system=None, scope='document', alternateIdentifier=None, entityName=None, entityDescription=None, physical=None, coverage=None, methods=None, additionalInfo=None, annotation=None, attributeList=None, constraint=None, entityType=None, references=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.scope = _cast(None, scope)
        self.scope_nsprefix_ = None
        if alternateIdentifier is None:
            self.alternateIdentifier = []
        else:
            self.alternateIdentifier = alternateIdentifier
        self.alternateIdentifier_nsprefix_ = None
        self.entityName = entityName
        self.validate_NonEmptyStringType(self.entityName)
        self.entityName_nsprefix_ = None
        self.entityDescription = entityDescription
        self.validate_NonEmptyStringType(self.entityDescription)
        self.entityDescription_nsprefix_ = None
        if physical is None:
            self.physical = []
        else:
            self.physical = physical
        self.physical_nsprefix_ = None
        self.coverage = coverage
        self.coverage_nsprefix_ = None
        self.methods = methods
        self.methods_nsprefix_ = None
        if additionalInfo is None:
            self.additionalInfo = []
        else:
            self.additionalInfo = additionalInfo
        self.additionalInfo_nsprefix_ = None
        if annotation is None:
            self.annotation = []
        else:
            self.annotation = annotation
        self.annotation_nsprefix_ = None
        self.attributeList = attributeList
        self.attributeList_nsprefix_ = None
        if constraint is None:
            self.constraint = []
        else:
            self.constraint = constraint
        self.constraint_nsprefix_ = None
        self.entityType = entityType
        self.validate_NonEmptyStringType(self.entityType)
        self.entityType_nsprefix_ = None
        self.references = references
        self.references_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OtherEntityType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OtherEntityType.subclass:
            return OtherEntityType.subclass(*args_, **kwargs_)
        else:
            return OtherEntityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_alternateIdentifier(self):
        return self.alternateIdentifier
    def set_alternateIdentifier(self, alternateIdentifier):
        self.alternateIdentifier = alternateIdentifier
    def add_alternateIdentifier(self, value):
        self.alternateIdentifier.append(value)
    def insert_alternateIdentifier_at(self, index, value):
        self.alternateIdentifier.insert(index, value)
    def replace_alternateIdentifier_at(self, index, value):
        self.alternateIdentifier[index] = value
    def get_entityName(self):
        return self.entityName
    def set_entityName(self, entityName):
        self.entityName = entityName
    def get_entityDescription(self):
        return self.entityDescription
    def set_entityDescription(self, entityDescription):
        self.entityDescription = entityDescription
    def get_physical(self):
        return self.physical
    def set_physical(self, physical):
        self.physical = physical
    def add_physical(self, value):
        self.physical.append(value)
    def insert_physical_at(self, index, value):
        self.physical.insert(index, value)
    def replace_physical_at(self, index, value):
        self.physical[index] = value
    def get_coverage(self):
        return self.coverage
    def set_coverage(self, coverage):
        self.coverage = coverage
    def get_methods(self):
        return self.methods
    def set_methods(self, methods):
        self.methods = methods
    def get_additionalInfo(self):
        return self.additionalInfo
    def set_additionalInfo(self, additionalInfo):
        self.additionalInfo = additionalInfo
    def add_additionalInfo(self, value):
        self.additionalInfo.append(value)
    def insert_additionalInfo_at(self, index, value):
        self.additionalInfo.insert(index, value)
    def replace_additionalInfo_at(self, index, value):
        self.additionalInfo[index] = value
    def get_annotation(self):
        return self.annotation
    def set_annotation(self, annotation):
        self.annotation = annotation
    def add_annotation(self, value):
        self.annotation.append(value)
    def insert_annotation_at(self, index, value):
        self.annotation.insert(index, value)
    def replace_annotation_at(self, index, value):
        self.annotation[index] = value
    def get_attributeList(self):
        return self.attributeList
    def set_attributeList(self, attributeList):
        self.attributeList = attributeList
    def get_constraint(self):
        return self.constraint
    def set_constraint(self, constraint):
        self.constraint = constraint
    def add_constraint(self, value):
        self.constraint.append(value)
    def insert_constraint_at(self, index, value):
        self.constraint.insert(index, value)
    def replace_constraint_at(self, index, value):
        self.constraint[index] = value
    def get_entityType(self):
        return self.entityType
    def set_entityType(self, entityType):
        self.entityType = entityType
    def get_references(self):
        return self.references
    def set_references(self, references):
        self.references = references
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_scope(self):
        return self.scope
    def set_scope(self, scope):
        self.scope = scope
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def validate_IDType(self, value):
        # Validate type res:IDType, a restriction on xs:string.
        pass
    def validate_SystemType(self, value):
        # Validate type res:SystemType, a restriction on xs:string.
        pass
    def validate_ScopeType(self, value):
        # Validate type res:ScopeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['system', 'document']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ScopeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.alternateIdentifier or
            self.entityName is not None or
            self.entityDescription is not None or
            self.physical or
            self.coverage is not None or
            self.methods is not None or
            self.additionalInfo or
            self.annotation or
            self.attributeList is not None or
            self.constraint or
            self.entityType is not None or
            self.references is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0"  xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:phys="https://eml.ecoinformatics.org/physical-2.2.0"  xmlns:cov="https://eml.ecoinformatics.org/coverage-2.2.0"  xmlns:md="https://eml.ecoinformatics.org/methods-2.2.0"  xmlns:txt="https://eml.ecoinformatics.org/text-2.2.0"  xmlns:sem="https://eml.ecoinformatics.org/semantics-2.2.0"  xmlns:att="https://eml.ecoinformatics.org/attribute-2.2.0"  xmlns:con="https://eml.ecoinformatics.org/constraint-2.2.0" ', name_='OtherEntityType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OtherEntityType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'OtherEntityType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OtherEntityType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='OtherEntityType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='OtherEntityType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
        if self.scope != "document" and 'scope' not in already_processed:
            already_processed.add('scope')
            outfile.write(' scope=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.scope), input_name='scope')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0"  xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:phys="https://eml.ecoinformatics.org/physical-2.2.0"  xmlns:cov="https://eml.ecoinformatics.org/coverage-2.2.0"  xmlns:md="https://eml.ecoinformatics.org/methods-2.2.0"  xmlns:txt="https://eml.ecoinformatics.org/text-2.2.0"  xmlns:sem="https://eml.ecoinformatics.org/semantics-2.2.0"  xmlns:att="https://eml.ecoinformatics.org/attribute-2.2.0"  xmlns:con="https://eml.ecoinformatics.org/constraint-2.2.0" ', name_='OtherEntityType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for alternateIdentifier_ in self.alternateIdentifier:
            namespaceprefix_ = self.alternateIdentifier_nsprefix_ + ':' if (UseCapturedNS_ and self.alternateIdentifier_nsprefix_) else ''
            alternateIdentifier_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='alternateIdentifier', pretty_print=pretty_print)
        if self.entityName is not None:
            namespaceprefix_ = self.entityName_nsprefix_ + ':' if (UseCapturedNS_ and self.entityName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sentityName>%s</%sentityName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.entityName), input_name='entityName')), namespaceprefix_ , eol_))
        if self.entityDescription is not None:
            namespaceprefix_ = self.entityDescription_nsprefix_ + ':' if (UseCapturedNS_ and self.entityDescription_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sentityDescription>%s</%sentityDescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.entityDescription), input_name='entityDescription')), namespaceprefix_ , eol_))
        for physical_ in self.physical:
            namespaceprefix_ = self.physical_nsprefix_ + ':' if (UseCapturedNS_ and self.physical_nsprefix_) else ''
            physical_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='physical', pretty_print=pretty_print)
        if self.coverage is not None:
            namespaceprefix_ = self.coverage_nsprefix_ + ':' if (UseCapturedNS_ and self.coverage_nsprefix_) else ''
            self.coverage.export(outfile, level, namespaceprefix_, namespacedef_='', name_='coverage', pretty_print=pretty_print)
        if self.methods is not None:
            namespaceprefix_ = self.methods_nsprefix_ + ':' if (UseCapturedNS_ and self.methods_nsprefix_) else ''
            self.methods.export(outfile, level, namespaceprefix_, namespacedef_='', name_='methods', pretty_print=pretty_print)
        for additionalInfo_ in self.additionalInfo:
            namespaceprefix_ = self.additionalInfo_nsprefix_ + ':' if (UseCapturedNS_ and self.additionalInfo_nsprefix_) else ''
            additionalInfo_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='additionalInfo', pretty_print=pretty_print)
        for annotation_ in self.annotation:
            namespaceprefix_ = self.annotation_nsprefix_ + ':' if (UseCapturedNS_ and self.annotation_nsprefix_) else ''
            annotation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='annotation', pretty_print=pretty_print)
        if self.attributeList is not None:
            namespaceprefix_ = self.attributeList_nsprefix_ + ':' if (UseCapturedNS_ and self.attributeList_nsprefix_) else ''
            self.attributeList.export(outfile, level, namespaceprefix_, namespacedef_='', name_='attributeList', pretty_print=pretty_print)
        for constraint_ in self.constraint:
            namespaceprefix_ = self.constraint_nsprefix_ + ':' if (UseCapturedNS_ and self.constraint_nsprefix_) else ''
            constraint_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='constraint', pretty_print=pretty_print)
        if self.entityType is not None:
            namespaceprefix_ = self.entityType_nsprefix_ + ':' if (UseCapturedNS_ and self.entityType_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sentityType>%s</%sentityType>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.entityType), input_name='entityType')), namespaceprefix_ , eol_))
        if self.references is not None:
            namespaceprefix_ = self.references_nsprefix_ + ':' if (UseCapturedNS_ and self.references_nsprefix_) else ''
            self.references.export(outfile, level, namespaceprefix_, namespacedef_='', name_='references', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_IDType(self.id)    # validate type IDType
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
        value = find_attr_value_('scope', node)
        if value is not None and 'scope' not in already_processed:
            already_processed.add('scope')
            self.scope = value
            self.validate_ScopeType(self.scope)    # validate type ScopeType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'alternateIdentifier':
            obj_ = alternateIdentifierType23.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.alternateIdentifier.append(obj_)
            obj_.original_tagname_ = 'alternateIdentifier'
        elif nodeName_ == 'entityName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'entityName')
            value_ = self.gds_validate_string(value_, node, 'entityName')
            self.entityName = value_
            self.entityName_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.entityName)
        elif nodeName_ == 'entityDescription':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'entityDescription')
            value_ = self.gds_validate_string(value_, node, 'entityDescription')
            self.entityDescription = value_
            self.entityDescription_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.entityDescription)
        elif nodeName_ == 'physical':
            obj_ = PhysicalType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.physical.append(obj_)
            obj_.original_tagname_ = 'physical'
        elif nodeName_ == 'coverage':
            obj_ = Coverage.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.coverage = obj_
            obj_.original_tagname_ = 'coverage'
        elif nodeName_ == 'methods':
            obj_ = MethodsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.methods = obj_
            obj_.original_tagname_ = 'methods'
        elif nodeName_ == 'additionalInfo':
            obj_ = TextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.additionalInfo.append(obj_)
            obj_.original_tagname_ = 'additionalInfo'
        elif nodeName_ == 'annotation':
            class_obj_ = self.get_class_obj_(child_, SemanticAnnotation)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.annotation.append(obj_)
            obj_.original_tagname_ = 'annotation'
        elif nodeName_ == 'attributeList':
            obj_ = AttributeListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.attributeList = obj_
            obj_.original_tagname_ = 'attributeList'
        elif nodeName_ == 'constraint':
            obj_ = ConstraintType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.constraint.append(obj_)
            obj_.original_tagname_ = 'constraint'
        elif nodeName_ == 'entityType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'entityType')
            value_ = self.gds_validate_string(value_, node, 'entityType')
            self.entityType = value_
            self.entityType_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.entityType)
        elif nodeName_ == 'references':
            obj_ = referencesType24.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.references = obj_
            obj_.original_tagname_ = 'references'
# end class OtherEntityType


class PhysicalType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'res:IDType', 0, 1, {'use': 'optional'}),
        MemberSpec_('system', 'res:SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('scope', 'res:ScopeType', 0, 1, {'use': 'optional'}),
        MemberSpec_('objectName', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'objectName', 'type': 'xs:string'}, 31),
        MemberSpec_('size', 'sizeType', 0, 1, {'minOccurs': '0', 'name': 'size', 'type': 'sizeType'}, 31),
        MemberSpec_('authentication', 'authenticationType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'authentication', 'type': 'authenticationType'}, 31),
        MemberSpec_('compressionMethod', ['NonEmptyStringType', 'xs:string'], 1, 1, {'name': 'compressionMethod', 'type': 'xs:string'}, 32),
        MemberSpec_('encodingMethod', ['NonEmptyStringType', 'xs:string'], 1, 1, {'name': 'encodingMethod', 'type': 'xs:string'}, 32),
        MemberSpec_('characterEncoding', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'characterEncoding', 'type': 'xs:string'}, None),
        MemberSpec_('dataFormat', 'dataFormatType', 0, 0, {'name': 'dataFormat', 'type': 'dataFormatType'}, None),
        MemberSpec_('distribution', 'PhysicalDistributionType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'distribution', 'type': 'PhysicalDistributionType'}, None),
        MemberSpec_('references', 'referencesType27', 0, 0, {'name': 'references', 'type': 'referencesType27'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, system=None, scope='document', objectName=None, size=None, authentication=None, compressionMethod=None, encodingMethod=None, characterEncoding=None, dataFormat=None, distribution=None, references=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.scope = _cast(None, scope)
        self.scope_nsprefix_ = None
        self.objectName = objectName
        self.validate_NonEmptyStringType(self.objectName)
        self.objectName_nsprefix_ = None
        self.size = size
        self.size_nsprefix_ = None
        if authentication is None:
            self.authentication = []
        else:
            self.authentication = authentication
        self.authentication_nsprefix_ = None
        if compressionMethod is None:
            self.compressionMethod = []
        else:
            self.compressionMethod = compressionMethod
        self.compressionMethod_nsprefix_ = None
        if encodingMethod is None:
            self.encodingMethod = []
        else:
            self.encodingMethod = encodingMethod
        self.encodingMethod_nsprefix_ = None
        self.characterEncoding = characterEncoding
        self.validate_NonEmptyStringType(self.characterEncoding)
        self.characterEncoding_nsprefix_ = None
        self.dataFormat = dataFormat
        self.dataFormat_nsprefix_ = None
        if distribution is None:
            self.distribution = []
        else:
            self.distribution = distribution
        self.distribution_nsprefix_ = None
        self.references = references
        self.references_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhysicalType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhysicalType.subclass:
            return PhysicalType.subclass(*args_, **kwargs_)
        else:
            return PhysicalType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_objectName(self):
        return self.objectName
    def set_objectName(self, objectName):
        self.objectName = objectName
    def get_size(self):
        return self.size
    def set_size(self, size):
        self.size = size
    def get_authentication(self):
        return self.authentication
    def set_authentication(self, authentication):
        self.authentication = authentication
    def add_authentication(self, value):
        self.authentication.append(value)
    def insert_authentication_at(self, index, value):
        self.authentication.insert(index, value)
    def replace_authentication_at(self, index, value):
        self.authentication[index] = value
    def get_compressionMethod(self):
        return self.compressionMethod
    def set_compressionMethod(self, compressionMethod):
        self.compressionMethod = compressionMethod
    def add_compressionMethod(self, value):
        self.compressionMethod.append(value)
    def insert_compressionMethod_at(self, index, value):
        self.compressionMethod.insert(index, value)
    def replace_compressionMethod_at(self, index, value):
        self.compressionMethod[index] = value
    def get_encodingMethod(self):
        return self.encodingMethod
    def set_encodingMethod(self, encodingMethod):
        self.encodingMethod = encodingMethod
    def add_encodingMethod(self, value):
        self.encodingMethod.append(value)
    def insert_encodingMethod_at(self, index, value):
        self.encodingMethod.insert(index, value)
    def replace_encodingMethod_at(self, index, value):
        self.encodingMethod[index] = value
    def get_characterEncoding(self):
        return self.characterEncoding
    def set_characterEncoding(self, characterEncoding):
        self.characterEncoding = characterEncoding
    def get_dataFormat(self):
        return self.dataFormat
    def set_dataFormat(self, dataFormat):
        self.dataFormat = dataFormat
    def get_distribution(self):
        return self.distribution
    def set_distribution(self, distribution):
        self.distribution = distribution
    def add_distribution(self, value):
        self.distribution.append(value)
    def insert_distribution_at(self, index, value):
        self.distribution.insert(index, value)
    def replace_distribution_at(self, index, value):
        self.distribution[index] = value
    def get_references(self):
        return self.references
    def set_references(self, references):
        self.references = references
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_scope(self):
        return self.scope
    def set_scope(self, scope):
        self.scope = scope
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def validate_IDType(self, value):
        # Validate type res:IDType, a restriction on xs:string.
        pass
    def validate_SystemType(self, value):
        # Validate type res:SystemType, a restriction on xs:string.
        pass
    def validate_ScopeType(self, value):
        # Validate type res:ScopeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['system', 'document']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ScopeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.objectName is not None or
            self.size is not None or
            self.authentication or
            self.compressionMethod or
            self.encodingMethod or
            self.characterEncoding is not None or
            self.dataFormat is not None or
            self.distribution or
            self.references is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='PhysicalType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PhysicalType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PhysicalType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PhysicalType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PhysicalType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PhysicalType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
        if self.scope != "document" and 'scope' not in already_processed:
            already_processed.add('scope')
            outfile.write(' scope=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.scope), input_name='scope')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='PhysicalType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.objectName is not None:
            namespaceprefix_ = self.objectName_nsprefix_ + ':' if (UseCapturedNS_ and self.objectName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sobjectName>%s</%sobjectName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.objectName), input_name='objectName')), namespaceprefix_ , eol_))
        if self.size is not None:
            namespaceprefix_ = self.size_nsprefix_ + ':' if (UseCapturedNS_ and self.size_nsprefix_) else ''
            self.size.export(outfile, level, namespaceprefix_, namespacedef_='', name_='size', pretty_print=pretty_print)
        for authentication_ in self.authentication:
            namespaceprefix_ = self.authentication_nsprefix_ + ':' if (UseCapturedNS_ and self.authentication_nsprefix_) else ''
            authentication_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='authentication', pretty_print=pretty_print)
        for compressionMethod_ in self.compressionMethod:
            namespaceprefix_ = self.compressionMethod_nsprefix_ + ':' if (UseCapturedNS_ and self.compressionMethod_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scompressionMethod>%s</%scompressionMethod>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(compressionMethod_), input_name='compressionMethod')), namespaceprefix_ , eol_))
        for encodingMethod_ in self.encodingMethod:
            namespaceprefix_ = self.encodingMethod_nsprefix_ + ':' if (UseCapturedNS_ and self.encodingMethod_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sencodingMethod>%s</%sencodingMethod>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(encodingMethod_), input_name='encodingMethod')), namespaceprefix_ , eol_))
        if self.characterEncoding is not None:
            namespaceprefix_ = self.characterEncoding_nsprefix_ + ':' if (UseCapturedNS_ and self.characterEncoding_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scharacterEncoding>%s</%scharacterEncoding>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.characterEncoding), input_name='characterEncoding')), namespaceprefix_ , eol_))
        if self.dataFormat is not None:
            namespaceprefix_ = self.dataFormat_nsprefix_ + ':' if (UseCapturedNS_ and self.dataFormat_nsprefix_) else ''
            self.dataFormat.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataFormat', pretty_print=pretty_print)
        for distribution_ in self.distribution:
            namespaceprefix_ = self.distribution_nsprefix_ + ':' if (UseCapturedNS_ and self.distribution_nsprefix_) else ''
            distribution_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='distribution', pretty_print=pretty_print)
        if self.references is not None:
            namespaceprefix_ = self.references_nsprefix_ + ':' if (UseCapturedNS_ and self.references_nsprefix_) else ''
            self.references.export(outfile, level, namespaceprefix_, namespacedef_='', name_='references', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_IDType(self.id)    # validate type IDType
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
        value = find_attr_value_('scope', node)
        if value is not None and 'scope' not in already_processed:
            already_processed.add('scope')
            self.scope = value
            self.validate_ScopeType(self.scope)    # validate type ScopeType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'objectName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'objectName')
            value_ = self.gds_validate_string(value_, node, 'objectName')
            self.objectName = value_
            self.objectName_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.objectName)
        elif nodeName_ == 'size':
            obj_ = sizeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.size = obj_
            obj_.original_tagname_ = 'size'
        elif nodeName_ == 'authentication':
            obj_ = authenticationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.authentication.append(obj_)
            obj_.original_tagname_ = 'authentication'
        elif nodeName_ == 'compressionMethod':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'compressionMethod')
            value_ = self.gds_validate_string(value_, node, 'compressionMethod')
            self.compressionMethod.append(value_)
            self.compressionMethod_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.compressionMethod[-1])
        elif nodeName_ == 'encodingMethod':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'encodingMethod')
            value_ = self.gds_validate_string(value_, node, 'encodingMethod')
            self.encodingMethod.append(value_)
            self.encodingMethod_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.encodingMethod[-1])
        elif nodeName_ == 'characterEncoding':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'characterEncoding')
            value_ = self.gds_validate_string(value_, node, 'characterEncoding')
            self.characterEncoding = value_
            self.characterEncoding_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.characterEncoding)
        elif nodeName_ == 'dataFormat':
            obj_ = dataFormatType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dataFormat = obj_
            obj_.original_tagname_ = 'dataFormat'
        elif nodeName_ == 'distribution':
            obj_ = PhysicalDistributionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.distribution.append(obj_)
            obj_.original_tagname_ = 'distribution'
        elif nodeName_ == 'references':
            obj_ = referencesType27.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.references = obj_
            obj_.original_tagname_ = 'references'
# end class PhysicalType


class PhysicalDistributionType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'res:IDType', 0, 1, {'use': 'optional'}),
        MemberSpec_('system', 'res:SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('scope', 'res:ScopeType', 0, 1, {'use': 'optional'}),
        MemberSpec_('online', 'PhysicalOnlineType', 0, 0, {'name': 'online', 'type': 'PhysicalOnlineType'}, 34),
        MemberSpec_('offline', 'OfflineType', 0, 0, {'name': 'offline', 'type': 'OfflineType'}, 34),
        MemberSpec_('inline', 'InlineType', 0, 0, {'name': 'inline', 'type': 'InlineType'}, 34),
        MemberSpec_('access', 'AccessType', 0, 1, {'minOccurs': '0', 'name': 'access', 'type': 'AccessType'}, None),
        MemberSpec_('references', 'referencesType28', 0, 0, {'name': 'references', 'type': 'referencesType28'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, system=None, scope='document', online=None, offline=None, inline=None, access=None, references=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.scope = _cast(None, scope)
        self.scope_nsprefix_ = None
        self.online = online
        self.online_nsprefix_ = None
        self.offline = offline
        self.offline_nsprefix_ = None
        self.inline = inline
        self.inline_nsprefix_ = None
        self.access = access
        self.access_nsprefix_ = None
        self.references = references
        self.references_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhysicalDistributionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhysicalDistributionType.subclass:
            return PhysicalDistributionType.subclass(*args_, **kwargs_)
        else:
            return PhysicalDistributionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_online(self):
        return self.online
    def set_online(self, online):
        self.online = online
    def get_offline(self):
        return self.offline
    def set_offline(self, offline):
        self.offline = offline
    def get_inline(self):
        return self.inline
    def set_inline(self, inline):
        self.inline = inline
    def get_access(self):
        return self.access
    def set_access(self, access):
        self.access = access
    def get_references(self):
        return self.references
    def set_references(self, references):
        self.references = references
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_scope(self):
        return self.scope
    def set_scope(self, scope):
        self.scope = scope
    def validate_IDType(self, value):
        # Validate type res:IDType, a restriction on xs:string.
        pass
    def validate_SystemType(self, value):
        # Validate type res:SystemType, a restriction on xs:string.
        pass
    def validate_ScopeType(self, value):
        # Validate type res:ScopeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['system', 'document']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ScopeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.online is not None or
            self.offline is not None or
            self.inline is not None or
            self.access is not None or
            self.references is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0"  xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:acc="https://eml.ecoinformatics.org/access-2.2.0" ', name_='PhysicalDistributionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PhysicalDistributionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PhysicalDistributionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PhysicalDistributionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PhysicalDistributionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PhysicalDistributionType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
        if self.scope != "document" and 'scope' not in already_processed:
            already_processed.add('scope')
            outfile.write(' scope=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.scope), input_name='scope')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0"  xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:acc="https://eml.ecoinformatics.org/access-2.2.0" ', name_='PhysicalDistributionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.online is not None:
            namespaceprefix_ = self.online_nsprefix_ + ':' if (UseCapturedNS_ and self.online_nsprefix_) else ''
            self.online.export(outfile, level, namespaceprefix_, namespacedef_='', name_='online', pretty_print=pretty_print)
        if self.offline is not None:
            namespaceprefix_ = self.offline_nsprefix_ + ':' if (UseCapturedNS_ and self.offline_nsprefix_) else ''
            self.offline.export(outfile, level, namespaceprefix_, namespacedef_='', name_='offline', pretty_print=pretty_print)
        if self.inline is not None:
            namespaceprefix_ = self.inline_nsprefix_ + ':' if (UseCapturedNS_ and self.inline_nsprefix_) else ''
            self.inline.export(outfile, level, namespaceprefix_, namespacedef_='', name_='inline', pretty_print=pretty_print)
        if self.access is not None:
            namespaceprefix_ = self.access_nsprefix_ + ':' if (UseCapturedNS_ and self.access_nsprefix_) else ''
            self.access.export(outfile, level, namespaceprefix_, namespacedef_='', name_='access', pretty_print=pretty_print)
        if self.references is not None:
            namespaceprefix_ = self.references_nsprefix_ + ':' if (UseCapturedNS_ and self.references_nsprefix_) else ''
            self.references.export(outfile, level, namespaceprefix_, namespacedef_='', name_='references', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_IDType(self.id)    # validate type IDType
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
        value = find_attr_value_('scope', node)
        if value is not None and 'scope' not in already_processed:
            already_processed.add('scope')
            self.scope = value
            self.validate_ScopeType(self.scope)    # validate type ScopeType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'online':
            obj_ = PhysicalOnlineType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.online = obj_
            obj_.original_tagname_ = 'online'
        elif nodeName_ == 'offline':
            obj_ = OfflineType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.offline = obj_
            obj_.original_tagname_ = 'offline'
        elif nodeName_ == 'inline':
            obj_ = InlineType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.inline = obj_
            obj_.original_tagname_ = 'inline'
        elif nodeName_ == 'access':
            obj_ = AccessType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.access = obj_
            obj_.original_tagname_ = 'access'
        elif nodeName_ == 'references':
            obj_ = referencesType28.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.references = obj_
            obj_.original_tagname_ = 'references'
# end class PhysicalDistributionType


class PhysicalOnlineType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('onlineDescription', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'onlineDescription', 'type': 'xs:string'}, None),
        MemberSpec_('url', 'UrlType', 0, 0, {'name': 'url', 'type': 'UrlType'}, 35),
        MemberSpec_('connection', 'ConnectionType', 0, 0, {'name': 'connection', 'type': 'ConnectionType'}, 35),
    ]
    subclass = None
    superclass = None
    def __init__(self, onlineDescription=None, url=None, connection=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.onlineDescription = onlineDescription
        self.validate_NonEmptyStringType(self.onlineDescription)
        self.onlineDescription_nsprefix_ = None
        self.url = url
        self.url_nsprefix_ = None
        self.connection = connection
        self.connection_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhysicalOnlineType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhysicalOnlineType.subclass:
            return PhysicalOnlineType.subclass(*args_, **kwargs_)
        else:
            return PhysicalOnlineType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_onlineDescription(self):
        return self.onlineDescription
    def set_onlineDescription(self, onlineDescription):
        self.onlineDescription = onlineDescription
    def get_url(self):
        return self.url
    def set_url(self, url):
        self.url = url
    def get_connection(self):
        return self.connection
    def set_connection(self, connection):
        self.connection = connection
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def hasContent_(self):
        if (
            self.onlineDescription is not None or
            self.url is not None or
            self.connection is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='PhysicalOnlineType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PhysicalOnlineType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PhysicalOnlineType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PhysicalOnlineType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PhysicalOnlineType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PhysicalOnlineType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='PhysicalOnlineType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.onlineDescription is not None:
            namespaceprefix_ = self.onlineDescription_nsprefix_ + ':' if (UseCapturedNS_ and self.onlineDescription_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sonlineDescription>%s</%sonlineDescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.onlineDescription), input_name='onlineDescription')), namespaceprefix_ , eol_))
        if self.url is not None:
            namespaceprefix_ = self.url_nsprefix_ + ':' if (UseCapturedNS_ and self.url_nsprefix_) else ''
            self.url.export(outfile, level, namespaceprefix_, namespacedef_='', name_='url', pretty_print=pretty_print)
        if self.connection is not None:
            namespaceprefix_ = self.connection_nsprefix_ + ':' if (UseCapturedNS_ and self.connection_nsprefix_) else ''
            self.connection.export(outfile, level, namespaceprefix_, namespacedef_='', name_='connection', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'onlineDescription':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'onlineDescription')
            value_ = self.gds_validate_string(value_, node, 'onlineDescription')
            self.onlineDescription = value_
            self.onlineDescription_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.onlineDescription)
        elif nodeName_ == 'url':
            obj_ = UrlType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.url = obj_
            obj_.original_tagname_ = 'url'
        elif nodeName_ == 'connection':
            obj_ = ConnectionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.connection = obj_
            obj_.original_tagname_ = 'connection'
# end class PhysicalOnlineType


class MethodsType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('methodStep', 'methodStepType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'methodStep', 'type': 'methodStepType'}, None),
        MemberSpec_('sampling', 'samplingType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'sampling', 'type': 'samplingType'}, None),
        MemberSpec_('qualityControl', 'ProcedureStepType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'qualityControl', 'type': 'ProcedureStepType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, methodStep=None, sampling=None, qualityControl=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if methodStep is None:
            self.methodStep = []
        else:
            self.methodStep = methodStep
        self.methodStep_nsprefix_ = None
        if sampling is None:
            self.sampling = []
        else:
            self.sampling = sampling
        self.sampling_nsprefix_ = None
        if qualityControl is None:
            self.qualityControl = []
        else:
            self.qualityControl = qualityControl
        self.qualityControl_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MethodsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MethodsType.subclass:
            return MethodsType.subclass(*args_, **kwargs_)
        else:
            return MethodsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_methodStep(self):
        return self.methodStep
    def set_methodStep(self, methodStep):
        self.methodStep = methodStep
    def add_methodStep(self, value):
        self.methodStep.append(value)
    def insert_methodStep_at(self, index, value):
        self.methodStep.insert(index, value)
    def replace_methodStep_at(self, index, value):
        self.methodStep[index] = value
    def get_sampling(self):
        return self.sampling
    def set_sampling(self, sampling):
        self.sampling = sampling
    def add_sampling(self, value):
        self.sampling.append(value)
    def insert_sampling_at(self, index, value):
        self.sampling.insert(index, value)
    def replace_sampling_at(self, index, value):
        self.sampling[index] = value
    def get_qualityControl(self):
        return self.qualityControl
    def set_qualityControl(self, qualityControl):
        self.qualityControl = qualityControl
    def add_qualityControl(self, value):
        self.qualityControl.append(value)
    def insert_qualityControl_at(self, index, value):
        self.qualityControl.insert(index, value)
    def replace_qualityControl_at(self, index, value):
        self.qualityControl[index] = value
    def hasContent_(self):
        if (
            self.methodStep or
            self.sampling or
            self.qualityControl
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='MethodsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MethodsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MethodsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MethodsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MethodsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MethodsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='MethodsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for methodStep_ in self.methodStep:
            namespaceprefix_ = self.methodStep_nsprefix_ + ':' if (UseCapturedNS_ and self.methodStep_nsprefix_) else ''
            methodStep_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='methodStep', pretty_print=pretty_print)
        for sampling_ in self.sampling:
            namespaceprefix_ = self.sampling_nsprefix_ + ':' if (UseCapturedNS_ and self.sampling_nsprefix_) else ''
            sampling_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sampling', pretty_print=pretty_print)
        for qualityControl_ in self.qualityControl:
            namespaceprefix_ = self.qualityControl_nsprefix_ + ':' if (UseCapturedNS_ and self.qualityControl_nsprefix_) else ''
            qualityControl_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='qualityControl', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'methodStep':
            obj_ = methodStepType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.methodStep.append(obj_)
            obj_.original_tagname_ = 'methodStep'
        elif nodeName_ == 'sampling':
            obj_ = samplingType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.sampling.append(obj_)
            obj_.original_tagname_ = 'sampling'
        elif nodeName_ == 'qualityControl':
            class_obj_ = self.get_class_obj_(child_, ProcedureStepType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.qualityControl.append(obj_)
            obj_.original_tagname_ = 'qualityControl'
# end class MethodsType


class ProcedureStepType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('description', 'TextType', 0, 0, {'name': 'description', 'type': 'TextType'}, None),
        MemberSpec_('citation', 'CitationType', 1, 1, {'name': 'citation', 'type': 'CitationType'}, 36),
        MemberSpec_('protocol', 'ProtocolType', 1, 1, {'name': 'protocol', 'type': 'ProtocolType'}, 36),
        MemberSpec_('instrumentation', ['NonEmptyStringType', 'xs:string'], 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'instrumentation', 'type': 'xs:string'}, None),
        MemberSpec_('software', 'SoftwareType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'software', 'type': 'SoftwareType'}, None),
        MemberSpec_('subStep', 'ProcedureStepType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'subStep', 'type': 'ProcedureStepType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, description=None, citation=None, protocol=None, instrumentation=None, software=None, subStep=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.description = description
        self.description_nsprefix_ = None
        if citation is None:
            self.citation = []
        else:
            self.citation = citation
        self.citation_nsprefix_ = None
        if protocol is None:
            self.protocol = []
        else:
            self.protocol = protocol
        self.protocol_nsprefix_ = None
        if instrumentation is None:
            self.instrumentation = []
        else:
            self.instrumentation = instrumentation
        self.instrumentation_nsprefix_ = None
        if software is None:
            self.software = []
        else:
            self.software = software
        self.software_nsprefix_ = None
        if subStep is None:
            self.subStep = []
        else:
            self.subStep = subStep
        self.subStep_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProcedureStepType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProcedureStepType.subclass:
            return ProcedureStepType.subclass(*args_, **kwargs_)
        else:
            return ProcedureStepType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_citation(self):
        return self.citation
    def set_citation(self, citation):
        self.citation = citation
    def add_citation(self, value):
        self.citation.append(value)
    def insert_citation_at(self, index, value):
        self.citation.insert(index, value)
    def replace_citation_at(self, index, value):
        self.citation[index] = value
    def get_protocol(self):
        return self.protocol
    def set_protocol(self, protocol):
        self.protocol = protocol
    def add_protocol(self, value):
        self.protocol.append(value)
    def insert_protocol_at(self, index, value):
        self.protocol.insert(index, value)
    def replace_protocol_at(self, index, value):
        self.protocol[index] = value
    def get_instrumentation(self):
        return self.instrumentation
    def set_instrumentation(self, instrumentation):
        self.instrumentation = instrumentation
    def add_instrumentation(self, value):
        self.instrumentation.append(value)
    def insert_instrumentation_at(self, index, value):
        self.instrumentation.insert(index, value)
    def replace_instrumentation_at(self, index, value):
        self.instrumentation[index] = value
    def get_software(self):
        return self.software
    def set_software(self, software):
        self.software = software
    def add_software(self, value):
        self.software.append(value)
    def insert_software_at(self, index, value):
        self.software.insert(index, value)
    def replace_software_at(self, index, value):
        self.software[index] = value
    def get_subStep(self):
        return self.subStep
    def set_subStep(self, subStep):
        self.subStep = subStep
    def add_subStep(self, value):
        self.subStep.append(value)
    def insert_subStep_at(self, index, value):
        self.subStep.insert(index, value)
    def replace_subStep_at(self, index, value):
        self.subStep[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def hasContent_(self):
        if (
            self.description is not None or
            self.citation or
            self.protocol or
            self.instrumentation or
            self.software or
            self.subStep
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:txt="https://eml.ecoinformatics.org/text-2.2.0"  xmlns:cit="https://eml.ecoinformatics.org/literature-2.2.0"  xmlns:pro="https://eml.ecoinformatics.org/protocol-2.2.0"  xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:sw="https://eml.ecoinformatics.org/software-2.2.0"  xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='ProcedureStepType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ProcedureStepType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ProcedureStepType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ProcedureStepType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ProcedureStepType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ProcedureStepType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:txt="https://eml.ecoinformatics.org/text-2.2.0"  xmlns:cit="https://eml.ecoinformatics.org/literature-2.2.0"  xmlns:pro="https://eml.ecoinformatics.org/protocol-2.2.0"  xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:sw="https://eml.ecoinformatics.org/software-2.2.0"  xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='ProcedureStepType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            self.description.export(outfile, level, namespaceprefix_, namespacedef_='', name_='description', pretty_print=pretty_print)
        for citation_ in self.citation:
            namespaceprefix_ = self.citation_nsprefix_ + ':' if (UseCapturedNS_ and self.citation_nsprefix_) else ''
            citation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='citation', pretty_print=pretty_print)
        for protocol_ in self.protocol:
            namespaceprefix_ = self.protocol_nsprefix_ + ':' if (UseCapturedNS_ and self.protocol_nsprefix_) else ''
            protocol_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='protocol', pretty_print=pretty_print)
        for instrumentation_ in self.instrumentation:
            namespaceprefix_ = self.instrumentation_nsprefix_ + ':' if (UseCapturedNS_ and self.instrumentation_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinstrumentation>%s</%sinstrumentation>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(instrumentation_), input_name='instrumentation')), namespaceprefix_ , eol_))
        for software_ in self.software:
            namespaceprefix_ = self.software_nsprefix_ + ':' if (UseCapturedNS_ and self.software_nsprefix_) else ''
            software_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='software', pretty_print=pretty_print)
        for subStep_ in self.subStep:
            namespaceprefix_ = self.subStep_nsprefix_ + ':' if (UseCapturedNS_ and self.subStep_nsprefix_) else ''
            subStep_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subStep', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'description':
            obj_ = TextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.description = obj_
            obj_.original_tagname_ = 'description'
        elif nodeName_ == 'citation':
            obj_ = CitationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.citation.append(obj_)
            obj_.original_tagname_ = 'citation'
        elif nodeName_ == 'protocol':
            obj_ = ProtocolType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.protocol.append(obj_)
            obj_.original_tagname_ = 'protocol'
        elif nodeName_ == 'instrumentation':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'instrumentation')
            value_ = self.gds_validate_string(value_, node, 'instrumentation')
            self.instrumentation.append(value_)
            self.instrumentation_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.instrumentation[-1])
        elif nodeName_ == 'software':
            obj_ = SoftwareType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.software.append(obj_)
            obj_.original_tagname_ = 'software'
        elif nodeName_ == 'subStep':
            class_obj_ = self.get_class_obj_(child_, ProcedureStepType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subStep.append(obj_)
            obj_.original_tagname_ = 'subStep'
# end class ProcedureStepType


class SoftwareType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'res:IDType', 0, 1, {'use': 'optional'}),
        MemberSpec_('system', 'res:SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('scope', 'res:ScopeType', 0, 1, {'use': 'optional'}),
        MemberSpec_('alternateIdentifier', 'alternateIdentifierType29', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'alternateIdentifier', 'type': 'alternateIdentifierType29'}, 37),
        MemberSpec_('shortName', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'shortName', 'type': 'xs:string'}, 37),
        MemberSpec_('title', 'i18nNonEmptyStringType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'title', 'type': 'i18nNonEmptyStringType'}, 37),
        MemberSpec_('creator', 'ResponsibleParty', 1, 0, {'maxOccurs': 'unbounded', 'name': 'creator', 'type': 'ResponsibleParty'}, 37),
        MemberSpec_('metadataProvider', 'ResponsibleParty', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'metadataProvider', 'type': 'ResponsibleParty'}, 37),
        MemberSpec_('associatedParty', 'associatedPartyType30', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'associatedParty', 'type': 'associatedPartyType30'}, 37),
        MemberSpec_('pubDate', 'yearDate', 0, 1, {'minOccurs': '0', 'name': 'pubDate', 'type': 'xs:string'}, 37),
        MemberSpec_('language', 'i18nNonEmptyStringType', 0, 1, {'minOccurs': '0', 'name': 'language', 'type': 'i18nNonEmptyStringType'}, 37),
        MemberSpec_('series', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'series', 'type': 'xs:string'}, 37),
        MemberSpec_('abstract', 'TextType', 0, 1, {'minOccurs': '0', 'name': 'abstract', 'type': 'TextType'}, 37),
        MemberSpec_('keywordSet', 'keywordSetType31', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'keywordSet', 'type': 'keywordSetType31'}, 37),
        MemberSpec_('additionalInfo', 'TextType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'additionalInfo', 'type': 'TextType'}, 37),
        MemberSpec_('intellectualRights', 'TextType', 0, 1, {'minOccurs': '0', 'name': 'intellectualRights', 'type': 'TextType'}, 37),
        MemberSpec_('licensed', 'LicenseType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'licensed', 'type': 'LicenseType'}, 37),
        MemberSpec_('distribution', 'DistributionType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'distribution', 'type': 'DistributionType'}, 37),
        MemberSpec_('coverage', 'Coverage', 0, 1, {'minOccurs': '0', 'name': 'coverage', 'type': 'Coverage'}, 37),
        MemberSpec_('annotation', 'SemanticAnnotation', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'annotation', 'type': 'SemanticAnnotation'}, 37),
        MemberSpec_('implementation', 'implementationType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'implementation', 'type': 'implementationType'}, 37),
        MemberSpec_('dependency', 'DependencyType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'dependency', 'type': 'DependencyType'}, 37),
        MemberSpec_('licenseURL', ['NonEmptyStringType', 'xs:string'], 1, 1, {'name': 'licenseURL', 'type': 'xs:string'}, 38),
        MemberSpec_('license', ['NonEmptyStringType', 'xs:string'], 1, 1, {'name': 'license', 'type': 'xs:string'}, 38),
        MemberSpec_('version', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'version', 'type': 'xs:string'}, None),
        MemberSpec_('project', 'ResearchProjectType', 0, 1, {'minOccurs': '0', 'name': 'project', 'type': 'ResearchProjectType'}, None),
        MemberSpec_('references', 'referencesType33', 0, 0, {'name': 'references', 'type': 'referencesType33'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, system=None, scope='document', alternateIdentifier=None, shortName=None, title=None, creator=None, metadataProvider=None, associatedParty=None, pubDate=None, language=None, series=None, abstract=None, keywordSet=None, additionalInfo=None, intellectualRights=None, licensed=None, distribution=None, coverage=None, annotation=None, implementation=None, dependency=None, licenseURL=None, license=None, version=None, project=None, references=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.scope = _cast(None, scope)
        self.scope_nsprefix_ = None
        if alternateIdentifier is None:
            self.alternateIdentifier = []
        else:
            self.alternateIdentifier = alternateIdentifier
        self.alternateIdentifier_nsprefix_ = None
        self.shortName = shortName
        self.validate_NonEmptyStringType(self.shortName)
        self.shortName_nsprefix_ = None
        if title is None:
            self.title = []
        else:
            self.title = title
        self.title_nsprefix_ = None
        if creator is None:
            self.creator = []
        else:
            self.creator = creator
        self.creator_nsprefix_ = None
        if metadataProvider is None:
            self.metadataProvider = []
        else:
            self.metadataProvider = metadataProvider
        self.metadataProvider_nsprefix_ = None
        if associatedParty is None:
            self.associatedParty = []
        else:
            self.associatedParty = associatedParty
        self.associatedParty_nsprefix_ = None
        self.pubDate = pubDate
        self.validate_yearDate(self.pubDate)
        self.pubDate_nsprefix_ = None
        self.language = language
        self.language_nsprefix_ = None
        self.series = series
        self.validate_NonEmptyStringType(self.series)
        self.series_nsprefix_ = None
        self.abstract = abstract
        self.abstract_nsprefix_ = None
        if keywordSet is None:
            self.keywordSet = []
        else:
            self.keywordSet = keywordSet
        self.keywordSet_nsprefix_ = None
        if additionalInfo is None:
            self.additionalInfo = []
        else:
            self.additionalInfo = additionalInfo
        self.additionalInfo_nsprefix_ = None
        self.intellectualRights = intellectualRights
        self.intellectualRights_nsprefix_ = None
        if licensed is None:
            self.licensed = []
        else:
            self.licensed = licensed
        self.licensed_nsprefix_ = None
        if distribution is None:
            self.distribution = []
        else:
            self.distribution = distribution
        self.distribution_nsprefix_ = None
        self.coverage = coverage
        self.coverage_nsprefix_ = None
        if annotation is None:
            self.annotation = []
        else:
            self.annotation = annotation
        self.annotation_nsprefix_ = None
        if implementation is None:
            self.implementation = []
        else:
            self.implementation = implementation
        self.implementation_nsprefix_ = None
        if dependency is None:
            self.dependency = []
        else:
            self.dependency = dependency
        self.dependency_nsprefix_ = None
        if licenseURL is None:
            self.licenseURL = []
        else:
            self.licenseURL = licenseURL
        self.licenseURL_nsprefix_ = None
        if license is None:
            self.license = []
        else:
            self.license = license
        self.license_nsprefix_ = None
        self.version = version
        self.validate_NonEmptyStringType(self.version)
        self.version_nsprefix_ = None
        self.project = project
        self.project_nsprefix_ = None
        self.references = references
        self.references_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SoftwareType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SoftwareType.subclass:
            return SoftwareType.subclass(*args_, **kwargs_)
        else:
            return SoftwareType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_alternateIdentifier(self):
        return self.alternateIdentifier
    def set_alternateIdentifier(self, alternateIdentifier):
        self.alternateIdentifier = alternateIdentifier
    def add_alternateIdentifier(self, value):
        self.alternateIdentifier.append(value)
    def insert_alternateIdentifier_at(self, index, value):
        self.alternateIdentifier.insert(index, value)
    def replace_alternateIdentifier_at(self, index, value):
        self.alternateIdentifier[index] = value
    def get_shortName(self):
        return self.shortName
    def set_shortName(self, shortName):
        self.shortName = shortName
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def add_title(self, value):
        self.title.append(value)
    def insert_title_at(self, index, value):
        self.title.insert(index, value)
    def replace_title_at(self, index, value):
        self.title[index] = value
    def get_creator(self):
        return self.creator
    def set_creator(self, creator):
        self.creator = creator
    def add_creator(self, value):
        self.creator.append(value)
    def insert_creator_at(self, index, value):
        self.creator.insert(index, value)
    def replace_creator_at(self, index, value):
        self.creator[index] = value
    def get_metadataProvider(self):
        return self.metadataProvider
    def set_metadataProvider(self, metadataProvider):
        self.metadataProvider = metadataProvider
    def add_metadataProvider(self, value):
        self.metadataProvider.append(value)
    def insert_metadataProvider_at(self, index, value):
        self.metadataProvider.insert(index, value)
    def replace_metadataProvider_at(self, index, value):
        self.metadataProvider[index] = value
    def get_associatedParty(self):
        return self.associatedParty
    def set_associatedParty(self, associatedParty):
        self.associatedParty = associatedParty
    def add_associatedParty(self, value):
        self.associatedParty.append(value)
    def insert_associatedParty_at(self, index, value):
        self.associatedParty.insert(index, value)
    def replace_associatedParty_at(self, index, value):
        self.associatedParty[index] = value
    def get_pubDate(self):
        return self.pubDate
    def set_pubDate(self, pubDate):
        self.pubDate = pubDate
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_series(self):
        return self.series
    def set_series(self, series):
        self.series = series
    def get_abstract(self):
        return self.abstract
    def set_abstract(self, abstract):
        self.abstract = abstract
    def get_keywordSet(self):
        return self.keywordSet
    def set_keywordSet(self, keywordSet):
        self.keywordSet = keywordSet
    def add_keywordSet(self, value):
        self.keywordSet.append(value)
    def insert_keywordSet_at(self, index, value):
        self.keywordSet.insert(index, value)
    def replace_keywordSet_at(self, index, value):
        self.keywordSet[index] = value
    def get_additionalInfo(self):
        return self.additionalInfo
    def set_additionalInfo(self, additionalInfo):
        self.additionalInfo = additionalInfo
    def add_additionalInfo(self, value):
        self.additionalInfo.append(value)
    def insert_additionalInfo_at(self, index, value):
        self.additionalInfo.insert(index, value)
    def replace_additionalInfo_at(self, index, value):
        self.additionalInfo[index] = value
    def get_intellectualRights(self):
        return self.intellectualRights
    def set_intellectualRights(self, intellectualRights):
        self.intellectualRights = intellectualRights
    def get_licensed(self):
        return self.licensed
    def set_licensed(self, licensed):
        self.licensed = licensed
    def add_licensed(self, value):
        self.licensed.append(value)
    def insert_licensed_at(self, index, value):
        self.licensed.insert(index, value)
    def replace_licensed_at(self, index, value):
        self.licensed[index] = value
    def get_distribution(self):
        return self.distribution
    def set_distribution(self, distribution):
        self.distribution = distribution
    def add_distribution(self, value):
        self.distribution.append(value)
    def insert_distribution_at(self, index, value):
        self.distribution.insert(index, value)
    def replace_distribution_at(self, index, value):
        self.distribution[index] = value
    def get_coverage(self):
        return self.coverage
    def set_coverage(self, coverage):
        self.coverage = coverage
    def get_annotation(self):
        return self.annotation
    def set_annotation(self, annotation):
        self.annotation = annotation
    def add_annotation(self, value):
        self.annotation.append(value)
    def insert_annotation_at(self, index, value):
        self.annotation.insert(index, value)
    def replace_annotation_at(self, index, value):
        self.annotation[index] = value
    def get_implementation(self):
        return self.implementation
    def set_implementation(self, implementation):
        self.implementation = implementation
    def add_implementation(self, value):
        self.implementation.append(value)
    def insert_implementation_at(self, index, value):
        self.implementation.insert(index, value)
    def replace_implementation_at(self, index, value):
        self.implementation[index] = value
    def get_dependency(self):
        return self.dependency
    def set_dependency(self, dependency):
        self.dependency = dependency
    def add_dependency(self, value):
        self.dependency.append(value)
    def insert_dependency_at(self, index, value):
        self.dependency.insert(index, value)
    def replace_dependency_at(self, index, value):
        self.dependency[index] = value
    def get_licenseURL(self):
        return self.licenseURL
    def set_licenseURL(self, licenseURL):
        self.licenseURL = licenseURL
    def add_licenseURL(self, value):
        self.licenseURL.append(value)
    def insert_licenseURL_at(self, index, value):
        self.licenseURL.insert(index, value)
    def replace_licenseURL_at(self, index, value):
        self.licenseURL[index] = value
    def get_license(self):
        return self.license
    def set_license(self, license):
        self.license = license
    def add_license(self, value):
        self.license.append(value)
    def insert_license_at(self, index, value):
        self.license.insert(index, value)
    def replace_license_at(self, index, value):
        self.license[index] = value
    def get_version(self):
        return self.version
    def set_version(self, version):
        self.version = version
    def get_project(self):
        return self.project
    def set_project(self, project):
        self.project = project
    def get_references(self):
        return self.references
    def set_references(self, references):
        self.references = references
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_scope(self):
        return self.scope
    def set_scope(self, scope):
        self.scope = scope
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def validate_yearDate(self, value):
        result = True
        # Validate type yearDate, a restriction on None.
        pass
        return result
    def validate_IDType(self, value):
        # Validate type res:IDType, a restriction on xs:string.
        pass
    def validate_SystemType(self, value):
        # Validate type res:SystemType, a restriction on xs:string.
        pass
    def validate_ScopeType(self, value):
        # Validate type res:ScopeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['system', 'document']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ScopeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.alternateIdentifier or
            self.shortName is not None or
            self.title or
            self.creator or
            self.metadataProvider or
            self.associatedParty or
            self.pubDate is not None or
            self.language is not None or
            self.series is not None or
            self.abstract is not None or
            self.keywordSet or
            self.additionalInfo or
            self.intellectualRights is not None or
            self.licensed or
            self.distribution or
            self.coverage is not None or
            self.annotation or
            self.implementation or
            self.dependency or
            self.licenseURL or
            self.license or
            self.version is not None or
            self.project is not None or
            self.references is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0"  xmlns:rp="https://eml.ecoinformatics.org/party-2.2.0"  xmlns:txt="https://eml.ecoinformatics.org/text-2.2.0"  xmlns:cov="https://eml.ecoinformatics.org/coverage-2.2.0"  xmlns:sem="https://eml.ecoinformatics.org/semantics-2.2.0"  xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:proj="https://eml.ecoinformatics.org/project-2.2.0" ', name_='SoftwareType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SoftwareType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SoftwareType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SoftwareType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SoftwareType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SoftwareType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
        if self.scope != "document" and 'scope' not in already_processed:
            already_processed.add('scope')
            outfile.write(' scope=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.scope), input_name='scope')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0"  xmlns:rp="https://eml.ecoinformatics.org/party-2.2.0"  xmlns:txt="https://eml.ecoinformatics.org/text-2.2.0"  xmlns:cov="https://eml.ecoinformatics.org/coverage-2.2.0"  xmlns:sem="https://eml.ecoinformatics.org/semantics-2.2.0"  xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:proj="https://eml.ecoinformatics.org/project-2.2.0" ', name_='SoftwareType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for alternateIdentifier_ in self.alternateIdentifier:
            namespaceprefix_ = self.alternateIdentifier_nsprefix_ + ':' if (UseCapturedNS_ and self.alternateIdentifier_nsprefix_) else ''
            alternateIdentifier_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='alternateIdentifier', pretty_print=pretty_print)
        if self.shortName is not None:
            namespaceprefix_ = self.shortName_nsprefix_ + ':' if (UseCapturedNS_ and self.shortName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sshortName>%s</%sshortName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.shortName), input_name='shortName')), namespaceprefix_ , eol_))
        for title_ in self.title:
            namespaceprefix_ = self.title_nsprefix_ + ':' if (UseCapturedNS_ and self.title_nsprefix_) else ''
            title_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='title', pretty_print=pretty_print)
        for creator_ in self.creator:
            namespaceprefix_ = self.creator_nsprefix_ + ':' if (UseCapturedNS_ and self.creator_nsprefix_) else ''
            creator_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='creator', pretty_print=pretty_print)
        for metadataProvider_ in self.metadataProvider:
            namespaceprefix_ = self.metadataProvider_nsprefix_ + ':' if (UseCapturedNS_ and self.metadataProvider_nsprefix_) else ''
            metadataProvider_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='metadataProvider', pretty_print=pretty_print)
        for associatedParty_ in self.associatedParty:
            namespaceprefix_ = self.associatedParty_nsprefix_ + ':' if (UseCapturedNS_ and self.associatedParty_nsprefix_) else ''
            associatedParty_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='associatedParty', pretty_print=pretty_print)
        if self.pubDate is not None:
            namespaceprefix_ = self.pubDate_nsprefix_ + ':' if (UseCapturedNS_ and self.pubDate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spubDate>%s</%spubDate>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pubDate), input_name='pubDate')), namespaceprefix_ , eol_))
        if self.language is not None:
            namespaceprefix_ = self.language_nsprefix_ + ':' if (UseCapturedNS_ and self.language_nsprefix_) else ''
            self.language.export(outfile, level, namespaceprefix_, namespacedef_='', name_='language', pretty_print=pretty_print)
        if self.series is not None:
            namespaceprefix_ = self.series_nsprefix_ + ':' if (UseCapturedNS_ and self.series_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sseries>%s</%sseries>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.series), input_name='series')), namespaceprefix_ , eol_))
        if self.abstract is not None:
            namespaceprefix_ = self.abstract_nsprefix_ + ':' if (UseCapturedNS_ and self.abstract_nsprefix_) else ''
            self.abstract.export(outfile, level, namespaceprefix_, namespacedef_='', name_='abstract', pretty_print=pretty_print)
        for keywordSet_ in self.keywordSet:
            namespaceprefix_ = self.keywordSet_nsprefix_ + ':' if (UseCapturedNS_ and self.keywordSet_nsprefix_) else ''
            keywordSet_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='keywordSet', pretty_print=pretty_print)
        for additionalInfo_ in self.additionalInfo:
            namespaceprefix_ = self.additionalInfo_nsprefix_ + ':' if (UseCapturedNS_ and self.additionalInfo_nsprefix_) else ''
            additionalInfo_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='additionalInfo', pretty_print=pretty_print)
        if self.intellectualRights is not None:
            namespaceprefix_ = self.intellectualRights_nsprefix_ + ':' if (UseCapturedNS_ and self.intellectualRights_nsprefix_) else ''
            self.intellectualRights.export(outfile, level, namespaceprefix_, namespacedef_='', name_='intellectualRights', pretty_print=pretty_print)
        for licensed_ in self.licensed:
            namespaceprefix_ = self.licensed_nsprefix_ + ':' if (UseCapturedNS_ and self.licensed_nsprefix_) else ''
            licensed_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='licensed', pretty_print=pretty_print)
        for distribution_ in self.distribution:
            namespaceprefix_ = self.distribution_nsprefix_ + ':' if (UseCapturedNS_ and self.distribution_nsprefix_) else ''
            distribution_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='distribution', pretty_print=pretty_print)
        if self.coverage is not None:
            namespaceprefix_ = self.coverage_nsprefix_ + ':' if (UseCapturedNS_ and self.coverage_nsprefix_) else ''
            self.coverage.export(outfile, level, namespaceprefix_, namespacedef_='', name_='coverage', pretty_print=pretty_print)
        for annotation_ in self.annotation:
            namespaceprefix_ = self.annotation_nsprefix_ + ':' if (UseCapturedNS_ and self.annotation_nsprefix_) else ''
            annotation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='annotation', pretty_print=pretty_print)
        for implementation_ in self.implementation:
            namespaceprefix_ = self.implementation_nsprefix_ + ':' if (UseCapturedNS_ and self.implementation_nsprefix_) else ''
            implementation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='implementation', pretty_print=pretty_print)
        for dependency_ in self.dependency:
            namespaceprefix_ = self.dependency_nsprefix_ + ':' if (UseCapturedNS_ and self.dependency_nsprefix_) else ''
            dependency_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dependency', pretty_print=pretty_print)
        for licenseURL_ in self.licenseURL:
            namespaceprefix_ = self.licenseURL_nsprefix_ + ':' if (UseCapturedNS_ and self.licenseURL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slicenseURL>%s</%slicenseURL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(licenseURL_), input_name='licenseURL')), namespaceprefix_ , eol_))
        for license_ in self.license:
            namespaceprefix_ = self.license_nsprefix_ + ':' if (UseCapturedNS_ and self.license_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slicense>%s</%slicense>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(license_), input_name='license')), namespaceprefix_ , eol_))
        if self.version is not None:
            namespaceprefix_ = self.version_nsprefix_ + ':' if (UseCapturedNS_ and self.version_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sversion>%s</%sversion>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.version), input_name='version')), namespaceprefix_ , eol_))
        if self.project is not None:
            namespaceprefix_ = self.project_nsprefix_ + ':' if (UseCapturedNS_ and self.project_nsprefix_) else ''
            self.project.export(outfile, level, namespaceprefix_, namespacedef_='', name_='project', pretty_print=pretty_print)
        if self.references is not None:
            namespaceprefix_ = self.references_nsprefix_ + ':' if (UseCapturedNS_ and self.references_nsprefix_) else ''
            self.references.export(outfile, level, namespaceprefix_, namespacedef_='', name_='references', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_IDType(self.id)    # validate type IDType
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
        value = find_attr_value_('scope', node)
        if value is not None and 'scope' not in already_processed:
            already_processed.add('scope')
            self.scope = value
            self.validate_ScopeType(self.scope)    # validate type ScopeType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'alternateIdentifier':
            obj_ = alternateIdentifierType29.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.alternateIdentifier.append(obj_)
            obj_.original_tagname_ = 'alternateIdentifier'
        elif nodeName_ == 'shortName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'shortName')
            value_ = self.gds_validate_string(value_, node, 'shortName')
            self.shortName = value_
            self.shortName_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.shortName)
        elif nodeName_ == 'title':
            class_obj_ = self.get_class_obj_(child_, i18nNonEmptyStringType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.title.append(obj_)
            obj_.original_tagname_ = 'title'
        elif nodeName_ == 'creator':
            class_obj_ = self.get_class_obj_(child_, ResponsibleParty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.creator.append(obj_)
            obj_.original_tagname_ = 'creator'
        elif nodeName_ == 'metadataProvider':
            class_obj_ = self.get_class_obj_(child_, ResponsibleParty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.metadataProvider.append(obj_)
            obj_.original_tagname_ = 'metadataProvider'
        elif nodeName_ == 'associatedParty':
            obj_ = associatedPartyType30.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.associatedParty.append(obj_)
            obj_.original_tagname_ = 'associatedParty'
        elif nodeName_ == 'pubDate':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'pubDate')
            value_ = self.gds_validate_string(value_, node, 'pubDate')
            self.pubDate = value_
            self.pubDate_nsprefix_ = child_.prefix
            # validate type yearDate
            self.validate_yearDate(self.pubDate)
        elif nodeName_ == 'language':
            class_obj_ = self.get_class_obj_(child_, i18nNonEmptyStringType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.language = obj_
            obj_.original_tagname_ = 'language'
        elif nodeName_ == 'series':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'series')
            value_ = self.gds_validate_string(value_, node, 'series')
            self.series = value_
            self.series_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.series)
        elif nodeName_ == 'abstract':
            obj_ = TextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.abstract = obj_
            obj_.original_tagname_ = 'abstract'
        elif nodeName_ == 'keywordSet':
            obj_ = keywordSetType31.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.keywordSet.append(obj_)
            obj_.original_tagname_ = 'keywordSet'
        elif nodeName_ == 'additionalInfo':
            obj_ = TextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.additionalInfo.append(obj_)
            obj_.original_tagname_ = 'additionalInfo'
        elif nodeName_ == 'intellectualRights':
            obj_ = TextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.intellectualRights = obj_
            obj_.original_tagname_ = 'intellectualRights'
        elif nodeName_ == 'licensed':
            obj_ = LicenseType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.licensed.append(obj_)
            obj_.original_tagname_ = 'licensed'
        elif nodeName_ == 'distribution':
            obj_ = DistributionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.distribution.append(obj_)
            obj_.original_tagname_ = 'distribution'
        elif nodeName_ == 'coverage':
            obj_ = Coverage.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.coverage = obj_
            obj_.original_tagname_ = 'coverage'
        elif nodeName_ == 'annotation':
            class_obj_ = self.get_class_obj_(child_, SemanticAnnotation)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.annotation.append(obj_)
            obj_.original_tagname_ = 'annotation'
        elif nodeName_ == 'implementation':
            obj_ = implementationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.implementation.append(obj_)
            obj_.original_tagname_ = 'implementation'
        elif nodeName_ == 'dependency':
            obj_ = DependencyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dependency.append(obj_)
            obj_.original_tagname_ = 'dependency'
        elif nodeName_ == 'licenseURL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'licenseURL')
            value_ = self.gds_validate_string(value_, node, 'licenseURL')
            self.licenseURL.append(value_)
            self.licenseURL_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.licenseURL[-1])
        elif nodeName_ == 'license':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'license')
            value_ = self.gds_validate_string(value_, node, 'license')
            self.license.append(value_)
            self.license_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.license[-1])
        elif nodeName_ == 'version':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'version')
            value_ = self.gds_validate_string(value_, node, 'version')
            self.version = value_
            self.version_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.version)
        elif nodeName_ == 'project':
            obj_ = ResearchProjectType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.project = obj_
            obj_.original_tagname_ = 'project'
        elif nodeName_ == 'references':
            obj_ = referencesType33.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.references = obj_
            obj_.original_tagname_ = 'references'
# end class SoftwareType


class DependencyType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('action', ['Action', 'xs:string'], 0, 0, {'name': 'action', 'type': 'xs:string'}, None),
        MemberSpec_('software', 'SoftwareType', 0, 0, {'name': 'software', 'type': 'SoftwareType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, action=None, software=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.action = action
        self.validate_Action(self.action)
        self.action_nsprefix_ = None
        self.software = software
        self.software_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DependencyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DependencyType.subclass:
            return DependencyType.subclass(*args_, **kwargs_)
        else:
            return DependencyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_action(self):
        return self.action
    def set_action(self, action):
        self.action = action
    def get_software(self):
        return self.software
    def set_software(self, software):
        self.software = software
    def validate_Action(self, value):
        result = True
        # Validate type Action, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['install', 'assert']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on Action' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.action is not None or
            self.software is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='DependencyType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DependencyType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DependencyType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DependencyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DependencyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DependencyType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='DependencyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.action is not None:
            namespaceprefix_ = self.action_nsprefix_ + ':' if (UseCapturedNS_ and self.action_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saction>%s</%saction>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.action), input_name='action')), namespaceprefix_ , eol_))
        if self.software is not None:
            namespaceprefix_ = self.software_nsprefix_ + ':' if (UseCapturedNS_ and self.software_nsprefix_) else ''
            self.software.export(outfile, level, namespaceprefix_, namespacedef_='', name_='software', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'action':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'action')
            value_ = self.gds_validate_string(value_, node, 'action')
            self.action = value_
            self.action_nsprefix_ = child_.prefix
            # validate type Action
            self.validate_Action(self.action)
        elif nodeName_ == 'software':
            obj_ = SoftwareType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.software = obj_
            obj_.original_tagname_ = 'software'
# end class DependencyType


class ProtocolType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'res:IDType', 0, 1, {'use': 'optional'}),
        MemberSpec_('system', 'res:SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('scope', 'res:ScopeType', 0, 1, {'use': 'optional'}),
        MemberSpec_('alternateIdentifier', 'alternateIdentifierType34', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'alternateIdentifier', 'type': 'alternateIdentifierType34'}, 39),
        MemberSpec_('shortName', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'shortName', 'type': 'xs:string'}, 39),
        MemberSpec_('title', 'i18nNonEmptyStringType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'title', 'type': 'i18nNonEmptyStringType'}, 39),
        MemberSpec_('creator', 'ResponsibleParty', 1, 0, {'maxOccurs': 'unbounded', 'name': 'creator', 'type': 'ResponsibleParty'}, 39),
        MemberSpec_('metadataProvider', 'ResponsibleParty', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'metadataProvider', 'type': 'ResponsibleParty'}, 39),
        MemberSpec_('associatedParty', 'associatedPartyType35', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'associatedParty', 'type': 'associatedPartyType35'}, 39),
        MemberSpec_('pubDate', 'yearDate', 0, 1, {'minOccurs': '0', 'name': 'pubDate', 'type': 'xs:string'}, 39),
        MemberSpec_('language', 'i18nNonEmptyStringType', 0, 1, {'minOccurs': '0', 'name': 'language', 'type': 'i18nNonEmptyStringType'}, 39),
        MemberSpec_('series', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'series', 'type': 'xs:string'}, 39),
        MemberSpec_('abstract', 'TextType', 0, 1, {'minOccurs': '0', 'name': 'abstract', 'type': 'TextType'}, 39),
        MemberSpec_('keywordSet', 'keywordSetType36', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'keywordSet', 'type': 'keywordSetType36'}, 39),
        MemberSpec_('additionalInfo', 'TextType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'additionalInfo', 'type': 'TextType'}, 39),
        MemberSpec_('intellectualRights', 'TextType', 0, 1, {'minOccurs': '0', 'name': 'intellectualRights', 'type': 'TextType'}, 39),
        MemberSpec_('licensed', 'LicenseType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'licensed', 'type': 'LicenseType'}, 39),
        MemberSpec_('distribution', 'DistributionType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'distribution', 'type': 'DistributionType'}, 39),
        MemberSpec_('coverage', 'Coverage', 0, 1, {'minOccurs': '0', 'name': 'coverage', 'type': 'Coverage'}, 39),
        MemberSpec_('annotation', 'SemanticAnnotation', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'annotation', 'type': 'SemanticAnnotation'}, 39),
        MemberSpec_('proceduralStep', 'ProcedureStepType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'proceduralStep', 'type': 'ProcedureStepType'}, 39),
        MemberSpec_('references', 'referencesType38', 0, 0, {'name': 'references', 'type': 'referencesType38'}, 39),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, system=None, scope='document', alternateIdentifier=None, shortName=None, title=None, creator=None, metadataProvider=None, associatedParty=None, pubDate=None, language=None, series=None, abstract=None, keywordSet=None, additionalInfo=None, intellectualRights=None, licensed=None, distribution=None, coverage=None, annotation=None, proceduralStep=None, references=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.scope = _cast(None, scope)
        self.scope_nsprefix_ = None
        if alternateIdentifier is None:
            self.alternateIdentifier = []
        else:
            self.alternateIdentifier = alternateIdentifier
        self.alternateIdentifier_nsprefix_ = None
        self.shortName = shortName
        self.validate_NonEmptyStringType(self.shortName)
        self.shortName_nsprefix_ = None
        if title is None:
            self.title = []
        else:
            self.title = title
        self.title_nsprefix_ = None
        if creator is None:
            self.creator = []
        else:
            self.creator = creator
        self.creator_nsprefix_ = None
        if metadataProvider is None:
            self.metadataProvider = []
        else:
            self.metadataProvider = metadataProvider
        self.metadataProvider_nsprefix_ = None
        if associatedParty is None:
            self.associatedParty = []
        else:
            self.associatedParty = associatedParty
        self.associatedParty_nsprefix_ = None
        self.pubDate = pubDate
        self.validate_yearDate(self.pubDate)
        self.pubDate_nsprefix_ = None
        self.language = language
        self.language_nsprefix_ = None
        self.series = series
        self.validate_NonEmptyStringType(self.series)
        self.series_nsprefix_ = None
        self.abstract = abstract
        self.abstract_nsprefix_ = None
        if keywordSet is None:
            self.keywordSet = []
        else:
            self.keywordSet = keywordSet
        self.keywordSet_nsprefix_ = None
        if additionalInfo is None:
            self.additionalInfo = []
        else:
            self.additionalInfo = additionalInfo
        self.additionalInfo_nsprefix_ = None
        self.intellectualRights = intellectualRights
        self.intellectualRights_nsprefix_ = None
        if licensed is None:
            self.licensed = []
        else:
            self.licensed = licensed
        self.licensed_nsprefix_ = None
        if distribution is None:
            self.distribution = []
        else:
            self.distribution = distribution
        self.distribution_nsprefix_ = None
        self.coverage = coverage
        self.coverage_nsprefix_ = None
        if annotation is None:
            self.annotation = []
        else:
            self.annotation = annotation
        self.annotation_nsprefix_ = None
        if proceduralStep is None:
            self.proceduralStep = []
        else:
            self.proceduralStep = proceduralStep
        self.proceduralStep_nsprefix_ = None
        self.references = references
        self.references_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProtocolType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProtocolType.subclass:
            return ProtocolType.subclass(*args_, **kwargs_)
        else:
            return ProtocolType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_alternateIdentifier(self):
        return self.alternateIdentifier
    def set_alternateIdentifier(self, alternateIdentifier):
        self.alternateIdentifier = alternateIdentifier
    def add_alternateIdentifier(self, value):
        self.alternateIdentifier.append(value)
    def insert_alternateIdentifier_at(self, index, value):
        self.alternateIdentifier.insert(index, value)
    def replace_alternateIdentifier_at(self, index, value):
        self.alternateIdentifier[index] = value
    def get_shortName(self):
        return self.shortName
    def set_shortName(self, shortName):
        self.shortName = shortName
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def add_title(self, value):
        self.title.append(value)
    def insert_title_at(self, index, value):
        self.title.insert(index, value)
    def replace_title_at(self, index, value):
        self.title[index] = value
    def get_creator(self):
        return self.creator
    def set_creator(self, creator):
        self.creator = creator
    def add_creator(self, value):
        self.creator.append(value)
    def insert_creator_at(self, index, value):
        self.creator.insert(index, value)
    def replace_creator_at(self, index, value):
        self.creator[index] = value
    def get_metadataProvider(self):
        return self.metadataProvider
    def set_metadataProvider(self, metadataProvider):
        self.metadataProvider = metadataProvider
    def add_metadataProvider(self, value):
        self.metadataProvider.append(value)
    def insert_metadataProvider_at(self, index, value):
        self.metadataProvider.insert(index, value)
    def replace_metadataProvider_at(self, index, value):
        self.metadataProvider[index] = value
    def get_associatedParty(self):
        return self.associatedParty
    def set_associatedParty(self, associatedParty):
        self.associatedParty = associatedParty
    def add_associatedParty(self, value):
        self.associatedParty.append(value)
    def insert_associatedParty_at(self, index, value):
        self.associatedParty.insert(index, value)
    def replace_associatedParty_at(self, index, value):
        self.associatedParty[index] = value
    def get_pubDate(self):
        return self.pubDate
    def set_pubDate(self, pubDate):
        self.pubDate = pubDate
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_series(self):
        return self.series
    def set_series(self, series):
        self.series = series
    def get_abstract(self):
        return self.abstract
    def set_abstract(self, abstract):
        self.abstract = abstract
    def get_keywordSet(self):
        return self.keywordSet
    def set_keywordSet(self, keywordSet):
        self.keywordSet = keywordSet
    def add_keywordSet(self, value):
        self.keywordSet.append(value)
    def insert_keywordSet_at(self, index, value):
        self.keywordSet.insert(index, value)
    def replace_keywordSet_at(self, index, value):
        self.keywordSet[index] = value
    def get_additionalInfo(self):
        return self.additionalInfo
    def set_additionalInfo(self, additionalInfo):
        self.additionalInfo = additionalInfo
    def add_additionalInfo(self, value):
        self.additionalInfo.append(value)
    def insert_additionalInfo_at(self, index, value):
        self.additionalInfo.insert(index, value)
    def replace_additionalInfo_at(self, index, value):
        self.additionalInfo[index] = value
    def get_intellectualRights(self):
        return self.intellectualRights
    def set_intellectualRights(self, intellectualRights):
        self.intellectualRights = intellectualRights
    def get_licensed(self):
        return self.licensed
    def set_licensed(self, licensed):
        self.licensed = licensed
    def add_licensed(self, value):
        self.licensed.append(value)
    def insert_licensed_at(self, index, value):
        self.licensed.insert(index, value)
    def replace_licensed_at(self, index, value):
        self.licensed[index] = value
    def get_distribution(self):
        return self.distribution
    def set_distribution(self, distribution):
        self.distribution = distribution
    def add_distribution(self, value):
        self.distribution.append(value)
    def insert_distribution_at(self, index, value):
        self.distribution.insert(index, value)
    def replace_distribution_at(self, index, value):
        self.distribution[index] = value
    def get_coverage(self):
        return self.coverage
    def set_coverage(self, coverage):
        self.coverage = coverage
    def get_annotation(self):
        return self.annotation
    def set_annotation(self, annotation):
        self.annotation = annotation
    def add_annotation(self, value):
        self.annotation.append(value)
    def insert_annotation_at(self, index, value):
        self.annotation.insert(index, value)
    def replace_annotation_at(self, index, value):
        self.annotation[index] = value
    def get_proceduralStep(self):
        return self.proceduralStep
    def set_proceduralStep(self, proceduralStep):
        self.proceduralStep = proceduralStep
    def add_proceduralStep(self, value):
        self.proceduralStep.append(value)
    def insert_proceduralStep_at(self, index, value):
        self.proceduralStep.insert(index, value)
    def replace_proceduralStep_at(self, index, value):
        self.proceduralStep[index] = value
    def get_references(self):
        return self.references
    def set_references(self, references):
        self.references = references
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_scope(self):
        return self.scope
    def set_scope(self, scope):
        self.scope = scope
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def validate_yearDate(self, value):
        result = True
        # Validate type yearDate, a restriction on None.
        pass
        return result
    def validate_IDType(self, value):
        # Validate type res:IDType, a restriction on xs:string.
        pass
    def validate_SystemType(self, value):
        # Validate type res:SystemType, a restriction on xs:string.
        pass
    def validate_ScopeType(self, value):
        # Validate type res:ScopeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['system', 'document']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ScopeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.alternateIdentifier or
            self.shortName is not None or
            self.title or
            self.creator or
            self.metadataProvider or
            self.associatedParty or
            self.pubDate is not None or
            self.language is not None or
            self.series is not None or
            self.abstract is not None or
            self.keywordSet or
            self.additionalInfo or
            self.intellectualRights is not None or
            self.licensed or
            self.distribution or
            self.coverage is not None or
            self.annotation or
            self.proceduralStep or
            self.references is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0"  xmlns:rp="https://eml.ecoinformatics.org/party-2.2.0"  xmlns:txt="https://eml.ecoinformatics.org/text-2.2.0"  xmlns:cov="https://eml.ecoinformatics.org/coverage-2.2.0"  xmlns:sem="https://eml.ecoinformatics.org/semantics-2.2.0"  xmlns:md="https://eml.ecoinformatics.org/methods-2.2.0" ', name_='ProtocolType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ProtocolType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ProtocolType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ProtocolType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ProtocolType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ProtocolType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
        if self.scope != "document" and 'scope' not in already_processed:
            already_processed.add('scope')
            outfile.write(' scope=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.scope), input_name='scope')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0"  xmlns:rp="https://eml.ecoinformatics.org/party-2.2.0"  xmlns:txt="https://eml.ecoinformatics.org/text-2.2.0"  xmlns:cov="https://eml.ecoinformatics.org/coverage-2.2.0"  xmlns:sem="https://eml.ecoinformatics.org/semantics-2.2.0"  xmlns:md="https://eml.ecoinformatics.org/methods-2.2.0" ', name_='ProtocolType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for alternateIdentifier_ in self.alternateIdentifier:
            namespaceprefix_ = self.alternateIdentifier_nsprefix_ + ':' if (UseCapturedNS_ and self.alternateIdentifier_nsprefix_) else ''
            alternateIdentifier_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='alternateIdentifier', pretty_print=pretty_print)
        if self.shortName is not None:
            namespaceprefix_ = self.shortName_nsprefix_ + ':' if (UseCapturedNS_ and self.shortName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sshortName>%s</%sshortName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.shortName), input_name='shortName')), namespaceprefix_ , eol_))
        for title_ in self.title:
            namespaceprefix_ = self.title_nsprefix_ + ':' if (UseCapturedNS_ and self.title_nsprefix_) else ''
            title_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='title', pretty_print=pretty_print)
        for creator_ in self.creator:
            namespaceprefix_ = self.creator_nsprefix_ + ':' if (UseCapturedNS_ and self.creator_nsprefix_) else ''
            creator_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='creator', pretty_print=pretty_print)
        for metadataProvider_ in self.metadataProvider:
            namespaceprefix_ = self.metadataProvider_nsprefix_ + ':' if (UseCapturedNS_ and self.metadataProvider_nsprefix_) else ''
            metadataProvider_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='metadataProvider', pretty_print=pretty_print)
        for associatedParty_ in self.associatedParty:
            namespaceprefix_ = self.associatedParty_nsprefix_ + ':' if (UseCapturedNS_ and self.associatedParty_nsprefix_) else ''
            associatedParty_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='associatedParty', pretty_print=pretty_print)
        if self.pubDate is not None:
            namespaceprefix_ = self.pubDate_nsprefix_ + ':' if (UseCapturedNS_ and self.pubDate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spubDate>%s</%spubDate>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pubDate), input_name='pubDate')), namespaceprefix_ , eol_))
        if self.language is not None:
            namespaceprefix_ = self.language_nsprefix_ + ':' if (UseCapturedNS_ and self.language_nsprefix_) else ''
            self.language.export(outfile, level, namespaceprefix_, namespacedef_='', name_='language', pretty_print=pretty_print)
        if self.series is not None:
            namespaceprefix_ = self.series_nsprefix_ + ':' if (UseCapturedNS_ and self.series_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sseries>%s</%sseries>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.series), input_name='series')), namespaceprefix_ , eol_))
        if self.abstract is not None:
            namespaceprefix_ = self.abstract_nsprefix_ + ':' if (UseCapturedNS_ and self.abstract_nsprefix_) else ''
            self.abstract.export(outfile, level, namespaceprefix_, namespacedef_='', name_='abstract', pretty_print=pretty_print)
        for keywordSet_ in self.keywordSet:
            namespaceprefix_ = self.keywordSet_nsprefix_ + ':' if (UseCapturedNS_ and self.keywordSet_nsprefix_) else ''
            keywordSet_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='keywordSet', pretty_print=pretty_print)
        for additionalInfo_ in self.additionalInfo:
            namespaceprefix_ = self.additionalInfo_nsprefix_ + ':' if (UseCapturedNS_ and self.additionalInfo_nsprefix_) else ''
            additionalInfo_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='additionalInfo', pretty_print=pretty_print)
        if self.intellectualRights is not None:
            namespaceprefix_ = self.intellectualRights_nsprefix_ + ':' if (UseCapturedNS_ and self.intellectualRights_nsprefix_) else ''
            self.intellectualRights.export(outfile, level, namespaceprefix_, namespacedef_='', name_='intellectualRights', pretty_print=pretty_print)
        for licensed_ in self.licensed:
            namespaceprefix_ = self.licensed_nsprefix_ + ':' if (UseCapturedNS_ and self.licensed_nsprefix_) else ''
            licensed_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='licensed', pretty_print=pretty_print)
        for distribution_ in self.distribution:
            namespaceprefix_ = self.distribution_nsprefix_ + ':' if (UseCapturedNS_ and self.distribution_nsprefix_) else ''
            distribution_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='distribution', pretty_print=pretty_print)
        if self.coverage is not None:
            namespaceprefix_ = self.coverage_nsprefix_ + ':' if (UseCapturedNS_ and self.coverage_nsprefix_) else ''
            self.coverage.export(outfile, level, namespaceprefix_, namespacedef_='', name_='coverage', pretty_print=pretty_print)
        for annotation_ in self.annotation:
            namespaceprefix_ = self.annotation_nsprefix_ + ':' if (UseCapturedNS_ and self.annotation_nsprefix_) else ''
            annotation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='annotation', pretty_print=pretty_print)
        for proceduralStep_ in self.proceduralStep:
            namespaceprefix_ = self.proceduralStep_nsprefix_ + ':' if (UseCapturedNS_ and self.proceduralStep_nsprefix_) else ''
            proceduralStep_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='proceduralStep', pretty_print=pretty_print)
        if self.references is not None:
            namespaceprefix_ = self.references_nsprefix_ + ':' if (UseCapturedNS_ and self.references_nsprefix_) else ''
            self.references.export(outfile, level, namespaceprefix_, namespacedef_='', name_='references', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_IDType(self.id)    # validate type IDType
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
        value = find_attr_value_('scope', node)
        if value is not None and 'scope' not in already_processed:
            already_processed.add('scope')
            self.scope = value
            self.validate_ScopeType(self.scope)    # validate type ScopeType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'alternateIdentifier':
            obj_ = alternateIdentifierType34.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.alternateIdentifier.append(obj_)
            obj_.original_tagname_ = 'alternateIdentifier'
        elif nodeName_ == 'shortName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'shortName')
            value_ = self.gds_validate_string(value_, node, 'shortName')
            self.shortName = value_
            self.shortName_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.shortName)
        elif nodeName_ == 'title':
            class_obj_ = self.get_class_obj_(child_, i18nNonEmptyStringType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.title.append(obj_)
            obj_.original_tagname_ = 'title'
        elif nodeName_ == 'creator':
            class_obj_ = self.get_class_obj_(child_, ResponsibleParty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.creator.append(obj_)
            obj_.original_tagname_ = 'creator'
        elif nodeName_ == 'metadataProvider':
            class_obj_ = self.get_class_obj_(child_, ResponsibleParty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.metadataProvider.append(obj_)
            obj_.original_tagname_ = 'metadataProvider'
        elif nodeName_ == 'associatedParty':
            obj_ = associatedPartyType35.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.associatedParty.append(obj_)
            obj_.original_tagname_ = 'associatedParty'
        elif nodeName_ == 'pubDate':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'pubDate')
            value_ = self.gds_validate_string(value_, node, 'pubDate')
            self.pubDate = value_
            self.pubDate_nsprefix_ = child_.prefix
            # validate type yearDate
            self.validate_yearDate(self.pubDate)
        elif nodeName_ == 'language':
            class_obj_ = self.get_class_obj_(child_, i18nNonEmptyStringType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.language = obj_
            obj_.original_tagname_ = 'language'
        elif nodeName_ == 'series':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'series')
            value_ = self.gds_validate_string(value_, node, 'series')
            self.series = value_
            self.series_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.series)
        elif nodeName_ == 'abstract':
            obj_ = TextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.abstract = obj_
            obj_.original_tagname_ = 'abstract'
        elif nodeName_ == 'keywordSet':
            obj_ = keywordSetType36.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.keywordSet.append(obj_)
            obj_.original_tagname_ = 'keywordSet'
        elif nodeName_ == 'additionalInfo':
            obj_ = TextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.additionalInfo.append(obj_)
            obj_.original_tagname_ = 'additionalInfo'
        elif nodeName_ == 'intellectualRights':
            obj_ = TextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.intellectualRights = obj_
            obj_.original_tagname_ = 'intellectualRights'
        elif nodeName_ == 'licensed':
            obj_ = LicenseType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.licensed.append(obj_)
            obj_.original_tagname_ = 'licensed'
        elif nodeName_ == 'distribution':
            obj_ = DistributionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.distribution.append(obj_)
            obj_.original_tagname_ = 'distribution'
        elif nodeName_ == 'coverage':
            obj_ = Coverage.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.coverage = obj_
            obj_.original_tagname_ = 'coverage'
        elif nodeName_ == 'annotation':
            class_obj_ = self.get_class_obj_(child_, SemanticAnnotation)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.annotation.append(obj_)
            obj_.original_tagname_ = 'annotation'
        elif nodeName_ == 'proceduralStep':
            class_obj_ = self.get_class_obj_(child_, ProcedureStepType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.proceduralStep.append(obj_)
            obj_.original_tagname_ = 'proceduralStep'
        elif nodeName_ == 'references':
            obj_ = referencesType38.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.references = obj_
            obj_.original_tagname_ = 'references'
# end class ProtocolType


class AttributeListType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'res:IDType', 0, 1, {'use': 'optional'}),
        MemberSpec_('attribute', 'AttributeType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'attribute', 'type': 'AttributeType'}, 40),
        MemberSpec_('references', 'referencesType39', 0, 0, {'name': 'references', 'type': 'referencesType39'}, 40),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, attribute=None, references=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        if attribute is None:
            self.attribute = []
        else:
            self.attribute = attribute
        self.attribute_nsprefix_ = None
        self.references = references
        self.references_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AttributeListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AttributeListType.subclass:
            return AttributeListType.subclass(*args_, **kwargs_)
        else:
            return AttributeListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_attribute(self):
        return self.attribute
    def set_attribute(self, attribute):
        self.attribute = attribute
    def add_attribute(self, value):
        self.attribute.append(value)
    def insert_attribute_at(self, index, value):
        self.attribute.insert(index, value)
    def replace_attribute_at(self, index, value):
        self.attribute[index] = value
    def get_references(self):
        return self.references
    def set_references(self, references):
        self.references = references
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_IDType(self, value):
        # Validate type res:IDType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.attribute or
            self.references is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='AttributeListType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AttributeListType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AttributeListType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AttributeListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AttributeListType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AttributeListType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='AttributeListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for attribute_ in self.attribute:
            namespaceprefix_ = self.attribute_nsprefix_ + ':' if (UseCapturedNS_ and self.attribute_nsprefix_) else ''
            attribute_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='attribute', pretty_print=pretty_print)
        if self.references is not None:
            namespaceprefix_ = self.references_nsprefix_ + ':' if (UseCapturedNS_ and self.references_nsprefix_) else ''
            self.references.export(outfile, level, namespaceprefix_, namespacedef_='', name_='references', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_IDType(self.id)    # validate type IDType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'attribute':
            obj_ = AttributeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.attribute.append(obj_)
            obj_.original_tagname_ = 'attribute'
        elif nodeName_ == 'references':
            obj_ = referencesType39.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.references = obj_
            obj_.original_tagname_ = 'references'
# end class AttributeListType


class AttributeType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'res:IDType', 0, 1, {'use': 'optional'}),
        MemberSpec_('system', 'res:SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('scope', 'res:ScopeType', 0, 1, {'use': 'optional'}),
        MemberSpec_('attributeName', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'attributeName', 'type': 'xs:string'}, 41),
        MemberSpec_('attributeLabel', ['NonEmptyStringType', 'xs:string'], 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'attributeLabel', 'type': 'xs:string'}, 41),
        MemberSpec_('attributeDefinition', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'attributeDefinition', 'type': 'xs:string'}, 41),
        MemberSpec_('storageType', 'storageTypeType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'storageType', 'type': 'storageTypeType'}, 41),
        MemberSpec_('measurementScale', 'measurementScaleType', 0, 0, {'name': 'measurementScale', 'type': 'measurementScaleType'}, 41),
        MemberSpec_('missingValueCode', 'missingValueCodeType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'missingValueCode', 'type': 'missingValueCodeType'}, 41),
        MemberSpec_('accuracy', 'Accuracy', 0, 1, {'minOccurs': '0', 'name': 'accuracy', 'type': 'Accuracy'}, 41),
        MemberSpec_('coverage', 'Coverage', 0, 1, {'minOccurs': '0', 'name': 'coverage', 'type': 'Coverage'}, 41),
        MemberSpec_('methods', 'MethodsType', 0, 1, {'minOccurs': '0', 'name': 'methods', 'type': 'MethodsType'}, 41),
        MemberSpec_('annotation', 'SemanticAnnotation', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'annotation', 'type': 'SemanticAnnotation'}, 41),
        MemberSpec_('references', 'referencesType40', 0, 0, {'name': 'references', 'type': 'referencesType40'}, 41),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, system=None, scope='document', attributeName=None, attributeLabel=None, attributeDefinition=None, storageType=None, measurementScale=None, missingValueCode=None, accuracy=None, coverage=None, methods=None, annotation=None, references=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.scope = _cast(None, scope)
        self.scope_nsprefix_ = None
        self.attributeName = attributeName
        self.validate_NonEmptyStringType(self.attributeName)
        self.attributeName_nsprefix_ = None
        if attributeLabel is None:
            self.attributeLabel = []
        else:
            self.attributeLabel = attributeLabel
        self.attributeLabel_nsprefix_ = None
        self.attributeDefinition = attributeDefinition
        self.validate_NonEmptyStringType(self.attributeDefinition)
        self.attributeDefinition_nsprefix_ = None
        if storageType is None:
            self.storageType = []
        else:
            self.storageType = storageType
        self.storageType_nsprefix_ = None
        self.measurementScale = measurementScale
        self.measurementScale_nsprefix_ = None
        if missingValueCode is None:
            self.missingValueCode = []
        else:
            self.missingValueCode = missingValueCode
        self.missingValueCode_nsprefix_ = None
        self.accuracy = accuracy
        self.accuracy_nsprefix_ = None
        self.coverage = coverage
        self.coverage_nsprefix_ = None
        self.methods = methods
        self.methods_nsprefix_ = None
        if annotation is None:
            self.annotation = []
        else:
            self.annotation = annotation
        self.annotation_nsprefix_ = None
        self.references = references
        self.references_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AttributeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AttributeType.subclass:
            return AttributeType.subclass(*args_, **kwargs_)
        else:
            return AttributeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_attributeName(self):
        return self.attributeName
    def set_attributeName(self, attributeName):
        self.attributeName = attributeName
    def get_attributeLabel(self):
        return self.attributeLabel
    def set_attributeLabel(self, attributeLabel):
        self.attributeLabel = attributeLabel
    def add_attributeLabel(self, value):
        self.attributeLabel.append(value)
    def insert_attributeLabel_at(self, index, value):
        self.attributeLabel.insert(index, value)
    def replace_attributeLabel_at(self, index, value):
        self.attributeLabel[index] = value
    def get_attributeDefinition(self):
        return self.attributeDefinition
    def set_attributeDefinition(self, attributeDefinition):
        self.attributeDefinition = attributeDefinition
    def get_storageType(self):
        return self.storageType
    def set_storageType(self, storageType):
        self.storageType = storageType
    def add_storageType(self, value):
        self.storageType.append(value)
    def insert_storageType_at(self, index, value):
        self.storageType.insert(index, value)
    def replace_storageType_at(self, index, value):
        self.storageType[index] = value
    def get_measurementScale(self):
        return self.measurementScale
    def set_measurementScale(self, measurementScale):
        self.measurementScale = measurementScale
    def get_missingValueCode(self):
        return self.missingValueCode
    def set_missingValueCode(self, missingValueCode):
        self.missingValueCode = missingValueCode
    def add_missingValueCode(self, value):
        self.missingValueCode.append(value)
    def insert_missingValueCode_at(self, index, value):
        self.missingValueCode.insert(index, value)
    def replace_missingValueCode_at(self, index, value):
        self.missingValueCode[index] = value
    def get_accuracy(self):
        return self.accuracy
    def set_accuracy(self, accuracy):
        self.accuracy = accuracy
    def get_coverage(self):
        return self.coverage
    def set_coverage(self, coverage):
        self.coverage = coverage
    def get_methods(self):
        return self.methods
    def set_methods(self, methods):
        self.methods = methods
    def get_annotation(self):
        return self.annotation
    def set_annotation(self, annotation):
        self.annotation = annotation
    def add_annotation(self, value):
        self.annotation.append(value)
    def insert_annotation_at(self, index, value):
        self.annotation.insert(index, value)
    def replace_annotation_at(self, index, value):
        self.annotation[index] = value
    def get_references(self):
        return self.references
    def set_references(self, references):
        self.references = references
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_scope(self):
        return self.scope
    def set_scope(self, scope):
        self.scope = scope
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def validate_IDType(self, value):
        # Validate type res:IDType, a restriction on xs:string.
        pass
    def validate_SystemType(self, value):
        # Validate type res:SystemType, a restriction on xs:string.
        pass
    def validate_ScopeType(self, value):
        # Validate type res:ScopeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['system', 'document']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ScopeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.attributeName is not None or
            self.attributeLabel or
            self.attributeDefinition is not None or
            self.storageType or
            self.measurementScale is not None or
            self.missingValueCode or
            self.accuracy is not None or
            self.coverage is not None or
            self.methods is not None or
            self.annotation or
            self.references is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:None="https://eml.ecoinformatics.org/view-2.2.0"  xmlns:cov="https://eml.ecoinformatics.org/coverage-2.2.0"  xmlns:md="https://eml.ecoinformatics.org/methods-2.2.0"  xmlns:sem="https://eml.ecoinformatics.org/semantics-2.2.0" ', name_='AttributeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AttributeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AttributeType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AttributeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AttributeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AttributeType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
        if self.scope != "document" and 'scope' not in already_processed:
            already_processed.add('scope')
            outfile.write(' scope=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.scope), input_name='scope')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:None="https://eml.ecoinformatics.org/view-2.2.0"  xmlns:cov="https://eml.ecoinformatics.org/coverage-2.2.0"  xmlns:md="https://eml.ecoinformatics.org/methods-2.2.0"  xmlns:sem="https://eml.ecoinformatics.org/semantics-2.2.0" ', name_='AttributeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.attributeName is not None:
            namespaceprefix_ = self.attributeName_nsprefix_ + ':' if (UseCapturedNS_ and self.attributeName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sattributeName>%s</%sattributeName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.attributeName), input_name='attributeName')), namespaceprefix_ , eol_))
        for attributeLabel_ in self.attributeLabel:
            namespaceprefix_ = self.attributeLabel_nsprefix_ + ':' if (UseCapturedNS_ and self.attributeLabel_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sattributeLabel>%s</%sattributeLabel>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(attributeLabel_), input_name='attributeLabel')), namespaceprefix_ , eol_))
        if self.attributeDefinition is not None:
            namespaceprefix_ = self.attributeDefinition_nsprefix_ + ':' if (UseCapturedNS_ and self.attributeDefinition_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sattributeDefinition>%s</%sattributeDefinition>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.attributeDefinition), input_name='attributeDefinition')), namespaceprefix_ , eol_))
        for storageType_ in self.storageType:
            namespaceprefix_ = self.storageType_nsprefix_ + ':' if (UseCapturedNS_ and self.storageType_nsprefix_) else ''
            storageType_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='storageType', pretty_print=pretty_print)
        if self.measurementScale is not None:
            namespaceprefix_ = self.measurementScale_nsprefix_ + ':' if (UseCapturedNS_ and self.measurementScale_nsprefix_) else ''
            self.measurementScale.export(outfile, level, namespaceprefix_, namespacedef_='', name_='measurementScale', pretty_print=pretty_print)
        for missingValueCode_ in self.missingValueCode:
            namespaceprefix_ = self.missingValueCode_nsprefix_ + ':' if (UseCapturedNS_ and self.missingValueCode_nsprefix_) else ''
            missingValueCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='missingValueCode', pretty_print=pretty_print)
        if self.accuracy is not None:
            namespaceprefix_ = self.accuracy_nsprefix_ + ':' if (UseCapturedNS_ and self.accuracy_nsprefix_) else ''
            self.accuracy.export(outfile, level, namespaceprefix_, namespacedef_='', name_='accuracy', pretty_print=pretty_print)
        if self.coverage is not None:
            namespaceprefix_ = self.coverage_nsprefix_ + ':' if (UseCapturedNS_ and self.coverage_nsprefix_) else ''
            self.coverage.export(outfile, level, namespaceprefix_, namespacedef_='', name_='coverage', pretty_print=pretty_print)
        if self.methods is not None:
            namespaceprefix_ = self.methods_nsprefix_ + ':' if (UseCapturedNS_ and self.methods_nsprefix_) else ''
            self.methods.export(outfile, level, namespaceprefix_, namespacedef_='', name_='methods', pretty_print=pretty_print)
        for annotation_ in self.annotation:
            namespaceprefix_ = self.annotation_nsprefix_ + ':' if (UseCapturedNS_ and self.annotation_nsprefix_) else ''
            annotation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='annotation', pretty_print=pretty_print)
        if self.references is not None:
            namespaceprefix_ = self.references_nsprefix_ + ':' if (UseCapturedNS_ and self.references_nsprefix_) else ''
            self.references.export(outfile, level, namespaceprefix_, namespacedef_='', name_='references', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_IDType(self.id)    # validate type IDType
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
        value = find_attr_value_('scope', node)
        if value is not None and 'scope' not in already_processed:
            already_processed.add('scope')
            self.scope = value
            self.validate_ScopeType(self.scope)    # validate type ScopeType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'attributeName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'attributeName')
            value_ = self.gds_validate_string(value_, node, 'attributeName')
            self.attributeName = value_
            self.attributeName_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.attributeName)
        elif nodeName_ == 'attributeLabel':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'attributeLabel')
            value_ = self.gds_validate_string(value_, node, 'attributeLabel')
            self.attributeLabel.append(value_)
            self.attributeLabel_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.attributeLabel[-1])
        elif nodeName_ == 'attributeDefinition':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'attributeDefinition')
            value_ = self.gds_validate_string(value_, node, 'attributeDefinition')
            self.attributeDefinition = value_
            self.attributeDefinition_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.attributeDefinition)
        elif nodeName_ == 'storageType':
            obj_ = storageTypeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.storageType.append(obj_)
            obj_.original_tagname_ = 'storageType'
        elif nodeName_ == 'measurementScale':
            obj_ = measurementScaleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.measurementScale = obj_
            obj_.original_tagname_ = 'measurementScale'
        elif nodeName_ == 'missingValueCode':
            obj_ = missingValueCodeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.missingValueCode.append(obj_)
            obj_.original_tagname_ = 'missingValueCode'
        elif nodeName_ == 'accuracy':
            obj_ = Accuracy.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.accuracy = obj_
            obj_.original_tagname_ = 'accuracy'
        elif nodeName_ == 'coverage':
            obj_ = Coverage.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.coverage = obj_
            obj_.original_tagname_ = 'coverage'
        elif nodeName_ == 'methods':
            obj_ = MethodsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.methods = obj_
            obj_.original_tagname_ = 'methods'
        elif nodeName_ == 'annotation':
            class_obj_ = self.get_class_obj_(child_, SemanticAnnotation)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.annotation.append(obj_)
            obj_.original_tagname_ = 'annotation'
        elif nodeName_ == 'references':
            obj_ = referencesType40.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.references = obj_
            obj_.original_tagname_ = 'references'
# end class AttributeType


class Accuracy(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('attributeAccuracyReport', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'attributeAccuracyReport', 'type': 'xs:string'}, None),
        MemberSpec_('quantitativeAttributeAccuracyAssessment', 'quantitativeAttributeAccuracyAssessmentType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'quantitativeAttributeAccuracyAssessment', 'type': 'quantitativeAttributeAccuracyAssessmentType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, attributeAccuracyReport=None, quantitativeAttributeAccuracyAssessment=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.attributeAccuracyReport = attributeAccuracyReport
        self.validate_NonEmptyStringType(self.attributeAccuracyReport)
        self.attributeAccuracyReport_nsprefix_ = None
        if quantitativeAttributeAccuracyAssessment is None:
            self.quantitativeAttributeAccuracyAssessment = []
        else:
            self.quantitativeAttributeAccuracyAssessment = quantitativeAttributeAccuracyAssessment
        self.quantitativeAttributeAccuracyAssessment_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Accuracy)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Accuracy.subclass:
            return Accuracy.subclass(*args_, **kwargs_)
        else:
            return Accuracy(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_attributeAccuracyReport(self):
        return self.attributeAccuracyReport
    def set_attributeAccuracyReport(self, attributeAccuracyReport):
        self.attributeAccuracyReport = attributeAccuracyReport
    def get_quantitativeAttributeAccuracyAssessment(self):
        return self.quantitativeAttributeAccuracyAssessment
    def set_quantitativeAttributeAccuracyAssessment(self, quantitativeAttributeAccuracyAssessment):
        self.quantitativeAttributeAccuracyAssessment = quantitativeAttributeAccuracyAssessment
    def add_quantitativeAttributeAccuracyAssessment(self, value):
        self.quantitativeAttributeAccuracyAssessment.append(value)
    def insert_quantitativeAttributeAccuracyAssessment_at(self, index, value):
        self.quantitativeAttributeAccuracyAssessment.insert(index, value)
    def replace_quantitativeAttributeAccuracyAssessment_at(self, index, value):
        self.quantitativeAttributeAccuracyAssessment[index] = value
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def hasContent_(self):
        if (
            self.attributeAccuracyReport is not None or
            self.quantitativeAttributeAccuracyAssessment
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='Accuracy', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Accuracy')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Accuracy':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Accuracy')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Accuracy', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Accuracy'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='Accuracy', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.attributeAccuracyReport is not None:
            namespaceprefix_ = self.attributeAccuracyReport_nsprefix_ + ':' if (UseCapturedNS_ and self.attributeAccuracyReport_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sattributeAccuracyReport>%s</%sattributeAccuracyReport>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.attributeAccuracyReport), input_name='attributeAccuracyReport')), namespaceprefix_ , eol_))
        for quantitativeAttributeAccuracyAssessment_ in self.quantitativeAttributeAccuracyAssessment:
            namespaceprefix_ = self.quantitativeAttributeAccuracyAssessment_nsprefix_ + ':' if (UseCapturedNS_ and self.quantitativeAttributeAccuracyAssessment_nsprefix_) else ''
            quantitativeAttributeAccuracyAssessment_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='quantitativeAttributeAccuracyAssessment', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'attributeAccuracyReport':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'attributeAccuracyReport')
            value_ = self.gds_validate_string(value_, node, 'attributeAccuracyReport')
            self.attributeAccuracyReport = value_
            self.attributeAccuracyReport_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.attributeAccuracyReport)
        elif nodeName_ == 'quantitativeAttributeAccuracyAssessment':
            obj_ = quantitativeAttributeAccuracyAssessmentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.quantitativeAttributeAccuracyAssessment.append(obj_)
            obj_.original_tagname_ = 'quantitativeAttributeAccuracyAssessment'
# end class Accuracy


class UnitType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('standardUnit', 'StandardUnitDictionary', 0, 0, {'name': 'standardUnit', 'type': 'xs:string'}, 42),
        MemberSpec_('customUnit', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'customUnit', 'type': 'xs:string'}, 42),
    ]
    subclass = None
    superclass = None
    def __init__(self, standardUnit=None, customUnit=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.standardUnit = standardUnit
        self.validate_StandardUnitDictionary(self.standardUnit)
        self.standardUnit_nsprefix_ = None
        self.customUnit = customUnit
        self.validate_NonEmptyStringType(self.customUnit)
        self.customUnit_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UnitType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UnitType.subclass:
            return UnitType.subclass(*args_, **kwargs_)
        else:
            return UnitType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_standardUnit(self):
        return self.standardUnit
    def set_standardUnit(self, standardUnit):
        self.standardUnit = standardUnit
    def get_customUnit(self):
        return self.customUnit
    def set_customUnit(self, customUnit):
        self.customUnit = customUnit
    def validate_StandardUnitDictionary(self, value):
        result = True
        # Validate type StandardUnitDictionary, a restriction on None.
        pass
        return result
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def hasContent_(self):
        if (
            self.standardUnit is not None or
            self.customUnit is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:unit="https://eml.ecoinformatics.org/units-2.2.0"  xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='UnitType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('UnitType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'UnitType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UnitType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='UnitType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='UnitType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:unit="https://eml.ecoinformatics.org/units-2.2.0"  xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='UnitType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.standardUnit is not None:
            namespaceprefix_ = self.standardUnit_nsprefix_ + ':' if (UseCapturedNS_ and self.standardUnit_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstandardUnit>%s</%sstandardUnit>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.standardUnit), input_name='standardUnit')), namespaceprefix_ , eol_))
        if self.customUnit is not None:
            namespaceprefix_ = self.customUnit_nsprefix_ + ':' if (UseCapturedNS_ and self.customUnit_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scustomUnit>%s</%scustomUnit>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.customUnit), input_name='customUnit')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'standardUnit':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'standardUnit')
            value_ = self.gds_validate_string(value_, node, 'standardUnit')
            self.standardUnit = value_
            self.standardUnit_nsprefix_ = child_.prefix
            # validate type StandardUnitDictionary
            self.validate_StandardUnitDictionary(self.standardUnit)
        elif nodeName_ == 'customUnit':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'customUnit')
            value_ = self.gds_validate_string(value_, node, 'customUnit')
            self.customUnit = value_
            self.customUnit_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.customUnit)
# end class UnitType


class PrecisionType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('valueOf_', 'xs:float', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PrecisionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PrecisionType.subclass:
            return PrecisionType.subclass(*args_, **kwargs_)
        else:
            return PrecisionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='PrecisionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PrecisionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PrecisionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PrecisionType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PrecisionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PrecisionType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='PrecisionType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class PrecisionType


class NonNumericDomainType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'res:IDType', 0, 1, {'use': 'optional'}),
        MemberSpec_('enumeratedDomain', 'enumeratedDomainType', 1, 0, {'name': 'enumeratedDomain', 'type': 'enumeratedDomainType'}, 44),
        MemberSpec_('textDomain', 'textDomainType', 1, 0, {'name': 'textDomain', 'type': 'textDomainType'}, 44),
        MemberSpec_('references', 'referencesType41', 0, 0, {'name': 'references', 'type': 'referencesType41'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, enumeratedDomain=None, textDomain=None, references=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        if enumeratedDomain is None:
            self.enumeratedDomain = []
        else:
            self.enumeratedDomain = enumeratedDomain
        self.enumeratedDomain_nsprefix_ = None
        if textDomain is None:
            self.textDomain = []
        else:
            self.textDomain = textDomain
        self.textDomain_nsprefix_ = None
        self.references = references
        self.references_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NonNumericDomainType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NonNumericDomainType.subclass:
            return NonNumericDomainType.subclass(*args_, **kwargs_)
        else:
            return NonNumericDomainType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_enumeratedDomain(self):
        return self.enumeratedDomain
    def set_enumeratedDomain(self, enumeratedDomain):
        self.enumeratedDomain = enumeratedDomain
    def add_enumeratedDomain(self, value):
        self.enumeratedDomain.append(value)
    def insert_enumeratedDomain_at(self, index, value):
        self.enumeratedDomain.insert(index, value)
    def replace_enumeratedDomain_at(self, index, value):
        self.enumeratedDomain[index] = value
    def get_textDomain(self):
        return self.textDomain
    def set_textDomain(self, textDomain):
        self.textDomain = textDomain
    def add_textDomain(self, value):
        self.textDomain.append(value)
    def insert_textDomain_at(self, index, value):
        self.textDomain.insert(index, value)
    def replace_textDomain_at(self, index, value):
        self.textDomain[index] = value
    def get_references(self):
        return self.references
    def set_references(self, references):
        self.references = references
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_IDType(self, value):
        # Validate type res:IDType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.enumeratedDomain or
            self.textDomain or
            self.references is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='NonNumericDomainType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NonNumericDomainType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'NonNumericDomainType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NonNumericDomainType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NonNumericDomainType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NonNumericDomainType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='NonNumericDomainType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for enumeratedDomain_ in self.enumeratedDomain:
            namespaceprefix_ = self.enumeratedDomain_nsprefix_ + ':' if (UseCapturedNS_ and self.enumeratedDomain_nsprefix_) else ''
            enumeratedDomain_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='enumeratedDomain', pretty_print=pretty_print)
        for textDomain_ in self.textDomain:
            namespaceprefix_ = self.textDomain_nsprefix_ + ':' if (UseCapturedNS_ and self.textDomain_nsprefix_) else ''
            textDomain_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='textDomain', pretty_print=pretty_print)
        if self.references is not None:
            namespaceprefix_ = self.references_nsprefix_ + ':' if (UseCapturedNS_ and self.references_nsprefix_) else ''
            self.references.export(outfile, level, namespaceprefix_, namespacedef_='', name_='references', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_IDType(self.id)    # validate type IDType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'enumeratedDomain':
            obj_ = enumeratedDomainType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.enumeratedDomain.append(obj_)
            obj_.original_tagname_ = 'enumeratedDomain'
        elif nodeName_ == 'textDomain':
            obj_ = textDomainType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.textDomain.append(obj_)
            obj_.original_tagname_ = 'textDomain'
        elif nodeName_ == 'references':
            obj_ = referencesType41.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.references = obj_
            obj_.original_tagname_ = 'references'
# end class NonNumericDomainType


class NumericDomainType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'res:IDType', 0, 1, {'use': 'optional'}),
        MemberSpec_('numberType', ['NumberType', 'xs:string'], 0, 0, {'name': 'numberType', 'type': 'xs:string'}, 45),
        MemberSpec_('bounds', 'boundsType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'bounds', 'type': 'boundsType'}, 45),
        MemberSpec_('references', 'referencesType42', 0, 0, {'name': 'references', 'type': 'referencesType42'}, 45),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, numberType=None, bounds=None, references=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.numberType = numberType
        self.validate_NumberType(self.numberType)
        self.numberType_nsprefix_ = None
        if bounds is None:
            self.bounds = []
        else:
            self.bounds = bounds
        self.bounds_nsprefix_ = None
        self.references = references
        self.references_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NumericDomainType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NumericDomainType.subclass:
            return NumericDomainType.subclass(*args_, **kwargs_)
        else:
            return NumericDomainType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_numberType(self):
        return self.numberType
    def set_numberType(self, numberType):
        self.numberType = numberType
    def get_bounds(self):
        return self.bounds
    def set_bounds(self, bounds):
        self.bounds = bounds
    def add_bounds(self, value):
        self.bounds.append(value)
    def insert_bounds_at(self, index, value):
        self.bounds.insert(index, value)
    def replace_bounds_at(self, index, value):
        self.bounds[index] = value
    def get_references(self):
        return self.references
    def set_references(self, references):
        self.references = references
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_NumberType(self, value):
        result = True
        # Validate type NumberType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['natural', 'whole', 'integer', 'real']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NumberType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_IDType(self, value):
        # Validate type res:IDType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.numberType is not None or
            self.bounds or
            self.references is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='NumericDomainType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NumericDomainType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'NumericDomainType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NumericDomainType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NumericDomainType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NumericDomainType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='NumericDomainType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.numberType is not None:
            namespaceprefix_ = self.numberType_nsprefix_ + ':' if (UseCapturedNS_ and self.numberType_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snumberType>%s</%snumberType>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.numberType), input_name='numberType')), namespaceprefix_ , eol_))
        for bounds_ in self.bounds:
            namespaceprefix_ = self.bounds_nsprefix_ + ':' if (UseCapturedNS_ and self.bounds_nsprefix_) else ''
            bounds_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='bounds', pretty_print=pretty_print)
        if self.references is not None:
            namespaceprefix_ = self.references_nsprefix_ + ':' if (UseCapturedNS_ and self.references_nsprefix_) else ''
            self.references.export(outfile, level, namespaceprefix_, namespacedef_='', name_='references', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_IDType(self.id)    # validate type IDType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'numberType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'numberType')
            value_ = self.gds_validate_string(value_, node, 'numberType')
            self.numberType = value_
            self.numberType_nsprefix_ = child_.prefix
            # validate type NumberType
            self.validate_NumberType(self.numberType)
        elif nodeName_ == 'bounds':
            obj_ = boundsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.bounds.append(obj_)
            obj_.original_tagname_ = 'bounds'
        elif nodeName_ == 'references':
            obj_ = referencesType42.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.references = obj_
            obj_.original_tagname_ = 'references'
# end class NumericDomainType


class DateTimeDomainType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'res:IDType', 0, 1, {'use': 'optional'}),
        MemberSpec_('bounds', 'boundsType43', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'bounds', 'type': 'boundsType43'}, 46),
        MemberSpec_('references', 'referencesType46', 0, 0, {'name': 'references', 'type': 'referencesType46'}, 46),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, bounds=None, references=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        if bounds is None:
            self.bounds = []
        else:
            self.bounds = bounds
        self.bounds_nsprefix_ = None
        self.references = references
        self.references_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DateTimeDomainType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DateTimeDomainType.subclass:
            return DateTimeDomainType.subclass(*args_, **kwargs_)
        else:
            return DateTimeDomainType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_bounds(self):
        return self.bounds
    def set_bounds(self, bounds):
        self.bounds = bounds
    def add_bounds(self, value):
        self.bounds.append(value)
    def insert_bounds_at(self, index, value):
        self.bounds.insert(index, value)
    def replace_bounds_at(self, index, value):
        self.bounds[index] = value
    def get_references(self):
        return self.references
    def set_references(self, references):
        self.references = references
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_IDType(self, value):
        # Validate type res:IDType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.bounds or
            self.references is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='DateTimeDomainType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DateTimeDomainType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DateTimeDomainType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DateTimeDomainType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DateTimeDomainType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DateTimeDomainType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='DateTimeDomainType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for bounds_ in self.bounds:
            namespaceprefix_ = self.bounds_nsprefix_ + ':' if (UseCapturedNS_ and self.bounds_nsprefix_) else ''
            bounds_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='bounds', pretty_print=pretty_print)
        if self.references is not None:
            namespaceprefix_ = self.references_nsprefix_ + ':' if (UseCapturedNS_ and self.references_nsprefix_) else ''
            self.references.export(outfile, level, namespaceprefix_, namespacedef_='', name_='references', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_IDType(self.id)    # validate type IDType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'bounds':
            obj_ = boundsType43.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.bounds.append(obj_)
            obj_.original_tagname_ = 'bounds'
        elif nodeName_ == 'references':
            obj_ = referencesType46.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.references = obj_
            obj_.original_tagname_ = 'references'
# end class DateTimeDomainType


class ConstraintType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'res:IDType', 0, 1, {'use': 'optional'}),
        MemberSpec_('system', 'res:SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('scope', 'res:ScopeType', 0, 1, {'use': 'optional'}),
        MemberSpec_('primaryKey', 'primaryKeyType', 0, 0, {'name': 'primaryKey', 'type': 'primaryKeyType'}, 47),
        MemberSpec_('uniqueKey', 'uniqueKeyType', 0, 0, {'name': 'uniqueKey', 'type': 'uniqueKeyType'}, 47),
        MemberSpec_('checkConstraint', 'checkConstraintType', 0, 0, {'name': 'checkConstraint', 'type': 'checkConstraintType'}, 47),
        MemberSpec_('foreignKey', 'foreignKeyType', 0, 0, {'name': 'foreignKey', 'type': 'foreignKeyType'}, 47),
        MemberSpec_('joinCondition', 'joinConditionType', 0, 0, {'name': 'joinCondition', 'type': 'joinConditionType'}, 47),
        MemberSpec_('notNullConstraint', 'notNullConstraintType', 0, 0, {'name': 'notNullConstraint', 'type': 'notNullConstraintType'}, 47),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, system=None, scope='document', primaryKey=None, uniqueKey=None, checkConstraint=None, foreignKey=None, joinCondition=None, notNullConstraint=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.scope = _cast(None, scope)
        self.scope_nsprefix_ = None
        self.primaryKey = primaryKey
        self.primaryKey_nsprefix_ = None
        self.uniqueKey = uniqueKey
        self.uniqueKey_nsprefix_ = None
        self.checkConstraint = checkConstraint
        self.checkConstraint_nsprefix_ = None
        self.foreignKey = foreignKey
        self.foreignKey_nsprefix_ = None
        self.joinCondition = joinCondition
        self.joinCondition_nsprefix_ = None
        self.notNullConstraint = notNullConstraint
        self.notNullConstraint_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConstraintType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConstraintType.subclass:
            return ConstraintType.subclass(*args_, **kwargs_)
        else:
            return ConstraintType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_primaryKey(self):
        return self.primaryKey
    def set_primaryKey(self, primaryKey):
        self.primaryKey = primaryKey
    def get_uniqueKey(self):
        return self.uniqueKey
    def set_uniqueKey(self, uniqueKey):
        self.uniqueKey = uniqueKey
    def get_checkConstraint(self):
        return self.checkConstraint
    def set_checkConstraint(self, checkConstraint):
        self.checkConstraint = checkConstraint
    def get_foreignKey(self):
        return self.foreignKey
    def set_foreignKey(self, foreignKey):
        self.foreignKey = foreignKey
    def get_joinCondition(self):
        return self.joinCondition
    def set_joinCondition(self, joinCondition):
        self.joinCondition = joinCondition
    def get_notNullConstraint(self):
        return self.notNullConstraint
    def set_notNullConstraint(self, notNullConstraint):
        self.notNullConstraint = notNullConstraint
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_scope(self):
        return self.scope
    def set_scope(self, scope):
        self.scope = scope
    def validate_IDType(self, value):
        # Validate type res:IDType, a restriction on xs:string.
        pass
    def validate_SystemType(self, value):
        # Validate type res:SystemType, a restriction on xs:string.
        pass
    def validate_ScopeType(self, value):
        # Validate type res:ScopeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['system', 'document']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ScopeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.primaryKey is not None or
            self.uniqueKey is not None or
            self.checkConstraint is not None or
            self.foreignKey is not None or
            self.joinCondition is not None or
            self.notNullConstraint is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='ConstraintType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ConstraintType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ConstraintType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ConstraintType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ConstraintType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ConstraintType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
        if self.scope != "document" and 'scope' not in already_processed:
            already_processed.add('scope')
            outfile.write(' scope=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.scope), input_name='scope')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='ConstraintType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.primaryKey is not None:
            namespaceprefix_ = self.primaryKey_nsprefix_ + ':' if (UseCapturedNS_ and self.primaryKey_nsprefix_) else ''
            self.primaryKey.export(outfile, level, namespaceprefix_, namespacedef_='', name_='primaryKey', pretty_print=pretty_print)
        if self.uniqueKey is not None:
            namespaceprefix_ = self.uniqueKey_nsprefix_ + ':' if (UseCapturedNS_ and self.uniqueKey_nsprefix_) else ''
            self.uniqueKey.export(outfile, level, namespaceprefix_, namespacedef_='', name_='uniqueKey', pretty_print=pretty_print)
        if self.checkConstraint is not None:
            namespaceprefix_ = self.checkConstraint_nsprefix_ + ':' if (UseCapturedNS_ and self.checkConstraint_nsprefix_) else ''
            self.checkConstraint.export(outfile, level, namespaceprefix_, namespacedef_='', name_='checkConstraint', pretty_print=pretty_print)
        if self.foreignKey is not None:
            namespaceprefix_ = self.foreignKey_nsprefix_ + ':' if (UseCapturedNS_ and self.foreignKey_nsprefix_) else ''
            self.foreignKey.export(outfile, level, namespaceprefix_, namespacedef_='', name_='foreignKey', pretty_print=pretty_print)
        if self.joinCondition is not None:
            namespaceprefix_ = self.joinCondition_nsprefix_ + ':' if (UseCapturedNS_ and self.joinCondition_nsprefix_) else ''
            self.joinCondition.export(outfile, level, namespaceprefix_, namespacedef_='', name_='joinCondition', pretty_print=pretty_print)
        if self.notNullConstraint is not None:
            namespaceprefix_ = self.notNullConstraint_nsprefix_ + ':' if (UseCapturedNS_ and self.notNullConstraint_nsprefix_) else ''
            self.notNullConstraint.export(outfile, level, namespaceprefix_, namespacedef_='', name_='notNullConstraint', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_IDType(self.id)    # validate type IDType
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
        value = find_attr_value_('scope', node)
        if value is not None and 'scope' not in already_processed:
            already_processed.add('scope')
            self.scope = value
            self.validate_ScopeType(self.scope)    # validate type ScopeType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'primaryKey':
            obj_ = primaryKeyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.primaryKey = obj_
            obj_.original_tagname_ = 'primaryKey'
        elif nodeName_ == 'uniqueKey':
            obj_ = uniqueKeyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.uniqueKey = obj_
            obj_.original_tagname_ = 'uniqueKey'
        elif nodeName_ == 'checkConstraint':
            obj_ = checkConstraintType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.checkConstraint = obj_
            obj_.original_tagname_ = 'checkConstraint'
        elif nodeName_ == 'foreignKey':
            obj_ = foreignKeyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.foreignKey = obj_
            obj_.original_tagname_ = 'foreignKey'
        elif nodeName_ == 'joinCondition':
            obj_ = joinConditionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.joinCondition = obj_
            obj_.original_tagname_ = 'joinCondition'
        elif nodeName_ == 'notNullConstraint':
            obj_ = notNullConstraintType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.notNullConstraint = obj_
            obj_.original_tagname_ = 'notNullConstraint'
# end class ConstraintType


class DataTableType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'res:IDType', 0, 1, {'use': 'optional'}),
        MemberSpec_('system', 'res:SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('scope', 'res:ScopeType', 0, 1, {'use': 'optional'}),
        MemberSpec_('alternateIdentifier', 'alternateIdentifierType64', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'alternateIdentifier', 'type': 'alternateIdentifierType64'}, 48),
        MemberSpec_('entityName', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'entityName', 'type': 'xs:string'}, 48),
        MemberSpec_('entityDescription', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'entityDescription', 'type': 'xs:string'}, 48),
        MemberSpec_('physical', 'PhysicalType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'physical', 'type': 'PhysicalType'}, 48),
        MemberSpec_('coverage', 'Coverage', 0, 1, {'minOccurs': '0', 'name': 'coverage', 'type': 'Coverage'}, 48),
        MemberSpec_('methods', 'MethodsType', 0, 1, {'minOccurs': '0', 'name': 'methods', 'type': 'MethodsType'}, 48),
        MemberSpec_('additionalInfo', 'TextType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'additionalInfo', 'type': 'TextType'}, 48),
        MemberSpec_('annotation', 'SemanticAnnotation', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'annotation', 'type': 'SemanticAnnotation'}, 48),
        MemberSpec_('attributeList', 'AttributeListType', 0, 0, {'name': 'attributeList', 'type': 'AttributeListType'}, 48),
        MemberSpec_('constraint', 'ConstraintType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'constraint', 'type': 'ConstraintType'}, 48),
        MemberSpec_('caseSensitive', ['caseSensitiveType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'caseSensitive', 'type': 'xs:string'}, 48),
        MemberSpec_('numberOfRecords', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'numberOfRecords', 'type': 'xs:string'}, 48),
        MemberSpec_('references', 'referencesType65', 0, 0, {'name': 'references', 'type': 'referencesType65'}, 48),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, system=None, scope='document', alternateIdentifier=None, entityName=None, entityDescription=None, physical=None, coverage=None, methods=None, additionalInfo=None, annotation=None, attributeList=None, constraint=None, caseSensitive=None, numberOfRecords=None, references=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.scope = _cast(None, scope)
        self.scope_nsprefix_ = None
        if alternateIdentifier is None:
            self.alternateIdentifier = []
        else:
            self.alternateIdentifier = alternateIdentifier
        self.alternateIdentifier_nsprefix_ = None
        self.entityName = entityName
        self.validate_NonEmptyStringType(self.entityName)
        self.entityName_nsprefix_ = None
        self.entityDescription = entityDescription
        self.validate_NonEmptyStringType(self.entityDescription)
        self.entityDescription_nsprefix_ = None
        if physical is None:
            self.physical = []
        else:
            self.physical = physical
        self.physical_nsprefix_ = None
        self.coverage = coverage
        self.coverage_nsprefix_ = None
        self.methods = methods
        self.methods_nsprefix_ = None
        if additionalInfo is None:
            self.additionalInfo = []
        else:
            self.additionalInfo = additionalInfo
        self.additionalInfo_nsprefix_ = None
        if annotation is None:
            self.annotation = []
        else:
            self.annotation = annotation
        self.annotation_nsprefix_ = None
        self.attributeList = attributeList
        self.attributeList_nsprefix_ = None
        if constraint is None:
            self.constraint = []
        else:
            self.constraint = constraint
        self.constraint_nsprefix_ = None
        self.caseSensitive = caseSensitive
        self.validate_caseSensitiveType(self.caseSensitive)
        self.caseSensitive_nsprefix_ = None
        self.numberOfRecords = numberOfRecords
        self.validate_NonEmptyStringType(self.numberOfRecords)
        self.numberOfRecords_nsprefix_ = None
        self.references = references
        self.references_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DataTableType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DataTableType.subclass:
            return DataTableType.subclass(*args_, **kwargs_)
        else:
            return DataTableType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_alternateIdentifier(self):
        return self.alternateIdentifier
    def set_alternateIdentifier(self, alternateIdentifier):
        self.alternateIdentifier = alternateIdentifier
    def add_alternateIdentifier(self, value):
        self.alternateIdentifier.append(value)
    def insert_alternateIdentifier_at(self, index, value):
        self.alternateIdentifier.insert(index, value)
    def replace_alternateIdentifier_at(self, index, value):
        self.alternateIdentifier[index] = value
    def get_entityName(self):
        return self.entityName
    def set_entityName(self, entityName):
        self.entityName = entityName
    def get_entityDescription(self):
        return self.entityDescription
    def set_entityDescription(self, entityDescription):
        self.entityDescription = entityDescription
    def get_physical(self):
        return self.physical
    def set_physical(self, physical):
        self.physical = physical
    def add_physical(self, value):
        self.physical.append(value)
    def insert_physical_at(self, index, value):
        self.physical.insert(index, value)
    def replace_physical_at(self, index, value):
        self.physical[index] = value
    def get_coverage(self):
        return self.coverage
    def set_coverage(self, coverage):
        self.coverage = coverage
    def get_methods(self):
        return self.methods
    def set_methods(self, methods):
        self.methods = methods
    def get_additionalInfo(self):
        return self.additionalInfo
    def set_additionalInfo(self, additionalInfo):
        self.additionalInfo = additionalInfo
    def add_additionalInfo(self, value):
        self.additionalInfo.append(value)
    def insert_additionalInfo_at(self, index, value):
        self.additionalInfo.insert(index, value)
    def replace_additionalInfo_at(self, index, value):
        self.additionalInfo[index] = value
    def get_annotation(self):
        return self.annotation
    def set_annotation(self, annotation):
        self.annotation = annotation
    def add_annotation(self, value):
        self.annotation.append(value)
    def insert_annotation_at(self, index, value):
        self.annotation.insert(index, value)
    def replace_annotation_at(self, index, value):
        self.annotation[index] = value
    def get_attributeList(self):
        return self.attributeList
    def set_attributeList(self, attributeList):
        self.attributeList = attributeList
    def get_constraint(self):
        return self.constraint
    def set_constraint(self, constraint):
        self.constraint = constraint
    def add_constraint(self, value):
        self.constraint.append(value)
    def insert_constraint_at(self, index, value):
        self.constraint.insert(index, value)
    def replace_constraint_at(self, index, value):
        self.constraint[index] = value
    def get_caseSensitive(self):
        return self.caseSensitive
    def set_caseSensitive(self, caseSensitive):
        self.caseSensitive = caseSensitive
    def get_numberOfRecords(self):
        return self.numberOfRecords
    def set_numberOfRecords(self, numberOfRecords):
        self.numberOfRecords = numberOfRecords
    def get_references(self):
        return self.references
    def set_references(self, references):
        self.references = references
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_scope(self):
        return self.scope
    def set_scope(self, scope):
        self.scope = scope
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def validate_caseSensitiveType(self, value):
        result = True
        # Validate type caseSensitiveType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on caseSensitiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_IDType(self, value):
        # Validate type res:IDType, a restriction on xs:string.
        pass
    def validate_SystemType(self, value):
        # Validate type res:SystemType, a restriction on xs:string.
        pass
    def validate_ScopeType(self, value):
        # Validate type res:ScopeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['system', 'document']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ScopeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.alternateIdentifier or
            self.entityName is not None or
            self.entityDescription is not None or
            self.physical or
            self.coverage is not None or
            self.methods is not None or
            self.additionalInfo or
            self.annotation or
            self.attributeList is not None or
            self.constraint or
            self.caseSensitive is not None or
            self.numberOfRecords is not None or
            self.references is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0"  xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:phys="https://eml.ecoinformatics.org/physical-2.2.0"  xmlns:cov="https://eml.ecoinformatics.org/coverage-2.2.0"  xmlns:md="https://eml.ecoinformatics.org/methods-2.2.0"  xmlns:txt="https://eml.ecoinformatics.org/text-2.2.0"  xmlns:sem="https://eml.ecoinformatics.org/semantics-2.2.0"  xmlns:att="https://eml.ecoinformatics.org/attribute-2.2.0"  xmlns:con="https://eml.ecoinformatics.org/constraint-2.2.0" ', name_='DataTableType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DataTableType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DataTableType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DataTableType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DataTableType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DataTableType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
        if self.scope != "document" and 'scope' not in already_processed:
            already_processed.add('scope')
            outfile.write(' scope=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.scope), input_name='scope')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0"  xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:phys="https://eml.ecoinformatics.org/physical-2.2.0"  xmlns:cov="https://eml.ecoinformatics.org/coverage-2.2.0"  xmlns:md="https://eml.ecoinformatics.org/methods-2.2.0"  xmlns:txt="https://eml.ecoinformatics.org/text-2.2.0"  xmlns:sem="https://eml.ecoinformatics.org/semantics-2.2.0"  xmlns:att="https://eml.ecoinformatics.org/attribute-2.2.0"  xmlns:con="https://eml.ecoinformatics.org/constraint-2.2.0" ', name_='DataTableType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for alternateIdentifier_ in self.alternateIdentifier:
            namespaceprefix_ = self.alternateIdentifier_nsprefix_ + ':' if (UseCapturedNS_ and self.alternateIdentifier_nsprefix_) else ''
            alternateIdentifier_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='alternateIdentifier', pretty_print=pretty_print)
        if self.entityName is not None:
            namespaceprefix_ = self.entityName_nsprefix_ + ':' if (UseCapturedNS_ and self.entityName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sentityName>%s</%sentityName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.entityName), input_name='entityName')), namespaceprefix_ , eol_))
        if self.entityDescription is not None:
            namespaceprefix_ = self.entityDescription_nsprefix_ + ':' if (UseCapturedNS_ and self.entityDescription_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sentityDescription>%s</%sentityDescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.entityDescription), input_name='entityDescription')), namespaceprefix_ , eol_))
        for physical_ in self.physical:
            namespaceprefix_ = self.physical_nsprefix_ + ':' if (UseCapturedNS_ and self.physical_nsprefix_) else ''
            physical_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='physical', pretty_print=pretty_print)
        if self.coverage is not None:
            namespaceprefix_ = self.coverage_nsprefix_ + ':' if (UseCapturedNS_ and self.coverage_nsprefix_) else ''
            self.coverage.export(outfile, level, namespaceprefix_, namespacedef_='', name_='coverage', pretty_print=pretty_print)
        if self.methods is not None:
            namespaceprefix_ = self.methods_nsprefix_ + ':' if (UseCapturedNS_ and self.methods_nsprefix_) else ''
            self.methods.export(outfile, level, namespaceprefix_, namespacedef_='', name_='methods', pretty_print=pretty_print)
        for additionalInfo_ in self.additionalInfo:
            namespaceprefix_ = self.additionalInfo_nsprefix_ + ':' if (UseCapturedNS_ and self.additionalInfo_nsprefix_) else ''
            additionalInfo_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='additionalInfo', pretty_print=pretty_print)
        for annotation_ in self.annotation:
            namespaceprefix_ = self.annotation_nsprefix_ + ':' if (UseCapturedNS_ and self.annotation_nsprefix_) else ''
            annotation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='annotation', pretty_print=pretty_print)
        if self.attributeList is not None:
            namespaceprefix_ = self.attributeList_nsprefix_ + ':' if (UseCapturedNS_ and self.attributeList_nsprefix_) else ''
            self.attributeList.export(outfile, level, namespaceprefix_, namespacedef_='', name_='attributeList', pretty_print=pretty_print)
        for constraint_ in self.constraint:
            namespaceprefix_ = self.constraint_nsprefix_ + ':' if (UseCapturedNS_ and self.constraint_nsprefix_) else ''
            constraint_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='constraint', pretty_print=pretty_print)
        if self.caseSensitive is not None:
            namespaceprefix_ = self.caseSensitive_nsprefix_ + ':' if (UseCapturedNS_ and self.caseSensitive_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scaseSensitive>%s</%scaseSensitive>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.caseSensitive), input_name='caseSensitive')), namespaceprefix_ , eol_))
        if self.numberOfRecords is not None:
            namespaceprefix_ = self.numberOfRecords_nsprefix_ + ':' if (UseCapturedNS_ and self.numberOfRecords_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snumberOfRecords>%s</%snumberOfRecords>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.numberOfRecords), input_name='numberOfRecords')), namespaceprefix_ , eol_))
        if self.references is not None:
            namespaceprefix_ = self.references_nsprefix_ + ':' if (UseCapturedNS_ and self.references_nsprefix_) else ''
            self.references.export(outfile, level, namespaceprefix_, namespacedef_='', name_='references', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_IDType(self.id)    # validate type IDType
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
        value = find_attr_value_('scope', node)
        if value is not None and 'scope' not in already_processed:
            already_processed.add('scope')
            self.scope = value
            self.validate_ScopeType(self.scope)    # validate type ScopeType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'alternateIdentifier':
            obj_ = alternateIdentifierType64.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.alternateIdentifier.append(obj_)
            obj_.original_tagname_ = 'alternateIdentifier'
        elif nodeName_ == 'entityName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'entityName')
            value_ = self.gds_validate_string(value_, node, 'entityName')
            self.entityName = value_
            self.entityName_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.entityName)
        elif nodeName_ == 'entityDescription':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'entityDescription')
            value_ = self.gds_validate_string(value_, node, 'entityDescription')
            self.entityDescription = value_
            self.entityDescription_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.entityDescription)
        elif nodeName_ == 'physical':
            obj_ = PhysicalType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.physical.append(obj_)
            obj_.original_tagname_ = 'physical'
        elif nodeName_ == 'coverage':
            obj_ = Coverage.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.coverage = obj_
            obj_.original_tagname_ = 'coverage'
        elif nodeName_ == 'methods':
            obj_ = MethodsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.methods = obj_
            obj_.original_tagname_ = 'methods'
        elif nodeName_ == 'additionalInfo':
            obj_ = TextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.additionalInfo.append(obj_)
            obj_.original_tagname_ = 'additionalInfo'
        elif nodeName_ == 'annotation':
            class_obj_ = self.get_class_obj_(child_, SemanticAnnotation)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.annotation.append(obj_)
            obj_.original_tagname_ = 'annotation'
        elif nodeName_ == 'attributeList':
            obj_ = AttributeListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.attributeList = obj_
            obj_.original_tagname_ = 'attributeList'
        elif nodeName_ == 'constraint':
            obj_ = ConstraintType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.constraint.append(obj_)
            obj_.original_tagname_ = 'constraint'
        elif nodeName_ == 'caseSensitive':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'caseSensitive')
            value_ = self.gds_validate_string(value_, node, 'caseSensitive')
            self.caseSensitive = value_
            self.caseSensitive_nsprefix_ = child_.prefix
            # validate type caseSensitiveType
            self.validate_caseSensitiveType(self.caseSensitive)
        elif nodeName_ == 'numberOfRecords':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'numberOfRecords')
            value_ = self.gds_validate_string(value_, node, 'numberOfRecords')
            self.numberOfRecords = value_
            self.numberOfRecords_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.numberOfRecords)
        elif nodeName_ == 'references':
            obj_ = referencesType65.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.references = obj_
            obj_.original_tagname_ = 'references'
# end class DataTableType


class SpatialRasterType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'res:IDType', 0, 1, {'use': 'optional'}),
        MemberSpec_('system', 'res:SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('scope', 'res:ScopeType', 0, 1, {'use': 'optional'}),
        MemberSpec_('alternateIdentifier', 'alternateIdentifierType66', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'alternateIdentifier', 'type': 'alternateIdentifierType66'}, 49),
        MemberSpec_('entityName', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'entityName', 'type': 'xs:string'}, 49),
        MemberSpec_('entityDescription', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'entityDescription', 'type': 'xs:string'}, 49),
        MemberSpec_('physical', 'PhysicalType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'physical', 'type': 'PhysicalType'}, 49),
        MemberSpec_('coverage', 'Coverage', 0, 1, {'minOccurs': '0', 'name': 'coverage', 'type': 'Coverage'}, 49),
        MemberSpec_('methods', 'MethodsType', 0, 1, {'minOccurs': '0', 'name': 'methods', 'type': 'MethodsType'}, 49),
        MemberSpec_('additionalInfo', 'TextType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'additionalInfo', 'type': 'TextType'}, 49),
        MemberSpec_('annotation', 'SemanticAnnotation', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'annotation', 'type': 'SemanticAnnotation'}, 49),
        MemberSpec_('attributeList', 'AttributeListType', 0, 0, {'name': 'attributeList', 'type': 'AttributeListType'}, 49),
        MemberSpec_('constraint', 'ConstraintType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'constraint', 'type': 'ConstraintType'}, 49),
        MemberSpec_('spatialReference', 'SpatialReferenceType', 0, 0, {'name': 'spatialReference', 'type': 'SpatialReferenceType'}, 49),
        MemberSpec_('georeferenceInfo', 'georeferenceInfoType', 0, 1, {'minOccurs': '0', 'name': 'georeferenceInfo', 'type': 'georeferenceInfoType'}, 49),
        MemberSpec_('horizontalAccuracy', 'DataQuality', 0, 0, {'name': 'horizontalAccuracy', 'type': 'DataQuality'}, 49),
        MemberSpec_('verticalAccuracy', 'DataQuality', 0, 0, {'name': 'verticalAccuracy', 'type': 'DataQuality'}, 49),
        MemberSpec_('cellSizeXDirection', 'xs:string', 0, 0, {'name': 'cellSizeXDirection', 'type': 'xs:string'}, 49),
        MemberSpec_('cellSizeYDirection', 'xs:string', 0, 0, {'name': 'cellSizeYDirection', 'type': 'xs:string'}, 49),
        MemberSpec_('numberOfBands', 'xs:string', 0, 0, {'name': 'numberOfBands', 'type': 'xs:string'}, 49),
        MemberSpec_('rasterOrigin', ['rasterOriginType', 'xs:string'], 0, 0, {'name': 'rasterOrigin', 'type': 'xs:string'}, 49),
        MemberSpec_('rows', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'rows', 'type': 'xs:string'}, 49),
        MemberSpec_('columns', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'columns', 'type': 'xs:string'}, 49),
        MemberSpec_('verticals', 'xs:string', 0, 0, {'name': 'verticals', 'type': 'xs:string'}, 49),
        MemberSpec_('cellGeometry', ['CellGeometryType', 'xs:string'], 0, 0, {'name': 'cellGeometry', 'type': 'xs:string'}, 49),
        MemberSpec_('toneGradation', 'xs:integer', 0, 1, {'minOccurs': '0', 'name': 'toneGradation', 'type': 'xs:integer'}, 49),
        MemberSpec_('scaleFactor', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'scaleFactor', 'type': 'xs:string'}, 49),
        MemberSpec_('offset', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'offset', 'type': 'xs:string'}, 49),
        MemberSpec_('imageDescription', 'imageDescriptionType', 0, 1, {'minOccurs': '0', 'name': 'imageDescription', 'type': 'imageDescriptionType'}, 49),
        MemberSpec_('references', 'referencesType68', 0, 0, {'name': 'references', 'type': 'referencesType68'}, 49),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, system=None, scope='document', alternateIdentifier=None, entityName=None, entityDescription=None, physical=None, coverage=None, methods=None, additionalInfo=None, annotation=None, attributeList=None, constraint=None, spatialReference=None, georeferenceInfo=None, horizontalAccuracy=None, verticalAccuracy=None, cellSizeXDirection=None, cellSizeYDirection=None, numberOfBands=None, rasterOrigin=None, rows=None, columns=None, verticals=None, cellGeometry=None, toneGradation=None, scaleFactor=None, offset=None, imageDescription=None, references=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.scope = _cast(None, scope)
        self.scope_nsprefix_ = None
        if alternateIdentifier is None:
            self.alternateIdentifier = []
        else:
            self.alternateIdentifier = alternateIdentifier
        self.alternateIdentifier_nsprefix_ = None
        self.entityName = entityName
        self.validate_NonEmptyStringType(self.entityName)
        self.entityName_nsprefix_ = None
        self.entityDescription = entityDescription
        self.validate_NonEmptyStringType(self.entityDescription)
        self.entityDescription_nsprefix_ = None
        if physical is None:
            self.physical = []
        else:
            self.physical = physical
        self.physical_nsprefix_ = None
        self.coverage = coverage
        self.coverage_nsprefix_ = None
        self.methods = methods
        self.methods_nsprefix_ = None
        if additionalInfo is None:
            self.additionalInfo = []
        else:
            self.additionalInfo = additionalInfo
        self.additionalInfo_nsprefix_ = None
        if annotation is None:
            self.annotation = []
        else:
            self.annotation = annotation
        self.annotation_nsprefix_ = None
        self.attributeList = attributeList
        self.attributeList_nsprefix_ = None
        if constraint is None:
            self.constraint = []
        else:
            self.constraint = constraint
        self.constraint_nsprefix_ = None
        self.spatialReference = spatialReference
        self.spatialReference_nsprefix_ = None
        self.georeferenceInfo = georeferenceInfo
        self.georeferenceInfo_nsprefix_ = None
        self.horizontalAccuracy = horizontalAccuracy
        self.horizontalAccuracy_nsprefix_ = None
        self.verticalAccuracy = verticalAccuracy
        self.verticalAccuracy_nsprefix_ = None
        self.cellSizeXDirection = cellSizeXDirection
        self.cellSizeXDirection_nsprefix_ = None
        self.cellSizeYDirection = cellSizeYDirection
        self.cellSizeYDirection_nsprefix_ = None
        self.numberOfBands = numberOfBands
        self.numberOfBands_nsprefix_ = None
        self.rasterOrigin = rasterOrigin
        self.validate_rasterOriginType(self.rasterOrigin)
        self.rasterOrigin_nsprefix_ = None
        self.rows = rows
        self.validate_NonEmptyStringType(self.rows)
        self.rows_nsprefix_ = None
        self.columns = columns
        self.validate_NonEmptyStringType(self.columns)
        self.columns_nsprefix_ = None
        self.verticals = verticals
        self.verticals_nsprefix_ = None
        self.cellGeometry = cellGeometry
        self.validate_CellGeometryType(self.cellGeometry)
        self.cellGeometry_nsprefix_ = None
        self.toneGradation = toneGradation
        self.toneGradation_nsprefix_ = None
        self.scaleFactor = scaleFactor
        self.validate_NonEmptyStringType(self.scaleFactor)
        self.scaleFactor_nsprefix_ = None
        self.offset = offset
        self.validate_NonEmptyStringType(self.offset)
        self.offset_nsprefix_ = None
        self.imageDescription = imageDescription
        self.imageDescription_nsprefix_ = None
        self.references = references
        self.references_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SpatialRasterType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SpatialRasterType.subclass:
            return SpatialRasterType.subclass(*args_, **kwargs_)
        else:
            return SpatialRasterType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_alternateIdentifier(self):
        return self.alternateIdentifier
    def set_alternateIdentifier(self, alternateIdentifier):
        self.alternateIdentifier = alternateIdentifier
    def add_alternateIdentifier(self, value):
        self.alternateIdentifier.append(value)
    def insert_alternateIdentifier_at(self, index, value):
        self.alternateIdentifier.insert(index, value)
    def replace_alternateIdentifier_at(self, index, value):
        self.alternateIdentifier[index] = value
    def get_entityName(self):
        return self.entityName
    def set_entityName(self, entityName):
        self.entityName = entityName
    def get_entityDescription(self):
        return self.entityDescription
    def set_entityDescription(self, entityDescription):
        self.entityDescription = entityDescription
    def get_physical(self):
        return self.physical
    def set_physical(self, physical):
        self.physical = physical
    def add_physical(self, value):
        self.physical.append(value)
    def insert_physical_at(self, index, value):
        self.physical.insert(index, value)
    def replace_physical_at(self, index, value):
        self.physical[index] = value
    def get_coverage(self):
        return self.coverage
    def set_coverage(self, coverage):
        self.coverage = coverage
    def get_methods(self):
        return self.methods
    def set_methods(self, methods):
        self.methods = methods
    def get_additionalInfo(self):
        return self.additionalInfo
    def set_additionalInfo(self, additionalInfo):
        self.additionalInfo = additionalInfo
    def add_additionalInfo(self, value):
        self.additionalInfo.append(value)
    def insert_additionalInfo_at(self, index, value):
        self.additionalInfo.insert(index, value)
    def replace_additionalInfo_at(self, index, value):
        self.additionalInfo[index] = value
    def get_annotation(self):
        return self.annotation
    def set_annotation(self, annotation):
        self.annotation = annotation
    def add_annotation(self, value):
        self.annotation.append(value)
    def insert_annotation_at(self, index, value):
        self.annotation.insert(index, value)
    def replace_annotation_at(self, index, value):
        self.annotation[index] = value
    def get_attributeList(self):
        return self.attributeList
    def set_attributeList(self, attributeList):
        self.attributeList = attributeList
    def get_constraint(self):
        return self.constraint
    def set_constraint(self, constraint):
        self.constraint = constraint
    def add_constraint(self, value):
        self.constraint.append(value)
    def insert_constraint_at(self, index, value):
        self.constraint.insert(index, value)
    def replace_constraint_at(self, index, value):
        self.constraint[index] = value
    def get_spatialReference(self):
        return self.spatialReference
    def set_spatialReference(self, spatialReference):
        self.spatialReference = spatialReference
    def get_georeferenceInfo(self):
        return self.georeferenceInfo
    def set_georeferenceInfo(self, georeferenceInfo):
        self.georeferenceInfo = georeferenceInfo
    def get_horizontalAccuracy(self):
        return self.horizontalAccuracy
    def set_horizontalAccuracy(self, horizontalAccuracy):
        self.horizontalAccuracy = horizontalAccuracy
    def get_verticalAccuracy(self):
        return self.verticalAccuracy
    def set_verticalAccuracy(self, verticalAccuracy):
        self.verticalAccuracy = verticalAccuracy
    def get_cellSizeXDirection(self):
        return self.cellSizeXDirection
    def set_cellSizeXDirection(self, cellSizeXDirection):
        self.cellSizeXDirection = cellSizeXDirection
    def get_cellSizeYDirection(self):
        return self.cellSizeYDirection
    def set_cellSizeYDirection(self, cellSizeYDirection):
        self.cellSizeYDirection = cellSizeYDirection
    def get_numberOfBands(self):
        return self.numberOfBands
    def set_numberOfBands(self, numberOfBands):
        self.numberOfBands = numberOfBands
    def get_rasterOrigin(self):
        return self.rasterOrigin
    def set_rasterOrigin(self, rasterOrigin):
        self.rasterOrigin = rasterOrigin
    def get_rows(self):
        return self.rows
    def set_rows(self, rows):
        self.rows = rows
    def get_columns(self):
        return self.columns
    def set_columns(self, columns):
        self.columns = columns
    def get_verticals(self):
        return self.verticals
    def set_verticals(self, verticals):
        self.verticals = verticals
    def get_cellGeometry(self):
        return self.cellGeometry
    def set_cellGeometry(self, cellGeometry):
        self.cellGeometry = cellGeometry
    def get_toneGradation(self):
        return self.toneGradation
    def set_toneGradation(self, toneGradation):
        self.toneGradation = toneGradation
    def get_scaleFactor(self):
        return self.scaleFactor
    def set_scaleFactor(self, scaleFactor):
        self.scaleFactor = scaleFactor
    def get_offset(self):
        return self.offset
    def set_offset(self, offset):
        self.offset = offset
    def get_imageDescription(self):
        return self.imageDescription
    def set_imageDescription(self, imageDescription):
        self.imageDescription = imageDescription
    def get_references(self):
        return self.references
    def set_references(self, references):
        self.references = references
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_scope(self):
        return self.scope
    def set_scope(self, scope):
        self.scope = scope
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def validate_rasterOriginType(self, value):
        result = True
        # Validate type rasterOriginType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Upper Left', 'Lower Left', 'Upper Right', 'Lower Right']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on rasterOriginType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_CellGeometryType(self, value):
        result = True
        # Validate type CellGeometryType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['pixel', 'matrix']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on CellGeometryType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_IDType(self, value):
        # Validate type res:IDType, a restriction on xs:string.
        pass
    def validate_SystemType(self, value):
        # Validate type res:SystemType, a restriction on xs:string.
        pass
    def validate_ScopeType(self, value):
        # Validate type res:ScopeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['system', 'document']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ScopeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.alternateIdentifier or
            self.entityName is not None or
            self.entityDescription is not None or
            self.physical or
            self.coverage is not None or
            self.methods is not None or
            self.additionalInfo or
            self.annotation or
            self.attributeList is not None or
            self.constraint or
            self.spatialReference is not None or
            self.georeferenceInfo is not None or
            self.horizontalAccuracy is not None or
            self.verticalAccuracy is not None or
            self.cellSizeXDirection is not None or
            self.cellSizeYDirection is not None or
            self.numberOfBands is not None or
            self.rasterOrigin is not None or
            self.rows is not None or
            self.columns is not None or
            self.verticals is not None or
            self.cellGeometry is not None or
            self.toneGradation is not None or
            self.scaleFactor is not None or
            self.offset is not None or
            self.imageDescription is not None or
            self.references is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0"  xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:phys="https://eml.ecoinformatics.org/physical-2.2.0"  xmlns:cov="https://eml.ecoinformatics.org/coverage-2.2.0"  xmlns:md="https://eml.ecoinformatics.org/methods-2.2.0"  xmlns:txt="https://eml.ecoinformatics.org/text-2.2.0"  xmlns:sem="https://eml.ecoinformatics.org/semantics-2.2.0"  xmlns:att="https://eml.ecoinformatics.org/attribute-2.2.0"  xmlns:con="https://eml.ecoinformatics.org/constraint-2.2.0"  xmlns:spref="https://eml.ecoinformatics.org/spatialReference-2.2.0" ', name_='SpatialRasterType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SpatialRasterType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SpatialRasterType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SpatialRasterType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SpatialRasterType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SpatialRasterType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
        if self.scope != "document" and 'scope' not in already_processed:
            already_processed.add('scope')
            outfile.write(' scope=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.scope), input_name='scope')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0"  xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:phys="https://eml.ecoinformatics.org/physical-2.2.0"  xmlns:cov="https://eml.ecoinformatics.org/coverage-2.2.0"  xmlns:md="https://eml.ecoinformatics.org/methods-2.2.0"  xmlns:txt="https://eml.ecoinformatics.org/text-2.2.0"  xmlns:sem="https://eml.ecoinformatics.org/semantics-2.2.0"  xmlns:att="https://eml.ecoinformatics.org/attribute-2.2.0"  xmlns:con="https://eml.ecoinformatics.org/constraint-2.2.0"  xmlns:spref="https://eml.ecoinformatics.org/spatialReference-2.2.0" ', name_='SpatialRasterType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for alternateIdentifier_ in self.alternateIdentifier:
            namespaceprefix_ = self.alternateIdentifier_nsprefix_ + ':' if (UseCapturedNS_ and self.alternateIdentifier_nsprefix_) else ''
            alternateIdentifier_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='alternateIdentifier', pretty_print=pretty_print)
        if self.entityName is not None:
            namespaceprefix_ = self.entityName_nsprefix_ + ':' if (UseCapturedNS_ and self.entityName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sentityName>%s</%sentityName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.entityName), input_name='entityName')), namespaceprefix_ , eol_))
        if self.entityDescription is not None:
            namespaceprefix_ = self.entityDescription_nsprefix_ + ':' if (UseCapturedNS_ and self.entityDescription_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sentityDescription>%s</%sentityDescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.entityDescription), input_name='entityDescription')), namespaceprefix_ , eol_))
        for physical_ in self.physical:
            namespaceprefix_ = self.physical_nsprefix_ + ':' if (UseCapturedNS_ and self.physical_nsprefix_) else ''
            physical_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='physical', pretty_print=pretty_print)
        if self.coverage is not None:
            namespaceprefix_ = self.coverage_nsprefix_ + ':' if (UseCapturedNS_ and self.coverage_nsprefix_) else ''
            self.coverage.export(outfile, level, namespaceprefix_, namespacedef_='', name_='coverage', pretty_print=pretty_print)
        if self.methods is not None:
            namespaceprefix_ = self.methods_nsprefix_ + ':' if (UseCapturedNS_ and self.methods_nsprefix_) else ''
            self.methods.export(outfile, level, namespaceprefix_, namespacedef_='', name_='methods', pretty_print=pretty_print)
        for additionalInfo_ in self.additionalInfo:
            namespaceprefix_ = self.additionalInfo_nsprefix_ + ':' if (UseCapturedNS_ and self.additionalInfo_nsprefix_) else ''
            additionalInfo_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='additionalInfo', pretty_print=pretty_print)
        for annotation_ in self.annotation:
            namespaceprefix_ = self.annotation_nsprefix_ + ':' if (UseCapturedNS_ and self.annotation_nsprefix_) else ''
            annotation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='annotation', pretty_print=pretty_print)
        if self.attributeList is not None:
            namespaceprefix_ = self.attributeList_nsprefix_ + ':' if (UseCapturedNS_ and self.attributeList_nsprefix_) else ''
            self.attributeList.export(outfile, level, namespaceprefix_, namespacedef_='', name_='attributeList', pretty_print=pretty_print)
        for constraint_ in self.constraint:
            namespaceprefix_ = self.constraint_nsprefix_ + ':' if (UseCapturedNS_ and self.constraint_nsprefix_) else ''
            constraint_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='constraint', pretty_print=pretty_print)
        if self.spatialReference is not None:
            namespaceprefix_ = self.spatialReference_nsprefix_ + ':' if (UseCapturedNS_ and self.spatialReference_nsprefix_) else ''
            self.spatialReference.export(outfile, level, namespaceprefix_, namespacedef_='', name_='spatialReference', pretty_print=pretty_print)
        if self.georeferenceInfo is not None:
            namespaceprefix_ = self.georeferenceInfo_nsprefix_ + ':' if (UseCapturedNS_ and self.georeferenceInfo_nsprefix_) else ''
            self.georeferenceInfo.export(outfile, level, namespaceprefix_, namespacedef_='', name_='georeferenceInfo', pretty_print=pretty_print)
        if self.horizontalAccuracy is not None:
            namespaceprefix_ = self.horizontalAccuracy_nsprefix_ + ':' if (UseCapturedNS_ and self.horizontalAccuracy_nsprefix_) else ''
            self.horizontalAccuracy.export(outfile, level, namespaceprefix_, namespacedef_='', name_='horizontalAccuracy', pretty_print=pretty_print)
        if self.verticalAccuracy is not None:
            namespaceprefix_ = self.verticalAccuracy_nsprefix_ + ':' if (UseCapturedNS_ and self.verticalAccuracy_nsprefix_) else ''
            self.verticalAccuracy.export(outfile, level, namespaceprefix_, namespacedef_='', name_='verticalAccuracy', pretty_print=pretty_print)
        if self.cellSizeXDirection is not None:
            namespaceprefix_ = self.cellSizeXDirection_nsprefix_ + ':' if (UseCapturedNS_ and self.cellSizeXDirection_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scellSizeXDirection>%s</%scellSizeXDirection>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cellSizeXDirection), input_name='cellSizeXDirection')), namespaceprefix_ , eol_))
        if self.cellSizeYDirection is not None:
            namespaceprefix_ = self.cellSizeYDirection_nsprefix_ + ':' if (UseCapturedNS_ and self.cellSizeYDirection_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scellSizeYDirection>%s</%scellSizeYDirection>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cellSizeYDirection), input_name='cellSizeYDirection')), namespaceprefix_ , eol_))
        if self.numberOfBands is not None:
            namespaceprefix_ = self.numberOfBands_nsprefix_ + ':' if (UseCapturedNS_ and self.numberOfBands_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snumberOfBands>%s</%snumberOfBands>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.numberOfBands), input_name='numberOfBands')), namespaceprefix_ , eol_))
        if self.rasterOrigin is not None:
            namespaceprefix_ = self.rasterOrigin_nsprefix_ + ':' if (UseCapturedNS_ and self.rasterOrigin_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srasterOrigin>%s</%srasterOrigin>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.rasterOrigin), input_name='rasterOrigin')), namespaceprefix_ , eol_))
        if self.rows is not None:
            namespaceprefix_ = self.rows_nsprefix_ + ':' if (UseCapturedNS_ and self.rows_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srows>%s</%srows>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.rows), input_name='rows')), namespaceprefix_ , eol_))
        if self.columns is not None:
            namespaceprefix_ = self.columns_nsprefix_ + ':' if (UseCapturedNS_ and self.columns_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scolumns>%s</%scolumns>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.columns), input_name='columns')), namespaceprefix_ , eol_))
        if self.verticals is not None:
            namespaceprefix_ = self.verticals_nsprefix_ + ':' if (UseCapturedNS_ and self.verticals_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sverticals>%s</%sverticals>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.verticals), input_name='verticals')), namespaceprefix_ , eol_))
        if self.cellGeometry is not None:
            namespaceprefix_ = self.cellGeometry_nsprefix_ + ':' if (UseCapturedNS_ and self.cellGeometry_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scellGeometry>%s</%scellGeometry>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cellGeometry), input_name='cellGeometry')), namespaceprefix_ , eol_))
        if self.toneGradation is not None:
            namespaceprefix_ = self.toneGradation_nsprefix_ + ':' if (UseCapturedNS_ and self.toneGradation_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stoneGradation>%s</%stoneGradation>%s' % (namespaceprefix_ , self.gds_format_integer(self.toneGradation, input_name='toneGradation'), namespaceprefix_ , eol_))
        if self.scaleFactor is not None:
            namespaceprefix_ = self.scaleFactor_nsprefix_ + ':' if (UseCapturedNS_ and self.scaleFactor_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sscaleFactor>%s</%sscaleFactor>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.scaleFactor), input_name='scaleFactor')), namespaceprefix_ , eol_))
        if self.offset is not None:
            namespaceprefix_ = self.offset_nsprefix_ + ':' if (UseCapturedNS_ and self.offset_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soffset>%s</%soffset>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.offset), input_name='offset')), namespaceprefix_ , eol_))
        if self.imageDescription is not None:
            namespaceprefix_ = self.imageDescription_nsprefix_ + ':' if (UseCapturedNS_ and self.imageDescription_nsprefix_) else ''
            self.imageDescription.export(outfile, level, namespaceprefix_, namespacedef_='', name_='imageDescription', pretty_print=pretty_print)
        if self.references is not None:
            namespaceprefix_ = self.references_nsprefix_ + ':' if (UseCapturedNS_ and self.references_nsprefix_) else ''
            self.references.export(outfile, level, namespaceprefix_, namespacedef_='', name_='references', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_IDType(self.id)    # validate type IDType
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
        value = find_attr_value_('scope', node)
        if value is not None and 'scope' not in already_processed:
            already_processed.add('scope')
            self.scope = value
            self.validate_ScopeType(self.scope)    # validate type ScopeType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'alternateIdentifier':
            obj_ = alternateIdentifierType66.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.alternateIdentifier.append(obj_)
            obj_.original_tagname_ = 'alternateIdentifier'
        elif nodeName_ == 'entityName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'entityName')
            value_ = self.gds_validate_string(value_, node, 'entityName')
            self.entityName = value_
            self.entityName_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.entityName)
        elif nodeName_ == 'entityDescription':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'entityDescription')
            value_ = self.gds_validate_string(value_, node, 'entityDescription')
            self.entityDescription = value_
            self.entityDescription_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.entityDescription)
        elif nodeName_ == 'physical':
            obj_ = PhysicalType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.physical.append(obj_)
            obj_.original_tagname_ = 'physical'
        elif nodeName_ == 'coverage':
            obj_ = Coverage.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.coverage = obj_
            obj_.original_tagname_ = 'coverage'
        elif nodeName_ == 'methods':
            obj_ = MethodsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.methods = obj_
            obj_.original_tagname_ = 'methods'
        elif nodeName_ == 'additionalInfo':
            obj_ = TextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.additionalInfo.append(obj_)
            obj_.original_tagname_ = 'additionalInfo'
        elif nodeName_ == 'annotation':
            class_obj_ = self.get_class_obj_(child_, SemanticAnnotation)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.annotation.append(obj_)
            obj_.original_tagname_ = 'annotation'
        elif nodeName_ == 'attributeList':
            obj_ = AttributeListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.attributeList = obj_
            obj_.original_tagname_ = 'attributeList'
        elif nodeName_ == 'constraint':
            obj_ = ConstraintType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.constraint.append(obj_)
            obj_.original_tagname_ = 'constraint'
        elif nodeName_ == 'spatialReference':
            obj_ = SpatialReferenceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.spatialReference = obj_
            obj_.original_tagname_ = 'spatialReference'
        elif nodeName_ == 'georeferenceInfo':
            obj_ = georeferenceInfoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.georeferenceInfo = obj_
            obj_.original_tagname_ = 'georeferenceInfo'
        elif nodeName_ == 'horizontalAccuracy':
            obj_ = DataQuality.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.horizontalAccuracy = obj_
            obj_.original_tagname_ = 'horizontalAccuracy'
        elif nodeName_ == 'verticalAccuracy':
            obj_ = DataQuality.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.verticalAccuracy = obj_
            obj_.original_tagname_ = 'verticalAccuracy'
        elif nodeName_ == 'cellSizeXDirection':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'cellSizeXDirection')
            value_ = self.gds_validate_string(value_, node, 'cellSizeXDirection')
            self.cellSizeXDirection = value_
            self.cellSizeXDirection_nsprefix_ = child_.prefix
        elif nodeName_ == 'cellSizeYDirection':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'cellSizeYDirection')
            value_ = self.gds_validate_string(value_, node, 'cellSizeYDirection')
            self.cellSizeYDirection = value_
            self.cellSizeYDirection_nsprefix_ = child_.prefix
        elif nodeName_ == 'numberOfBands':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'numberOfBands')
            value_ = self.gds_validate_string(value_, node, 'numberOfBands')
            self.numberOfBands = value_
            self.numberOfBands_nsprefix_ = child_.prefix
        elif nodeName_ == 'rasterOrigin':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'rasterOrigin')
            value_ = self.gds_validate_string(value_, node, 'rasterOrigin')
            self.rasterOrigin = value_
            self.rasterOrigin_nsprefix_ = child_.prefix
            # validate type rasterOriginType
            self.validate_rasterOriginType(self.rasterOrigin)
        elif nodeName_ == 'rows':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'rows')
            value_ = self.gds_validate_string(value_, node, 'rows')
            self.rows = value_
            self.rows_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.rows)
        elif nodeName_ == 'columns':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'columns')
            value_ = self.gds_validate_string(value_, node, 'columns')
            self.columns = value_
            self.columns_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.columns)
        elif nodeName_ == 'verticals':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'verticals')
            value_ = self.gds_validate_string(value_, node, 'verticals')
            self.verticals = value_
            self.verticals_nsprefix_ = child_.prefix
        elif nodeName_ == 'cellGeometry':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'cellGeometry')
            value_ = self.gds_validate_string(value_, node, 'cellGeometry')
            self.cellGeometry = value_
            self.cellGeometry_nsprefix_ = child_.prefix
            # validate type CellGeometryType
            self.validate_CellGeometryType(self.cellGeometry)
        elif nodeName_ == 'toneGradation' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'toneGradation')
            ival_ = self.gds_validate_integer(ival_, node, 'toneGradation')
            self.toneGradation = ival_
            self.toneGradation_nsprefix_ = child_.prefix
        elif nodeName_ == 'scaleFactor':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'scaleFactor')
            value_ = self.gds_validate_string(value_, node, 'scaleFactor')
            self.scaleFactor = value_
            self.scaleFactor_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.scaleFactor)
        elif nodeName_ == 'offset':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'offset')
            value_ = self.gds_validate_string(value_, node, 'offset')
            self.offset = value_
            self.offset_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.offset)
        elif nodeName_ == 'imageDescription':
            obj_ = imageDescriptionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.imageDescription = obj_
            obj_.original_tagname_ = 'imageDescription'
        elif nodeName_ == 'references':
            obj_ = referencesType68.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.references = obj_
            obj_.original_tagname_ = 'references'
# end class SpatialRasterType


class cellSizeXDirection(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cellSizeXDirection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cellSizeXDirection.subclass:
            return cellSizeXDirection.subclass(*args_, **kwargs_)
        else:
            return cellSizeXDirection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='cellSizeXDirection', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cellSizeXDirection')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'cellSizeXDirection':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='cellSizeXDirection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='cellSizeXDirection', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='cellSizeXDirection'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='cellSizeXDirection', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class cellSizeXDirection


class cellSizeYDirection(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cellSizeYDirection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cellSizeYDirection.subclass:
            return cellSizeYDirection.subclass(*args_, **kwargs_)
        else:
            return cellSizeYDirection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='cellSizeYDirection', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cellSizeYDirection')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'cellSizeYDirection':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='cellSizeYDirection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='cellSizeYDirection', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='cellSizeYDirection'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='cellSizeYDirection', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class cellSizeYDirection


class numberOfBands(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, numberOfBands)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if numberOfBands.subclass:
            return numberOfBands.subclass(*args_, **kwargs_)
        else:
            return numberOfBands(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='numberOfBands', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('numberOfBands')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'numberOfBands':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='numberOfBands')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='numberOfBands', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='numberOfBands'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='numberOfBands', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class numberOfBands


class verticals(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, verticals)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if verticals.subclass:
            return verticals.subclass(*args_, **kwargs_)
        else:
            return verticals(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='verticals', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('verticals')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'verticals':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='verticals')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='verticals', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='verticals'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='verticals', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class verticals


class BandType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('sequenceIdentifier', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'sequenceIdentifier', 'type': 'xs:string'}, None),
        MemberSpec_('highWavelength', 'xs:float', 0, 1, {'minOccurs': '0', 'name': 'highWavelength', 'type': 'xs:float'}, None),
        MemberSpec_('lowWaveLength', 'xs:float', 0, 1, {'minOccurs': '0', 'name': 'lowWaveLength', 'type': 'xs:float'}, None),
        MemberSpec_('waveLengthUnits', ['lengthUnits', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'waveLengthUnits', 'type': 'xs:string'}, None),
        MemberSpec_('peakResponse', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'peakResponse', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, sequenceIdentifier=None, highWavelength=None, lowWaveLength=None, waveLengthUnits=None, peakResponse=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.sequenceIdentifier = sequenceIdentifier
        self.validate_NonEmptyStringType(self.sequenceIdentifier)
        self.sequenceIdentifier_nsprefix_ = None
        self.highWavelength = highWavelength
        self.highWavelength_nsprefix_ = None
        self.lowWaveLength = lowWaveLength
        self.lowWaveLength_nsprefix_ = None
        self.waveLengthUnits = waveLengthUnits
        self.validate_lengthUnits(self.waveLengthUnits)
        self.waveLengthUnits_nsprefix_ = None
        self.peakResponse = peakResponse
        self.peakResponse_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BandType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BandType.subclass:
            return BandType.subclass(*args_, **kwargs_)
        else:
            return BandType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_sequenceIdentifier(self):
        return self.sequenceIdentifier
    def set_sequenceIdentifier(self, sequenceIdentifier):
        self.sequenceIdentifier = sequenceIdentifier
    def get_highWavelength(self):
        return self.highWavelength
    def set_highWavelength(self, highWavelength):
        self.highWavelength = highWavelength
    def get_lowWaveLength(self):
        return self.lowWaveLength
    def set_lowWaveLength(self, lowWaveLength):
        self.lowWaveLength = lowWaveLength
    def get_waveLengthUnits(self):
        return self.waveLengthUnits
    def set_waveLengthUnits(self, waveLengthUnits):
        self.waveLengthUnits = waveLengthUnits
    def get_peakResponse(self):
        return self.peakResponse
    def set_peakResponse(self, peakResponse):
        self.peakResponse = peakResponse
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def validate_lengthUnits(self, value):
        result = True
        # Validate type lengthUnits, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['meter', 'nanometer', 'micrometer', 'micron', 'millimeter', 'centimeter', 'decimeter', 'dekameter', 'hectometer', 'kilometer', 'megameter', 'angstrom', 'inch', 'Foot_US', 'foot', 'Foot_Gold_Coast', 'fathom', 'nauticalMile', 'yard', 'Yard_Indian', 'Link_Clarke', 'Yard_Sears', 'mile']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on lengthUnits' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.sequenceIdentifier is not None or
            self.highWavelength is not None or
            self.lowWaveLength is not None or
            self.waveLengthUnits is not None or
            self.peakResponse is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:None="https://eml.ecoinformatics.org/view-2.2.0"  xmlns:spref="https://eml.ecoinformatics.org/spatialReference-2.2.0" ', name_='BandType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BandType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BandType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BandType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BandType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BandType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:None="https://eml.ecoinformatics.org/view-2.2.0"  xmlns:spref="https://eml.ecoinformatics.org/spatialReference-2.2.0" ', name_='BandType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.sequenceIdentifier is not None:
            namespaceprefix_ = self.sequenceIdentifier_nsprefix_ + ':' if (UseCapturedNS_ and self.sequenceIdentifier_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssequenceIdentifier>%s</%ssequenceIdentifier>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.sequenceIdentifier), input_name='sequenceIdentifier')), namespaceprefix_ , eol_))
        if self.highWavelength is not None:
            namespaceprefix_ = self.highWavelength_nsprefix_ + ':' if (UseCapturedNS_ and self.highWavelength_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shighWavelength>%s</%shighWavelength>%s' % (namespaceprefix_ , self.gds_format_float(self.highWavelength, input_name='highWavelength'), namespaceprefix_ , eol_))
        if self.lowWaveLength is not None:
            namespaceprefix_ = self.lowWaveLength_nsprefix_ + ':' if (UseCapturedNS_ and self.lowWaveLength_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slowWaveLength>%s</%slowWaveLength>%s' % (namespaceprefix_ , self.gds_format_float(self.lowWaveLength, input_name='lowWaveLength'), namespaceprefix_ , eol_))
        if self.waveLengthUnits is not None:
            namespaceprefix_ = self.waveLengthUnits_nsprefix_ + ':' if (UseCapturedNS_ and self.waveLengthUnits_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%swaveLengthUnits>%s</%swaveLengthUnits>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.waveLengthUnits), input_name='waveLengthUnits')), namespaceprefix_ , eol_))
        if self.peakResponse is not None:
            namespaceprefix_ = self.peakResponse_nsprefix_ + ':' if (UseCapturedNS_ and self.peakResponse_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%speakResponse>%s</%speakResponse>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.peakResponse), input_name='peakResponse')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'sequenceIdentifier':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'sequenceIdentifier')
            value_ = self.gds_validate_string(value_, node, 'sequenceIdentifier')
            self.sequenceIdentifier = value_
            self.sequenceIdentifier_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.sequenceIdentifier)
        elif nodeName_ == 'highWavelength' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_float(sval_, node, 'highWavelength')
            fval_ = self.gds_validate_float(fval_, node, 'highWavelength')
            self.highWavelength = fval_
            self.highWavelength_nsprefix_ = child_.prefix
        elif nodeName_ == 'lowWaveLength' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_float(sval_, node, 'lowWaveLength')
            fval_ = self.gds_validate_float(fval_, node, 'lowWaveLength')
            self.lowWaveLength = fval_
            self.lowWaveLength_nsprefix_ = child_.prefix
        elif nodeName_ == 'waveLengthUnits':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'waveLengthUnits')
            value_ = self.gds_validate_string(value_, node, 'waveLengthUnits')
            self.waveLengthUnits = value_
            self.waveLengthUnits_nsprefix_ = child_.prefix
            # validate type lengthUnits
            self.validate_lengthUnits(self.waveLengthUnits)
        elif nodeName_ == 'peakResponse':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'peakResponse')
            value_ = self.gds_validate_string(value_, node, 'peakResponse')
            self.peakResponse = value_
            self.peakResponse_nsprefix_ = child_.prefix
# end class BandType


class peakResponse(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, peakResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if peakResponse.subclass:
            return peakResponse.subclass(*args_, **kwargs_)
        else:
            return peakResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='peakResponse', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('peakResponse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'peakResponse':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='peakResponse')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='peakResponse', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='peakResponse'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='peakResponse', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class peakResponse


class DataQuality(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('accuracyReport', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'accuracyReport', 'type': 'xs:string'}, None),
        MemberSpec_('quantitativeAccuracyReport', 'quantitativeAccuracyReportType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'quantitativeAccuracyReport', 'type': 'quantitativeAccuracyReportType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, accuracyReport=None, quantitativeAccuracyReport=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.accuracyReport = accuracyReport
        self.validate_NonEmptyStringType(self.accuracyReport)
        self.accuracyReport_nsprefix_ = None
        if quantitativeAccuracyReport is None:
            self.quantitativeAccuracyReport = []
        else:
            self.quantitativeAccuracyReport = quantitativeAccuracyReport
        self.quantitativeAccuracyReport_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DataQuality)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DataQuality.subclass:
            return DataQuality.subclass(*args_, **kwargs_)
        else:
            return DataQuality(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_accuracyReport(self):
        return self.accuracyReport
    def set_accuracyReport(self, accuracyReport):
        self.accuracyReport = accuracyReport
    def get_quantitativeAccuracyReport(self):
        return self.quantitativeAccuracyReport
    def set_quantitativeAccuracyReport(self, quantitativeAccuracyReport):
        self.quantitativeAccuracyReport = quantitativeAccuracyReport
    def add_quantitativeAccuracyReport(self, value):
        self.quantitativeAccuracyReport.append(value)
    def insert_quantitativeAccuracyReport_at(self, index, value):
        self.quantitativeAccuracyReport.insert(index, value)
    def replace_quantitativeAccuracyReport_at(self, index, value):
        self.quantitativeAccuracyReport[index] = value
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def hasContent_(self):
        if (
            self.accuracyReport is not None or
            self.quantitativeAccuracyReport
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='DataQuality', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DataQuality')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DataQuality':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DataQuality')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DataQuality', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DataQuality'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='DataQuality', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.accuracyReport is not None:
            namespaceprefix_ = self.accuracyReport_nsprefix_ + ':' if (UseCapturedNS_ and self.accuracyReport_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saccuracyReport>%s</%saccuracyReport>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.accuracyReport), input_name='accuracyReport')), namespaceprefix_ , eol_))
        for quantitativeAccuracyReport_ in self.quantitativeAccuracyReport:
            namespaceprefix_ = self.quantitativeAccuracyReport_nsprefix_ + ':' if (UseCapturedNS_ and self.quantitativeAccuracyReport_nsprefix_) else ''
            quantitativeAccuracyReport_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='quantitativeAccuracyReport', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'accuracyReport':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'accuracyReport')
            value_ = self.gds_validate_string(value_, node, 'accuracyReport')
            self.accuracyReport = value_
            self.accuracyReport_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.accuracyReport)
        elif nodeName_ == 'quantitativeAccuracyReport':
            obj_ = quantitativeAccuracyReportType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.quantitativeAccuracyReport.append(obj_)
            obj_.original_tagname_ = 'quantitativeAccuracyReport'
# end class DataQuality


class SpatialReferenceType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'res:IDType', 0, 1, {'use': 'optional'}),
        MemberSpec_('system', 'res:SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('scope', 'res:ScopeType', 0, 1, {'use': 'optional'}),
        MemberSpec_('horizCoordSysName', ['horizCoordSysNameType', 'xs:string'], 0, 0, {'name': 'horizCoordSysName', 'type': 'xs:string'}, 51),
        MemberSpec_('horizCoordSysDef', 'horizCoordSysType', 0, 0, {'name': 'horizCoordSysDef', 'type': 'horizCoordSysType'}, 51),
        MemberSpec_('vertCoordSys', 'vertCoordSysType', 0, 1, {'minOccurs': '0', 'name': 'vertCoordSys', 'type': 'vertCoordSysType'}, None),
        MemberSpec_('references', 'referencesType69', 0, 0, {'name': 'references', 'type': 'referencesType69'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, system=None, scope='document', horizCoordSysName=None, horizCoordSysDef=None, vertCoordSys=None, references=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.scope = _cast(None, scope)
        self.scope_nsprefix_ = None
        self.horizCoordSysName = horizCoordSysName
        self.validate_horizCoordSysNameType(self.horizCoordSysName)
        self.horizCoordSysName_nsprefix_ = None
        self.horizCoordSysDef = horizCoordSysDef
        self.horizCoordSysDef_nsprefix_ = None
        self.vertCoordSys = vertCoordSys
        self.vertCoordSys_nsprefix_ = None
        self.references = references
        self.references_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SpatialReferenceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SpatialReferenceType.subclass:
            return SpatialReferenceType.subclass(*args_, **kwargs_)
        else:
            return SpatialReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_horizCoordSysName(self):
        return self.horizCoordSysName
    def set_horizCoordSysName(self, horizCoordSysName):
        self.horizCoordSysName = horizCoordSysName
    def get_horizCoordSysDef(self):
        return self.horizCoordSysDef
    def set_horizCoordSysDef(self, horizCoordSysDef):
        self.horizCoordSysDef = horizCoordSysDef
    def get_vertCoordSys(self):
        return self.vertCoordSys
    def set_vertCoordSys(self, vertCoordSys):
        self.vertCoordSys = vertCoordSys
    def get_references(self):
        return self.references
    def set_references(self, references):
        self.references = references
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_scope(self):
        return self.scope
    def set_scope(self, scope):
        self.scope = scope
    def validate_horizCoordSysNameType(self, value):
        result = True
        # Validate type horizCoordSysNameType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['GCS_Abidjan_1987', 'GCS_Accra', 'GCS_Adindan', 'GCS_Afgooye', 'GCS_Agadez', 'GCS_Ain_el_Abd_1970', 'GCS_Arc_1950', 'GCS_Arc_1960', 'GCS_Ayabelle', 'GCS_Beduaram', 'GCS_Bissau', 'GCS_Camacupa', 'GCS_Cape', 'GCS_Carthage_Degree', 'GCS_Carthage_Paris', 'GCS_Carthage', 'GCS_Conakry_1905', 'GCS_Cote_d_Ivoire', 'GCS_Dabola', 'GCS_Douala', 'GCS_Egypt_1907', 'GCS_European_1950', 'GCS_European_Libyan_Datum_1979', 'GCS_Garoua', 'GCS_Hartebeesthoek_1994', 'GCS_Kuwait_Oil_Company', 'GCS_KUDAMS', 'GCS_Leigon', 'GCS_Liberia_1964', 'GCS_Locodjo_1965', 'GCS_Lome', 'GCS_Mporaloko', 'GCS_Madzansua', 'GCS_Mahe_1971', 'GCS_Malongo_1987', 'GCS_Manoca', 'GCS_Massawa', 'GCS_Merchich_Degree', 'GCS_Merchich', 'GCS_Mhast', 'GCS_Minna', 'GCS_Moznet', 'GCS_Nahrwan_1967', 'GCS_NGN', 'GCS_Nord_Sahara_1959', 'GCS_Observatario', 'GCS_Oman', 'GCS_Palestine_1923', 'GCS_PDO_1993', 'GCS_Point_58', 'GCS_Pointe_Noire', 'GCS_Qatar_1948', 'GCS_Qatar', 'GCS_Schwarzeck', 'GCS_Sierra_Leone_1924', 'GCS_Sierra_Leone_1960', 'GCS_Sierra_Leone_1968', 'GCS_South_Yemen', 'GCS_Sudan', 'GCS_Tananarive_1925_Paris', 'GCS_Tananarive_1925', 'GCS_Tete', 'GCS_Trucial_Coast_1948', 'GCS_Voirol_1875_Degree', 'GCS_Voirol_1875_Paris', 'GCS_Voirol_1875', 'GCS_Voirol_Unifie_1960_Degree', 'GCS_Voirol_Unifie_1960_Paris', 'GCS_Voirol_Unifie_1960', 'GCS_Yemen_NGN_1996', 'GCS_Yoff', 'GCS_Camp_Area', 'GCS_Deception_Island', 'GCS_Ain_el_Abd_1970', 'GCS_Batavia_Jakarta', 'GCS_Batavia', 'GCS_Beijing_1954', 'GCS_Bukit_Rimpah', 'GCS_Deir_ez_Zor', 'GCS_European_1950_ED77', 'GCS_European_1950', 'GCS_Everest_def_1962', 'GCS_Everest_def_1967', 'GCS_Everest_def_1975', 'GCS_Everest_Bangladesh', 'GCS_Everest_India_Nepal', 'GCS_Everest_1830', 'GCS_Everest_Modified', 'GCS_Fahud', 'GCS_FD_1958', 'GCS_Gandajika_1970', 'GCS_Gunung_Segara', 'GCS_Hanoi_1972', 'GCS_Herat_North', 'GCS_Hong_Kong_1963', 'GCS_Hong_Kong_1980', 'GCS_Hu_Tzu_Shan', 'GCS_Indian_1954', 'GCS_Indian_1960', 'GCS_Indian_1975', 'GCS_Indonesian_1974', 'GCS_Israel', 'GCS_JGD_2000', 'GCS_Kalianpur_1880', 'GCS_Kalianpur_1937', 'GCS_Kalianpur_1962', 'GCS_Kalianpur_1975', 'GCS_Kandawala', 'GCS_Kertau', 'GCS_Korean_Datum_1985', 'GCS_Korean_Datum_1995', 'GCS_Kuwait_Oil_Company', 'GCS_KUDAMS', 'GCS_Luzon_1911', 'GCS_Makassar_Jakarta', 'GCS_Makassar', 'GCS_Nahrwan_1967', 'GCS_NGN', 'GCS_Oman', 'GCS_Padang_1884_Jakarta', 'GCS_Padang_1884', 'GCS_Palestine_1923', 'GCS_Pulkovo_1942', 'GCS_Pulkovo_1995', 'GCS_Qatar_1948', 'GCS_Qatar', 'GCS_Rassadiran', 'GCS_Samboja', 'GCS_Segora', 'GCS_Serindung', 'GCS_South_Asia_Singapore', 'GCS_Timbalai_1948', 'GCS_Tokyo', 'GCS_Trucial_Coast_1948', 'GCS_Australian_1966', 'GCS_Australian_1984', 'GCS_GDA_1994', 'GCS_New_Zealand_1949', 'GCS_NZGD_2000', 'GCS_Amersfoort', 'GCS_ATF_Paris', 'GCS_Belge_1950_Brussels', 'GCS_Belge_1972', 'GCS_Bern_1898_Bern', 'GCS_Bern_1898', 'GCS_Bern_1938', 'GCS_CH1903+', 'GCS_CH1903', 'GCS_Datum_73', 'GCS_Datum_Lisboa_Bessel', 'GCS_Datum_Lisboa_Bessel', 'GCS_Dealul_Piscului_1933', 'GCS_Dealul_Piscului_1970', 'GCS_Deutsche_Hauptdreiecksnetz', 'GCS_Estonia_1937', 'GCS_Estonia_1992', 'GCS_ETRF_1989', 'GCS_European_1979', 'GCS_European_1950', 'GCS_European_1987', 'GCS_Greek_Athens', 'GCS_Greek', 'GCS_Hermannskogel', 'GCS_Hjorsey_1955', 'GCS_Hungarian_1972', 'GCS_IRENET95', 'GCS_KKJ', 'GCS_Lisbon_Lisbon', 'GCS_Lisbon', 'GCS_LKS_1994', 'GCS_Madrid_1870_Madrid', 'GCS_MGI_Ferro', 'GCS_MGI', 'GCS_Monte_Mario_Rome', 'GCS_Monte_Mario', 'GCS_NGO_1948_Oslo', 'GCS_NGO_1948', 'GCS_Nord_de_Guerre_Paris', 'GCS_NTF', 'GCS_NTF_Paris', 'GCS_OS_SN_1980', 'GCS_OSGB_1936', 'GCS_OSGB_1970_SN', 'GCS_Pulkovo_1942', 'GCS_Pulkovo_1995', 'GCS_Qornoq', 'GCS_Belge_1950', 'GCS_Belge_1972', 'GCS_RGF_1993', 'GCS_RT_1990', 'GCS_RT38_Stockholm', 'GCS_RT38', 'GCS_S42_Hungary', 'GCS_S_JTSK', 'GCS_Swiss_TRF_1995', 'GCS_TM65', 'GCS_TM75', 'GCS_Alaskan_Islands', 'GCS_American_Samoa_1962', 'GCS_ATS_1977', 'GCS_Barbados', 'GCS_Bermuda_1957', 'GCS_Cape_Canaveral', 'GCS_Guam_1963', 'GCS_Jamaica_1875', 'GCS_Jamaica_1969', 'GCS_NAD_1927_CGQ77', 'GCS_NAD_1927_Definition_1976', 'GCS_North_American_Michigan', 'GCS_North_American_1983_CSRS98', 'GCS_North_American_1983_HARN', 'GCS_North_American_1927', 'GCS_North_American_1983', 'GCS_Old_Hawaiian', 'GCS_Puerto_Rico', 'GCS_Qornoq', 'GCS_St_George_Island', 'GCS_St_Lawrence_Island', 'GCS_St_Paul_Island', 'GCS_Alaskan_Islands', 'GCS_American_Samoa_1962', 'GCS_Anguilla_1957', 'GCS_Anna_1_1965', 'GCS_Antigua_1943', 'GCS_Ascension_Island_1958', 'GCS_Beacon_E_1945', 'GCS_DOS_71_4', 'GCS_Astro_1952', 'GCS_Bab_South', 'GCS_Barbados_1938', 'GCS_Barbados', 'GCS_Bellevue_IGN', 'GCS_Bermuda_1957', 'GCS_Canton_1966', 'GCS_Chatham_Island_1971', 'GCS_Dominica_1945', 'GCS_DOS_1968', 'GCS_Easter_Island_1967', 'GCS_Fort_Thomas_1955', 'GCS_Gan_1970', 'GCS_Graciosa_Base_SW_1948', 'GCS_Grenada_1953', 'GCS_Guam_1963', 'GCS_GUX_1', 'GCS_Hjorsey_1955', 'GCS_ISTS_061_1968', 'GCS_ISTS_073_1969', 'GCS_Jamaica_1875', 'GCS_Jamaica_1969', 'GCS_Johnston_Island_1961', 'GCS_Kerguelen_Island_1949', 'GCS_Kusaie_1951', 'GCS_LC5_1961', 'GCS_Mahe_1971', 'GCS_Majuro', 'GCS_Midway_1961', 'GCS_Montserrat_1958', 'GCS_Observ_Meteorologico_1939', 'GCS_Old_Hawaiian', 'GCS_Pico_de_Las_Nieves', 'GCS_Pitcairn_1967', 'GCS_Pohnpei', 'GCS_Porto_Santo_1936', 'GCS_Puerto_Rico', 'GCS_Reunion', 'GCS_Santo_DOS_1965', 'GCS_Sao_Braz', 'GCS_Sapper_Hill_1943', 'GCS_Selvagem_Grande_1938', 'GCS_St_Kitts_1955', 'GCS_St_Lucia_1955', 'GCS_St_Vincent_1945', 'GCS_Tern_Island_1961', 'GCS_Tristan_1968', 'GCS_Viti_Levu_1916', 'GCS_Wake_Island_1952', 'GCS_Wake_Eniwetok_1960', 'GCS_Aratu', 'GCS_Bogota_Bogota', 'GCS_Bogota', 'GCS_Campo_Inchauspe', 'GCS_Chos_Malal_1914', 'GCS_Chua', 'GCS_Corrego_Alegre', 'GCS_Guyane_Francaise', 'GCS_Hito_XVIII_1963', 'GCS_La_Canoa', 'GCS_Lake', 'GCS_Loma_Quintana', 'GCS_Mount_Dillon', 'GCS_Naparima_1955', 'GCS_Naparima_1972', 'GCS_Pampa_del_Castillo', 'GCS_POSGAR', 'GCS_REGVEN', 'GCS_Sapper_Hill_1943', 'GCS_SIRGAS', 'GCS_South_American_1969', 'GCS_Trinidad_1903', 'GCS_Yacare', 'GCS_Zanderij', 'GCS_Airy_1830', 'GCS_Airy_Modified', 'GCS_Australian', 'GCS_Sphere_ARC_INFO', 'GCS_Sphere', 'GCS_ATS_1977', 'GCS_Bessel_1841', 'GCS_Bessel_Modified', 'GCS_Bessel_Namibia', 'GCS_Clarke_1858', 'GCS_Clarke_1866_Michigan', 'GCS_Clarke_1866', 'GCS_Clarke_1880_Arc', 'GCS_Clarke_1880_Benoit', 'GCS_Clarke_1880_IGN', 'GCS_Clarke_1880_RGS', 'GCS_Clarke_1880_SGA', 'GCS_Clarke_1880', 'GCS_Everest_def_1967', 'GCS_Everest_def_1975', 'GCS_Everest_1830', 'GCS_Everest_Modified_1969', 'GCS_Everest_Modified', 'GCS_Fischer_1960', 'GCS_Fischer_1968', 'GCS_Fischer_Modified', 'GCS_GEM_10C', 'GCS_GRS_1967', 'GCS_GRS_1980', 'GCS_Helmert_1906', 'GCS_Hough_1960', 'GCS_Indonesian', 'GCS_International_1924', 'GCS_International_1967', 'GCS_Krasovsky_1940', 'GCS_OSU_86F', 'GCS_OSU_91A', 'GCS_Plessis_1817', 'GCS_Struve_1860', 'GCS_NWL_9D', 'GCS_Walbeck', 'GCS_War_Office', 'GCS_WGS_1966', 'GCS_NSWC_9Z_2', 'GCS_WGS_1966', 'GCS_WGS_1972_BE', 'GCS_WGS_1972', 'GCS_WGS_1984', 'Africa_Albers_Equal_Area_Conic', 'Africa_Equidistant_Conic', 'Africa_Lambert_Conformal_Conic', 'Africa_Sinusoidal', 'Asia_Lambert_Conformal_Conic', 'Asia_North_Albers_Equal_Area_Conic', 'Asia_North_Equidistant_Conic', 'Asia_North_Lambert_Conformal_Conic', 'Asia_South_Albers_Equal_Area_Conic', 'Asia_South_Equidistant_Conic', 'Asia_South_Lambert_Conformal_Conic', 'Europe_Albers_Equal_Area_Conic', 'Europe_Equidistant_Conic', 'Europe_Lambert_Conformal_Conic', 'Alaska_Albers_Equal_Area_Conic', 'Canada_Albers_Equal_Area_Conic', 'Canada_Lambert_Conformal_Conic', 'Hawaii_Albers_Equal_Area_Conic', 'North_America_Albers_Equal_Area_Conic', 'North_America_Equidistant_Conic', 'North_America_Lambert_Conformal_Conic', 'USA_Contiguous_Albers_Equal_Area_Conic_USGS_version', 'USA_Contiguous_Albers_Equal_Area_Conic', 'USA_Contiguous_Equidistant_Conic', 'USA_Contiguous_Lambert_Conformal_Conic', 'South_America_Albers_Equal_Area_Conic', 'South_America_Equidistant_Conic', 'South_America_Lambert_Conformal_Conic', 'Beijing_1954_GK_Zone_13', 'Beijing_1954_GK_Zone_13N', 'Beijing_1954_GK_Zone_14', 'Beijing_1954_GK_Zone_14N', 'Beijing_1954_GK_Zone_15', 'Beijing_1954_GK_Zone_15N', 'Beijing_1954_GK_Zone_16', 'Beijing_1954_GK_Zone_16N', 'Beijing_1954_GK_Zone_17', 'Beijing_1954_GK_Zone_17N', 'Beijing_1954_GK_Zone_18', 'Beijing_1954_GK_Zone_18N', 'Beijing_1954_GK_Zone_19', 'Beijing_1954_GK_Zone_19N', 'Beijing_1954_GK_Zone_20', 'Beijing_1954_GK_Zone_20N', 'Beijing_1954_GK_Zone_21', 'Beijing_1954_GK_Zone_21N', 'Beijing_1954_GK_Zone_22', 'Beijing_1954_GK_Zone_22N', 'Beijing_1954_GK_Zone_23', 'Beijing_1954_GK_Zone_23N', 'Hanoi_1972_GK_Zone_18', 'Hanoi_1972_GK_Zone_19', 'South_Yemen_GK_Zone_8', 'South_Yemen_GK_Zone_9', 'Pulkovo_1942_GK_Zone_10', 'Pulkovo_1942_GK_Zone_10N', 'Pulkovo_1942_GK_Zone_11', 'Pulkovo_1942_GK_Zone_11N', 'Pulkovo_1942_GK_Zone_12', 'Pulkovo_1942_GK_Zone_12N', 'Pulkovo_1942_GK_Zone_13', 'Pulkovo_1942_GK_Zone_13N', 'Pulkovo_1942_GK_Zone_14', 'Pulkovo_1942_GK_Zone_14N', 'Pulkovo_1942_GK_Zone_15', 'Pulkovo_1942_GK_Zone_15N', 'Pulkovo_1942_GK_Zone_16', 'Pulkovo_1942_GK_Zone_16N', 'Pulkovo_1942_GK_Zone_17', 'Pulkovo_1942_GK_Zone_17N', 'Pulkovo_1942_GK_Zone_18', 'Pulkovo_1942_GK_Zone_18N', 'Pulkovo_1942_GK_Zone_19', 'Pulkovo_1942_GK_Zone_19N', 'Pulkovo_1942_GK_Zone_2', 'Pulkovo_1942_GK_Zone_20', 'Pulkovo_1942_GK_Zone_20N', 'Pulkovo_1942_GK_Zone_21', 'Pulkovo_1942_GK_Zone_21N', 'Pulkovo_1942_GK_Zone_22', 'Pulkovo_1942_GK_Zone_22N', 'Pulkovo_1942_GK_Zone_23', 'Pulkovo_1942_GK_Zone_23N', 'Pulkovo_1942_GK_Zone_24', 'Pulkovo_1942_GK_Zone_24N', 'Pulkovo_1942_GK_Zone_25', 'Pulkovo_1942_GK_Zone_25N', 'Pulkovo_1942_GK_Zone_26', 'Pulkovo_1942_GK_Zone_26N', 'Pulkovo_1942_GK_Zone_27', 'Pulkovo_1942_GK_Zone_27N', 'Pulkovo_1942_GK_Zone_28', 'Pulkovo_1942_GK_Zone_28N', 'Pulkovo_1942_GK_Zone_29', 'Pulkovo_1942_GK_Zone_29N', 'Pulkovo_1942_GK_Zone_2N', 'Pulkovo_1942_GK_Zone_3', 'Pulkovo_1942_GK_Zone_30', 'Pulkovo_1942_GK_Zone_30N', 'Pulkovo_1942_GK_Zone_31', 'Pulkovo_1942_GK_Zone_31N', 'Pulkovo_1942_GK_Zone_32', 'Pulkovo_1942_GK_Zone_32N', 'Pulkovo_1942_GK_Zone_3N', 'Pulkovo_1942_GK_Zone_4', 'Pulkovo_1942_GK_Zone_4N', 'Pulkovo_1942_GK_Zone_5', 'Pulkovo_1942_GK_Zone_5N', 'Pulkovo_1942_GK_Zone_6', 'Pulkovo_1942_GK_Zone_6N', 'Pulkovo_1942_GK_Zone_7', 'Pulkovo_1942_GK_Zone_7N', 'Pulkovo_1942_GK_Zone_8', 'Pulkovo_1942_GK_Zone_8N', 'Pulkovo_1942_GK_Zone_9', 'Pulkovo_1942_GK_Zone_9N', 'Pulkovo_1995_GK_Zone_10', 'Pulkovo_1995_GK_Zone_10N', 'Pulkovo_1995_GK_Zone_11', 'Pulkovo_1995_GK_Zone_11N', 'Pulkovo_1995_GK_Zone_12', 'Pulkovo_1995_GK_Zone_12N', 'Pulkovo_1995_GK_Zone_13', 'Pulkovo_1995_GK_Zone_13N', 'Pulkovo_1995_GK_Zone_14', 'Pulkovo_1995_GK_Zone_14N', 'Pulkovo_1995_GK_Zone_15', 'Pulkovo_1995_GK_Zone_15N', 'Pulkovo_1995_GK_Zone_16', 'Pulkovo_1995_GK_Zone_16N', 'Pulkovo_1995_GK_Zone_17', 'Pulkovo_1995_GK_Zone_17N', 'Pulkovo_1995_GK_Zone_18', 'Pulkovo_1995_GK_Zone_18N', 'Pulkovo_1995_GK_Zone_19', 'Pulkovo_1995_GK_Zone_19N', 'Pulkovo_1995_GK_Zone_2', 'Pulkovo_1995_GK_Zone_20', 'Pulkovo_1995_GK_Zone_20N', 'Pulkovo_1995_GK_Zone_21', 'Pulkovo_1995_GK_Zone_21N', 'Pulkovo_1995_GK_Zone_22', 'Pulkovo_1995_GK_Zone_22N', 'Pulkovo_1995_GK_Zone_23', 'Pulkovo_1995_GK_Zone_23N', 'Pulkovo_1995_GK_Zone_24', 'Pulkovo_1995_GK_Zone_24N', 'Pulkovo_1995_GK_Zone_25', 'Pulkovo_1995_GK_Zone_25N', 'Pulkovo_1995_GK_Zone_26', 'Pulkovo_1995_GK_Zone_26N', 'Pulkovo_1995_GK_Zone_27', 'Pulkovo_1995_GK_Zone_27N', 'Pulkovo_1995_GK_Zone_28', 'Pulkovo_1995_GK_Zone_28N', 'Pulkovo_1995_GK_Zone_29', 'Pulkovo_1995_GK_Zone_29N', 'Pulkovo_1995_GK_Zone_2N', 'Pulkovo_1995_GK_Zone_3', 'Pulkovo_1995_GK_Zone_30', 'Pulkovo_1995_GK_Zone_30N', 'Pulkovo_1995_GK_Zone_31', 'Pulkovo_1995_GK_Zone_31N', 'Pulkovo_1995_GK_Zone_32', 'Pulkovo_1995_GK_Zone_32N', 'Pulkovo_1995_GK_Zone_3N', 'Pulkovo_1995_GK_Zone_4', 'Pulkovo_1995_GK_Zone_4N', 'Pulkovo_1995_GK_Zone_5', 'Pulkovo_1995_GK_Zone_5N', 'Pulkovo_1995_GK_Zone_6', 'Pulkovo_1995_GK_Zone_6N', 'Pulkovo_1995_GK_Zone_7', 'Pulkovo_1995_GK_Zone_7N', 'Pulkovo_1995_GK_Zone_8', 'Pulkovo_1995_GK_Zone_8N', 'Pulkovo_1995_GK_Zone_9', 'Pulkovo_1995_GK_Zone_9N', 'Abidjan_1987_TM_5_NW', 'Accra_Ghana_Grid', 'Accra_TM_1_NW', 'Samoa_1962_Samoa_Lambert', 'Anguilla_1957_British_West_Indies_Grid', 'Antigua_1943_British_West_Indies_Grid', 'Argentina_Zone_1', 'Argentina_Zone_2', 'Argentina_Zone_3', 'Argentina_Zone_4', 'Argentina_Zone_5', 'Argentina_Zone_6', 'Argentina_Zone_7', 'AGD_1966_AMG_Zone_48', 'AGD_1966_AMG_Zone_49', 'AGD_1966_AMG_Zone_50', 'AGD_1966_AMG_Zone_51', 'AGD_1966_AMG_Zone_52', 'AGD_1966_AMG_Zone_53', 'AGD_1966_AMG_Zone_54', 'AGD_1966_AMG_Zone_55', 'AGD_1966_AMG_Zone_56', 'AGD_1966_AMG_Zone_57', 'AGD_1966_AMG_Zone_58', 'AGD_1966_VICGRID', 'AGD_1984_AMG_Zone_48', 'AGD_1984_AMG_Zone_49', 'AGD_1984_AMG_Zone_50', 'AGD_1984_AMG_Zone_51', 'AGD_1984_AMG_Zone_52', 'AGD_1984_AMG_Zone_53', 'AGD_1984_AMG_Zone_54', 'AGD_1984_AMG_Zone_55', 'AGD_1984_AMG_Zone_56', 'AGD_1984_AMG_Zone_57', 'AGD_1984_AMG_Zone_58', 'GDA_1994_MGA_Zone_48', 'GDA_1994_MGA_Zone_49', 'GDA_1994_MGA_Zone_50', 'GDA_1994_MGA_Zone_51', 'GDA_1994_MGA_Zone_52', 'GDA_1994_MGA_Zone_53', 'GDA_1994_MGA_Zone_54', 'GDA_1994_MGA_Zone_55', 'GDA_1994_MGA_Zone_56', 'GDA_1994_MGA_Zone_57', 'GDA_1994_MGA_Zone_58', 'GDA_1994_South_Australia_Lambert', 'GDA_1994_VICGRID94', 'Austria_Central_Zone', 'Austria_East_Zone', 'Austria_West_Zone', 'Bahrain_State_Grid', 'Barbados_1938_Barbados_Grid', 'Barbados_1938_British_West_Indies_Grid', 'Belge_Lambert_1950', 'Belge_Lambert_1972', 'Bern_1898_Bern_LV03C', 'British_National_Grid', 'Camacupa_TM_11_30_SE', 'Camacupa_TM_12_SE', 'ATS_1977_MTM_4_Nova_Scotia', 'ATS_1977_MTM_5_Nova_Scotia', 'ATS_1977_New_Brunswick_Stereographic', 'NAD_1927_10TM_AEP_Forest', 'NAD_1927_10TM_AEP_Resource', 'NAD_1927_3TM_111', 'NAD_1927_3TM_114', 'NAD_1927_3TM_117', 'NAD_1927_3TM_120', 'NAD_1927_CGQ77_MTM_10_SCoPQ', 'NAD_1927_CGQ77_MTM_2_SCoPQ', 'NAD_1927_CGQ77_MTM_3_SCoPQ', 'NAD_1927_CGQ77_MTM_4_SCoPQ', 'NAD_1927_CGQ77_MTM_5_SCoPQ', 'NAD_1927_CGQ77_MTM_6_SCoPQ', 'NAD_1927_CGQ77_MTM_7_SCoPQ', 'NAD_1927_CGQ77_MTM_8_SCoPQ', 'NAD_1927_CGQ77_MTM_9_SCoPQ', 'NAD_1927_CGQ77_Quebec_Lambert', 'NAD_1927_CGQ77_UTM_Zone_17N', 'NAD_1927_CGQ77_UTM_Zone_18N', 'NAD_1927_CGQ77_UTM_Zone_19N', 'NAD_1927_CGQ77_UTM_Zone_20N', 'NAD_1927_CGQ77_UTM_Zone_21N', 'NAD_1927_DEF_1976_MTM_10', 'NAD_1927_DEF_1976_MTM_11', 'NAD_1927_DEF_1976_MTM_12', 'NAD_1927_DEF_1976_MTM_13', 'NAD_1927_DEF_1976_MTM_14', 'NAD_1927_DEF_1976_MTM_15', 'NAD_1927_DEF_1976_MTM_16', 'NAD_1927_DEF_1976_MTM_17', 'NAD_1927_DEF_1976_MTM_8', 'NAD_1927_DEF_1976_MTM_9', 'NAD_1927_DEF_1976_UTM_Zone_15N', 'NAD_1927_DEF_1976_UTM_Zone_16N', 'NAD_1927_DEF_1976_UTM_Zone_17N', 'NAD_1927_DEF_1976_UTM_Zone_18N', 'NAD_1927_MTM_1', 'NAD_1927_MTM_2', 'NAD_1927_MTM_3', 'NAD_1927_MTM_4', 'NAD_1927_MTM_5', 'NAD_1927_MTM_6', 'NAD_1927_Quebec_Lambert', 'NAD_1983_10TM_AEP_Forest', 'NAD_1983_10TM_AEP_Resource', 'NAD_1983_3TM_111', 'NAD_1983_3TM_114', 'NAD_1983_3TM_117', 'NAD_1983_3TM_120', 'NAD_1983_BC_Environment_Albers', 'NAD_1983_CRS98_MTM_10', 'NAD_1983_CSRS98_MTM_2_SCoPQ', 'NAD_1983_CRS98_MTM_3', 'NAD_1983_CRS98_MTM_4', 'NAD_1983_CRS98_MTM_5', 'NAD_1983_CRS98_MTM_6', 'NAD_1983_CRS98_MTM_7', 'NAD_1983_CRS98_MTM_8', 'NAD_1983_CRS98_MTM_9', 'NAD_1983_CSRS98_New_Brunswick_Stereographic', 'NAD_1983_CSRS98_Prince_Edward_Island', 'NAD_1983_CSRS98_UTM_Zone_21N', 'NAD_1983_CSRS98_UTM_Zone_11N', 'NAD_1983_CSRS98_UTM_Zone_12N', 'NAD_1983_CSRS98_UTM_Zone_13N', 'NAD_1983_CSRS98_UTM_Zone_17N', 'NAD_1983_CSRS98_UTM_Zone_18N', 'NAD_1983_CSRS98_UTM_Zone_19N', 'NAD_1983_CSRS98_UTM_Zone_20N', 'NAD_1983_MTM_1', 'NAD_1983_MTM_10', 'NAD_1983_MTM_11', 'NAD_1983_MTM_12', 'NAD_1983_MTM_13', 'NAD_1983_MTM_14', 'NAD_1983_MTM_15', 'NAD_1983_MTM_16', 'NAD_1983_MTM_17', 'NAD_1983_MTM_2_SCoPQ', 'NAD_1983_MTM_2', 'NAD_1983_MTM_3', 'NAD_1983_MTM_4', 'NAD_1983_MTM_5', 'NAD_1983_MTM_6', 'NAD_1983_MTM_7', 'NAD_1983_MTM_8', 'NAD_1983_MTM_9', 'NAD_1983_Quebec_Lambert', 'Prince_Edward_Island_Stereographic', 'Carthage_TM_11_NE', 'Centre_France', 'CH1903_LV03', 'CH1903+_LV95', 'Chos_Malal_1914_Argentina_2', 'Colombia_Bogota_Zone', 'Colombia_East_Central_Zone', 'Colombia_East_Zone', 'Colombia_West_Zone', 'Corse', 'Datum_73_Hayford_Gauss_IGeoE', 'Datum_73_Hayford_Gauss_IPCC', 'Deir_ez_Zor_Levant_Stereographic', 'Deir_ez_Zor_Levant_Zone', 'Deir_ez_Zor_Syria_Lambert', 'DHDN_3_Degree_Gauss_Zone_1', 'DHDN_3_Degree_Gauss_Zone_2', 'DHDN_3_Degree_Gauss_Zone_3', 'DHDN_3_Degree_Gauss_Zone_4', 'DHDN_3_Degree_Gauss_Zone_5', 'Dominica_1945_British_West_Indies_Grid', 'ED_1950_TM_0_N', 'ED_1950_TM_5_NE', 'Egypt_Blue_Belt', 'Egypt_Extended_Purple_Belt', 'Egypt_Purple_Belt', 'Egypt_Red_Belt', 'ELD_1979_Libya_10', 'ELD_1979_Libya_11', 'ELD_1979_Libya_12', 'ELD_1979_Libya_13', 'ELD_1979_Libya_5', 'ELD_1979_Libya_6', 'ELD_1979_Libya_7', 'ELD_1979_Libya_8', 'ELD_1979_Libya_9', 'ELD_1979_TM_12_NE', 'Estonian_Coordinate_System_of_1992', 'ETRF_1989_TM_Baltic_1993', 'FD_1958_Iraq', 'Finland_Zone_1', 'Finland_Zone_2', 'Finland_Zone_3', 'Finland_Zone_4', 'France_I', 'France_II', 'France_III', 'France_IV', 'Germany_Zone_1', 'Germany_Zone_2', 'Germany_Zone_3', 'Germany_Zone_4', 'Germany_Zone_5', 'Ghana_Metre_Grid', 'Greek_Grid', 'Grenada_1953_British_West_Indies_Grid', 'Hanoi_1972_GK_106_NE', 'HD_1972_Egyseges_Orszagos_Vetuleti', 'Hito_XVIII_1963_Argentina_2', 'Hong_Kong_1980_Grid', 'Indian_1960_TM_106NE', 'Kalianpur_1880_India_Zone_0', 'Kalianpur_1880_India_Zone_I', 'Kalianpur_1880_India_Zone_IIa', 'Kalianpur_1880_India_Zone_IIb', 'Kalianpur_1880_India_Zone_III', 'Kalianpur_1880_India_Zone_IV', 'Kalianpur_1937_India_Zone_IIb', 'Kalianpur_1937_UTM_Zone_45N', 'Kalianpur_1937_UTM_Zone_46N', 'Kalianpur_1962_India_Zone_I', 'Kalianpur_1962_India_Zone_IIa', 'Kalianpur_1962_UTM_Zone_41N', 'Kalianpur_1962_UTM_Zone_42N', 'Kalianpur_1962_UTM_Zone_43N', 'Kalianpur_1975_India_Zone_I', 'Kalianpur_1975_India_Zone_IIa', 'Kalianpur_1975_India_Zone_IIb', 'Kalianpur_1975_India_Zone_III', 'Kalianpur_1975_India_Zone_IV', 'Kalianpur_1975_UTM_Zone_42N', 'Kalianpur_1975_UTM_Zone_43N', 'Kalianpur_1975_UTM_Zone_44N', 'Kalianpur_1975_UTM_Zone_45N', 'Kalianpur_1975_UTM_Zone_46N', 'Kalianpur_1975_UTM_Zone_47N', 'IRENET95_IRISH_Transverse_Mercator', 'Irish_National_Grid', 'Israel_TM_Grid', 'Jamaica_1875_Old_Grid', 'Jamaica_Grid', 'Japan_Zone_1', 'Japan_Zone_10', 'Japan_Zone_11', 'Japan_Zone_12', 'Japan_Zone_13', 'Japan_Zone_14', 'Japan_Zone_15', 'Japan_Zone_16', 'Japan_Zone_17', 'Japan_Zone_18', 'Japan_Zone_19', 'Japan_Zone_2', 'Japan_Zone_3', 'Japan_Zone_4', 'Japan_Zone_5', 'Japan_Zone_6', 'Japan_Zone_7', 'Japan_Zone_8', 'Japan_Zone_9', 'Kertau_Singapore_Grid', 'KOC_Lambert', 'Korean_1985_Korea_Central_Belt', 'Korean_1985_Korea_East_Belt', 'Korean_1985_Korea_West_Belt', 'KUDAMS_KTM', 'KOC_Lambert', 'KUDAMS_KTM', 'Lake_Maracaibo_Grid_M1', 'Lake_Maracaibo_Grid_M3', 'Lake_Maracaibo_Grid', 'Lake_Maracaibo_La_Rosa_Grid', 'Lietuvos_Koordinaciu_Sistema', 'Lisboa_Bessel_Bonne', 'Lisboa_Hayford_Gauss_IGeoE', 'Lisboa_Hayford_Gauss_IPCC', 'Locodjo_1965_TM_5_NW', 'Madrid_1870_Madrid_Spain', 'MGI_3_Degree_Gauss_Zone_5', 'MGI_3_Degree_Gauss_Zone_6', 'MGI_3_Degree_Gauss_Zone_7', 'MGI_3_Degree_Gauss_Zone_8', 'MGI_Austria_Lambert', 'MGI_Balkans_5', 'MGI_Balkans_6', 'MGI_Balkans_8', 'MGI_Balkans_8', 'MGI_M28', 'MGI_M31', 'MGI_M34', 'Monte_Mario_Rome_Italy_1', 'Monte_Mario_Rome_Italy_2', 'Monte_Mario_Italy_1', 'Monte_Mario_Italy_2', 'Montserrat_1958_British_West_Indies_Grid', 'Mount_Dillon_Tobago_Grid', 'NAD_1927_Cuba_Norte', 'NAD_1927_Cuba_Sur', 'NAD_1927_Guatemala_Norte', 'NAD_1927_Guatemala_Sur', 'NAD_1927_Michigan_GeoRef_Meters', 'NAD_1927_Michigan_GeoRef_Feet_US', 'NAD_1983_HARN_Guam_Map_Grid', 'NAD_1983_Michigan_GeoRef_Meters', 'NAD_1983_Michigan_GeoRef_Feet_US', 'GD_1949_New_Zealand_Map_Grid', 'New_Zealand_North_Island', 'New_Zealand_South_Island', 'NZGD_1949_Amuri_Circuit', 'NZGD_1949_Bay_of_Plenty_Circuit', 'NZGD_1949_Bluff_Circuit', 'NZGD_1949_Buller_Circuit', 'NZGD_1949_Collingwood_Circuit', 'NZGD_1949_Gawler_Circuit', 'NZGD_1949_Grey_Circuit', 'NZGD_1949_Hawkes_Bay_Circuit', 'NZGD_1949_Hokitika_Circuit', 'NZGD_1949_Jacksons_Bay_Circuit', 'NZGD_1949_Karamea_Circuit', 'NZGD_1949_Lindis_Peak_Circuit', 'NZGD_1949_Marlborough_Circuit', 'NZGD_1949_Mount_Eden_Circuit', 'NZGD_1949_Mount_Nicholas_Circuit', 'NZGD_1949_Mount_Pleasant_Circuit', 'NZGD_1949_Mount_York_Circuit', 'NZGD_1949_Nelson_Circuit', 'NZGD_1949_North_Taieri_Circuit', 'NZGD_1949_Observation_Point_Circuit', 'NZGD_1949_Okarito_Circuit', 'NZGD_1949_Poverty_Bay_Circuit', 'NZGD_1949_Taranaki_Circuit', 'NZGD_1949_Timaru_Circuit', 'NZGD_1949_Tuhirangi_Circuit', 'NZGD_1949_UTM_Zone_58S', 'NZGD_1949_UTM_Zone_59S', 'NZGD_1949_UTM_Zone_60S', 'NZGD_1949_Wairarapa_Circuit', 'NZGD_1949_Wanganui_Circuit', 'NZGD_1949_Wellington_Circuit', 'NZGD_2000_Amuri_Circuit', 'NZGD_2000_Bay_of_Plenty_Circuit', 'NZGD_2000_Bluff_Circuit', 'NZGD_2000_Buller_Circuit', 'NZGD_2000_Collingwood_Circuit', 'NZGD_2000_Gawler_Circuit', 'NZGD_2000_Grey_Circuit', 'NZGD_2000_Hawkes_Bay_Circuit', 'NZGD_2000_Hokitika_Circuit', 'NZGD_2000_Jacksons_Bay_Circuit', 'NZGD_2000_Karamea_Circuit', 'NZGD_2000_Lindis_Peak_Circuit', 'NZGD_2000_Marlborough_Circuit', 'NZGD_2000_Mount_Eden_Circuit', 'NZGD_2000_Mount_Nicholas_Circuit', 'NZGD_2000_Mount_Pleasant_Circuit', 'NZGD_2000_Mount_York_Circuit', 'NZGD_2000_Nelson_Circuit', 'NZGD_2000_North_Taieri_Circuit', 'NZGD_2000_Observation_Point_Circuit', 'NZGD_2000_Okarito_Circuit', 'NZGD_2000_Poverty_Bay_Circuit', 'NZGD_2000_Taranaki_Circuit', 'NZGD_2000_Timaru_Circuit', 'NZGD_2000_Tuhirangi_Circuit', 'NZGD_2000_UTM_Zone_58S', 'NZGD_2000_UTM_Zone_59S', 'NZGD_2000_UTM_Zone_60S', 'NZGD_2000_Wairarapa_Circuit', 'NZGD_2000_Wanganui_Circuit', 'NZGD_2000_Wellington_Circuit', 'GD_1949_New_Zealand_Map_Grid', 'New_Zealand_North_Island', 'New_Zealand_South_Island', 'Nigeria_East_Belt', 'Nigeria_Mid_Belt', 'Nigeria_West_Belt', 'Nord_Algerie_Degree', 'Nord_Algerie_Ancienne_Degree', 'Sud_Algerie_Ancienne', 'Nord_Algerie', 'Nord_de_Guerre', 'Nord_France', 'Nord_Maroc_Degree', 'Nord_Maroc', 'Nord_Tunisie', 'NGO_1948_Baerum_Kommune', 'NGO_1948_Bergenhalvoen', 'NGO_1948_Norway_Zone_1', 'NGO_1948_Norway_Zone_2', 'NGO_1948_Norway_Zone_3', 'NGO_1948_Norway_Zone_4', 'NGO_1948_Norway_Zone_5', 'NGO_1948_Norway_Zone_6', 'NGO_1948_Norway_Zone_7', 'NGO_1948_Norway_Zone_8', 'NGO_1948_Oslo_Kommune', 'NGO_1948_Oslo_Norway_Zone_1', 'NGO_1948_Oslo_Norway_Zone_2', 'NGO_1948_Oslo_Norway_Zone_3', 'NGO_1948_Oslo_Norway_Zone_4', 'NGO_1948_Oslo_Norway_Zone_5', 'NGO_1948_Oslo_Norway_Zone_6', 'NGO_1948_Oslo_Norway_Zone_7', 'NGO_1948_Oslo_Norway_Zone_8', 'NTF_France_I_degrees', 'NTF_France_II_degrees', 'NTF_France_III_degrees', 'NTF_France_IV_degrees', 'Palestine_1923_Israel_CS_Grid', 'Palestine_1923_Palestine_Belt', 'Palestine_1923_Palestine_Grid', 'Pampa_del_Castillo_Argentina_2', 'Peru_Central_Zone', 'Peru_East_Zone', 'Peru_West_Zone', 'Philippines_Zone_I', 'Philippines_Zone_II', 'Philippines_Zone_III', 'Philippines_Zone_IV', 'Philippines_Zone_V', 'Portuguese_National_Grid', 'Qatar_1948_Qatar_Grid', 'Qatar_National_Grid', 'RD_Old', 'RGF_1993_Lambert_93', 'Rijksdriehoekstelsel_New', 'RT90_25_gon_W', 'S-JTSK_Ferro_Krovak_East_North', 'S-JTSK_Ferro_Krovak', 'S-JTSK_Krovak_East_North', 'S-JTSK_Krovak', 'SAD_1969_Brazil_Polyconic', 'Sahara_Degree', 'Sahara', 'Sierra_Leone_1924_New_Colony_Grid', 'Sierra_Leone_1924_New_War_Office_Grid', 'St_Kitts_1955_British_West_Indies_Grid', 'St_Lucia_1955_British_West_Indies_Grid', 'St_Vincent_1945_British_West_Indies_Grid', 'Stereo_33', 'Stereo_70', 'Sud_Algerie_Degree', 'Sud_Algerie_Ancienne_Degree', 'Sud_Algerie', 'Sud_France', 'Sud_Maroc_Degree', 'Sud_Maroc', 'Sud_Tunisie', 'Swedish_National_Grid', 'Trinidad_1903_Trinidad_Grid', 'UWPP_1992', 'UWPP_2000_pas_5', 'UWPP_2000_pas_6', 'UWPP_2000_pas_7', 'UWPP_2000_pas_8', 'WGS_1972_BE_TM_106_NE', 'WGS_1984_TM_36_SE', 'Zanderij_Suriname_Old_TM', 'Zanderij_Suriname_TM', 'Zanderij_TM_54_NW', 'North_Pole_Azimuthal_Equidistant', 'North_Pole_Gnomonic', 'North_Pole_Lambert_Azimuthal_Equal_Area', 'North_Pole_Orthographic', 'North_Pole_Stereographic', 'South_Pole_Azimuthal_Equidistant', 'South_Pole_Gnomonic', 'South_Pole_Lambert_Azimuthal_Equal_Area', 'South_Pole_Orthographic', 'South_Pole_Stereographic', 'UPS_North', 'UPS_South', 'NAD_1927_StatePlane_Alabama_East_FIPS_0101', 'NAD_1927_StatePlane_Alabama_West_FIPS_0102', 'NAD_1927_StatePlane_Alaska_1_FIPS_5001', 'NAD_1927_StatePlane_Alaska_10_FIPS_5010', 'NAD_1927_StatePlane_Alaska_2_FIPS_5002', 'NAD_1927_StatePlane_Alaska_3_FIPS_5003', 'NAD_1927_StatePlane_Alaska_4_FIPS_5004', 'NAD_1927_StatePlane_Alaska_5_FIPS_5005', 'NAD_1927_StatePlane_Alaska_6_FIPS_5006', 'NAD_1927_StatePlane_Alaska_7_FIPS_5007', 'NAD_1927_StatePlane_Alaska_8_FIPS_5008', 'NAD_1927_StatePlane_Alaska_9_FIPS_5009', 'NAD_1927_StatePlane_Arizona_Central_FIPS_0202', 'NAD_1927_StatePlane_Arizona_East_FIPS_0201', 'NAD_1927_StatePlane_Arizona_West_FIPS_0203', 'NAD_1927_StatePlane_Arkansas_North_FIPS_0301', 'NAD_1927_StatePlane_Arkansas_South_FIPS_0302', 'NAD_1927_StatePlane_California_I_FIPS_0401', 'NAD_1927_StatePlane_California_II_FIPS_0402', 'NAD_1927_StatePlane_California_III_FIPS_0403', 'NAD_1927_StatePlane_California_IV_FIPS_0404', 'NAD_1927_StatePlane_California_V_FIPS_0405', 'NAD_1927_StatePlane_California_VI_FIPS_0406', 'NAD_1927_StatePlane_California_VII_FIPS_0407', 'NAD_1927_StatePlane_Colorado_Central_FIPS_0502', 'NAD_1927_StatePlane_Colorado_North_FIPS_0501', 'NAD_1927_StatePlane_Colorado_South_FIPS_0503', 'NAD_1927_StatePlane_Connecticut_FIPS_0600', 'NAD_1927_StatePlane_Delaware_FIPS_0700', 'NAD_1927_StatePlane_Florida_East_FIPS_0901', 'NAD_1927_StatePlane_Florida_North_FIPS_0903', 'NAD_1927_StatePlane_Florida_West_FIPS_0902', 'NAD_1927_StatePlane_Georgia_East_FIPS_1001', 'NAD_1927_StatePlane_Georgia_West_FIPS_1002', 'NAD_1927_StatePlane_Guam_FIPS_5400', 'NAD_1927_StatePlane_Idaho_Central_FIPS_1102', 'NAD_1927_StatePlane_Idaho_East_FIPS_1101', 'NAD_1927_StatePlane_Idaho_West_FIPS_1103', 'NAD_1927_StatePlane_Illinois_East_FIPS_1201', 'NAD_1927_StatePlane_Illinois_West_FIPS_1202', 'NAD_1927_StatePlane_Indiana_East_FIPS_1301', 'NAD_1927_StatePlane_Indiana_West_FIPS_1302', 'NAD_1927_StatePlane_Iowa_North_FIPS_1401', 'NAD_1927_StatePlane_Iowa_South_FIPS_1402', 'NAD_1927_StatePlane_Kansas_North_FIPS_1501', 'NAD_1927_StatePlane_Kansas_South_FIPS_1502', 'NAD_1927_StatePlane_Kentucky_North_FIPS_1601', 'NAD_1927_StatePlane_Kentucky_South_FIPS_1602', 'NAD_1927_StatePlane_Louisiana_North_FIPS_1701', 'NAD_1927_StatePlane_Louisiana_South_FIPS_1702', 'NAD_1927_StatePlane_Maine_East_FIPS_1801', 'NAD_1927_StatePlane_Maine_West_FIPS_1802', 'NAD_1927_StatePlane_Maryland_FIPS_1900', 'NAD_1927_StatePlane_Massachusetts_Island_FIPS_2002', 'NAD_1927_StatePlane_Massachusetts_Mainland_FIPS_2001', 'NAD_1927_StatePlane_Michigan_Central_FIPS_2112', 'NAD_1927_StatePlane_Michigan_North_FIPS_2111', 'NAD_1927_StatePlane_Michigan_South_FIPS_2113', 'NAD_1927_StatePlane_Minnesota_Central_FIPS_2202', 'NAD_1927_StatePlane_Minnesota_North_FIPS_2201', 'NAD_1927_StatePlane_Minnesota_South_FIPS_2203', 'NAD_1927_StatePlane_Mississippi_East_FIPS_2301', 'NAD_1927_StatePlane_Mississippi_West_FIPS_2302', 'NAD_1927_StatePlane_Missouri_Central_FIPS_2402', 'NAD_1927_StatePlane_Missouri_East_FIPS_2401', 'NAD_1927_StatePlane_Missouri_West_FIPS_2403', 'NAD_1927_StatePlane_Montana_Central_FIPS_2502', 'NAD_1927_StatePlane_Montana_North_FIPS_2501', 'NAD_1927_StatePlane_Montana_South_FIPS_2503', 'NAD_1927_StatePlane_Nebraska_North_FIPS_2601', 'NAD_1927_StatePlane_Nebraska_South_FIPS_2602', 'NAD_1927_StatePlane_Nevada_Central_FIPS_2702', 'NAD_1927_StatePlane_Nevada_East_FIPS_2701', 'NAD_1927_StatePlane_Nevada_West_FIPS_2703', 'NAD_1927_StatePlane_New_Hampshire_FIPS_2800', 'NAD_1927_StatePlane_New_Jersey_FIPS_2900', 'NAD_1927_StatePlane_New_Mexico_Central_FIPS_3002', 'NAD_1927_StatePlane_New_Mexico_East_FIPS_3001', 'NAD_1927_StatePlane_New_Mexico_West_FIPS_3003', 'NAD_1927_StatePlane_New_York_Central_FIPS_3102', 'NAD_1927_StatePlane_New_York_East_FIPS_3101', 'NAD_1927_StatePlane_New_York_Long_Island_FIPS_3104', 'NAD_1927_StatePlane_New_York_West_FIPS_3103', 'NAD_1927_StatePlane_North_Carolina_FIPS_3200', 'NAD_1927_StatePlane_North_Dakota_North_FIPS_3301', 'NAD_1927_StatePlane_North_Dakota_South_FIPS_3302', 'NAD_1927_StatePlane_Ohio_North_FIPS_3401', 'NAD_1927_StatePlane_Ohio_South_FIPS_3402', 'NAD_1927_StatePlane_Oklahoma_North_FIPS_3501', 'NAD_1927_StatePlane_Oklahoma_South_FIPS_3502', 'NAD_1927_StatePlane_Oregon_North_FIPS_3601', 'NAD_1927_StatePlane_Oregon_South_FIPS_3602', 'NAD_1927_StatePlane_Pennsylvania_North_FIPS_3701', 'NAD_1927_StatePlane_Pennsylvania_South_FIPS_3702', 'NAD_1927_StatePlane_Puerto_Rico_FIPS_5201', 'NAD_1927_StatePlane_Rhode_Island_FIPS_3800', 'NAD_1927_StatePlane_South_Carolina_North_FIPS_3901', 'NAD_1927_StatePlane_South_Carolina_South_FIPS_3902', 'NAD_1927_StatePlane_South_Dakota_North_FIPS_4001', 'NAD_1927_StatePlane_South_Dakota_South_FIPS_4002', 'NAD_1927_StatePlane_Tennessee_FIPS_4100', 'NAD_1927_StatePlane_Texas_Central_FIPS_4203', 'NAD_1927_StatePlane_Texas_North_Central_FIPS_4202', 'NAD_1927_StatePlane_Texas_North_FIPS_4201', 'NAD_1927_StatePlane_Texas_South_Central_FIPS_4204', 'NAD_1927_StatePlane_Texas_South_FIPS_4205', 'NAD_1927_StatePlane_Utah_Central_FIPS_4302', 'NAD_1927_StatePlane_Utah_North_FIPS_4301', 'NAD_1927_StatePlane_Utah_South_FIPS_4303', 'NAD_1927_StatePlane_Vermont_FIPS_3400', 'NAD_1927_StatePlane_Virginia_North_FIPS_4501', 'NAD_1927_StatePlane_Virginia_South_FIPS_4502', 'NAD_1927_StatePlane_Washington_North_FIPS_4601', 'NAD_1927_StatePlane_Washington_South_FIPS_4602', 'NAD_1927_StatePlane_West_Virginia_North_FIPS_4701', 'NAD_1927_StatePlane_West_Virginia_South_FIPS_4702', 'NAD_1927_StatePlane_Wisconsin_Central_FIPS_4802', 'NAD_1927_StatePlane_Wisconsin_North_FIPS_4801', 'NAD_1927_StatePlane_Wisconsin_South_FIPS_4803', 'NAD_1927_StatePlane_Wyoming_East_Central_FIPS_4902', 'NAD_1927_StatePlane_Wyoming_East_FIPS_4901', 'NAD_1927_StatePlane_Wyoming_West_Central_FIPS_4903', 'NAD_1927_StatePlane_Wyoming_West_FIPS_4904', 'NAD_1983_StatePlane_Alabama_East_FIPS_0101', 'NAD_1983_StatePlane_Alabama_West_FIPS_0102', 'NAD_1983_StatePlane_Alaska_1_FIPS_5001', 'NAD_1983_StatePlane_Alaska_10_FIPS_5010', 'NAD_1983_StatePlane_Alaska_2_FIPS_5002', 'NAD_1983_StatePlane_Alaska_3_FIPS_5003', 'NAD_1983_StatePlane_Alaska_4_FIPS_5004', 'NAD_1983_StatePlane_Alaska_5_FIPS_5005', 'NAD_1983_StatePlane_Alaska_6_FIPS_5006', 'NAD_1983_StatePlane_Alaska_7_FIPS_5007', 'NAD_1983_StatePlane_Alaska_8_FIPS_5008', 'NAD_1983_StatePlane_Alaska_9_FIPS_5009', 'NAD_1983_StatePlane_Arizona_Central_FIPS_0202', 'NAD_1983_StatePlane_Arizona_East_FIPS_0201', 'NAD_1983_StatePlane_Arizona_West_FIPS_0203', 'NAD_1983_StatePlane_Arkansas_North_FIPS_0301', 'NAD_1983_StatePlane_Arkansas_South_FIPS_0302', 'NAD_1983_StatePlane_California_I_FIPS_0401', 'NAD_1983_StatePlane_California_II_FIPS_0402', 'NAD_1983_StatePlane_California_III_FIPS_0403', 'NAD_1983_StatePlane_California_IV_FIPS_0404', 'NAD_1983_StatePlane_California_V_FIPS_0405', 'NAD_1983_StatePlane_California_VI_FIPS_0406', 'NAD_1983_StatePlane_Colorado_Central_FIPS_0502', 'NAD_1983_StatePlane_Colorado_North_FIPS_0501', 'NAD_1983_StatePlane_Colorado_South_FIPS_0503', 'NAD_1983_StatePlane_Connecticut_FIPS_0600', 'NAD_1983_StatePlane_Delaware_FIPS_0700', 'NAD_1983_StatePlane_Florida_East_FIPS_0901', 'NAD_1983_StatePlane_Florida_North_FIPS_0903', 'NAD_1983_StatePlane_Florida_West_FIPS_0902', 'NAD_1983_StatePlane_Georgia_East_FIPS_1001', 'NAD_1983_StatePlane_Georgia_West_FIPS_1002', 'NAD_1983_StatePlane_Guam_FIPS_5400', 'NAD_1983_StatePlane_Hawaii_1_FIPS_5101', 'NAD_1983_StatePlane_Hawaii_2_FIPS_5102', 'NAD_1983_StatePlane_Hawaii_3_FIPS_5103', 'NAD_1983_StatePlane_Hawaii_4_FIPS_5104', 'NAD_1983_StatePlane_Hawaii_5_FIPS_5105', 'NAD_1983_StatePlane_Idaho_Central_FIPS_1102', 'NAD_1983_StatePlane_Idaho_East_FIPS_1101', 'NAD_1983_StatePlane_Idaho_West_FIPS_1103', 'NAD_1983_StatePlane_Illinois_East_FIPS_1201', 'NAD_1983_StatePlane_Illinois_West_FIPS_1202', 'NAD_1983_StatePlane_Indiana_East_FIPS_1301', 'NAD_1983_StatePlane_Indiana_West_FIPS_1302', 'NAD_1983_StatePlane_Iowa_North_FIPS_1401', 'NAD_1983_StatePlane_Iowa_South_FIPS_1402', 'NAD_1983_StatePlane_Kansas_North_FIPS_1501', 'NAD_1983_StatePlane_Kansas_South_FIPS_1502', 'NAD_1983_StatePlane_Kentucky_FIPS_1600', 'NAD_1983_StatePlane_Kentucky_North_FIPS_1601', 'NAD_1983_StatePlane_Kentucky_South_FIPS_1602', 'NAD_1983_StatePlane_Louisiana_North_FIPS_1701', 'NAD_1983_StatePlane_Louisiana_South_FIPS_1702', 'NAD_1983_StatePlane_Maine_East_FIPS_1801', 'NAD_1983_StatePlane_Maine_West_FIPS_1802', 'NAD_1983_StatePlane_Maryland_FIPS_1900', 'NAD_1983_StatePlane_Massachusetts_Island_FIPS_2002', 'NAD_1983_StatePlane_Massachusetts_Mainland_FIPS_2001', 'NAD_1983_StatePlane_Michigan_Central_FIPS_2202', 'NAD_1983_StatePlane_Michigan_North_FIPS_2111', 'NAD_1983_StatePlane_Michigan_South_FIPS_2113', 'NAD_1983_StatePlane_Minnesota_Central_FIPS_2202', 'NAD_1983_StatePlane_Minnesota_North_FIPS_2201', 'NAD_1983_StatePlane_Minnesota_South_FIPS_2203', 'NAD_1983_StatePlane_Mississippi_East_FIPS_2301', 'NAD_1983_StatePlane_Mississippi_West_FIPS_2302', 'NAD_1983_StatePlane_Missouri_Central_FIPS_2402', 'NAD_1983_StatePlane_Missouri_East_FIPS_2401', 'NAD_1983_StatePlane_Missouri_West_FIPS_2403', 'NAD_1983_StatePlane_Montana_FIPS_2500', 'NAD_1983_StatePlane_Nebraska_FIPS_2600', 'NAD_1983_StatePlane_Nevada_Central_FIPS_2702', 'NAD_1983_StatePlane_Nevada_East_FIPS_2701', 'NAD_1983_StatePlane_Nevada_West_FIPS_2703', 'NAD_1983_StatePlane_New_Hampshire_FIPS_2800', 'NAD_1983_StatePlane_New_Jersey_FIPS_2900', 'NAD_1983_StatePlane_New_Mexico_Central_FIPS_3002', 'NAD_1983_StatePlane_New_Mexico_East_FIPS_3001', 'NAD_1983_StatePlane_New_Mexico_West_FIPS_3003', 'NAD_1983_StatePlane_New_York_Central_FIPS_3102', 'NAD_1983_StatePlane_New_York_East_FIPS_3101', 'NAD_1983_StatePlane_New_York_Long_Island_FIPS_3104', 'NAD_1983_StatePlane_New_York_West_FIPS_3103', 'NAD_1983_StatePlane_North_Carolina_FIPS_3200', 'NAD_1983_StatePlane_North_Dakota_North_FIPS_3301', 'NAD_1983_StatePlane_North_Dakota_South_FIPS_3302', 'NAD_1983_StatePlane_Ohio_North_FIPS_3401', 'NAD_1983_StatePlane_Ohio_South_FIPS_3402', 'NAD_1983_StatePlane_Oklahoma_North_FIPS_3501', 'NAD_1983_StatePlane_Oklahoma_South_FIPS_3502', 'NAD_1983_StatePlane_Oregon_North_FIPS_3601', 'NAD_1983_StatePlane_Oregon_South_FIPS_3602', 'NAD_1983_StatePlane_Pennsylvania_North_FIPS_3701', 'NAD_1983_StatePlane_Pennsylvania_South_FIPS_3702', 'NAD_1983_StatePlane_Puerto_Rico_Virgin_Islands_FIPS_5200', 'NAD_1983_StatePlane_Rhode_Island_FIPS_3800', 'NAD_1983_StatePlane_South_Carolina_FIPS_3900', 'NAD_1983_StatePlane_South_Dakota_North_FIPS_4001', 'NAD_1983_StatePlane_South_Dakota_South_FIPS_4002', 'NAD_1983_StatePlane_Tennessee_FIPS_4100', 'NAD_1983_StatePlane_Texas_Central_FIPS_4203', 'NAD_1983_StatePlane_Texas_North_Central_FIPS_4202', 'NAD_1983_StatePlane_Texas_North_FIPS_4201', 'NAD_1983_StatePlane_Texas_South_Central_FIPS_4204', 'NAD_1983_StatePlane_Texas_South_FIPS_4205', 'NAD_1983_StatePlane_Utah_Central_FIPS_4302', 'NAD_1983_StatePlane_Utah_North_FIPS_4301', 'NAD_1983_StatePlane_Utah_South_FIPS_4303', 'NAD_1983_StatePlane_Vermont_FIPS_4400', 'NAD_1983_StatePlane_Virginia_North_FIPS_4501', 'NAD_1983_StatePlane_Virginia_South_FIPS_4502', 'NAD_1983_StatePlane_Washington_North_FIPS_4601', 'NAD_1983_StatePlane_Washington_South_FIPS_4602', 'NAD_1983_StatePlane_West_Virginia_North_FIPS_4701', 'NAD_1983_StatePlane_West_Virginia_South_FIPS_4702', 'NAD_1983_StatePlane_Wisconsin_Central_FIPS_4802', 'NAD_1983_StatePlane_Wisconsin_North_FIPS_4801', 'NAD_1983_StatePlane_Wisconsin_South_FIPS_4803', 'NAD_1983_StatePlane_Wyoming_East_Central_FIPS_4902', 'NAD_1983_StatePlane_Wyoming_East_FIPS_4901', 'NAD_1983_StatePlane_Wyoming_West_Central_FIPS_4903', 'NAD_1983_StatePlane_Wyoming_West_FIPS_4904', 'NAD_1983_StatePlane_Alabama_East_FIPS_0101_Feet', 'NAD_1983_StatePlane_Alabama_West_FIPS_0102_Feet', 'NAD_1983_StatePlane_Alaska_1_FIPS_5001_Feet', 'NAD_1983_StatePlane_Alaska_10_FIPS_5010_Feet', 'NAD_1983_StatePlane_Alaska_2_FIPS_5002_Feet', 'NAD_1983_StatePlane_Alaska_3_FIPS_5003_Feet', 'NAD_1983_StatePlane_Alaska_4_FIPS_5004_Feet', 'NAD_1983_StatePlane_Alaska_5_FIPS_5005_Feet', 'NAD_1983_StatePlane_Alaska_6_FIPS_5006_Feet', 'NAD_1983_StatePlane_Alaska_7_FIPS_5007_Feet', 'NAD_1983_StatePlane_Alaska_8_FIPS_5008_Feet', 'NAD_1983_StatePlane_Alaska_9_FIPS_5009_Feet', 'NAD_1983_StatePlane_Arizona_Central_FIPS_0202_Feet', 'NAD_1983_StatePlane_Arizona_East_FIPS_0201_Feet', 'NAD_1983_StatePlane_Arizona_West_FIPS_0203_Feet', 'NAD_1983_StatePlane_Arkansas_North_FIPS_0301_Feet', 'NAD_1983_StatePlane_Arkansas_South_FIPS_0302_Feet', 'NAD_1983_StatePlane_California_I_FIPS_0401_Feet', 'NAD_1983_StatePlane_California_II_FIPS_0402_Feet', 'NAD_1983_StatePlane_California_III_FIPS_0403_Feet', 'NAD_1983_StatePlane_California_IV_FIPS_0404_Feet', 'NAD_1983_StatePlane_California_V_FIPS_0405_Feet', 'NAD_1983_StatePlane_California_VI_FIPS_0406_Feet', 'NAD_1983_StatePlane_Colorado_Central_FIPS_0502_Feet', 'NAD_1983_StatePlane_Colorado_North_FIPS_0501_Feet', 'NAD_1983_StatePlane_Colorado_South_FIPS_0503_Feet', 'NAD_1983_StatePlane_Connecticut_FIPS_0600_Feet', 'NAD_1983_StatePlane_Delaware_FIPS_0700_Feet', 'NAD_1983_StatePlane_Florida_East_FIPS_0901_Feet', 'NAD_1983_StatePlane_Florida_North_FIPS_0903_Feet', 'NAD_1983_StatePlane_Florida_West_FIPS_0902_Feet', 'NAD_1983_StatePlane_Georgia_East_FIPS_1001_Feet', 'NAD_1983_StatePlane_Georgia_West_FIPS_1002_Feet', 'NAD_1983_StatePlane_Guam_FIPS_5400_Feet', 'NAD_1983_StatePlane_Hawaii_1_FIPS_5101_Feet', 'NAD_1983_StatePlane_Hawaii_2_FIPS_5102_Feet', 'NAD_1983_StatePlane_Hawaii_3_FIPS_5103_Feet', 'NAD_1983_StatePlane_Hawaii_4_FIPS_5104_Feet', 'NAD_1983_StatePlane_Hawaii_5_FIPS_5105_Feet', 'NAD_1983_StatePlane_Idaho_Central_FIPS_1102_Feet', 'NAD_1983_StatePlane_Idaho_East_FIPS_1101_Feet', 'NAD_1983_StatePlane_Idaho_West_FIPS_1103_Feet', 'NAD_1983_StatePlane_Illinois_East_FIPS_1201_Feet', 'NAD_1983_StatePlane_Illinois_West_FIPS_1202_Feet', 'NAD_1983_StatePlane_Indiana_East_FIPS_1301_Feet', 'NAD_1983_StatePlane_Indiana_West_FIPS_1302_Feet', 'NAD_1983_StatePlane_Iowa_North_FIPS_1401_Feet', 'NAD_1983_StatePlane_Iowa_South_FIPS_1402_Feet', 'NAD_1983_StatePlane_Kansas_North_FIPS_1501_Feet', 'NAD_1983_StatePlane_Kansas_South_FIPS_1502_Feet', 'NAD_1983_StatePlane_Kentucky_FIPS_1600_Feet', 'NAD_1983_StatePlane_Kentucky_North_FIPS_1601_Feet', 'NAD_1983_StatePlane_Kentucky_South_FIPS_1602_Feet', 'NAD_1983_StatePlane_Louisiana_North_FIPS_1701_Feet', 'NAD_1983_StatePlane_Louisiana_South_FIPS_1702_Feet', 'NAD_1983_StatePlane_Maine_East_FIPS_1801_Feet', 'NAD_1983_StatePlane_Maine_West_FIPS_1802_Feet', 'NAD_1983_StatePlane_Maryland_FIPS_1900_Feet', 'NAD_1983_StatePlane_Massachusetts_Island_FIPS_2002_Feet', 'NAD_1983_StatePlane_Massachusetts_Mainland_FIPS_2001_Feet', 'NAD_1983_StatePlane_Michigan_Central_FIPS_2202_Feet', 'NAD_1983_StatePlane_Michigan_North_FIPS_2111_Feet', 'NAD_1983_StatePlane_Michigan_South_FIPS_2113_Feet', 'NAD_1983_StatePlane_Minnesota_Central_FIPS_2202_Feet', 'NAD_1983_StatePlane_Minnesota_North_FIPS_2201_Feet', 'NAD_1983_StatePlane_Minnesota_South_FIPS_2203_Feet', 'NAD_1983_StatePlane_Mississippi_East_FIPS_2301_Feet', 'NAD_1983_StatePlane_Mississippi_West_FIPS_2302_Feet', 'NAD_1983_StatePlane_Missouri_Central_FIPS_2402_Feet', 'NAD_1983_StatePlane_Missouri_East_FIPS_2401_Feet', 'NAD_1983_StatePlane_Missouri_West_FIPS_2403_Feet', 'NAD_1983_StatePlane_Montana_FIPS_2500_Feet', 'NAD_1983_StatePlane_Nebraska_FIPS_2600_Feet', 'NAD_1983_StatePlane_Nevada_Central_FIPS_2702_Feet', 'NAD_1983_StatePlane_Nevada_East_FIPS_2701_Feet', 'NAD_1983_StatePlane_Nevada_West_FIPS_2703_Feet', 'NAD_1983_StatePlane_New_Hampshire_FIPS_2800_Feet', 'NAD_1983_StatePlane_New_Jersey_FIPS_2900_Feet', 'NAD_1983_StatePlane_New_Mexico_Central_FIPS_3002_Feet', 'NAD_1983_StatePlane_New_Mexico_East_FIPS_3001_Feet', 'NAD_1983_StatePlane_New_Mexico_West_FIPS_3003_Feet', 'NAD_1983_StatePlane_New_York_Central_FIPS_3102_Feet', 'NAD_1983_StatePlane_New_York_East_FIPS_3101_Feet', 'NAD_1983_StatePlane_New_York_Long_Island_FIPS_3104_Feet', 'NAD_1983_StatePlane_New_York_West_FIPS_3103_Feet', 'NAD_1983_StatePlane_North_Carolina_FIPS_3200_Feet', 'NAD_1983_StatePlane_North_Dakota_North_FIPS_3301_Feet', 'NAD_1983_StatePlane_North_Dakota_South_FIPS_3302_Feet', 'NAD_1983_StatePlane_Ohio_North_FIPS_3401_Feet', 'NAD_1983_StatePlane_Ohio_South_FIPS_3402_Feet', 'NAD_1983_StatePlane_Oklahoma_North_FIPS_3501_Feet', 'NAD_1983_StatePlane_Oklahoma_South_FIPS_3502_Feet', 'NAD_1983_StatePlane_Oregon_North_FIPS_3601_Feet', 'NAD_1983_StatePlane_Oregon_South_FIPS_3602_Feet', 'NAD_1983_StatePlane_Pennsylvania_North_FIPS_3701_Feet', 'NAD_1983_StatePlane_Pennsylvania_South_FIPS_3702_Feet', 'NAD_1983_StatePlane_Puerto_Rico_Virgin_Islands_FIPS_5200_Feet', 'NAD_1983_StatePlane_Rhode_Island_FIPS_3800_Feet', 'NAD_1983_StatePlane_South_Carolina_FIPS_3900_Feet', 'NAD_1983_StatePlane_South_Dakota_North_FIPS_4001_Feet', 'NAD_1983_StatePlane_South_Dakota_South_FIPS_4002_Feet', 'NAD_1983_StatePlane_Tennessee_FIPS_4100_Feet', 'NAD_1983_StatePlane_Texas_Central_FIPS_4203_Feet', 'NAD_1983_StatePlane_Texas_North_Central_FIPS_4202_Feet', 'NAD_1983_StatePlane_Texas_North_FIPS_4201_Feet', 'NAD_1983_StatePlane_Texas_South_Central_FIPS_4204_Feet', 'NAD_1983_StatePlane_Texas_South_FIPS_4205_Feet', 'NAD_1983_StatePlane_Utah_Central_FIPS_4302_Feet', 'NAD_1983_StatePlane_Utah_North_FIPS_4301_Feet', 'NAD_1983_StatePlane_Utah_South_FIPS_4303_Feet', 'NAD_1983_StatePlane_Vermont_FIPS_4400_Feet', 'NAD_1983_StatePlane_Virginia_North_FIPS_4501_Feet', 'NAD_1983_StatePlane_Virginia_South_FIPS_4502_Feet', 'NAD_1983_StatePlane_Washington_North_FIPS_4601_Feet', 'NAD_1983_StatePlane_Washington_South_FIPS_4602_Feet', 'NAD_1983_StatePlane_West_Virginia_North_FIPS_4701_Feet', 'NAD_1983_StatePlane_West_Virginia_South_FIPS_4702_Feet', 'NAD_1983_StatePlane_Wisconsin_Central_FIPS_4802_Feet', 'NAD_1983_StatePlane_Wisconsin_North_FIPS_4801_Feet', 'NAD_1983_StatePlane_Wisconsin_South_FIPS_4803_Feet', 'NAD_1983_StatePlane_Wyoming_East_Central_FIPS_4902_Feet', 'NAD_1983_StatePlane_Wyoming_East_FIPS_4901_Feet', 'NAD_1983_StatePlane_Wyoming_West_Central_FIPS_4903_Feet', 'NAD_1983_StatePlane_Wyoming_West_FIPS_4904_Feet', 'NAD_1983_HARN_StatePlane_Alabama_East_FIPS_0101', 'NAD_1983_HARN_StatePlane_Alabama_West_FIPS_0102', 'NAD_1983_HARN_StatePlane_Arizona_Central_FIPS_0202', 'NAD_1983_HARN_StatePlane_Arizona_East_FIPS_0201', 'NAD_1983_HARN_StatePlane_Arizona_West_FIPS_0203', 'NAD_1983_HARN_StatePlane_California_I_FIPS_0401', 'NAD_1983_HARN_StatePlane_California_II_FIPS_0402', 'NAD_1983_HARN_StatePlane_California_III_FIPS_0403', 'NAD_1983_HARN_StatePlane_California_IV_FIPS_0404', 'NAD_1983_HARN_StatePlane_California_V_FIPS_0405', 'NAD_1983_HARN_StatePlane_California_VI_FIPS_0406', 'NAD_1983_HARN_StatePlane_Colorado_Central_FIPS_0502', 'NAD_1983_HARN_StatePlane_Colorado_North_FIPS_0501', 'NAD_1983_HARN_StatePlane_Colorado_South_FIPS_0503', 'NAD_1983_HARN_StatePlane_Connecticut_FIPS_0600', 'NAD_1983_HARN_StatePlane_Delaware_FIPS_0700', 'NAD_1983_HARN_StatePlane_Florida_East_FIPS_0901', 'NAD_1983_HARN_StatePlane_Florida_North_FIPS_0903', 'NAD_1983_HARN_StatePlane_Florida_West_FIPS_0902', 'NAD_1983_HARN_StatePlane_Georgia_East_FIPS_1001', 'NAD_1983_HARN_StatePlane_Georgia_West_FIPS_1002', 'NAD_1983_HARN_StatePlane_Hawaii_1_FIPS_5101', 'NAD_1983_HARN_StatePlane_Hawaii_2_FIPS_5102', 'NAD_1983_HARN_StatePlane_Hawaii_3_FIPS_5103', 'NAD_1983_HARN_StatePlane_Hawaii_4_FIPS_5104', 'NAD_1983_HARN_StatePlane_Hawaii_5_FIPS_5105', 'NAD_1983_HARN_StatePlane_Idaho_Central_FIPS_1102', 'NAD_1983_HARN_StatePlane_Idaho_East_FIPS_1101', 'NAD_1983_HARN_StatePlane_Idaho_West_FIPS_1103', 'NAD_1983_HARN_StatePlane_Illinois_East_FIPS_1201', 'NAD_1983_HARN_StatePlane_Illinois_West_FIPS_1202', 'NAD_1983_HARN_StatePlane_Indiana_East_FIPS_1301', 'NAD_1983_HARN_StatePlane_Indiana_West_FIPS_1302', 'NAD_1983_HARN_StatePlane_Kansas_North_FIPS_1501', 'NAD_1983_HARN_StatePlane_Kansas_South_FIPS_1502', 'NAD_1983_HARN_StatePlane_Kentucky_North_FIPS_1601', 'NAD_1983_HARN_StatePlane_Kentucky_South_FIPS_1602', 'NAD_1983_HARN_StatePlane_Louisiana_North_FIPS_1701', 'NAD_1983_HARN_StatePlane_Louisiana_South_FIPS_1702', 'NAD_1983_HARN_StatePlane_Maine_East_FIPS_1801', 'NAD_1983_HARN_StatePlane_Maine_West_FIPS_1802', 'NAD_1983_HARN_StatePlane_Maryland_FIPS_1900', 'NAD_1983_HARN_StatePlane_Massachusetts_Island_FIPS_2002', 'NAD_1983_HARN_StatePlane_Massachusetts_Mainland_FIPS_2001', 'NAD_1983_HARN_StatePlane_Michigan_Central_FIPS_2202', 'NAD_1983_HARN_StatePlane_Michigan_North_FIPS_2111', 'NAD_1983_HARN_StatePlane_Michigan_South_FIPS_2113', 'NAD_1983_HARN_StatePlane_Mississippi_East_FIPS_2301', 'NAD_1983_HARN_StatePlane_Mississippi_West_FIPS_2302', 'NAD_1983_HARN_StatePlane_Montana_FIPS_2500', 'NAD_1983_HARN_StatePlane_Nebraska_FIPS_2600', 'NAD_1983_HARN_StatePlane_Nevada_Central_FIPS_2702', 'NAD_1983_HARN_StatePlane_Nevada_East_FIPS_2701', 'NAD_1983_HARN_StatePlane_Nevada_West_FIPS_2703', 'NAD_1983_HARN_StatePlane_New_Hampshire_FIPS_2800', 'NAD_1983_HARN_StatePlane_New_Jersey_FIPS_2900', 'NAD_1983_HARN_StatePlane_New_Mexico_Central_FIPS_3002', 'NAD_1983_HARN_StatePlane_New_Mexico_East_FIPS_3001', 'NAD_1983_HARN_StatePlane_New_Mexico_West_FIPS_3003', 'NAD_1983_HARN_StatePlane_New_York_Central_FIPS_3102', 'NAD_1983_HARN_StatePlane_New_York_East_FIPS_3101', 'NAD_1983_HARN_StatePlane_New_York_Long_Island_FIPS_3104', 'NAD_1983_HARN_StatePlane_New_York_West_FIPS_3103', 'NAD_1983_HARN_StatePlane_North_Dakota_North_FIPS_3301', 'NAD_1983_HARN_StatePlane_North_Dakota_South_FIPS_3302', 'NAD_1983_HARN_StatePlane_Ohio_North_FIPS_3401', 'NAD_1983_HARN_StatePlane_Ohio_South_FIPS_3402', 'NAD_1983_HARN_StatePlane_Oklahoma_North_FIPS_3501', 'NAD_1983_HARN_StatePlane_Oklahoma_South_FIPS_3502', 'NAD_1983_HARN_StatePlane_Oregon_North_FIPS_3601', 'NAD_1983_HARN_StatePlane_Oregon_South_FIPS_3602', 'NAD_1983_HARN_StatePlane_Puerto_Rico_Virgin_Islands_FIPS_5200', 'NAD_1983_HARN_StatePlane_Rhode_Island_FIPS_3800', 'NAD_1983_HARN_StatePlane_South_Dakota_North_FIPS_4001', 'NAD_1983_HARN_StatePlane_South_Dakota_South_FIPS_4002', 'NAD_1983_HARN_StatePlane_Tennessee_FIPS_4100', 'NAD_1983_HARN_StatePlane_Texas_Central_FIPS_4203', 'NAD_1983_HARN_StatePlane_Texas_North_Central_FIPS_4202', 'NAD_1983_HARN_StatePlane_Texas_North_FIPS_4201', 'NAD_1983_HARN_StatePlane_Texas_South_Central_FIPS_4204', 'NAD_1983_HARN_StatePlane_Texas_South_FIPS_4205', 'NAD_1983_HARN_StatePlane_Utah_Central_FIPS_4302', 'NAD_1983_HARN_StatePlane_Utah_North_FIPS_4301', 'NAD_1983_HARN_StatePlane_Utah_South_FIPS_4303', 'NAD_1983_HARN_StatePlane_Vermont_FIPS_4400', 'NAD_1983_HARN_StatePlane_Virginia_North_FIPS_4501', 'NAD_1983_HARN_StatePlane_Virginia_South_FIPS_4502', 'NAD_1983_HARN_StatePlane_Washington_North_FIPS_4601', 'NAD_1983_HARN_StatePlane_Washington_South_FIPS_4602', 'NAD_1983_HARN_StatePlane_West_Virginia_North_FIPS_4701', 'NAD_1983_HARN_StatePlane_West_Virginia_South_FIPS_4702', 'NAD_1983_HARN_StatePlane_Wisconsin_Central_FIPS_4802', 'NAD_1983_HARN_StatePlane_Wisconsin_North_FIPS_4801', 'NAD_1983_HARN_StatePlane_Wisconsin_South_FIPS_4803', 'NAD_1983_HARN_StatePlane_Wyoming_East_FIPS_4901', 'NAD_1983_HARN_StatePlane_Wyoming_East_Central_FIPS_4902', 'NAD_1983_HARN_StatePlane_Wyoming_West_Central_FIPS_4903', 'NAD_1983_HARN_StatePlane_Wyoming_West_FIPS_4904', 'American_Samoa_1962_StatePlane_American_Samoa_FIPS_5300', 'NAD_1983_HARN_Guam_Map_Grid', 'NAD_1983_HARN_UTM_Zone_2S', 'NAD_Michigan_StatePlane_Michigan_Central_FIPS_2112', 'NAD_Michigan_StatePlane_Michigan_Central_Old_FIPS_2102', 'NAD_Michigan_StatePlane_Michigan_East_Old_FIPS_2101', 'NAD_Michigan_StatePlane_Michigan_North_FIPS_2111', 'NAD_Michigan_StatePlane_Michigan_South_FIPS_2113', 'NAD_Michigan_StatePlane_Michigan_West_Old_FIPS_2103', 'Old_Hawaiian_StatePlane_Hawaii_1_FIPS_5101', 'Old_Hawaiian_StatePlane_Hawaii_2_FIPS_5102', 'Old_Hawaiian_StatePlane_Hawaii_3_FIPS_5103', 'Old_Hawaiian_StatePlane_Hawaii_4_FIPS_5104', 'Old_Hawaiian_StatePlane_Hawaii_5_FIPS_5105', 'Puerto_Rico_StatePlane_Puerto_Rico_FIPS_5201', 'Puerto_Rico_StatePlane_Virgin_Islands_St_Croix_FIPS_5202', 'NAD_1927_UTM_Zone_10N', 'NAD_1927_UTM_Zone_11N', 'NAD_1927_UTM_Zone_12N', 'NAD_1927_UTM_Zone_13N', 'NAD_1927_UTM_Zone_14N', 'NAD_1927_UTM_Zone_15N', 'NAD_1927_UTM_Zone_16N', 'NAD_1927_UTM_Zone_17N', 'NAD_1927_UTM_Zone_18N', 'NAD_1927_UTM_Zone_19N', 'NAD_1927_UTM_Zone_20N', 'NAD_1927_UTM_Zone_21N', 'NAD_1927_UTM_Zone_22N', 'NAD_1927_UTM_Zone_3N', 'NAD_1927_UTM_Zone_4N', 'NAD_1927_UTM_Zone_5N', 'NAD_1927_UTM_Zone_6N', 'NAD_1927_UTM_Zone_7N', 'NAD_1927_UTM_Zone_8N', 'NAD_1927_UTM_Zone_9N', 'NAD_1983_UTM_Zone_10N', 'NAD_1983_UTM_Zone_11N', 'NAD_1983_UTM_Zone_12N', 'NAD_1983_UTM_Zone_13N', 'NAD_1983_UTM_Zone_14N', 'NAD_1983_UTM_Zone_15N', 'NAD_1983_UTM_Zone_16N', 'NAD_1983_UTM_Zone_17N', 'NAD_1983_UTM_Zone_18N', 'NAD_1983_UTM_Zone_19N', 'NAD_1983_UTM_Zone_20N', 'NAD_1983_UTM_Zone_21N', 'NAD_1983_UTM_Zone_22N', 'NAD_1983_UTM_Zone_23N', 'NAD_1983_UTM_Zone_3N', 'NAD_1983_UTM_Zone_4N', 'NAD_1983_UTM_Zone_5N', 'NAD_1983_UTM_Zone_6N', 'NAD_1983_UTM_Zone_7N', 'NAD_1983_UTM_Zone_8N', 'NAD_1983_UTM_Zone_9N', 'Abidjan_1987_UTM_Zone_29N', 'Abidjan_1987_UTM_Zone_30N', 'Adindan_UTM_Zone_37N', 'Adindan_UTM_Zone_38N', 'Afgooye_UTM_Zone_38N', 'Afgooye_UTM_Zone_39N', 'Ain_el_Abd_UTM_Zone_37N', 'Ain_el_Abd_UTM_Zone_38N', 'Ain_el_Abd_UTM_Zone_39N', 'Aratu_UTM_Zone_22S', 'Aratu_UTM_Zone_23S', 'Aratu_UTM_Zone_24S', 'Arc_1950_UTM_Zone_34S', 'Arc_1950_UTM_Zone_35S', 'Arc_1950_UTM_Zone_36S', 'Arc_1960_UTM_Zone_35N', 'Arc_1960_UTM_Zone_35S', 'Arc_1960_UTM_Zone_36N', 'Arc_1960_UTM_Zone_36S', 'Arc_1960_UTM_Zone_37N', 'Arc_1960_UTM_Zone_37S', 'ATS_1977_UTM_Zone_19N', 'ATS_1977_UTM_Zone_20N', 'Batavia_UTM_Zone_48S', 'Batavia_UTM_Zone_49S', 'Batavia_UTM_Zone_50S', 'Bissau_UTM_Zone_28N', 'Bogota_UTM_Zone_17N', 'Bogota_UTM_Zone_18N', 'Camacupa_UTM_Zone_32S', 'Camacupa_UTM_Zone_33S', 'Cape_UTM_Zone_34S', 'Cape_UTM_Zone_35S', 'Cape_UTM_Zone_36S', 'Carthage_UTM_Zone_32N', 'Conakry_1905_UTM_Zone_28N', 'Conakry_1905_UTM_Zone_29N', 'Corrego_Alegre_UTM_Zone_23S', 'Corrego_Alegre_UTM_Zone_24S', 'Dabola_UTM_Zone_28N', 'Dabola_UTM_Zone_29N', 'Datum_73_UTM_Zone_29N', 'Douala_UTM_Zone_32N', 'ED_1950_ED77_UTM_Zone_38N', 'ED_1950_ED77_UTM_Zone_39N', 'ED_1950_ED77_UTM_Zone_40N', 'ED_1950_ED77_UTM_Zone_41N', 'ELD_1979_UTM_Zone_32N', 'ELD_1979_UTM_Zone_33N', 'ELD_1979_UTM_Zone_34N', 'ELD_1979_UTM_Zone_35N', 'ETRF_1989_UTM_Zone_28N', 'ETRF_1989_UTM_Zone_29N', 'ETRF_1989_UTM_Zone_30N', 'ETRF_1989_UTM_Zone_31N', 'ETRF_1989_UTM_Zone_32N', 'ETRF_1989_UTM_Zone_33N', 'ETRF_1989_UTM_Zone_34N', 'ETRF_1989_UTM_Zone_35N', 'ETRF_1989_UTM_Zone_36N', 'ETRF_1989_UTM_Zone_37N', 'ETRF_1989_UTM_Zone_38N', 'ED_1950_UTM_Zone_28N', 'ED_1950_UTM_Zone_29N', 'ED_1950_UTM_Zone_30N', 'ED_1950_UTM_Zone_31N', 'ED_1950_UTM_Zone_32N', 'ED_1950_UTM_Zone_33N', 'ED_1950_UTM_Zone_34N', 'ED_1950_UTM_Zone_35N', 'ED_1950_UTM_Zone_36N', 'ED_1950_UTM_Zone_37N', 'ED_1950_UTM_Zone_38N', 'Fahud_UTM_Zone_39N', 'Fahud_UTM_Zone_40N', 'Garoua_UTM_Zone_33N', 'Graciosa_Base_SW_1948_UTM_Zone_26N', 'Hito_XVIII_1963_UTM_19S', 'Hong_Kong_1980_UTM_Zone_49N', 'Hong_Kong_1980_UTM_Zone_50N', 'Indian_1954_UTM_Zone_46N', 'Indian_1954_UTM_Zone_47N', 'Indian_1954_UTM_Zone_48N', 'Indian_1960_UTM_Zone_48N', 'Indian_1960_UTM_Zone_49N', 'Indian_1975_UTM_Zone_47N', 'Indian_1975_UTM_Zone_48N', 'Indonesian_1974_UTM_Zone_46N', 'Indonesian_1974_UTM_Zone_46S', 'Indonesian_1974_UTM_Zone_47N', 'Indonesian_1974_UTM_Zone_47S', 'Indonesian_1974_UTM_Zone_48N', 'Indonesian_1974_UTM_Zone_48S', 'Indonesian_1974_UTM_Zone_49N', 'Indonesian_1974_UTM_Zone_49S', 'Indonesian_1974_UTM_Zone_50N', 'Indonesian_1974_UTM_Zone_50S', 'Indonesian_1974_UTM_Zone_51N', 'Indonesian_1974_UTM_Zone_51S', 'Indonesian_1974_UTM_Zone_52N', 'Indonesian_1974_UTM_Zone_52S', 'Indonesian_1974_UTM_Zone_53N', 'Indonesian_1974_UTM_Zone_53S', 'Indonesian_1974_UTM_Zone_54S', 'IRENET95_UTM_Zone_29N', 'Kertau_UTM_Zone_47N', 'Kertau_UTM_Zone_48N', 'La_Canoa_UTM_Zone_18N', 'La_Canoa_UTM_Zone_19N', 'La_Canoa_UTM_Zone_20N', 'La_Canoa_UTM_Zone_21N', 'Locodjo_1965_UTM_Zone_29N', 'Locodjo_1965_UTM_Zone_30N', 'Lome_UTM_Zone_31N', 'Mporaloko_UTM_Zone_32N', 'Mporaloko_UTM_Zone_32S', 'Malongo_1987_UTM_Zone_32S', 'Massawa_UTM_Zone_37N', 'Mhast_UTM_Zone_32S', 'Minna_UTM_Zone_31N', 'Minna_UTM_Zone_32N', 'Moznet_UTM_Zone_36S', 'Moznet_UTM_Zone_37S', 'NAD_1927_BLM_Zone_14N', 'NAD_1927_BLM_Zone_15N', 'NAD_1927_BLM_Zone_16N', 'NAD_1927_BLM_Zone_17N', 'NAD_1983_HARN_UTM_Zone_2S', 'Nahrwan_1967_UTM_Zone_38N', 'Nahrwan_1967_UTM_Zone_39N', 'Nahrwan_1967_UTM_Zone_40N', 'Naparima_1955_UTM_Zone_20N', 'Naparima_1972_UTM_Zone_20N', 'NGN_UTM_Zone_38N', 'NGN_UTM_Zone_39N', 'NGO_1948_UTM_Zone_32N', 'NGO_1948_UTM_Zone_33N', 'NGO_1948_UTM_Zone_34N', 'NGO_1948_UTM_Zone_35N', 'Nord_Sahara_1959_UTM_Zone_29N', 'Nord_Sahara_1959_UTM_Zone_30N', 'Nord_Sahara_1959_UTM_Zone_31N', 'Nord_Sahara_1959_UTM_Zone_32N', 'NZGD_1949_UTM_Zone_58S', 'NZGD_1949_UTM_Zone_59S', 'NZGD_1949_UTM_Zone_60S', 'NZGD_2000_UTM_Zone_58S', 'NZGD_2000_UTM_Zone_59S', 'NZGD_2000_UTM_Zone_60S', 'Observ_Meteorologico_1939_UTM_Zone_25N', 'Old_Hawaiian_UTM_Zone_4N', 'Old_Hawaiian_UTM_Zone_5N', 'PDO_1993_UTM_Zone_39N', 'PDO_1993_UTM_Zone_40N', 'Pointe_Noire_UTM_Zone_32S', 'Porto_Santo_1936_UTM_Zone_28N', 'PSAD_1956_UTM_Zone_17S', 'PSAD_1956_UTM_Zone_18N', 'PSAD_1956_UTM_Zone_18S', 'PSAD_1956_UTM_Zone_19N', 'PSAD_1956_UTM_Zone_19S', 'PSAD_1956_UTM_Zone_20N', 'PSAD_1956_UTM_Zone_20S', 'PSAD_1956_UTM_Zone_21N', 'PSAD_1956_UTM_Zone_22S', 'Puerto_Rico_UTM_Zone_20N', 'Samboja_UTM_Zone_50S', 'Sao_Braz_UTM_Zone_26N', 'Sapper_Hill_1943_UTM_Zone_20S', 'Sapper_Hill_1943_UTM_Zone_21S', 'Schwarzeck_UTM_Zone_33S', 'Selvagem_Grande_1938_UTM_Zone_28N', 'Sierra_Leone_1968_UTM_Zone_28N', 'Sierra_Leone_1968_UTM_Zone_29N', 'SIRGAS_UTM_Zone_17N', 'SIRGAS_UTM_Zone_17S', 'SIRGAS_UTM_Zone_18N', 'SIRGAS_UTM_Zone_18S', 'SIRGAS_UTM_Zone_19N', 'SIRGAS_UTM_Zone_19S', 'SIRGAS_UTM_Zone_20N', 'SIRGAS_UTM_Zone_20S', 'SIRGAS_UTM_Zone_21N', 'SIRGAS_UTM_Zone_21S', 'SIRGAS_UTM_Zone_22N', 'SIRGAS_UTM_Zone_22S', 'SIRGAS_UTM_Zone_23S', 'SIRGAS_UTM_Zone_24S', 'SIRGAS_UTM_Zone_25S', 'SAD_1969_UTM_Zone_17S', 'SAD_1969_UTM_Zone_18N', 'SAD_1969_UTM_Zone_18S', 'SAD_1969_UTM_Zone_19N', 'SAD_1969_UTM_Zone_19S', 'SAD_1969_UTM_Zone_20N', 'SAD_1969_UTM_Zone_20S', 'SAD_1969_UTM_Zone_21N', 'SAD_1969_UTM_Zone_21S', 'SAD_1969_UTM_Zone_22N', 'SAD_1969_UTM_Zone_22S', 'SAD_1969_UTM_Zone_23S', 'SAD_1969_UTM_Zone_24S', 'SAD_1969_UTM_Zone_25S', 'Sudan_UTM_Zone_35N', 'Sudan_UTM_Zone_36N', 'Tananarive_1925_UTM_Zone_38S', 'Tananarive_1925_UTM_Zone_39S', 'Tete_UTM_Zone_36S', 'Tete_UTM_Zone_37S', 'Timbalai_1948_UTM_Zone_49N', 'Timbalai_1948_UTM_Zone_50N', 'Tokyo_UTM_Zone_51N', 'Tokyo_UTM_Zone_52N', 'Tokyo_UTM_Zone_53N', 'Tokyo_UTM_Zone_54N', 'Tokyo_UTM_Zone_55N', 'Tokyo_UTM_Zone_56N', 'TC_1948_UTM_Zone_39N', 'TC_1948_UTM_Zone_40N', 'Yemen_NGN_1996_UTM_Zone_38N', 'Yemen_NGN_1996_UTM_Zone_39N', 'Yoff_1972_UTM_Zone_28N', 'Zanderij_1972_UTM_Zone_21N', 'WGS_1972_UTM_Zone_10N', 'WGS_1972_UTM_Zone_10S', 'WGS_1972_UTM_Zone_11N', 'WGS_1972_UTM_Zone_11S', 'WGS_1972_UTM_Zone_12N', 'WGS_1972_UTM_Zone_12S', 'WGS_1972_UTM_Zone_13N', 'WGS_1972_UTM_Zone_13S', 'WGS_1972_UTM_Zone_14N', 'WGS_1972_UTM_Zone_14S', 'WGS_1972_UTM_Zone_15N', 'WGS_1972_UTM_Zone_15S', 'WGS_1972_UTM_Zone_16N', 'WGS_1972_UTM_Zone_16S', 'WGS_1972_UTM_Zone_17N', 'WGS_1972_UTM_Zone_17S', 'WGS_1972_UTM_Zone_18N', 'WGS_1972_UTM_Zone_18S', 'WGS_1972_UTM_Zone_19N', 'WGS_1972_UTM_Zone_19S', 'WGS_1972_UTM_Zone_1N', 'WGS_1972_UTM_Zone_1S', 'WGS_1972_UTM_Zone_20N', 'WGS_1972_UTM_Zone_20S', 'WGS_1972_UTM_Zone_21N', 'WGS_1972_UTM_Zone_21S', 'WGS_1972_UTM_Zone_22N', 'WGS_1972_UTM_Zone_22S', 'WGS_1972_UTM_Zone_23N', 'WGS_1972_UTM_Zone_23S', 'WGS_1972_UTM_Zone_24N', 'WGS_1972_UTM_Zone_24S', 'WGS_1972_UTM_Zone_25N', 'WGS_1972_UTM_Zone_25S', 'WGS_1972_UTM_Zone_26N', 'WGS_1972_UTM_Zone_26S', 'WGS_1972_UTM_Zone_27N', 'WGS_1972_UTM_Zone_27S', 'WGS_1972_UTM_Zone_28N', 'WGS_1972_UTM_Zone_28S', 'WGS_1972_UTM_Zone_29N', 'WGS_1972_UTM_Zone_29S', 'WGS_1972_UTM_Zone_2N', 'WGS_1972_UTM_Zone_2S', 'WGS_1972_UTM_Zone_30N', 'WGS_1972_UTM_Zone_30S', 'WGS_1972_UTM_Zone_31N', 'WGS_1972_UTM_Zone_31S', 'WGS_1972_UTM_Zone_32N', 'WGS_1972_UTM_Zone_32S', 'WGS_1972_UTM_Zone_33N', 'WGS_1972_UTM_Zone_33S', 'WGS_1972_UTM_Zone_34N', 'WGS_1972_UTM_Zone_34S', 'WGS_1972_UTM_Zone_35N', 'WGS_1972_UTM_Zone_35S', 'WGS_1972_UTM_Zone_36N', 'WGS_1972_UTM_Zone_36S', 'WGS_1972_UTM_Zone_37N', 'WGS_1972_UTM_Zone_37S', 'WGS_1972_UTM_Zone_38N', 'WGS_1972_UTM_Zone_38S', 'WGS_1972_UTM_Zone_39N', 'WGS_1972_UTM_Zone_39S', 'WGS_1972_UTM_Zone_3N', 'WGS_1972_UTM_Zone_3S', 'WGS_1972_UTM_Zone_40N', 'WGS_1972_UTM_Zone_40S', 'WGS_1972_UTM_Zone_41N', 'WGS_1972_UTM_Zone_41S', 'WGS_1972_UTM_Zone_42N', 'WGS_1972_UTM_Zone_42S', 'WGS_1972_UTM_Zone_43N', 'WGS_1972_UTM_Zone_43S', 'WGS_1972_UTM_Zone_44N', 'WGS_1972_UTM_Zone_44S', 'WGS_1972_UTM_Zone_45N', 'WGS_1972_UTM_Zone_45S', 'WGS_1972_UTM_Zone_46N', 'WGS_1972_UTM_Zone_46S', 'WGS_1972_UTM_Zone_47N', 'WGS_1972_UTM_Zone_47S', 'WGS_1972_UTM_Zone_48N', 'WGS_1972_UTM_Zone_48S', 'WGS_1972_UTM_Zone_49N', 'WGS_1972_UTM_Zone_49S', 'WGS_1972_UTM_Zone_4N', 'WGS_1972_UTM_Zone_4S', 'WGS_1972_UTM_Zone_50N', 'WGS_1972_UTM_Zone_50S', 'WGS_1972_UTM_Zone_51N', 'WGS_1972_UTM_Zone_51S', 'WGS_1972_UTM_Zone_52N', 'WGS_1972_UTM_Zone_52S', 'WGS_1972_UTM_Zone_53N', 'WGS_1972_UTM_Zone_53S', 'WGS_1972_UTM_Zone_54N', 'WGS_1972_UTM_Zone_54S', 'WGS_1972_UTM_Zone_55N', 'WGS_1972_UTM_Zone_55S', 'WGS_1972_UTM_Zone_56N', 'WGS_1972_UTM_Zone_56S', 'WGS_1972_UTM_Zone_57N', 'WGS_1972_UTM_Zone_57S', 'WGS_1972_UTM_Zone_58N', 'WGS_1972_UTM_Zone_58S', 'WGS_1972_UTM_Zone_59N', 'WGS_1972_UTM_Zone_59S', 'WGS_1972_UTM_Zone_5N', 'WGS_1972_UTM_Zone_5S', 'WGS_1972_UTM_Zone_60N', 'WGS_1972_UTM_Zone_60S', 'WGS_1972_UTM_Zone_6N', 'WGS_1972_UTM_Zone_6S', 'WGS_1972_UTM_Zone_7N', 'WGS_1972_UTM_Zone_7S', 'WGS_1972_UTM_Zone_8N', 'WGS_1972_UTM_Zone_8S', 'WGS_1972_UTM_Zone_9N', 'WGS_1972_UTM_Zone_9S', 'WGS_1984_UTM_Zone_10N', 'WGS_1984_UTM_Zone_10S', 'WGS_1984_UTM_Zone_11N', 'WGS_1984_UTM_Zone_11S', 'WGS_1984_UTM_Zone_12N', 'WGS_1984_UTM_Zone_12S', 'WGS_1984_UTM_Zone_13N', 'WGS_1984_UTM_Zone_13S', 'WGS_1984_UTM_Zone_14N', 'WGS_1984_UTM_Zone_14S', 'WGS_1984_UTM_Zone_15N', 'WGS_1984_UTM_Zone_15S', 'WGS_1984_UTM_Zone_16N', 'WGS_1984_UTM_Zone_16S', 'WGS_1984_UTM_Zone_17N', 'WGS_1984_UTM_Zone_17S', 'WGS_1984_UTM_Zone_18N', 'WGS_1984_UTM_Zone_18S', 'WGS_1984_UTM_Zone_19N', 'WGS_1984_UTM_Zone_19S', 'WGS_1984_UTM_Zone_1N', 'WGS_1984_UTM_Zone_1S', 'WGS_1984_UTM_Zone_20N', 'WGS_1984_UTM_Zone_20S', 'WGS_1984_UTM_Zone_21N', 'WGS_1984_UTM_Zone_21S', 'WGS_1984_UTM_Zone_22N', 'WGS_1984_UTM_Zone_22S', 'WGS_1984_UTM_Zone_23N', 'WGS_1984_UTM_Zone_23S', 'WGS_1984_UTM_Zone_24N', 'WGS_1984_UTM_Zone_24S', 'WGS_1984_UTM_Zone_25N', 'WGS_1984_UTM_Zone_25S', 'WGS_1984_UTM_Zone_26N', 'WGS_1984_UTM_Zone_26S', 'WGS_1984_UTM_Zone_27N', 'WGS_1984_UTM_Zone_27S', 'WGS_1984_UTM_Zone_28N', 'WGS_1984_UTM_Zone_28S', 'WGS_1984_UTM_Zone_29N', 'WGS_1984_UTM_Zone_29S', 'WGS_1984_UTM_Zone_2N', 'WGS_1984_UTM_Zone_2S', 'WGS_1984_UTM_Zone_30N', 'WGS_1984_UTM_Zone_30S', 'WGS_1984_UTM_Zone_31N', 'WGS_1984_UTM_Zone_31S', 'WGS_1984_UTM_Zone_32N', 'WGS_1984_UTM_Zone_32S', 'WGS_1984_UTM_Zone_33N', 'WGS_1984_UTM_Zone_33S', 'WGS_1984_UTM_Zone_34N', 'WGS_1984_UTM_Zone_34S', 'WGS_1984_UTM_Zone_35N', 'WGS_1984_UTM_Zone_35S', 'WGS_1984_UTM_Zone_36N', 'WGS_1984_UTM_Zone_36S', 'WGS_1984_UTM_Zone_37N', 'WGS_1984_UTM_Zone_37S', 'WGS_1984_UTM_Zone_38N', 'WGS_1984_UTM_Zone_38S', 'WGS_1984_UTM_Zone_39N', 'WGS_1984_UTM_Zone_39S', 'WGS_1984_UTM_Zone_3N', 'WGS_1984_UTM_Zone_3S', 'WGS_1984_UTM_Zone_40N', 'WGS_1984_UTM_Zone_40S', 'WGS_1984_UTM_Zone_41N', 'WGS_1984_UTM_Zone_41S', 'WGS_1984_UTM_Zone_42N', 'WGS_1984_UTM_Zone_42S', 'WGS_1984_UTM_Zone_43N', 'WGS_1984_UTM_Zone_43S', 'WGS_1984_UTM_Zone_44N', 'WGS_1984_UTM_Zone_44S', 'WGS_1984_UTM_Zone_45N', 'WGS_1984_UTM_Zone_45S', 'WGS_1984_UTM_Zone_46N', 'WGS_1984_UTM_Zone_46S', 'WGS_1984_UTM_Zone_47N', 'WGS_1984_UTM_Zone_47S', 'WGS_1984_UTM_Zone_48N', 'WGS_1984_UTM_Zone_48S', 'WGS_1984_UTM_Zone_49N', 'WGS_1984_UTM_Zone_49S', 'WGS_1984_UTM_Zone_4N', 'WGS_1984_UTM_Zone_4S', 'WGS_1984_UTM_Zone_50N', 'WGS_1984_UTM_Zone_50S', 'WGS_1984_UTM_Zone_51N', 'WGS_1984_UTM_Zone_51S', 'WGS_1984_UTM_Zone_52N', 'WGS_1984_UTM_Zone_52S', 'WGS_1984_UTM_Zone_53N', 'WGS_1984_UTM_Zone_53S', 'WGS_1984_UTM_Zone_54N', 'WGS_1984_UTM_Zone_54S', 'WGS_1984_UTM_Zone_55N', 'WGS_1984_UTM_Zone_55S', 'WGS_1984_UTM_Zone_56N', 'WGS_1984_UTM_Zone_56S', 'WGS_1984_UTM_Zone_57N', 'WGS_1984_UTM_Zone_57S', 'WGS_1984_UTM_Zone_58N', 'WGS_1984_UTM_Zone_58S', 'WGS_1984_UTM_Zone_59N', 'WGS_1984_UTM_Zone_59S', 'WGS_1984_UTM_Zone_5N', 'WGS_1984_UTM_Zone_5S', 'WGS_1984_UTM_Zone_60N', 'WGS_1984_UTM_Zone_60S', 'WGS_1984_UTM_Zone_6N', 'WGS_1984_UTM_Zone_6S', 'WGS_1984_UTM_Zone_7N', 'WGS_1984_UTM_Zone_7S', 'WGS_1984_UTM_Zone_8N', 'WGS_1984_UTM_Zone_8S', 'WGS_1984_UTM_Zone_9N', 'WGS_1984_UTM_Zone_9S', 'World_Aitoff', 'World_Behrmann', 'World_Bonne', 'World_Craster_Parabolic', 'World_Cylindrical_Equal_Area', 'World_Eckert_I', 'World_Eckert_II', 'World_Eckert_III', 'World_Eckert_IV', 'World_Eckert_V', 'World_Eckert_VI', 'World_Equidistant_Conic', 'World_Equidistant_Cylindrical', 'World_Flat_Polar_Quartic', 'World_Gall_Stereographic', 'World_Hammer_Aitoff', 'World_Loximuthal', 'World_Mercator', 'World_Miller_Cylindrical', 'World_Mollweide', 'World_Plate_Carree', 'World_Polyconic', 'World_Quartic_Authalic', 'World_Robinson', 'World_Sinusoidal', 'Sphere_Aitoff', 'Sphere_Behrmann', 'Sphere_Bonne', 'Sphere_Craster_Parabolic', 'Sphere_Cylindrical_Equal_Area', 'Sphere_Eckert_I', 'Sphere_Eckert_II', 'Sphere_Eckert_III', 'Sphere_Eckert_IV', 'Sphere_Eckert_V', 'Sphere_Eckert_VI', 'Sphere_Equidistant_Conic', 'Sphere_Equidistant_Cylindrical', 'Sphere_Flat_Polar_Quartic', 'Sphere_Gall_Stereographic', 'Sphere_Hammer_Aitoff', 'Sphere_Loximuthal', 'Sphere_Mercator', 'Sphere_Miller_Cylindrical', 'Sphere_Mollweide', 'Sphere_Plate_Carree', 'Sphere_Polyconic', 'Sphere_Quartic_Authalic', 'Sphere_Robinson', 'Sphere_Sinusoidal', 'Sphere_Times', 'Sphere_Van_der_Grinten_I', 'Sphere_Vertical_Perspective', 'Sphere_Winkel_I', 'Sphere_Winkel_II', 'Sphere_Winkel_Tripel_NGS', 'The_World_From_Space', 'World_Times', 'World_Van_der_Grinten_I', 'World_Vertical_Perspective', 'World_Winkel_I', 'World_Winkel_II', 'World_Winkel_Tripel_NGS']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on horizCoordSysNameType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_IDType(self, value):
        # Validate type res:IDType, a restriction on xs:string.
        pass
    def validate_SystemType(self, value):
        # Validate type res:SystemType, a restriction on xs:string.
        pass
    def validate_ScopeType(self, value):
        # Validate type res:ScopeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['system', 'document']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ScopeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.horizCoordSysName is not None or
            self.horizCoordSysDef is not None or
            self.vertCoordSys is not None or
            self.references is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='SpatialReferenceType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SpatialReferenceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SpatialReferenceType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SpatialReferenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SpatialReferenceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SpatialReferenceType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
        if self.scope != "document" and 'scope' not in already_processed:
            already_processed.add('scope')
            outfile.write(' scope=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.scope), input_name='scope')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='SpatialReferenceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.horizCoordSysName is not None:
            namespaceprefix_ = self.horizCoordSysName_nsprefix_ + ':' if (UseCapturedNS_ and self.horizCoordSysName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shorizCoordSysName>%s</%shorizCoordSysName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.horizCoordSysName), input_name='horizCoordSysName')), namespaceprefix_ , eol_))
        if self.horizCoordSysDef is not None:
            namespaceprefix_ = self.horizCoordSysDef_nsprefix_ + ':' if (UseCapturedNS_ and self.horizCoordSysDef_nsprefix_) else ''
            self.horizCoordSysDef.export(outfile, level, namespaceprefix_, namespacedef_='', name_='horizCoordSysDef', pretty_print=pretty_print)
        if self.vertCoordSys is not None:
            namespaceprefix_ = self.vertCoordSys_nsprefix_ + ':' if (UseCapturedNS_ and self.vertCoordSys_nsprefix_) else ''
            self.vertCoordSys.export(outfile, level, namespaceprefix_, namespacedef_='', name_='vertCoordSys', pretty_print=pretty_print)
        if self.references is not None:
            namespaceprefix_ = self.references_nsprefix_ + ':' if (UseCapturedNS_ and self.references_nsprefix_) else ''
            self.references.export(outfile, level, namespaceprefix_, namespacedef_='', name_='references', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_IDType(self.id)    # validate type IDType
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
        value = find_attr_value_('scope', node)
        if value is not None and 'scope' not in already_processed:
            already_processed.add('scope')
            self.scope = value
            self.validate_ScopeType(self.scope)    # validate type ScopeType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'horizCoordSysName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'horizCoordSysName')
            value_ = self.gds_validate_string(value_, node, 'horizCoordSysName')
            self.horizCoordSysName = value_
            self.horizCoordSysName_nsprefix_ = child_.prefix
            # validate type horizCoordSysNameType
            self.validate_horizCoordSysNameType(self.horizCoordSysName)
        elif nodeName_ == 'horizCoordSysDef':
            obj_ = horizCoordSysType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.horizCoordSysDef = obj_
            obj_.original_tagname_ = 'horizCoordSysDef'
        elif nodeName_ == 'vertCoordSys':
            obj_ = vertCoordSysType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vertCoordSys = obj_
            obj_.original_tagname_ = 'vertCoordSys'
        elif nodeName_ == 'references':
            obj_ = referencesType69.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.references = obj_
            obj_.original_tagname_ = 'references'
# end class SpatialReferenceType


class geogCoordSysType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('name', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('datum', 'datumType', 0, 0, {'name': 'datum', 'type': 'datumType'}, None),
        MemberSpec_('spheroid', 'spheroidType', 0, 0, {'name': 'spheroid', 'type': 'spheroidType'}, None),
        MemberSpec_('primeMeridian', 'primeMeridianType', 0, 0, {'name': 'primeMeridian', 'type': 'primeMeridianType'}, None),
        MemberSpec_('unit', 'unitType', 0, 0, {'name': 'unit', 'type': 'unitType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, name=None, datum=None, spheroid=None, primeMeridian=None, unit=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.datum = datum
        self.datum_nsprefix_ = None
        self.spheroid = spheroid
        self.spheroid_nsprefix_ = None
        self.primeMeridian = primeMeridian
        self.primeMeridian_nsprefix_ = None
        self.unit = unit
        self.unit_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, geogCoordSysType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if geogCoordSysType.subclass:
            return geogCoordSysType.subclass(*args_, **kwargs_)
        else:
            return geogCoordSysType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_datum(self):
        return self.datum
    def set_datum(self, datum):
        self.datum = datum
    def get_spheroid(self):
        return self.spheroid
    def set_spheroid(self, spheroid):
        self.spheroid = spheroid
    def get_primeMeridian(self):
        return self.primeMeridian
    def set_primeMeridian(self, primeMeridian):
        self.primeMeridian = primeMeridian
    def get_unit(self):
        return self.unit
    def set_unit(self, unit):
        self.unit = unit
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def hasContent_(self):
        if (
            self.datum is not None or
            self.spheroid is not None or
            self.primeMeridian is not None or
            self.unit is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='geogCoordSysType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('geogCoordSysType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'geogCoordSysType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='geogCoordSysType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='geogCoordSysType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='geogCoordSysType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='geogCoordSysType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.datum is not None:
            namespaceprefix_ = self.datum_nsprefix_ + ':' if (UseCapturedNS_ and self.datum_nsprefix_) else ''
            self.datum.export(outfile, level, namespaceprefix_, namespacedef_='', name_='datum', pretty_print=pretty_print)
        if self.spheroid is not None:
            namespaceprefix_ = self.spheroid_nsprefix_ + ':' if (UseCapturedNS_ and self.spheroid_nsprefix_) else ''
            self.spheroid.export(outfile, level, namespaceprefix_, namespacedef_='', name_='spheroid', pretty_print=pretty_print)
        if self.primeMeridian is not None:
            namespaceprefix_ = self.primeMeridian_nsprefix_ + ':' if (UseCapturedNS_ and self.primeMeridian_nsprefix_) else ''
            self.primeMeridian.export(outfile, level, namespaceprefix_, namespacedef_='', name_='primeMeridian', pretty_print=pretty_print)
        if self.unit is not None:
            namespaceprefix_ = self.unit_nsprefix_ + ':' if (UseCapturedNS_ and self.unit_nsprefix_) else ''
            self.unit.export(outfile, level, namespaceprefix_, namespacedef_='', name_='unit', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'datum':
            obj_ = datumType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.datum = obj_
            obj_.original_tagname_ = 'datum'
        elif nodeName_ == 'spheroid':
            obj_ = spheroidType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.spheroid = obj_
            obj_.original_tagname_ = 'spheroid'
        elif nodeName_ == 'primeMeridian':
            obj_ = primeMeridianType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.primeMeridian = obj_
            obj_.original_tagname_ = 'primeMeridian'
        elif nodeName_ == 'unit':
            obj_ = unitType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.unit = obj_
            obj_.original_tagname_ = 'unit'
# end class geogCoordSysType


class horizCoordSysType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('name', 'xs:string', 0, 0, {'use': 'required'}),
        MemberSpec_('geogCoordSys', 'geogCoordSysType', 0, 0, {'name': 'geogCoordSys', 'type': 'geogCoordSysType'}, 52),
        MemberSpec_('projCoordSys', 'projCoordSysType', 0, 0, {'name': 'projCoordSys', 'type': 'projCoordSysType'}, 52),
    ]
    subclass = None
    superclass = None
    def __init__(self, name=None, geogCoordSys=None, projCoordSys=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.geogCoordSys = geogCoordSys
        self.geogCoordSys_nsprefix_ = None
        self.projCoordSys = projCoordSys
        self.projCoordSys_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, horizCoordSysType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if horizCoordSysType.subclass:
            return horizCoordSysType.subclass(*args_, **kwargs_)
        else:
            return horizCoordSysType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_geogCoordSys(self):
        return self.geogCoordSys
    def set_geogCoordSys(self, geogCoordSys):
        self.geogCoordSys = geogCoordSys
    def get_projCoordSys(self):
        return self.projCoordSys
    def set_projCoordSys(self, projCoordSys):
        self.projCoordSys = projCoordSys
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def hasContent_(self):
        if (
            self.geogCoordSys is not None or
            self.projCoordSys is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='horizCoordSysType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('horizCoordSysType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'horizCoordSysType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='horizCoordSysType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='horizCoordSysType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='horizCoordSysType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='horizCoordSysType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.geogCoordSys is not None:
            namespaceprefix_ = self.geogCoordSys_nsprefix_ + ':' if (UseCapturedNS_ and self.geogCoordSys_nsprefix_) else ''
            self.geogCoordSys.export(outfile, level, namespaceprefix_, namespacedef_='', name_='geogCoordSys', pretty_print=pretty_print)
        if self.projCoordSys is not None:
            namespaceprefix_ = self.projCoordSys_nsprefix_ + ':' if (UseCapturedNS_ and self.projCoordSys_nsprefix_) else ''
            self.projCoordSys.export(outfile, level, namespaceprefix_, namespacedef_='', name_='projCoordSys', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'geogCoordSys':
            obj_ = geogCoordSysType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.geogCoordSys = obj_
            obj_.original_tagname_ = 'geogCoordSys'
        elif nodeName_ == 'projCoordSys':
            obj_ = projCoordSysType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.projCoordSys = obj_
            obj_.original_tagname_ = 'projCoordSys'
# end class horizCoordSysType


class projectionList(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('horizCoordSysDef', 'horizCoordSysType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'horizCoordSysDef', 'type': 'horizCoordSysType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, horizCoordSysDef=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if horizCoordSysDef is None:
            self.horizCoordSysDef = []
        else:
            self.horizCoordSysDef = horizCoordSysDef
        self.horizCoordSysDef_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, projectionList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if projectionList.subclass:
            return projectionList.subclass(*args_, **kwargs_)
        else:
            return projectionList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_horizCoordSysDef(self):
        return self.horizCoordSysDef
    def set_horizCoordSysDef(self, horizCoordSysDef):
        self.horizCoordSysDef = horizCoordSysDef
    def add_horizCoordSysDef(self, value):
        self.horizCoordSysDef.append(value)
    def insert_horizCoordSysDef_at(self, index, value):
        self.horizCoordSysDef.insert(index, value)
    def replace_horizCoordSysDef_at(self, index, value):
        self.horizCoordSysDef[index] = value
    def hasContent_(self):
        if (
            self.horizCoordSysDef
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='projectionList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('projectionList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'projectionList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='projectionList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='projectionList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='projectionList'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='projectionList', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for horizCoordSysDef_ in self.horizCoordSysDef:
            namespaceprefix_ = self.horizCoordSysDef_nsprefix_ + ':' if (UseCapturedNS_ and self.horizCoordSysDef_nsprefix_) else ''
            horizCoordSysDef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='horizCoordSysDef', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'horizCoordSysDef':
            obj_ = horizCoordSysType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.horizCoordSysDef.append(obj_)
            obj_.original_tagname_ = 'horizCoordSysDef'
# end class projectionList


class SpatialVectorType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'res:IDType', 0, 1, {'use': 'optional'}),
        MemberSpec_('system', 'res:SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('scope', 'res:ScopeType', 0, 1, {'use': 'optional'}),
        MemberSpec_('alternateIdentifier', 'alternateIdentifierType72', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'alternateIdentifier', 'type': 'alternateIdentifierType72'}, 53),
        MemberSpec_('entityName', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'entityName', 'type': 'xs:string'}, 53),
        MemberSpec_('entityDescription', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'entityDescription', 'type': 'xs:string'}, 53),
        MemberSpec_('physical', 'PhysicalType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'physical', 'type': 'PhysicalType'}, 53),
        MemberSpec_('coverage', 'Coverage', 0, 1, {'minOccurs': '0', 'name': 'coverage', 'type': 'Coverage'}, 53),
        MemberSpec_('methods', 'MethodsType', 0, 1, {'minOccurs': '0', 'name': 'methods', 'type': 'MethodsType'}, 53),
        MemberSpec_('additionalInfo', 'TextType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'additionalInfo', 'type': 'TextType'}, 53),
        MemberSpec_('annotation', 'SemanticAnnotation', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'annotation', 'type': 'SemanticAnnotation'}, 53),
        MemberSpec_('attributeList', 'AttributeListType', 0, 0, {'name': 'attributeList', 'type': 'AttributeListType'}, 53),
        MemberSpec_('constraint', 'ConstraintType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'constraint', 'type': 'ConstraintType'}, 53),
        MemberSpec_('geometry', ['GeometryType', 'xs:string'], 1, 0, {'maxOccurs': 'unbounded', 'name': 'geometry', 'type': 'xs:string'}, 53),
        MemberSpec_('geometricObjectCount', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'geometricObjectCount', 'type': 'xs:string'}, 53),
        MemberSpec_('topologyLevel', ['TopologyLevel', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'topologyLevel', 'type': 'xs:string'}, 53),
        MemberSpec_('spatialReference', 'SpatialReferenceType', 0, 1, {'minOccurs': '0', 'name': 'spatialReference', 'type': 'SpatialReferenceType'}, 53),
        MemberSpec_('horizontalAccuracy', 'DataQuality', 0, 1, {'minOccurs': '0', 'name': 'horizontalAccuracy', 'type': 'DataQuality'}, 53),
        MemberSpec_('verticalAccuracy', 'DataQuality', 0, 1, {'minOccurs': '0', 'name': 'verticalAccuracy', 'type': 'DataQuality'}, 53),
        MemberSpec_('references', 'referencesType73', 0, 0, {'name': 'references', 'type': 'referencesType73'}, 53),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, system=None, scope='document', alternateIdentifier=None, entityName=None, entityDescription=None, physical=None, coverage=None, methods=None, additionalInfo=None, annotation=None, attributeList=None, constraint=None, geometry=None, geometricObjectCount=None, topologyLevel=None, spatialReference=None, horizontalAccuracy=None, verticalAccuracy=None, references=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.scope = _cast(None, scope)
        self.scope_nsprefix_ = None
        if alternateIdentifier is None:
            self.alternateIdentifier = []
        else:
            self.alternateIdentifier = alternateIdentifier
        self.alternateIdentifier_nsprefix_ = None
        self.entityName = entityName
        self.validate_NonEmptyStringType(self.entityName)
        self.entityName_nsprefix_ = None
        self.entityDescription = entityDescription
        self.validate_NonEmptyStringType(self.entityDescription)
        self.entityDescription_nsprefix_ = None
        if physical is None:
            self.physical = []
        else:
            self.physical = physical
        self.physical_nsprefix_ = None
        self.coverage = coverage
        self.coverage_nsprefix_ = None
        self.methods = methods
        self.methods_nsprefix_ = None
        if additionalInfo is None:
            self.additionalInfo = []
        else:
            self.additionalInfo = additionalInfo
        self.additionalInfo_nsprefix_ = None
        if annotation is None:
            self.annotation = []
        else:
            self.annotation = annotation
        self.annotation_nsprefix_ = None
        self.attributeList = attributeList
        self.attributeList_nsprefix_ = None
        if constraint is None:
            self.constraint = []
        else:
            self.constraint = constraint
        self.constraint_nsprefix_ = None
        if geometry is None:
            self.geometry = []
        else:
            self.geometry = geometry
        self.geometry_nsprefix_ = None
        self.geometricObjectCount = geometricObjectCount
        self.validate_NonEmptyStringType(self.geometricObjectCount)
        self.geometricObjectCount_nsprefix_ = None
        self.topologyLevel = topologyLevel
        self.validate_TopologyLevel(self.topologyLevel)
        self.topologyLevel_nsprefix_ = None
        self.spatialReference = spatialReference
        self.spatialReference_nsprefix_ = None
        self.horizontalAccuracy = horizontalAccuracy
        self.horizontalAccuracy_nsprefix_ = None
        self.verticalAccuracy = verticalAccuracy
        self.verticalAccuracy_nsprefix_ = None
        self.references = references
        self.references_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SpatialVectorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SpatialVectorType.subclass:
            return SpatialVectorType.subclass(*args_, **kwargs_)
        else:
            return SpatialVectorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_alternateIdentifier(self):
        return self.alternateIdentifier
    def set_alternateIdentifier(self, alternateIdentifier):
        self.alternateIdentifier = alternateIdentifier
    def add_alternateIdentifier(self, value):
        self.alternateIdentifier.append(value)
    def insert_alternateIdentifier_at(self, index, value):
        self.alternateIdentifier.insert(index, value)
    def replace_alternateIdentifier_at(self, index, value):
        self.alternateIdentifier[index] = value
    def get_entityName(self):
        return self.entityName
    def set_entityName(self, entityName):
        self.entityName = entityName
    def get_entityDescription(self):
        return self.entityDescription
    def set_entityDescription(self, entityDescription):
        self.entityDescription = entityDescription
    def get_physical(self):
        return self.physical
    def set_physical(self, physical):
        self.physical = physical
    def add_physical(self, value):
        self.physical.append(value)
    def insert_physical_at(self, index, value):
        self.physical.insert(index, value)
    def replace_physical_at(self, index, value):
        self.physical[index] = value
    def get_coverage(self):
        return self.coverage
    def set_coverage(self, coverage):
        self.coverage = coverage
    def get_methods(self):
        return self.methods
    def set_methods(self, methods):
        self.methods = methods
    def get_additionalInfo(self):
        return self.additionalInfo
    def set_additionalInfo(self, additionalInfo):
        self.additionalInfo = additionalInfo
    def add_additionalInfo(self, value):
        self.additionalInfo.append(value)
    def insert_additionalInfo_at(self, index, value):
        self.additionalInfo.insert(index, value)
    def replace_additionalInfo_at(self, index, value):
        self.additionalInfo[index] = value
    def get_annotation(self):
        return self.annotation
    def set_annotation(self, annotation):
        self.annotation = annotation
    def add_annotation(self, value):
        self.annotation.append(value)
    def insert_annotation_at(self, index, value):
        self.annotation.insert(index, value)
    def replace_annotation_at(self, index, value):
        self.annotation[index] = value
    def get_attributeList(self):
        return self.attributeList
    def set_attributeList(self, attributeList):
        self.attributeList = attributeList
    def get_constraint(self):
        return self.constraint
    def set_constraint(self, constraint):
        self.constraint = constraint
    def add_constraint(self, value):
        self.constraint.append(value)
    def insert_constraint_at(self, index, value):
        self.constraint.insert(index, value)
    def replace_constraint_at(self, index, value):
        self.constraint[index] = value
    def get_geometry(self):
        return self.geometry
    def set_geometry(self, geometry):
        self.geometry = geometry
    def add_geometry(self, value):
        self.geometry.append(value)
    def insert_geometry_at(self, index, value):
        self.geometry.insert(index, value)
    def replace_geometry_at(self, index, value):
        self.geometry[index] = value
    def get_geometricObjectCount(self):
        return self.geometricObjectCount
    def set_geometricObjectCount(self, geometricObjectCount):
        self.geometricObjectCount = geometricObjectCount
    def get_topologyLevel(self):
        return self.topologyLevel
    def set_topologyLevel(self, topologyLevel):
        self.topologyLevel = topologyLevel
    def get_spatialReference(self):
        return self.spatialReference
    def set_spatialReference(self, spatialReference):
        self.spatialReference = spatialReference
    def get_horizontalAccuracy(self):
        return self.horizontalAccuracy
    def set_horizontalAccuracy(self, horizontalAccuracy):
        self.horizontalAccuracy = horizontalAccuracy
    def get_verticalAccuracy(self):
        return self.verticalAccuracy
    def set_verticalAccuracy(self, verticalAccuracy):
        self.verticalAccuracy = verticalAccuracy
    def get_references(self):
        return self.references
    def set_references(self, references):
        self.references = references
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_scope(self):
        return self.scope
    def set_scope(self, scope):
        self.scope = scope
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def validate_GeometryType(self, value):
        result = True
        # Validate type GeometryType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Point', 'LineString', 'LinearRing', 'Polygon', 'MultiPoint', 'MultiLineString', 'MultiPolygon', 'MultiGeometry']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on GeometryType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_TopologyLevel(self, value):
        result = True
        # Validate type TopologyLevel, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['geometryOnly', 'nonPlanarGraph', 'planarLineGraph', 'fullPlanarGraph', 'surfaceGraph', 'fullTopology3D']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TopologyLevel' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_IDType(self, value):
        # Validate type res:IDType, a restriction on xs:string.
        pass
    def validate_SystemType(self, value):
        # Validate type res:SystemType, a restriction on xs:string.
        pass
    def validate_ScopeType(self, value):
        # Validate type res:ScopeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['system', 'document']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ScopeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.alternateIdentifier or
            self.entityName is not None or
            self.entityDescription is not None or
            self.physical or
            self.coverage is not None or
            self.methods is not None or
            self.additionalInfo or
            self.annotation or
            self.attributeList is not None or
            self.constraint or
            self.geometry or
            self.geometricObjectCount is not None or
            self.topologyLevel is not None or
            self.spatialReference is not None or
            self.horizontalAccuracy is not None or
            self.verticalAccuracy is not None or
            self.references is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0"  xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:phys="https://eml.ecoinformatics.org/physical-2.2.0"  xmlns:cov="https://eml.ecoinformatics.org/coverage-2.2.0"  xmlns:md="https://eml.ecoinformatics.org/methods-2.2.0"  xmlns:txt="https://eml.ecoinformatics.org/text-2.2.0"  xmlns:sem="https://eml.ecoinformatics.org/semantics-2.2.0"  xmlns:att="https://eml.ecoinformatics.org/attribute-2.2.0"  xmlns:con="https://eml.ecoinformatics.org/constraint-2.2.0"  xmlns:spref="https://eml.ecoinformatics.org/spatialReference-2.2.0" ', name_='SpatialVectorType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SpatialVectorType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SpatialVectorType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SpatialVectorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SpatialVectorType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SpatialVectorType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
        if self.scope != "document" and 'scope' not in already_processed:
            already_processed.add('scope')
            outfile.write(' scope=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.scope), input_name='scope')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0"  xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:phys="https://eml.ecoinformatics.org/physical-2.2.0"  xmlns:cov="https://eml.ecoinformatics.org/coverage-2.2.0"  xmlns:md="https://eml.ecoinformatics.org/methods-2.2.0"  xmlns:txt="https://eml.ecoinformatics.org/text-2.2.0"  xmlns:sem="https://eml.ecoinformatics.org/semantics-2.2.0"  xmlns:att="https://eml.ecoinformatics.org/attribute-2.2.0"  xmlns:con="https://eml.ecoinformatics.org/constraint-2.2.0"  xmlns:spref="https://eml.ecoinformatics.org/spatialReference-2.2.0" ', name_='SpatialVectorType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for alternateIdentifier_ in self.alternateIdentifier:
            namespaceprefix_ = self.alternateIdentifier_nsprefix_ + ':' if (UseCapturedNS_ and self.alternateIdentifier_nsprefix_) else ''
            alternateIdentifier_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='alternateIdentifier', pretty_print=pretty_print)
        if self.entityName is not None:
            namespaceprefix_ = self.entityName_nsprefix_ + ':' if (UseCapturedNS_ and self.entityName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sentityName>%s</%sentityName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.entityName), input_name='entityName')), namespaceprefix_ , eol_))
        if self.entityDescription is not None:
            namespaceprefix_ = self.entityDescription_nsprefix_ + ':' if (UseCapturedNS_ and self.entityDescription_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sentityDescription>%s</%sentityDescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.entityDescription), input_name='entityDescription')), namespaceprefix_ , eol_))
        for physical_ in self.physical:
            namespaceprefix_ = self.physical_nsprefix_ + ':' if (UseCapturedNS_ and self.physical_nsprefix_) else ''
            physical_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='physical', pretty_print=pretty_print)
        if self.coverage is not None:
            namespaceprefix_ = self.coverage_nsprefix_ + ':' if (UseCapturedNS_ and self.coverage_nsprefix_) else ''
            self.coverage.export(outfile, level, namespaceprefix_, namespacedef_='', name_='coverage', pretty_print=pretty_print)
        if self.methods is not None:
            namespaceprefix_ = self.methods_nsprefix_ + ':' if (UseCapturedNS_ and self.methods_nsprefix_) else ''
            self.methods.export(outfile, level, namespaceprefix_, namespacedef_='', name_='methods', pretty_print=pretty_print)
        for additionalInfo_ in self.additionalInfo:
            namespaceprefix_ = self.additionalInfo_nsprefix_ + ':' if (UseCapturedNS_ and self.additionalInfo_nsprefix_) else ''
            additionalInfo_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='additionalInfo', pretty_print=pretty_print)
        for annotation_ in self.annotation:
            namespaceprefix_ = self.annotation_nsprefix_ + ':' if (UseCapturedNS_ and self.annotation_nsprefix_) else ''
            annotation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='annotation', pretty_print=pretty_print)
        if self.attributeList is not None:
            namespaceprefix_ = self.attributeList_nsprefix_ + ':' if (UseCapturedNS_ and self.attributeList_nsprefix_) else ''
            self.attributeList.export(outfile, level, namespaceprefix_, namespacedef_='', name_='attributeList', pretty_print=pretty_print)
        for constraint_ in self.constraint:
            namespaceprefix_ = self.constraint_nsprefix_ + ':' if (UseCapturedNS_ and self.constraint_nsprefix_) else ''
            constraint_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='constraint', pretty_print=pretty_print)
        for geometry_ in self.geometry:
            namespaceprefix_ = self.geometry_nsprefix_ + ':' if (UseCapturedNS_ and self.geometry_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgeometry>%s</%sgeometry>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(geometry_), input_name='geometry')), namespaceprefix_ , eol_))
        if self.geometricObjectCount is not None:
            namespaceprefix_ = self.geometricObjectCount_nsprefix_ + ':' if (UseCapturedNS_ and self.geometricObjectCount_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgeometricObjectCount>%s</%sgeometricObjectCount>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.geometricObjectCount), input_name='geometricObjectCount')), namespaceprefix_ , eol_))
        if self.topologyLevel is not None:
            namespaceprefix_ = self.topologyLevel_nsprefix_ + ':' if (UseCapturedNS_ and self.topologyLevel_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stopologyLevel>%s</%stopologyLevel>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.topologyLevel), input_name='topologyLevel')), namespaceprefix_ , eol_))
        if self.spatialReference is not None:
            namespaceprefix_ = self.spatialReference_nsprefix_ + ':' if (UseCapturedNS_ and self.spatialReference_nsprefix_) else ''
            self.spatialReference.export(outfile, level, namespaceprefix_, namespacedef_='', name_='spatialReference', pretty_print=pretty_print)
        if self.horizontalAccuracy is not None:
            namespaceprefix_ = self.horizontalAccuracy_nsprefix_ + ':' if (UseCapturedNS_ and self.horizontalAccuracy_nsprefix_) else ''
            self.horizontalAccuracy.export(outfile, level, namespaceprefix_, namespacedef_='', name_='horizontalAccuracy', pretty_print=pretty_print)
        if self.verticalAccuracy is not None:
            namespaceprefix_ = self.verticalAccuracy_nsprefix_ + ':' if (UseCapturedNS_ and self.verticalAccuracy_nsprefix_) else ''
            self.verticalAccuracy.export(outfile, level, namespaceprefix_, namespacedef_='', name_='verticalAccuracy', pretty_print=pretty_print)
        if self.references is not None:
            namespaceprefix_ = self.references_nsprefix_ + ':' if (UseCapturedNS_ and self.references_nsprefix_) else ''
            self.references.export(outfile, level, namespaceprefix_, namespacedef_='', name_='references', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_IDType(self.id)    # validate type IDType
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
        value = find_attr_value_('scope', node)
        if value is not None and 'scope' not in already_processed:
            already_processed.add('scope')
            self.scope = value
            self.validate_ScopeType(self.scope)    # validate type ScopeType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'alternateIdentifier':
            obj_ = alternateIdentifierType72.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.alternateIdentifier.append(obj_)
            obj_.original_tagname_ = 'alternateIdentifier'
        elif nodeName_ == 'entityName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'entityName')
            value_ = self.gds_validate_string(value_, node, 'entityName')
            self.entityName = value_
            self.entityName_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.entityName)
        elif nodeName_ == 'entityDescription':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'entityDescription')
            value_ = self.gds_validate_string(value_, node, 'entityDescription')
            self.entityDescription = value_
            self.entityDescription_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.entityDescription)
        elif nodeName_ == 'physical':
            obj_ = PhysicalType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.physical.append(obj_)
            obj_.original_tagname_ = 'physical'
        elif nodeName_ == 'coverage':
            obj_ = Coverage.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.coverage = obj_
            obj_.original_tagname_ = 'coverage'
        elif nodeName_ == 'methods':
            obj_ = MethodsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.methods = obj_
            obj_.original_tagname_ = 'methods'
        elif nodeName_ == 'additionalInfo':
            obj_ = TextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.additionalInfo.append(obj_)
            obj_.original_tagname_ = 'additionalInfo'
        elif nodeName_ == 'annotation':
            class_obj_ = self.get_class_obj_(child_, SemanticAnnotation)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.annotation.append(obj_)
            obj_.original_tagname_ = 'annotation'
        elif nodeName_ == 'attributeList':
            obj_ = AttributeListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.attributeList = obj_
            obj_.original_tagname_ = 'attributeList'
        elif nodeName_ == 'constraint':
            obj_ = ConstraintType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.constraint.append(obj_)
            obj_.original_tagname_ = 'constraint'
        elif nodeName_ == 'geometry':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'geometry')
            value_ = self.gds_validate_string(value_, node, 'geometry')
            self.geometry.append(value_)
            self.geometry_nsprefix_ = child_.prefix
            # validate type GeometryType
            self.validate_GeometryType(self.geometry[-1])
        elif nodeName_ == 'geometricObjectCount':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'geometricObjectCount')
            value_ = self.gds_validate_string(value_, node, 'geometricObjectCount')
            self.geometricObjectCount = value_
            self.geometricObjectCount_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.geometricObjectCount)
        elif nodeName_ == 'topologyLevel':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'topologyLevel')
            value_ = self.gds_validate_string(value_, node, 'topologyLevel')
            self.topologyLevel = value_
            self.topologyLevel_nsprefix_ = child_.prefix
            # validate type TopologyLevel
            self.validate_TopologyLevel(self.topologyLevel)
        elif nodeName_ == 'spatialReference':
            obj_ = SpatialReferenceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.spatialReference = obj_
            obj_.original_tagname_ = 'spatialReference'
        elif nodeName_ == 'horizontalAccuracy':
            obj_ = DataQuality.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.horizontalAccuracy = obj_
            obj_.original_tagname_ = 'horizontalAccuracy'
        elif nodeName_ == 'verticalAccuracy':
            obj_ = DataQuality.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.verticalAccuracy = obj_
            obj_.original_tagname_ = 'verticalAccuracy'
        elif nodeName_ == 'references':
            obj_ = referencesType73.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.references = obj_
            obj_.original_tagname_ = 'references'
# end class SpatialVectorType


class DataQuality1(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('accuracyReport', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'accuracyReport', 'type': 'xs:string'}, None),
        MemberSpec_('quantitativeAccuracyReport', 'quantitativeAccuracyReportType74', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'quantitativeAccuracyReport', 'type': 'quantitativeAccuracyReportType74'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, accuracyReport=None, quantitativeAccuracyReport=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.accuracyReport = accuracyReport
        self.validate_NonEmptyStringType(self.accuracyReport)
        self.accuracyReport_nsprefix_ = None
        if quantitativeAccuracyReport is None:
            self.quantitativeAccuracyReport = []
        else:
            self.quantitativeAccuracyReport = quantitativeAccuracyReport
        self.quantitativeAccuracyReport_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DataQuality1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DataQuality1.subclass:
            return DataQuality1.subclass(*args_, **kwargs_)
        else:
            return DataQuality1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_accuracyReport(self):
        return self.accuracyReport
    def set_accuracyReport(self, accuracyReport):
        self.accuracyReport = accuracyReport
    def get_quantitativeAccuracyReport(self):
        return self.quantitativeAccuracyReport
    def set_quantitativeAccuracyReport(self, quantitativeAccuracyReport):
        self.quantitativeAccuracyReport = quantitativeAccuracyReport
    def add_quantitativeAccuracyReport(self, value):
        self.quantitativeAccuracyReport.append(value)
    def insert_quantitativeAccuracyReport_at(self, index, value):
        self.quantitativeAccuracyReport.insert(index, value)
    def replace_quantitativeAccuracyReport_at(self, index, value):
        self.quantitativeAccuracyReport[index] = value
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def hasContent_(self):
        if (
            self.accuracyReport is not None or
            self.quantitativeAccuracyReport
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='DataQuality1', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DataQuality1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DataQuality1':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DataQuality1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DataQuality1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DataQuality1'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='DataQuality1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.accuracyReport is not None:
            namespaceprefix_ = self.accuracyReport_nsprefix_ + ':' if (UseCapturedNS_ and self.accuracyReport_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saccuracyReport>%s</%saccuracyReport>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.accuracyReport), input_name='accuracyReport')), namespaceprefix_ , eol_))
        for quantitativeAccuracyReport_ in self.quantitativeAccuracyReport:
            namespaceprefix_ = self.quantitativeAccuracyReport_nsprefix_ + ':' if (UseCapturedNS_ and self.quantitativeAccuracyReport_nsprefix_) else ''
            quantitativeAccuracyReport_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='quantitativeAccuracyReport', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'accuracyReport':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'accuracyReport')
            value_ = self.gds_validate_string(value_, node, 'accuracyReport')
            self.accuracyReport = value_
            self.accuracyReport_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.accuracyReport)
        elif nodeName_ == 'quantitativeAccuracyReport':
            obj_ = quantitativeAccuracyReportType74.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.quantitativeAccuracyReport.append(obj_)
            obj_.original_tagname_ = 'quantitativeAccuracyReport'
# end class DataQuality1


class StoredProcedureType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'res:IDType', 0, 1, {'use': 'optional'}),
        MemberSpec_('system', 'res:SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('scope', 'res:ScopeType', 0, 1, {'use': 'optional'}),
        MemberSpec_('alternateIdentifier', 'alternateIdentifierType75', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'alternateIdentifier', 'type': 'alternateIdentifierType75'}, 54),
        MemberSpec_('entityName', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'entityName', 'type': 'xs:string'}, 54),
        MemberSpec_('entityDescription', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'entityDescription', 'type': 'xs:string'}, 54),
        MemberSpec_('physical', 'PhysicalType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'physical', 'type': 'PhysicalType'}, 54),
        MemberSpec_('coverage', 'Coverage', 0, 1, {'minOccurs': '0', 'name': 'coverage', 'type': 'Coverage'}, 54),
        MemberSpec_('methods', 'MethodsType', 0, 1, {'minOccurs': '0', 'name': 'methods', 'type': 'MethodsType'}, 54),
        MemberSpec_('additionalInfo', 'TextType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'additionalInfo', 'type': 'TextType'}, 54),
        MemberSpec_('annotation', 'SemanticAnnotation', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'annotation', 'type': 'SemanticAnnotation'}, 54),
        MemberSpec_('attributeList', 'AttributeListType', 0, 0, {'name': 'attributeList', 'type': 'AttributeListType'}, 54),
        MemberSpec_('constraint', 'ConstraintType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'constraint', 'type': 'ConstraintType'}, 54),
        MemberSpec_('parameter', 'ParameterType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'parameter', 'type': 'ParameterType'}, 54),
        MemberSpec_('references', 'referencesType76', 0, 0, {'name': 'references', 'type': 'referencesType76'}, 54),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, system=None, scope='document', alternateIdentifier=None, entityName=None, entityDescription=None, physical=None, coverage=None, methods=None, additionalInfo=None, annotation=None, attributeList=None, constraint=None, parameter=None, references=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.scope = _cast(None, scope)
        self.scope_nsprefix_ = None
        if alternateIdentifier is None:
            self.alternateIdentifier = []
        else:
            self.alternateIdentifier = alternateIdentifier
        self.alternateIdentifier_nsprefix_ = None
        self.entityName = entityName
        self.validate_NonEmptyStringType(self.entityName)
        self.entityName_nsprefix_ = None
        self.entityDescription = entityDescription
        self.validate_NonEmptyStringType(self.entityDescription)
        self.entityDescription_nsprefix_ = None
        if physical is None:
            self.physical = []
        else:
            self.physical = physical
        self.physical_nsprefix_ = None
        self.coverage = coverage
        self.coverage_nsprefix_ = None
        self.methods = methods
        self.methods_nsprefix_ = None
        if additionalInfo is None:
            self.additionalInfo = []
        else:
            self.additionalInfo = additionalInfo
        self.additionalInfo_nsprefix_ = None
        if annotation is None:
            self.annotation = []
        else:
            self.annotation = annotation
        self.annotation_nsprefix_ = None
        self.attributeList = attributeList
        self.attributeList_nsprefix_ = None
        if constraint is None:
            self.constraint = []
        else:
            self.constraint = constraint
        self.constraint_nsprefix_ = None
        if parameter is None:
            self.parameter = []
        else:
            self.parameter = parameter
        self.parameter_nsprefix_ = None
        self.references = references
        self.references_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StoredProcedureType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StoredProcedureType.subclass:
            return StoredProcedureType.subclass(*args_, **kwargs_)
        else:
            return StoredProcedureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_alternateIdentifier(self):
        return self.alternateIdentifier
    def set_alternateIdentifier(self, alternateIdentifier):
        self.alternateIdentifier = alternateIdentifier
    def add_alternateIdentifier(self, value):
        self.alternateIdentifier.append(value)
    def insert_alternateIdentifier_at(self, index, value):
        self.alternateIdentifier.insert(index, value)
    def replace_alternateIdentifier_at(self, index, value):
        self.alternateIdentifier[index] = value
    def get_entityName(self):
        return self.entityName
    def set_entityName(self, entityName):
        self.entityName = entityName
    def get_entityDescription(self):
        return self.entityDescription
    def set_entityDescription(self, entityDescription):
        self.entityDescription = entityDescription
    def get_physical(self):
        return self.physical
    def set_physical(self, physical):
        self.physical = physical
    def add_physical(self, value):
        self.physical.append(value)
    def insert_physical_at(self, index, value):
        self.physical.insert(index, value)
    def replace_physical_at(self, index, value):
        self.physical[index] = value
    def get_coverage(self):
        return self.coverage
    def set_coverage(self, coverage):
        self.coverage = coverage
    def get_methods(self):
        return self.methods
    def set_methods(self, methods):
        self.methods = methods
    def get_additionalInfo(self):
        return self.additionalInfo
    def set_additionalInfo(self, additionalInfo):
        self.additionalInfo = additionalInfo
    def add_additionalInfo(self, value):
        self.additionalInfo.append(value)
    def insert_additionalInfo_at(self, index, value):
        self.additionalInfo.insert(index, value)
    def replace_additionalInfo_at(self, index, value):
        self.additionalInfo[index] = value
    def get_annotation(self):
        return self.annotation
    def set_annotation(self, annotation):
        self.annotation = annotation
    def add_annotation(self, value):
        self.annotation.append(value)
    def insert_annotation_at(self, index, value):
        self.annotation.insert(index, value)
    def replace_annotation_at(self, index, value):
        self.annotation[index] = value
    def get_attributeList(self):
        return self.attributeList
    def set_attributeList(self, attributeList):
        self.attributeList = attributeList
    def get_constraint(self):
        return self.constraint
    def set_constraint(self, constraint):
        self.constraint = constraint
    def add_constraint(self, value):
        self.constraint.append(value)
    def insert_constraint_at(self, index, value):
        self.constraint.insert(index, value)
    def replace_constraint_at(self, index, value):
        self.constraint[index] = value
    def get_parameter(self):
        return self.parameter
    def set_parameter(self, parameter):
        self.parameter = parameter
    def add_parameter(self, value):
        self.parameter.append(value)
    def insert_parameter_at(self, index, value):
        self.parameter.insert(index, value)
    def replace_parameter_at(self, index, value):
        self.parameter[index] = value
    def get_references(self):
        return self.references
    def set_references(self, references):
        self.references = references
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_scope(self):
        return self.scope
    def set_scope(self, scope):
        self.scope = scope
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def validate_IDType(self, value):
        # Validate type res:IDType, a restriction on xs:string.
        pass
    def validate_SystemType(self, value):
        # Validate type res:SystemType, a restriction on xs:string.
        pass
    def validate_ScopeType(self, value):
        # Validate type res:ScopeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['system', 'document']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ScopeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.alternateIdentifier or
            self.entityName is not None or
            self.entityDescription is not None or
            self.physical or
            self.coverage is not None or
            self.methods is not None or
            self.additionalInfo or
            self.annotation or
            self.attributeList is not None or
            self.constraint or
            self.parameter or
            self.references is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0"  xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:phys="https://eml.ecoinformatics.org/physical-2.2.0"  xmlns:cov="https://eml.ecoinformatics.org/coverage-2.2.0"  xmlns:md="https://eml.ecoinformatics.org/methods-2.2.0"  xmlns:txt="https://eml.ecoinformatics.org/text-2.2.0"  xmlns:sem="https://eml.ecoinformatics.org/semantics-2.2.0"  xmlns:att="https://eml.ecoinformatics.org/attribute-2.2.0"  xmlns:con="https://eml.ecoinformatics.org/constraint-2.2.0" ', name_='StoredProcedureType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StoredProcedureType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StoredProcedureType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StoredProcedureType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StoredProcedureType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StoredProcedureType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
        if self.scope != "document" and 'scope' not in already_processed:
            already_processed.add('scope')
            outfile.write(' scope=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.scope), input_name='scope')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0"  xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:phys="https://eml.ecoinformatics.org/physical-2.2.0"  xmlns:cov="https://eml.ecoinformatics.org/coverage-2.2.0"  xmlns:md="https://eml.ecoinformatics.org/methods-2.2.0"  xmlns:txt="https://eml.ecoinformatics.org/text-2.2.0"  xmlns:sem="https://eml.ecoinformatics.org/semantics-2.2.0"  xmlns:att="https://eml.ecoinformatics.org/attribute-2.2.0"  xmlns:con="https://eml.ecoinformatics.org/constraint-2.2.0" ', name_='StoredProcedureType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for alternateIdentifier_ in self.alternateIdentifier:
            namespaceprefix_ = self.alternateIdentifier_nsprefix_ + ':' if (UseCapturedNS_ and self.alternateIdentifier_nsprefix_) else ''
            alternateIdentifier_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='alternateIdentifier', pretty_print=pretty_print)
        if self.entityName is not None:
            namespaceprefix_ = self.entityName_nsprefix_ + ':' if (UseCapturedNS_ and self.entityName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sentityName>%s</%sentityName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.entityName), input_name='entityName')), namespaceprefix_ , eol_))
        if self.entityDescription is not None:
            namespaceprefix_ = self.entityDescription_nsprefix_ + ':' if (UseCapturedNS_ and self.entityDescription_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sentityDescription>%s</%sentityDescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.entityDescription), input_name='entityDescription')), namespaceprefix_ , eol_))
        for physical_ in self.physical:
            namespaceprefix_ = self.physical_nsprefix_ + ':' if (UseCapturedNS_ and self.physical_nsprefix_) else ''
            physical_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='physical', pretty_print=pretty_print)
        if self.coverage is not None:
            namespaceprefix_ = self.coverage_nsprefix_ + ':' if (UseCapturedNS_ and self.coverage_nsprefix_) else ''
            self.coverage.export(outfile, level, namespaceprefix_, namespacedef_='', name_='coverage', pretty_print=pretty_print)
        if self.methods is not None:
            namespaceprefix_ = self.methods_nsprefix_ + ':' if (UseCapturedNS_ and self.methods_nsprefix_) else ''
            self.methods.export(outfile, level, namespaceprefix_, namespacedef_='', name_='methods', pretty_print=pretty_print)
        for additionalInfo_ in self.additionalInfo:
            namespaceprefix_ = self.additionalInfo_nsprefix_ + ':' if (UseCapturedNS_ and self.additionalInfo_nsprefix_) else ''
            additionalInfo_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='additionalInfo', pretty_print=pretty_print)
        for annotation_ in self.annotation:
            namespaceprefix_ = self.annotation_nsprefix_ + ':' if (UseCapturedNS_ and self.annotation_nsprefix_) else ''
            annotation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='annotation', pretty_print=pretty_print)
        if self.attributeList is not None:
            namespaceprefix_ = self.attributeList_nsprefix_ + ':' if (UseCapturedNS_ and self.attributeList_nsprefix_) else ''
            self.attributeList.export(outfile, level, namespaceprefix_, namespacedef_='', name_='attributeList', pretty_print=pretty_print)
        for constraint_ in self.constraint:
            namespaceprefix_ = self.constraint_nsprefix_ + ':' if (UseCapturedNS_ and self.constraint_nsprefix_) else ''
            constraint_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='constraint', pretty_print=pretty_print)
        for parameter_ in self.parameter:
            namespaceprefix_ = self.parameter_nsprefix_ + ':' if (UseCapturedNS_ and self.parameter_nsprefix_) else ''
            parameter_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='parameter', pretty_print=pretty_print)
        if self.references is not None:
            namespaceprefix_ = self.references_nsprefix_ + ':' if (UseCapturedNS_ and self.references_nsprefix_) else ''
            self.references.export(outfile, level, namespaceprefix_, namespacedef_='', name_='references', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_IDType(self.id)    # validate type IDType
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
        value = find_attr_value_('scope', node)
        if value is not None and 'scope' not in already_processed:
            already_processed.add('scope')
            self.scope = value
            self.validate_ScopeType(self.scope)    # validate type ScopeType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'alternateIdentifier':
            obj_ = alternateIdentifierType75.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.alternateIdentifier.append(obj_)
            obj_.original_tagname_ = 'alternateIdentifier'
        elif nodeName_ == 'entityName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'entityName')
            value_ = self.gds_validate_string(value_, node, 'entityName')
            self.entityName = value_
            self.entityName_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.entityName)
        elif nodeName_ == 'entityDescription':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'entityDescription')
            value_ = self.gds_validate_string(value_, node, 'entityDescription')
            self.entityDescription = value_
            self.entityDescription_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.entityDescription)
        elif nodeName_ == 'physical':
            obj_ = PhysicalType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.physical.append(obj_)
            obj_.original_tagname_ = 'physical'
        elif nodeName_ == 'coverage':
            obj_ = Coverage.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.coverage = obj_
            obj_.original_tagname_ = 'coverage'
        elif nodeName_ == 'methods':
            obj_ = MethodsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.methods = obj_
            obj_.original_tagname_ = 'methods'
        elif nodeName_ == 'additionalInfo':
            obj_ = TextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.additionalInfo.append(obj_)
            obj_.original_tagname_ = 'additionalInfo'
        elif nodeName_ == 'annotation':
            class_obj_ = self.get_class_obj_(child_, SemanticAnnotation)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.annotation.append(obj_)
            obj_.original_tagname_ = 'annotation'
        elif nodeName_ == 'attributeList':
            obj_ = AttributeListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.attributeList = obj_
            obj_.original_tagname_ = 'attributeList'
        elif nodeName_ == 'constraint':
            obj_ = ConstraintType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.constraint.append(obj_)
            obj_.original_tagname_ = 'constraint'
        elif nodeName_ == 'parameter':
            obj_ = ParameterType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.parameter.append(obj_)
            obj_.original_tagname_ = 'parameter'
        elif nodeName_ == 'references':
            obj_ = referencesType76.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.references = obj_
            obj_.original_tagname_ = 'references'
# end class StoredProcedureType


class ParameterType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('name', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
        MemberSpec_('domainDescription', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'domainDescription', 'type': 'xs:string'}, None),
        MemberSpec_('required', 'xs:boolean', 0, 0, {'name': 'required', 'type': 'xs:boolean'}, None),
        MemberSpec_('repeats', 'xs:boolean', 0, 0, {'name': 'repeats', 'type': 'xs:boolean'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, name=None, domainDescription=None, required=None, repeats=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = name
        self.validate_NonEmptyStringType(self.name)
        self.name_nsprefix_ = None
        self.domainDescription = domainDescription
        self.validate_NonEmptyStringType(self.domainDescription)
        self.domainDescription_nsprefix_ = None
        self.required = required
        self.required_nsprefix_ = None
        self.repeats = repeats
        self.repeats_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ParameterType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ParameterType.subclass:
            return ParameterType.subclass(*args_, **kwargs_)
        else:
            return ParameterType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_domainDescription(self):
        return self.domainDescription
    def set_domainDescription(self, domainDescription):
        self.domainDescription = domainDescription
    def get_required(self):
        return self.required
    def set_required(self, required):
        self.required = required
    def get_repeats(self):
        return self.repeats
    def set_repeats(self, repeats):
        self.repeats = repeats
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def hasContent_(self):
        if (
            self.name is not None or
            self.domainDescription is not None or
            self.required is not None or
            self.repeats is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='ParameterType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ParameterType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ParameterType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ParameterType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ParameterType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ParameterType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='ParameterType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.domainDescription is not None:
            namespaceprefix_ = self.domainDescription_nsprefix_ + ':' if (UseCapturedNS_ and self.domainDescription_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdomainDescription>%s</%sdomainDescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.domainDescription), input_name='domainDescription')), namespaceprefix_ , eol_))
        if self.required is not None:
            namespaceprefix_ = self.required_nsprefix_ + ':' if (UseCapturedNS_ and self.required_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srequired>%s</%srequired>%s' % (namespaceprefix_ , self.gds_format_boolean(self.required, input_name='required'), namespaceprefix_ , eol_))
        if self.repeats is not None:
            namespaceprefix_ = self.repeats_nsprefix_ + ':' if (UseCapturedNS_ and self.repeats_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srepeats>%s</%srepeats>%s' % (namespaceprefix_ , self.gds_format_boolean(self.repeats, input_name='repeats'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.name)
        elif nodeName_ == 'domainDescription':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'domainDescription')
            value_ = self.gds_validate_string(value_, node, 'domainDescription')
            self.domainDescription = value_
            self.domainDescription_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.domainDescription)
        elif nodeName_ == 'required':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'required')
            ival_ = self.gds_validate_boolean(ival_, node, 'required')
            self.required = ival_
            self.required_nsprefix_ = child_.prefix
        elif nodeName_ == 'repeats':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'repeats')
            ival_ = self.gds_validate_boolean(ival_, node, 'repeats')
            self.repeats = ival_
            self.repeats_nsprefix_ = child_.prefix
# end class ParameterType


class ViewType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'res:IDType', 0, 1, {'use': 'optional'}),
        MemberSpec_('system', 'res:SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('scope', 'res:ScopeType', 0, 1, {'use': 'optional'}),
        MemberSpec_('alternateIdentifier', 'alternateIdentifierType77', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'alternateIdentifier', 'type': 'alternateIdentifierType77'}, 55),
        MemberSpec_('entityName', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'entityName', 'type': 'xs:string'}, 55),
        MemberSpec_('entityDescription', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'entityDescription', 'type': 'xs:string'}, 55),
        MemberSpec_('physical', 'PhysicalType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'physical', 'type': 'PhysicalType'}, 55),
        MemberSpec_('coverage', 'Coverage', 0, 1, {'minOccurs': '0', 'name': 'coverage', 'type': 'Coverage'}, 55),
        MemberSpec_('methods', 'MethodsType', 0, 1, {'minOccurs': '0', 'name': 'methods', 'type': 'MethodsType'}, 55),
        MemberSpec_('additionalInfo', 'TextType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'additionalInfo', 'type': 'TextType'}, 55),
        MemberSpec_('annotation', 'SemanticAnnotation', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'annotation', 'type': 'SemanticAnnotation'}, 55),
        MemberSpec_('attributeList', 'AttributeListType', 0, 0, {'name': 'attributeList', 'type': 'AttributeListType'}, 55),
        MemberSpec_('constraint', 'ConstraintType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'constraint', 'type': 'ConstraintType'}, 55),
        MemberSpec_('queryStatement', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'queryStatement', 'type': 'xs:string'}, 55),
        MemberSpec_('references', 'referencesType78', 0, 0, {'name': 'references', 'type': 'referencesType78'}, 55),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, system=None, scope='document', alternateIdentifier=None, entityName=None, entityDescription=None, physical=None, coverage=None, methods=None, additionalInfo=None, annotation=None, attributeList=None, constraint=None, queryStatement=None, references=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.scope = _cast(None, scope)
        self.scope_nsprefix_ = None
        if alternateIdentifier is None:
            self.alternateIdentifier = []
        else:
            self.alternateIdentifier = alternateIdentifier
        self.alternateIdentifier_nsprefix_ = None
        self.entityName = entityName
        self.validate_NonEmptyStringType(self.entityName)
        self.entityName_nsprefix_ = None
        self.entityDescription = entityDescription
        self.validate_NonEmptyStringType(self.entityDescription)
        self.entityDescription_nsprefix_ = None
        if physical is None:
            self.physical = []
        else:
            self.physical = physical
        self.physical_nsprefix_ = None
        self.coverage = coverage
        self.coverage_nsprefix_ = None
        self.methods = methods
        self.methods_nsprefix_ = None
        if additionalInfo is None:
            self.additionalInfo = []
        else:
            self.additionalInfo = additionalInfo
        self.additionalInfo_nsprefix_ = None
        if annotation is None:
            self.annotation = []
        else:
            self.annotation = annotation
        self.annotation_nsprefix_ = None
        self.attributeList = attributeList
        self.attributeList_nsprefix_ = None
        if constraint is None:
            self.constraint = []
        else:
            self.constraint = constraint
        self.constraint_nsprefix_ = None
        self.queryStatement = queryStatement
        self.validate_NonEmptyStringType(self.queryStatement)
        self.queryStatement_nsprefix_ = None
        self.references = references
        self.references_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ViewType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ViewType.subclass:
            return ViewType.subclass(*args_, **kwargs_)
        else:
            return ViewType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_alternateIdentifier(self):
        return self.alternateIdentifier
    def set_alternateIdentifier(self, alternateIdentifier):
        self.alternateIdentifier = alternateIdentifier
    def add_alternateIdentifier(self, value):
        self.alternateIdentifier.append(value)
    def insert_alternateIdentifier_at(self, index, value):
        self.alternateIdentifier.insert(index, value)
    def replace_alternateIdentifier_at(self, index, value):
        self.alternateIdentifier[index] = value
    def get_entityName(self):
        return self.entityName
    def set_entityName(self, entityName):
        self.entityName = entityName
    def get_entityDescription(self):
        return self.entityDescription
    def set_entityDescription(self, entityDescription):
        self.entityDescription = entityDescription
    def get_physical(self):
        return self.physical
    def set_physical(self, physical):
        self.physical = physical
    def add_physical(self, value):
        self.physical.append(value)
    def insert_physical_at(self, index, value):
        self.physical.insert(index, value)
    def replace_physical_at(self, index, value):
        self.physical[index] = value
    def get_coverage(self):
        return self.coverage
    def set_coverage(self, coverage):
        self.coverage = coverage
    def get_methods(self):
        return self.methods
    def set_methods(self, methods):
        self.methods = methods
    def get_additionalInfo(self):
        return self.additionalInfo
    def set_additionalInfo(self, additionalInfo):
        self.additionalInfo = additionalInfo
    def add_additionalInfo(self, value):
        self.additionalInfo.append(value)
    def insert_additionalInfo_at(self, index, value):
        self.additionalInfo.insert(index, value)
    def replace_additionalInfo_at(self, index, value):
        self.additionalInfo[index] = value
    def get_annotation(self):
        return self.annotation
    def set_annotation(self, annotation):
        self.annotation = annotation
    def add_annotation(self, value):
        self.annotation.append(value)
    def insert_annotation_at(self, index, value):
        self.annotation.insert(index, value)
    def replace_annotation_at(self, index, value):
        self.annotation[index] = value
    def get_attributeList(self):
        return self.attributeList
    def set_attributeList(self, attributeList):
        self.attributeList = attributeList
    def get_constraint(self):
        return self.constraint
    def set_constraint(self, constraint):
        self.constraint = constraint
    def add_constraint(self, value):
        self.constraint.append(value)
    def insert_constraint_at(self, index, value):
        self.constraint.insert(index, value)
    def replace_constraint_at(self, index, value):
        self.constraint[index] = value
    def get_queryStatement(self):
        return self.queryStatement
    def set_queryStatement(self, queryStatement):
        self.queryStatement = queryStatement
    def get_references(self):
        return self.references
    def set_references(self, references):
        self.references = references
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_scope(self):
        return self.scope
    def set_scope(self, scope):
        self.scope = scope
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def validate_IDType(self, value):
        # Validate type res:IDType, a restriction on xs:string.
        pass
    def validate_SystemType(self, value):
        # Validate type res:SystemType, a restriction on xs:string.
        pass
    def validate_ScopeType(self, value):
        # Validate type res:ScopeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['system', 'document']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ScopeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.alternateIdentifier or
            self.entityName is not None or
            self.entityDescription is not None or
            self.physical or
            self.coverage is not None or
            self.methods is not None or
            self.additionalInfo or
            self.annotation or
            self.attributeList is not None or
            self.constraint or
            self.queryStatement is not None or
            self.references is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0"  xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:phys="https://eml.ecoinformatics.org/physical-2.2.0"  xmlns:cov="https://eml.ecoinformatics.org/coverage-2.2.0"  xmlns:md="https://eml.ecoinformatics.org/methods-2.2.0"  xmlns:txt="https://eml.ecoinformatics.org/text-2.2.0"  xmlns:sem="https://eml.ecoinformatics.org/semantics-2.2.0"  xmlns:att="https://eml.ecoinformatics.org/attribute-2.2.0"  xmlns:con="https://eml.ecoinformatics.org/constraint-2.2.0" ', name_='ViewType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ViewType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ViewType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ViewType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ViewType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ViewType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
        if self.scope != "document" and 'scope' not in already_processed:
            already_processed.add('scope')
            outfile.write(' scope=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.scope), input_name='scope')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0"  xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:phys="https://eml.ecoinformatics.org/physical-2.2.0"  xmlns:cov="https://eml.ecoinformatics.org/coverage-2.2.0"  xmlns:md="https://eml.ecoinformatics.org/methods-2.2.0"  xmlns:txt="https://eml.ecoinformatics.org/text-2.2.0"  xmlns:sem="https://eml.ecoinformatics.org/semantics-2.2.0"  xmlns:att="https://eml.ecoinformatics.org/attribute-2.2.0"  xmlns:con="https://eml.ecoinformatics.org/constraint-2.2.0" ', name_='ViewType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for alternateIdentifier_ in self.alternateIdentifier:
            namespaceprefix_ = self.alternateIdentifier_nsprefix_ + ':' if (UseCapturedNS_ and self.alternateIdentifier_nsprefix_) else ''
            alternateIdentifier_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='alternateIdentifier', pretty_print=pretty_print)
        if self.entityName is not None:
            namespaceprefix_ = self.entityName_nsprefix_ + ':' if (UseCapturedNS_ and self.entityName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sentityName>%s</%sentityName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.entityName), input_name='entityName')), namespaceprefix_ , eol_))
        if self.entityDescription is not None:
            namespaceprefix_ = self.entityDescription_nsprefix_ + ':' if (UseCapturedNS_ and self.entityDescription_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sentityDescription>%s</%sentityDescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.entityDescription), input_name='entityDescription')), namespaceprefix_ , eol_))
        for physical_ in self.physical:
            namespaceprefix_ = self.physical_nsprefix_ + ':' if (UseCapturedNS_ and self.physical_nsprefix_) else ''
            physical_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='physical', pretty_print=pretty_print)
        if self.coverage is not None:
            namespaceprefix_ = self.coverage_nsprefix_ + ':' if (UseCapturedNS_ and self.coverage_nsprefix_) else ''
            self.coverage.export(outfile, level, namespaceprefix_, namespacedef_='', name_='coverage', pretty_print=pretty_print)
        if self.methods is not None:
            namespaceprefix_ = self.methods_nsprefix_ + ':' if (UseCapturedNS_ and self.methods_nsprefix_) else ''
            self.methods.export(outfile, level, namespaceprefix_, namespacedef_='', name_='methods', pretty_print=pretty_print)
        for additionalInfo_ in self.additionalInfo:
            namespaceprefix_ = self.additionalInfo_nsprefix_ + ':' if (UseCapturedNS_ and self.additionalInfo_nsprefix_) else ''
            additionalInfo_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='additionalInfo', pretty_print=pretty_print)
        for annotation_ in self.annotation:
            namespaceprefix_ = self.annotation_nsprefix_ + ':' if (UseCapturedNS_ and self.annotation_nsprefix_) else ''
            annotation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='annotation', pretty_print=pretty_print)
        if self.attributeList is not None:
            namespaceprefix_ = self.attributeList_nsprefix_ + ':' if (UseCapturedNS_ and self.attributeList_nsprefix_) else ''
            self.attributeList.export(outfile, level, namespaceprefix_, namespacedef_='', name_='attributeList', pretty_print=pretty_print)
        for constraint_ in self.constraint:
            namespaceprefix_ = self.constraint_nsprefix_ + ':' if (UseCapturedNS_ and self.constraint_nsprefix_) else ''
            constraint_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='constraint', pretty_print=pretty_print)
        if self.queryStatement is not None:
            namespaceprefix_ = self.queryStatement_nsprefix_ + ':' if (UseCapturedNS_ and self.queryStatement_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%squeryStatement>%s</%squeryStatement>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.queryStatement), input_name='queryStatement')), namespaceprefix_ , eol_))
        if self.references is not None:
            namespaceprefix_ = self.references_nsprefix_ + ':' if (UseCapturedNS_ and self.references_nsprefix_) else ''
            self.references.export(outfile, level, namespaceprefix_, namespacedef_='', name_='references', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_IDType(self.id)    # validate type IDType
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
        value = find_attr_value_('scope', node)
        if value is not None and 'scope' not in already_processed:
            already_processed.add('scope')
            self.scope = value
            self.validate_ScopeType(self.scope)    # validate type ScopeType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'alternateIdentifier':
            obj_ = alternateIdentifierType77.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.alternateIdentifier.append(obj_)
            obj_.original_tagname_ = 'alternateIdentifier'
        elif nodeName_ == 'entityName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'entityName')
            value_ = self.gds_validate_string(value_, node, 'entityName')
            self.entityName = value_
            self.entityName_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.entityName)
        elif nodeName_ == 'entityDescription':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'entityDescription')
            value_ = self.gds_validate_string(value_, node, 'entityDescription')
            self.entityDescription = value_
            self.entityDescription_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.entityDescription)
        elif nodeName_ == 'physical':
            obj_ = PhysicalType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.physical.append(obj_)
            obj_.original_tagname_ = 'physical'
        elif nodeName_ == 'coverage':
            obj_ = Coverage.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.coverage = obj_
            obj_.original_tagname_ = 'coverage'
        elif nodeName_ == 'methods':
            obj_ = MethodsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.methods = obj_
            obj_.original_tagname_ = 'methods'
        elif nodeName_ == 'additionalInfo':
            obj_ = TextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.additionalInfo.append(obj_)
            obj_.original_tagname_ = 'additionalInfo'
        elif nodeName_ == 'annotation':
            class_obj_ = self.get_class_obj_(child_, SemanticAnnotation)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.annotation.append(obj_)
            obj_.original_tagname_ = 'annotation'
        elif nodeName_ == 'attributeList':
            obj_ = AttributeListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.attributeList = obj_
            obj_.original_tagname_ = 'attributeList'
        elif nodeName_ == 'constraint':
            obj_ = ConstraintType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.constraint.append(obj_)
            obj_.original_tagname_ = 'constraint'
        elif nodeName_ == 'queryStatement':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'queryStatement')
            value_ = self.gds_validate_string(value_, node, 'queryStatement')
            self.queryStatement = value_
            self.queryStatement_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.queryStatement)
        elif nodeName_ == 'references':
            obj_ = referencesType78.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.references = obj_
            obj_.original_tagname_ = 'references'
# end class ViewType


class annotationsType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('annotation', 'SemanticAnnotation', 1, 0, {'maxOccurs': 'unbounded', 'minOccurs': '1', 'name': 'annotation', 'type': 'annotationType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, annotation=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if annotation is None:
            self.annotation = []
        else:
            self.annotation = annotation
        self.annotation_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, annotationsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if annotationsType.subclass:
            return annotationsType.subclass(*args_, **kwargs_)
        else:
            return annotationsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_annotation(self):
        return self.annotation
    def set_annotation(self, annotation):
        self.annotation = annotation
    def add_annotation(self, value):
        self.annotation.append(value)
    def insert_annotation_at(self, index, value):
        self.annotation.insert(index, value)
    def replace_annotation_at(self, index, value):
        self.annotation[index] = value
    def hasContent_(self):
        if (
            self.annotation
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='annotationsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('annotationsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'annotationsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='annotationsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='annotationsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='annotationsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='annotationsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for annotation_ in self.annotation:
            namespaceprefix_ = self.annotation_nsprefix_ + ':' if (UseCapturedNS_ and self.annotation_nsprefix_) else ''
            annotation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='annotation', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'annotation':
            obj_ = annotationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.annotation.append(obj_)
            obj_.original_tagname_ = 'annotation'
# end class annotationsType


class annotationType(SemanticAnnotation):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('references', 'xs:string', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = SemanticAnnotation
    def __init__(self, id=None, system=None, scope='document', propertyURI=None, valueURI=None, references=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(annotationType, self).__init__(id, system, scope, propertyURI, valueURI,  **kwargs_)
        self.references = _cast(None, references)
        self.references_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, annotationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if annotationType.subclass:
            return annotationType.subclass(*args_, **kwargs_)
        else:
            return annotationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_references(self):
        return self.references
    def set_references(self, references):
        self.references = references
    def hasContent_(self):
        if (
            super(annotationType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='annotationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('annotationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'annotationType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='annotationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='annotationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='annotationType'):
        super(annotationType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='annotationType')
        if self.references is not None and 'references' not in already_processed:
            already_processed.add('references')
            outfile.write(' references=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.references), input_name='references')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='annotationType', fromsubclass_=False, pretty_print=True):
        super(annotationType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('references', node)
        if value is not None and 'references' not in already_processed:
            already_processed.add('references')
            self.references = value
        super(annotationType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(annotationType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class annotationType


class additionalMetadataType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'res:IDType', 0, 1, {'use': 'optional'}),
        MemberSpec_('describes', ['NonEmptyStringType', 'xs:string'], 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'describes', 'type': 'xs:string'}, None),
        MemberSpec_('metadata', 'metadataType', 0, 0, {'name': 'metadata', 'type': 'metadataType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, describes=None, metadata=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        if describes is None:
            self.describes = []
        else:
            self.describes = describes
        self.describes_nsprefix_ = None
        self.metadata = metadata
        self.metadata_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, additionalMetadataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if additionalMetadataType.subclass:
            return additionalMetadataType.subclass(*args_, **kwargs_)
        else:
            return additionalMetadataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_describes(self):
        return self.describes
    def set_describes(self, describes):
        self.describes = describes
    def add_describes(self, value):
        self.describes.append(value)
    def insert_describes_at(self, index, value):
        self.describes.insert(index, value)
    def replace_describes_at(self, index, value):
        self.describes[index] = value
    def get_metadata(self):
        return self.metadata
    def set_metadata(self, metadata):
        self.metadata = metadata
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def validate_IDType(self, value):
        # Validate type res:IDType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.describes or
            self.metadata is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='additionalMetadataType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('additionalMetadataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'additionalMetadataType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='additionalMetadataType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='additionalMetadataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='additionalMetadataType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='additionalMetadataType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for describes_ in self.describes:
            namespaceprefix_ = self.describes_nsprefix_ + ':' if (UseCapturedNS_ and self.describes_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescribes>%s</%sdescribes>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(describes_), input_name='describes')), namespaceprefix_ , eol_))
        if self.metadata is not None:
            namespaceprefix_ = self.metadata_nsprefix_ + ':' if (UseCapturedNS_ and self.metadata_nsprefix_) else ''
            self.metadata.export(outfile, level, namespaceprefix_, namespacedef_='', name_='metadata', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_IDType(self.id)    # validate type IDType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'describes':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'describes')
            value_ = self.gds_validate_string(value_, node, 'describes')
            self.describes.append(value_)
            self.describes_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.describes[-1])
        elif nodeName_ == 'metadata':
            obj_ = metadataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.metadata = obj_
            obj_.original_tagname_ = 'metadata'
# end class additionalMetadataType


class metadataType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('__ANY__', '__ANY__', 0, 0, {'processContents': 'lax'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, metadataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if metadataType.subclass:
            return metadataType.subclass(*args_, **kwargs_)
        else:
            return metadataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def hasContent_(self):
        if (
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='metadataType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('metadataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'metadataType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='metadataType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='metadataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='metadataType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='metadataType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if not fromsubclass_:
            if self.anytypeobjs_ is not None:
                content_ = self.anytypeobjs_
                outfile.write(content_)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        content_ = self.gds_build_any(child_, 'metadataType')
        self.set_anytypeobjs_(content_)
# end class metadataType


class markdownType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('valueOf_', ['NonEmptyStringType', 'xs:string'], 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, markdownType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if markdownType.subclass:
            return markdownType.subclass(*args_, **kwargs_)
        else:
            return markdownType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='markdownType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('markdownType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'markdownType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='markdownType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='markdownType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='markdownType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='markdownType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class markdownType


class emphasisType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('lang', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('value', 'i18nString', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'value', 'type': 'i18nString'}, None),
        MemberSpec_('valueOf_', [], 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, lang=None, value=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.lang = _cast(None, lang)
        self.lang_nsprefix_ = None
        if value is None:
            self.value = []
        else:
            self.value = value
        self.value_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, emphasisType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if emphasisType.subclass:
            return emphasisType.subclass(*args_, **kwargs_)
        else:
            return emphasisType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def add_value(self, value):
        self.value.append(value)
    def insert_value_at(self, index, value):
        self.value.insert(index, value)
    def replace_value_at(self, index, value):
        self.value[index] = value
    def get_lang(self):
        return self.lang
    def set_lang(self, lang):
        self.lang = lang
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.value or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='emphasisType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('emphasisType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'emphasisType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='emphasisType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='emphasisType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='emphasisType'):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' xml:lang=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lang), input_name='lang')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='emphasisType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for value_ in self.value:
            namespaceprefix_ = self.value_nsprefix_ + ':' if (UseCapturedNS_ and self.value_nsprefix_) else ''
            value_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='value', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'value':
            obj_ = i18nString.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'value', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_value'):
              self.add_value(obj_.value)
            elif hasattr(self, 'set_value'):
              self.set_value(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class emphasisType


class literalLayoutType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('value', 'i18nString', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'value', 'type': 'i18nString'}, None),
        MemberSpec_('valueOf_', [], 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, value=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if value is None:
            self.value = []
        else:
            self.value = value
        self.value_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, literalLayoutType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if literalLayoutType.subclass:
            return literalLayoutType.subclass(*args_, **kwargs_)
        else:
            return literalLayoutType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def add_value(self, value):
        self.value.append(value)
    def insert_value_at(self, index, value):
        self.value.insert(index, value)
    def replace_value_at(self, index, value):
        self.value[index] = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.value or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='literalLayoutType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('literalLayoutType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'literalLayoutType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='literalLayoutType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='literalLayoutType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='literalLayoutType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='literalLayoutType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for value_ in self.value:
            namespaceprefix_ = self.value_nsprefix_ + ':' if (UseCapturedNS_ and self.value_nsprefix_) else ''
            value_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='value', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'value':
            obj_ = i18nString.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'value', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_value'):
              self.add_value(obj_.value)
            elif hasattr(self, 'set_value'):
              self.set_value(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class literalLayoutType


class ulinkType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('url', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('citetitle', 'i18nString', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'citetitle', 'type': 'i18nString'}, None),
        MemberSpec_('valueOf_', [], 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, url=None, citetitle=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.url = _cast(None, url)
        self.url_nsprefix_ = None
        if citetitle is None:
            self.citetitle = []
        else:
            self.citetitle = citetitle
        self.citetitle_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ulinkType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ulinkType.subclass:
            return ulinkType.subclass(*args_, **kwargs_)
        else:
            return ulinkType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_citetitle(self):
        return self.citetitle
    def set_citetitle(self, citetitle):
        self.citetitle = citetitle
    def add_citetitle(self, value):
        self.citetitle.append(value)
    def insert_citetitle_at(self, index, value):
        self.citetitle.insert(index, value)
    def replace_citetitle_at(self, index, value):
        self.citetitle[index] = value
    def get_url(self):
        return self.url
    def set_url(self, url):
        self.url = url
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.citetitle or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='ulinkType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ulinkType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ulinkType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ulinkType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ulinkType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ulinkType'):
        if self.url is not None and 'url' not in already_processed:
            already_processed.add('url')
            outfile.write(' url=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.url), input_name='url')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='ulinkType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for citetitle_ in self.citetitle:
            namespaceprefix_ = self.citetitle_nsprefix_ + ':' if (UseCapturedNS_ and self.citetitle_nsprefix_) else ''
            citetitle_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='citetitle', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('url', node)
        if value is not None and 'url' not in already_processed:
            already_processed.add('url')
            self.url = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'citetitle':
            obj_ = i18nString.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'citetitle', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_citetitle'):
              self.add_citetitle(obj_.value)
            elif hasattr(self, 'set_citetitle'):
              self.set_citetitle(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class ulinkType


class listitemType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('para', 'ParagraphType', 1, 0, {'name': 'para', 'type': 'ParagraphType'}, 56),
        MemberSpec_('itemizedlist', 'ListType', 1, 0, {'name': 'itemizedlist', 'type': 'ListType'}, 56),
        MemberSpec_('orderedlist', 'ListType', 1, 0, {'name': 'orderedlist', 'type': 'ListType'}, 56),
    ]
    subclass = None
    superclass = None
    def __init__(self, para=None, itemizedlist=None, orderedlist=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if para is None:
            self.para = []
        else:
            self.para = para
        self.para_nsprefix_ = None
        if itemizedlist is None:
            self.itemizedlist = []
        else:
            self.itemizedlist = itemizedlist
        self.itemizedlist_nsprefix_ = None
        if orderedlist is None:
            self.orderedlist = []
        else:
            self.orderedlist = orderedlist
        self.orderedlist_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, listitemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if listitemType.subclass:
            return listitemType.subclass(*args_, **kwargs_)
        else:
            return listitemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_para(self):
        return self.para
    def set_para(self, para):
        self.para = para
    def add_para(self, value):
        self.para.append(value)
    def insert_para_at(self, index, value):
        self.para.insert(index, value)
    def replace_para_at(self, index, value):
        self.para[index] = value
    def get_itemizedlist(self):
        return self.itemizedlist
    def set_itemizedlist(self, itemizedlist):
        self.itemizedlist = itemizedlist
    def add_itemizedlist(self, value):
        self.itemizedlist.append(value)
    def insert_itemizedlist_at(self, index, value):
        self.itemizedlist.insert(index, value)
    def replace_itemizedlist_at(self, index, value):
        self.itemizedlist[index] = value
    def get_orderedlist(self):
        return self.orderedlist
    def set_orderedlist(self, orderedlist):
        self.orderedlist = orderedlist
    def add_orderedlist(self, value):
        self.orderedlist.append(value)
    def insert_orderedlist_at(self, index, value):
        self.orderedlist.insert(index, value)
    def replace_orderedlist_at(self, index, value):
        self.orderedlist[index] = value
    def hasContent_(self):
        if (
            self.para or
            self.itemizedlist or
            self.orderedlist
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='listitemType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('listitemType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'listitemType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='listitemType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='listitemType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='listitemType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='listitemType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for para_ in self.para:
            namespaceprefix_ = self.para_nsprefix_ + ':' if (UseCapturedNS_ and self.para_nsprefix_) else ''
            para_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='para', pretty_print=pretty_print)
        for itemizedlist_ in self.itemizedlist:
            namespaceprefix_ = self.itemizedlist_nsprefix_ + ':' if (UseCapturedNS_ and self.itemizedlist_nsprefix_) else ''
            itemizedlist_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='itemizedlist', pretty_print=pretty_print)
        for orderedlist_ in self.orderedlist:
            namespaceprefix_ = self.orderedlist_nsprefix_ + ':' if (UseCapturedNS_ and self.orderedlist_nsprefix_) else ''
            orderedlist_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='orderedlist', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'para':
            obj_ = ParagraphType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.para.append(obj_)
            obj_.original_tagname_ = 'para'
        elif nodeName_ == 'itemizedlist':
            obj_ = ListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.itemizedlist.append(obj_)
            obj_.original_tagname_ = 'itemizedlist'
        elif nodeName_ == 'orderedlist':
            obj_ = ListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.orderedlist.append(obj_)
            obj_.original_tagname_ = 'orderedlist'
# end class listitemType


class alternateIdentifierType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('system', 'SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, system=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, alternateIdentifierType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if alternateIdentifierType.subclass:
            return alternateIdentifierType.subclass(*args_, **kwargs_)
        else:
            return alternateIdentifierType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_SystemType(self, value):
        # Validate type SystemType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='alternateIdentifierType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('alternateIdentifierType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'alternateIdentifierType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='alternateIdentifierType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='alternateIdentifierType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='alternateIdentifierType'):
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='alternateIdentifierType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class alternateIdentifierType


class associatedPartyType(ResponsibleParty):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('role', ['RoleType', 'xs:string'], 0, 0, {'name': 'role', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = ResponsibleParty
    def __init__(self, id=None, system=None, scope='document', individualName=None, organizationName=None, positionName=None, address=None, phone=None, electronicMailAddress=None, onlineUrl=None, userId=None, references=None, role=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(associatedPartyType, self).__init__(id, system, scope, individualName, organizationName, positionName, address, phone, electronicMailAddress, onlineUrl, userId, references,  **kwargs_)
        self.role = role
        self.validate_RoleType(self.role)
        self.role_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, associatedPartyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if associatedPartyType.subclass:
            return associatedPartyType.subclass(*args_, **kwargs_)
        else:
            return associatedPartyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_role(self):
        return self.role
    def set_role(self, role):
        self.role = role
    def validate_RoleType(self, value):
        result = True
        # Validate type RoleType, a restriction on xs:string.
        pass
        return result
    def hasContent_(self):
        if (
            self.role is not None or
            super(associatedPartyType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:rp="https://eml.ecoinformatics.org/party-2.2.0" ', name_='associatedPartyType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('associatedPartyType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'associatedPartyType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='associatedPartyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='associatedPartyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='associatedPartyType'):
        super(associatedPartyType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='associatedPartyType')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:rp="https://eml.ecoinformatics.org/party-2.2.0" ', name_='associatedPartyType', fromsubclass_=False, pretty_print=True):
        super(associatedPartyType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.role is not None:
            namespaceprefix_ = self.role_nsprefix_ + ':' if (UseCapturedNS_ and self.role_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srole>%s</%srole>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.role), input_name='role')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(associatedPartyType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'role':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'role')
            value_ = self.gds_validate_string(value_, node, 'role')
            self.role = value_
            self.role_nsprefix_ = child_.prefix
            # validate type RoleType
            self.validate_RoleType(self.role)
        super(associatedPartyType, self).buildChildren(child_, node, nodeName_, True)
# end class associatedPartyType


class keywordSetType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('keyword', 'keywordType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'keyword', 'type': 'keywordType'}, None),
        MemberSpec_('keywordThesaurus', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'keywordThesaurus', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, keyword=None, keywordThesaurus=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if keyword is None:
            self.keyword = []
        else:
            self.keyword = keyword
        self.keyword_nsprefix_ = None
        self.keywordThesaurus = keywordThesaurus
        self.validate_NonEmptyStringType(self.keywordThesaurus)
        self.keywordThesaurus_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, keywordSetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if keywordSetType.subclass:
            return keywordSetType.subclass(*args_, **kwargs_)
        else:
            return keywordSetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_keyword(self):
        return self.keyword
    def set_keyword(self, keyword):
        self.keyword = keyword
    def add_keyword(self, value):
        self.keyword.append(value)
    def insert_keyword_at(self, index, value):
        self.keyword.insert(index, value)
    def replace_keyword_at(self, index, value):
        self.keyword[index] = value
    def get_keywordThesaurus(self):
        return self.keywordThesaurus
    def set_keywordThesaurus(self, keywordThesaurus):
        self.keywordThesaurus = keywordThesaurus
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def hasContent_(self):
        if (
            self.keyword or
            self.keywordThesaurus is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='keywordSetType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('keywordSetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'keywordSetType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='keywordSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='keywordSetType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='keywordSetType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='keywordSetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for keyword_ in self.keyword:
            namespaceprefix_ = self.keyword_nsprefix_ + ':' if (UseCapturedNS_ and self.keyword_nsprefix_) else ''
            keyword_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='keyword', pretty_print=pretty_print)
        if self.keywordThesaurus is not None:
            namespaceprefix_ = self.keywordThesaurus_nsprefix_ + ':' if (UseCapturedNS_ and self.keywordThesaurus_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%skeywordThesaurus>%s</%skeywordThesaurus>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.keywordThesaurus), input_name='keywordThesaurus')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'keyword':
            obj_ = keywordType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.keyword.append(obj_)
            obj_.original_tagname_ = 'keyword'
        elif nodeName_ == 'keywordThesaurus':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'keywordThesaurus')
            value_ = self.gds_validate_string(value_, node, 'keywordThesaurus')
            self.keywordThesaurus = value_
            self.keywordThesaurus_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.keywordThesaurus)
# end class keywordSetType


class keywordType(i18nNonEmptyStringType):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('keywordType', 'KeyTypeCode', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'i18nNonEmptyStringType', 0),
    ]
    subclass = None
    superclass = i18nNonEmptyStringType
    def __init__(self, lang=None, value=None, keywordType_member=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(keywordType, self).__init__(lang, value, valueOf_, mixedclass_, content_,  **kwargs_)
        self.keywordType = _cast(None, keywordType_member)
        self.keywordType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, keywordType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if keywordType.subclass:
            return keywordType.subclass(*args_, **kwargs_)
        else:
            return keywordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_keywordType(self):
        return self.keywordType
    def set_keywordType(self, keywordType):
        self.keywordType = keywordType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_KeyTypeCode(self, value):
        # Validate type KeyTypeCode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['place', 'stratum', 'temporal', 'theme', 'taxonomic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on KeyTypeCode' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(keywordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='keywordType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('keywordType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'keywordType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='keywordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='keywordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='keywordType'):
        super(keywordType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='keywordType')
        if self.keywordType is not None and 'keywordType' not in already_processed:
            already_processed.add('keywordType')
            outfile.write(' keywordType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.keywordType), input_name='keywordType')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='keywordType', fromsubclass_=False, pretty_print=True):
        super(keywordType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('keywordType', node)
        if value is not None and 'keywordType' not in already_processed:
            already_processed.add('keywordType')
            self.keywordType = value
            self.validate_KeyTypeCode(self.keywordType)    # validate type KeyTypeCode
        super(keywordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(keywordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class keywordType


class referencesType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('system', 'SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, system=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, referencesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if referencesType.subclass:
            return referencesType.subclass(*args_, **kwargs_)
        else:
            return referencesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_SystemType(self, value):
        # Validate type SystemType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referencesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('referencesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'referencesType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='referencesType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='referencesType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='referencesType'):
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referencesType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class referencesType


class referencesType2(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('system', 'SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, system=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, referencesType2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if referencesType2.subclass:
            return referencesType2.subclass(*args_, **kwargs_)
        else:
            return referencesType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_SystemType(self, value):
        # Validate type SystemType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referencesType2', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('referencesType2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'referencesType2':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='referencesType2')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='referencesType2', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='referencesType2'):
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referencesType2', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class referencesType2


class schemeNameType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('system', 'SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, system=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, schemeNameType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if schemeNameType.subclass:
            return schemeNameType.subclass(*args_, **kwargs_)
        else:
            return schemeNameType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_SystemType(self, value):
        # Validate type SystemType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='schemeNameType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('schemeNameType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'schemeNameType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='schemeNameType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='schemeNameType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='schemeNameType'):
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='schemeNameType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class schemeNameType


class parameterDefinitionType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('name', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
        MemberSpec_('definition', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'definition', 'type': 'xs:string'}, None),
        MemberSpec_('defaultValue', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'defaultValue', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, name=None, definition=None, defaultValue=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = name
        self.validate_NonEmptyStringType(self.name)
        self.name_nsprefix_ = None
        self.definition = definition
        self.validate_NonEmptyStringType(self.definition)
        self.definition_nsprefix_ = None
        self.defaultValue = defaultValue
        self.validate_NonEmptyStringType(self.defaultValue)
        self.defaultValue_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, parameterDefinitionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if parameterDefinitionType.subclass:
            return parameterDefinitionType.subclass(*args_, **kwargs_)
        else:
            return parameterDefinitionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_definition(self):
        return self.definition
    def set_definition(self, definition):
        self.definition = definition
    def get_defaultValue(self):
        return self.defaultValue
    def set_defaultValue(self, defaultValue):
        self.defaultValue = defaultValue
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def hasContent_(self):
        if (
            self.name is not None or
            self.definition is not None or
            self.defaultValue is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='parameterDefinitionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('parameterDefinitionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'parameterDefinitionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='parameterDefinitionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='parameterDefinitionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='parameterDefinitionType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='parameterDefinitionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.definition is not None:
            namespaceprefix_ = self.definition_nsprefix_ + ':' if (UseCapturedNS_ and self.definition_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdefinition>%s</%sdefinition>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.definition), input_name='definition')), namespaceprefix_ , eol_))
        if self.defaultValue is not None:
            namespaceprefix_ = self.defaultValue_nsprefix_ + ':' if (UseCapturedNS_ and self.defaultValue_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdefaultValue>%s</%sdefaultValue>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.defaultValue), input_name='defaultValue')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.name)
        elif nodeName_ == 'definition':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'definition')
            value_ = self.gds_validate_string(value_, node, 'definition')
            self.definition = value_
            self.definition_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.definition)
        elif nodeName_ == 'defaultValue':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'defaultValue')
            value_ = self.gds_validate_string(value_, node, 'defaultValue')
            self.defaultValue = value_
            self.defaultValue_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.defaultValue)
# end class parameterDefinitionType


class referencesType3(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('system', 'SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, system=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, referencesType3)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if referencesType3.subclass:
            return referencesType3.subclass(*args_, **kwargs_)
        else:
            return referencesType3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_SystemType(self, value):
        # Validate type SystemType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referencesType3', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('referencesType3')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'referencesType3':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='referencesType3')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='referencesType3', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='referencesType3'):
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referencesType3', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class referencesType3


class parameterType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('name', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
        MemberSpec_('value', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'value', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = name
        self.validate_NonEmptyStringType(self.name)
        self.name_nsprefix_ = None
        self.value = value
        self.validate_NonEmptyStringType(self.value)
        self.value_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, parameterType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if parameterType.subclass:
            return parameterType.subclass(*args_, **kwargs_)
        else:
            return parameterType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def hasContent_(self):
        if (
            self.name is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='parameterType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('parameterType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'parameterType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='parameterType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='parameterType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='parameterType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='parameterType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.value is not None:
            namespaceprefix_ = self.value_nsprefix_ + ':' if (UseCapturedNS_ and self.value_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.value), input_name='value')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.name)
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'value')
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
            self.value_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.value)
# end class parameterType


class referencesType4(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('system', 'SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, system=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, referencesType4)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if referencesType4.subclass:
            return referencesType4.subclass(*args_, **kwargs_)
        else:
            return referencesType4(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_SystemType(self, value):
        # Validate type SystemType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referencesType4', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('referencesType4')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'referencesType4':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='referencesType4')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='referencesType4', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='referencesType4'):
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referencesType4', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class referencesType4


class valueType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('lang', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', ['NonEmptyStringType', 'xs:string'], 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, lang=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.lang = _cast(None, lang)
        self.lang_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, valueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if valueType.subclass:
            return valueType.subclass(*args_, **kwargs_)
        else:
            return valueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_lang(self):
        return self.lang
    def set_lang(self, lang):
        self.lang = lang
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='valueType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('valueType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'valueType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='valueType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='valueType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='valueType'):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' xml:lang=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lang), input_name='lang')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='valueType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class valueType


class phoneType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('phonetype', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, phonetype='voice', valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.phonetype = _cast(None, phonetype)
        self.phonetype_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, phoneType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if phoneType.subclass:
            return phoneType.subclass(*args_, **kwargs_)
        else:
            return phoneType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_phonetype(self):
        return self.phonetype
    def set_phonetype(self, phonetype):
        self.phonetype = phonetype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='phoneType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('phoneType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'phoneType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='phoneType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='phoneType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='phoneType'):
        if self.phonetype != "voice" and 'phonetype' not in already_processed:
            already_processed.add('phonetype')
            outfile.write(' phonetype=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.phonetype), input_name='phonetype')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='phoneType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('phonetype', node)
        if value is not None and 'phonetype' not in already_processed:
            already_processed.add('phonetype')
            self.phonetype = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class phoneType


class userIdType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('directory', 'xs:string', 0, 0, {'use': 'required'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, directory=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.directory = _cast(None, directory)
        self.directory_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, userIdType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if userIdType.subclass:
            return userIdType.subclass(*args_, **kwargs_)
        else:
            return userIdType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_directory(self):
        return self.directory
    def set_directory(self, directory):
        self.directory = directory
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='userIdType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('userIdType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'userIdType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='userIdType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='userIdType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='userIdType'):
        if self.directory is not None and 'directory' not in already_processed:
            already_processed.add('directory')
            outfile.write(' directory=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.directory), input_name='directory')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='userIdType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('directory', node)
        if value is not None and 'directory' not in already_processed:
            already_processed.add('directory')
            self.directory = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class userIdType


class referencesType5(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('system', 'SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, system=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, referencesType5)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if referencesType5.subclass:
            return referencesType5.subclass(*args_, **kwargs_)
        else:
            return referencesType5(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_SystemType(self, value):
        # Validate type SystemType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referencesType5', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('referencesType5')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'referencesType5':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='referencesType5')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='referencesType5', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='referencesType5'):
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referencesType5', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class referencesType5


class referencesType6(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('system', 'SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, system=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, referencesType6)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if referencesType6.subclass:
            return referencesType6.subclass(*args_, **kwargs_)
        else:
            return referencesType6(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_SystemType(self, value):
        # Validate type SystemType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referencesType6', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('referencesType6')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'referencesType6':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='referencesType6')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='referencesType6', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='referencesType6'):
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referencesType6', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class referencesType6


class temporalCoverageType(TemporalCoverage):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('system', 'res:SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('scope', 'res:ScopeType', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = TemporalCoverage
    def __init__(self, id=None, singleDateTime=None, rangeOfDates=None, references=None, system=None, scope='document', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(temporalCoverageType, self).__init__(id, singleDateTime, rangeOfDates, references,  **kwargs_)
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.scope = _cast(None, scope)
        self.scope_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, temporalCoverageType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if temporalCoverageType.subclass:
            return temporalCoverageType.subclass(*args_, **kwargs_)
        else:
            return temporalCoverageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_scope(self):
        return self.scope
    def set_scope(self, scope):
        self.scope = scope
    def validate_SystemType(self, value):
        # Validate type res:SystemType, a restriction on xs:string.
        pass
    def validate_ScopeType(self, value):
        # Validate type res:ScopeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['system', 'document']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ScopeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            super(temporalCoverageType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='temporalCoverageType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('temporalCoverageType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'temporalCoverageType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='temporalCoverageType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='temporalCoverageType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='temporalCoverageType'):
        super(temporalCoverageType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='temporalCoverageType')
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
        if self.scope != "document" and 'scope' not in already_processed:
            already_processed.add('scope')
            outfile.write(' scope=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.scope), input_name='scope')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='temporalCoverageType', fromsubclass_=False, pretty_print=True):
        super(temporalCoverageType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
        value = find_attr_value_('scope', node)
        if value is not None and 'scope' not in already_processed:
            already_processed.add('scope')
            self.scope = value
            self.validate_ScopeType(self.scope)    # validate type ScopeType
        super(temporalCoverageType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(temporalCoverageType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class temporalCoverageType


class taxonomicCoverageType(TaxonomicCoverage):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('system', 'res:SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('scope', 'res:ScopeType', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = TaxonomicCoverage
    def __init__(self, id=None, taxonomicSystem=None, generalTaxonomicCoverage=None, taxonomicClassification=None, references=None, system=None, scope='document', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(taxonomicCoverageType, self).__init__(id, taxonomicSystem, generalTaxonomicCoverage, taxonomicClassification, references,  **kwargs_)
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.scope = _cast(None, scope)
        self.scope_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, taxonomicCoverageType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if taxonomicCoverageType.subclass:
            return taxonomicCoverageType.subclass(*args_, **kwargs_)
        else:
            return taxonomicCoverageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_scope(self):
        return self.scope
    def set_scope(self, scope):
        self.scope = scope
    def validate_SystemType(self, value):
        # Validate type res:SystemType, a restriction on xs:string.
        pass
    def validate_ScopeType(self, value):
        # Validate type res:ScopeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['system', 'document']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ScopeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            super(taxonomicCoverageType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='taxonomicCoverageType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('taxonomicCoverageType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'taxonomicCoverageType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='taxonomicCoverageType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='taxonomicCoverageType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='taxonomicCoverageType'):
        super(taxonomicCoverageType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='taxonomicCoverageType')
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
        if self.scope != "document" and 'scope' not in already_processed:
            already_processed.add('scope')
            outfile.write(' scope=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.scope), input_name='scope')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='taxonomicCoverageType', fromsubclass_=False, pretty_print=True):
        super(taxonomicCoverageType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
        value = find_attr_value_('scope', node)
        if value is not None and 'scope' not in already_processed:
            already_processed.add('scope')
            self.scope = value
            self.validate_ScopeType(self.scope)    # validate type ScopeType
        super(taxonomicCoverageType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(taxonomicCoverageType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class taxonomicCoverageType


class referencesType7(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('system', 'SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, system=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, referencesType7)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if referencesType7.subclass:
            return referencesType7.subclass(*args_, **kwargs_)
        else:
            return referencesType7(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_SystemType(self, value):
        # Validate type SystemType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referencesType7', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('referencesType7')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'referencesType7':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='referencesType7')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='referencesType7', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='referencesType7'):
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referencesType7', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class referencesType7


class rangeOfDatesType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('beginDate', 'SingleDateTimeType', 0, 0, {'name': 'beginDate', 'type': 'SingleDateTimeType'}, None),
        MemberSpec_('endDate', 'SingleDateTimeType', 0, 0, {'name': 'endDate', 'type': 'SingleDateTimeType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, beginDate=None, endDate=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.beginDate = beginDate
        self.beginDate_nsprefix_ = None
        self.endDate = endDate
        self.endDate_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, rangeOfDatesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if rangeOfDatesType.subclass:
            return rangeOfDatesType.subclass(*args_, **kwargs_)
        else:
            return rangeOfDatesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_beginDate(self):
        return self.beginDate
    def set_beginDate(self, beginDate):
        self.beginDate = beginDate
    def get_endDate(self):
        return self.endDate
    def set_endDate(self, endDate):
        self.endDate = endDate
    def hasContent_(self):
        if (
            self.beginDate is not None or
            self.endDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='rangeOfDatesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('rangeOfDatesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'rangeOfDatesType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='rangeOfDatesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='rangeOfDatesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='rangeOfDatesType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='rangeOfDatesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.beginDate is not None:
            namespaceprefix_ = self.beginDate_nsprefix_ + ':' if (UseCapturedNS_ and self.beginDate_nsprefix_) else ''
            self.beginDate.export(outfile, level, namespaceprefix_, namespacedef_='', name_='beginDate', pretty_print=pretty_print)
        if self.endDate is not None:
            namespaceprefix_ = self.endDate_nsprefix_ + ':' if (UseCapturedNS_ and self.endDate_nsprefix_) else ''
            self.endDate.export(outfile, level, namespaceprefix_, namespacedef_='', name_='endDate', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'beginDate':
            obj_ = SingleDateTimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.beginDate = obj_
            obj_.original_tagname_ = 'beginDate'
        elif nodeName_ == 'endDate':
            obj_ = SingleDateTimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.endDate = obj_
            obj_.original_tagname_ = 'endDate'
# end class rangeOfDatesType


class referencesType8(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('system', 'SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, system=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, referencesType8)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if referencesType8.subclass:
            return referencesType8.subclass(*args_, **kwargs_)
        else:
            return referencesType8(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_SystemType(self, value):
        # Validate type SystemType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referencesType8', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('referencesType8')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'referencesType8':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='referencesType8')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='referencesType8', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='referencesType8'):
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referencesType8', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class referencesType8


class alternativeTimeScaleType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('timeScaleName', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'timeScaleName', 'type': 'xs:string'}, None),
        MemberSpec_('timeScaleAgeEstimate', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'timeScaleAgeEstimate', 'type': 'xs:string'}, None),
        MemberSpec_('timeScaleAgeUncertainty', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'timeScaleAgeUncertainty', 'type': 'xs:string'}, None),
        MemberSpec_('timeScaleAgeExplanation', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'timeScaleAgeExplanation', 'type': 'xs:string'}, None),
        MemberSpec_('timeScaleCitation', 'CitationType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'timeScaleCitation', 'type': 'CitationType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, timeScaleName=None, timeScaleAgeEstimate=None, timeScaleAgeUncertainty=None, timeScaleAgeExplanation=None, timeScaleCitation=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.timeScaleName = timeScaleName
        self.validate_NonEmptyStringType(self.timeScaleName)
        self.timeScaleName_nsprefix_ = None
        self.timeScaleAgeEstimate = timeScaleAgeEstimate
        self.validate_NonEmptyStringType(self.timeScaleAgeEstimate)
        self.timeScaleAgeEstimate_nsprefix_ = None
        self.timeScaleAgeUncertainty = timeScaleAgeUncertainty
        self.validate_NonEmptyStringType(self.timeScaleAgeUncertainty)
        self.timeScaleAgeUncertainty_nsprefix_ = None
        self.timeScaleAgeExplanation = timeScaleAgeExplanation
        self.validate_NonEmptyStringType(self.timeScaleAgeExplanation)
        self.timeScaleAgeExplanation_nsprefix_ = None
        if timeScaleCitation is None:
            self.timeScaleCitation = []
        else:
            self.timeScaleCitation = timeScaleCitation
        self.timeScaleCitation_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, alternativeTimeScaleType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if alternativeTimeScaleType.subclass:
            return alternativeTimeScaleType.subclass(*args_, **kwargs_)
        else:
            return alternativeTimeScaleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_timeScaleName(self):
        return self.timeScaleName
    def set_timeScaleName(self, timeScaleName):
        self.timeScaleName = timeScaleName
    def get_timeScaleAgeEstimate(self):
        return self.timeScaleAgeEstimate
    def set_timeScaleAgeEstimate(self, timeScaleAgeEstimate):
        self.timeScaleAgeEstimate = timeScaleAgeEstimate
    def get_timeScaleAgeUncertainty(self):
        return self.timeScaleAgeUncertainty
    def set_timeScaleAgeUncertainty(self, timeScaleAgeUncertainty):
        self.timeScaleAgeUncertainty = timeScaleAgeUncertainty
    def get_timeScaleAgeExplanation(self):
        return self.timeScaleAgeExplanation
    def set_timeScaleAgeExplanation(self, timeScaleAgeExplanation):
        self.timeScaleAgeExplanation = timeScaleAgeExplanation
    def get_timeScaleCitation(self):
        return self.timeScaleCitation
    def set_timeScaleCitation(self, timeScaleCitation):
        self.timeScaleCitation = timeScaleCitation
    def add_timeScaleCitation(self, value):
        self.timeScaleCitation.append(value)
    def insert_timeScaleCitation_at(self, index, value):
        self.timeScaleCitation.insert(index, value)
    def replace_timeScaleCitation_at(self, index, value):
        self.timeScaleCitation[index] = value
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def hasContent_(self):
        if (
            self.timeScaleName is not None or
            self.timeScaleAgeEstimate is not None or
            self.timeScaleAgeUncertainty is not None or
            self.timeScaleAgeExplanation is not None or
            self.timeScaleCitation
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:cit="https://eml.ecoinformatics.org/literature-2.2.0" ', name_='alternativeTimeScaleType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('alternativeTimeScaleType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'alternativeTimeScaleType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='alternativeTimeScaleType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='alternativeTimeScaleType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='alternativeTimeScaleType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:cit="https://eml.ecoinformatics.org/literature-2.2.0" ', name_='alternativeTimeScaleType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.timeScaleName is not None:
            namespaceprefix_ = self.timeScaleName_nsprefix_ + ':' if (UseCapturedNS_ and self.timeScaleName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stimeScaleName>%s</%stimeScaleName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.timeScaleName), input_name='timeScaleName')), namespaceprefix_ , eol_))
        if self.timeScaleAgeEstimate is not None:
            namespaceprefix_ = self.timeScaleAgeEstimate_nsprefix_ + ':' if (UseCapturedNS_ and self.timeScaleAgeEstimate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stimeScaleAgeEstimate>%s</%stimeScaleAgeEstimate>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.timeScaleAgeEstimate), input_name='timeScaleAgeEstimate')), namespaceprefix_ , eol_))
        if self.timeScaleAgeUncertainty is not None:
            namespaceprefix_ = self.timeScaleAgeUncertainty_nsprefix_ + ':' if (UseCapturedNS_ and self.timeScaleAgeUncertainty_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stimeScaleAgeUncertainty>%s</%stimeScaleAgeUncertainty>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.timeScaleAgeUncertainty), input_name='timeScaleAgeUncertainty')), namespaceprefix_ , eol_))
        if self.timeScaleAgeExplanation is not None:
            namespaceprefix_ = self.timeScaleAgeExplanation_nsprefix_ + ':' if (UseCapturedNS_ and self.timeScaleAgeExplanation_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stimeScaleAgeExplanation>%s</%stimeScaleAgeExplanation>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.timeScaleAgeExplanation), input_name='timeScaleAgeExplanation')), namespaceprefix_ , eol_))
        for timeScaleCitation_ in self.timeScaleCitation:
            namespaceprefix_ = self.timeScaleCitation_nsprefix_ + ':' if (UseCapturedNS_ and self.timeScaleCitation_nsprefix_) else ''
            timeScaleCitation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='timeScaleCitation', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'timeScaleName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'timeScaleName')
            value_ = self.gds_validate_string(value_, node, 'timeScaleName')
            self.timeScaleName = value_
            self.timeScaleName_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.timeScaleName)
        elif nodeName_ == 'timeScaleAgeEstimate':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'timeScaleAgeEstimate')
            value_ = self.gds_validate_string(value_, node, 'timeScaleAgeEstimate')
            self.timeScaleAgeEstimate = value_
            self.timeScaleAgeEstimate_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.timeScaleAgeEstimate)
        elif nodeName_ == 'timeScaleAgeUncertainty':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'timeScaleAgeUncertainty')
            value_ = self.gds_validate_string(value_, node, 'timeScaleAgeUncertainty')
            self.timeScaleAgeUncertainty = value_
            self.timeScaleAgeUncertainty_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.timeScaleAgeUncertainty)
        elif nodeName_ == 'timeScaleAgeExplanation':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'timeScaleAgeExplanation')
            value_ = self.gds_validate_string(value_, node, 'timeScaleAgeExplanation')
            self.timeScaleAgeExplanation = value_
            self.timeScaleAgeExplanation_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.timeScaleAgeExplanation)
        elif nodeName_ == 'timeScaleCitation':
            obj_ = CitationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.timeScaleCitation.append(obj_)
            obj_.original_tagname_ = 'timeScaleCitation'
# end class alternativeTimeScaleType


class boundingCoordinatesType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('westBoundingCoordinate', ['westBoundingCoordinateType', 'xs:decimal'], 0, 0, {'name': 'westBoundingCoordinate', 'type': 'xs:decimal'}, None),
        MemberSpec_('eastBoundingCoordinate', ['eastBoundingCoordinateType', 'xs:decimal'], 0, 0, {'name': 'eastBoundingCoordinate', 'type': 'xs:decimal'}, None),
        MemberSpec_('northBoundingCoordinate', ['northBoundingCoordinateType', 'xs:decimal'], 0, 0, {'name': 'northBoundingCoordinate', 'type': 'xs:decimal'}, None),
        MemberSpec_('southBoundingCoordinate', ['southBoundingCoordinateType', 'xs:decimal'], 0, 0, {'name': 'southBoundingCoordinate', 'type': 'xs:decimal'}, None),
        MemberSpec_('boundingAltitudes', 'boundingAltitudesType', 0, 1, {'minOccurs': '0', 'name': 'boundingAltitudes', 'type': 'boundingAltitudesType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, westBoundingCoordinate=None, eastBoundingCoordinate=None, northBoundingCoordinate=None, southBoundingCoordinate=None, boundingAltitudes=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.westBoundingCoordinate = westBoundingCoordinate
        self.validate_westBoundingCoordinateType(self.westBoundingCoordinate)
        self.westBoundingCoordinate_nsprefix_ = None
        self.eastBoundingCoordinate = eastBoundingCoordinate
        self.validate_eastBoundingCoordinateType(self.eastBoundingCoordinate)
        self.eastBoundingCoordinate_nsprefix_ = None
        self.northBoundingCoordinate = northBoundingCoordinate
        self.validate_northBoundingCoordinateType(self.northBoundingCoordinate)
        self.northBoundingCoordinate_nsprefix_ = None
        self.southBoundingCoordinate = southBoundingCoordinate
        self.validate_southBoundingCoordinateType(self.southBoundingCoordinate)
        self.southBoundingCoordinate_nsprefix_ = None
        self.boundingAltitudes = boundingAltitudes
        self.boundingAltitudes_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, boundingCoordinatesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if boundingCoordinatesType.subclass:
            return boundingCoordinatesType.subclass(*args_, **kwargs_)
        else:
            return boundingCoordinatesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_westBoundingCoordinate(self):
        return self.westBoundingCoordinate
    def set_westBoundingCoordinate(self, westBoundingCoordinate):
        self.westBoundingCoordinate = westBoundingCoordinate
    def get_eastBoundingCoordinate(self):
        return self.eastBoundingCoordinate
    def set_eastBoundingCoordinate(self, eastBoundingCoordinate):
        self.eastBoundingCoordinate = eastBoundingCoordinate
    def get_northBoundingCoordinate(self):
        return self.northBoundingCoordinate
    def set_northBoundingCoordinate(self, northBoundingCoordinate):
        self.northBoundingCoordinate = northBoundingCoordinate
    def get_southBoundingCoordinate(self):
        return self.southBoundingCoordinate
    def set_southBoundingCoordinate(self, southBoundingCoordinate):
        self.southBoundingCoordinate = southBoundingCoordinate
    def get_boundingAltitudes(self):
        return self.boundingAltitudes
    def set_boundingAltitudes(self, boundingAltitudes):
        self.boundingAltitudes = boundingAltitudes
    def validate_westBoundingCoordinateType(self, value):
        result = True
        # Validate type westBoundingCoordinateType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value < -180.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on westBoundingCoordinateType' % {"value": value, "lineno": lineno} )
                result = False
            if value > 180.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on westBoundingCoordinateType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_eastBoundingCoordinateType(self, value):
        result = True
        # Validate type eastBoundingCoordinateType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value < -180.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on eastBoundingCoordinateType' % {"value": value, "lineno": lineno} )
                result = False
            if value > 180.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on eastBoundingCoordinateType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_northBoundingCoordinateType(self, value):
        result = True
        # Validate type northBoundingCoordinateType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value < -90.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on northBoundingCoordinateType' % {"value": value, "lineno": lineno} )
                result = False
            if value > 90.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on northBoundingCoordinateType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_southBoundingCoordinateType(self, value):
        result = True
        # Validate type southBoundingCoordinateType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value < -90.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on southBoundingCoordinateType' % {"value": value, "lineno": lineno} )
                result = False
            if value > 90.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on southBoundingCoordinateType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.westBoundingCoordinate is not None or
            self.eastBoundingCoordinate is not None or
            self.northBoundingCoordinate is not None or
            self.southBoundingCoordinate is not None or
            self.boundingAltitudes is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='boundingCoordinatesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('boundingCoordinatesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'boundingCoordinatesType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='boundingCoordinatesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='boundingCoordinatesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='boundingCoordinatesType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='boundingCoordinatesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.westBoundingCoordinate is not None:
            namespaceprefix_ = self.westBoundingCoordinate_nsprefix_ + ':' if (UseCapturedNS_ and self.westBoundingCoordinate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%swestBoundingCoordinate>%s</%swestBoundingCoordinate>%s' % (namespaceprefix_ , self.gds_format_decimal(self.westBoundingCoordinate, input_name='westBoundingCoordinate'), namespaceprefix_ , eol_))
        if self.eastBoundingCoordinate is not None:
            namespaceprefix_ = self.eastBoundingCoordinate_nsprefix_ + ':' if (UseCapturedNS_ and self.eastBoundingCoordinate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%seastBoundingCoordinate>%s</%seastBoundingCoordinate>%s' % (namespaceprefix_ , self.gds_format_decimal(self.eastBoundingCoordinate, input_name='eastBoundingCoordinate'), namespaceprefix_ , eol_))
        if self.northBoundingCoordinate is not None:
            namespaceprefix_ = self.northBoundingCoordinate_nsprefix_ + ':' if (UseCapturedNS_ and self.northBoundingCoordinate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snorthBoundingCoordinate>%s</%snorthBoundingCoordinate>%s' % (namespaceprefix_ , self.gds_format_decimal(self.northBoundingCoordinate, input_name='northBoundingCoordinate'), namespaceprefix_ , eol_))
        if self.southBoundingCoordinate is not None:
            namespaceprefix_ = self.southBoundingCoordinate_nsprefix_ + ':' if (UseCapturedNS_ and self.southBoundingCoordinate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssouthBoundingCoordinate>%s</%ssouthBoundingCoordinate>%s' % (namespaceprefix_ , self.gds_format_decimal(self.southBoundingCoordinate, input_name='southBoundingCoordinate'), namespaceprefix_ , eol_))
        if self.boundingAltitudes is not None:
            namespaceprefix_ = self.boundingAltitudes_nsprefix_ + ':' if (UseCapturedNS_ and self.boundingAltitudes_nsprefix_) else ''
            self.boundingAltitudes.export(outfile, level, namespaceprefix_, namespacedef_='', name_='boundingAltitudes', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'westBoundingCoordinate' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'westBoundingCoordinate')
            fval_ = self.gds_validate_decimal(fval_, node, 'westBoundingCoordinate')
            self.westBoundingCoordinate = fval_
            self.westBoundingCoordinate_nsprefix_ = child_.prefix
            # validate type westBoundingCoordinateType
            self.validate_westBoundingCoordinateType(self.westBoundingCoordinate)
        elif nodeName_ == 'eastBoundingCoordinate' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'eastBoundingCoordinate')
            fval_ = self.gds_validate_decimal(fval_, node, 'eastBoundingCoordinate')
            self.eastBoundingCoordinate = fval_
            self.eastBoundingCoordinate_nsprefix_ = child_.prefix
            # validate type eastBoundingCoordinateType
            self.validate_eastBoundingCoordinateType(self.eastBoundingCoordinate)
        elif nodeName_ == 'northBoundingCoordinate' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'northBoundingCoordinate')
            fval_ = self.gds_validate_decimal(fval_, node, 'northBoundingCoordinate')
            self.northBoundingCoordinate = fval_
            self.northBoundingCoordinate_nsprefix_ = child_.prefix
            # validate type northBoundingCoordinateType
            self.validate_northBoundingCoordinateType(self.northBoundingCoordinate)
        elif nodeName_ == 'southBoundingCoordinate' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'southBoundingCoordinate')
            fval_ = self.gds_validate_decimal(fval_, node, 'southBoundingCoordinate')
            self.southBoundingCoordinate = fval_
            self.southBoundingCoordinate_nsprefix_ = child_.prefix
            # validate type southBoundingCoordinateType
            self.validate_southBoundingCoordinateType(self.southBoundingCoordinate)
        elif nodeName_ == 'boundingAltitudes':
            obj_ = boundingAltitudesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.boundingAltitudes = obj_
            obj_.original_tagname_ = 'boundingAltitudes'
# end class boundingCoordinatesType


class boundingAltitudesType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('altitudeMinimum', 'xs:decimal', 0, 0, {'name': 'altitudeMinimum', 'type': 'xs:decimal'}, None),
        MemberSpec_('altitudeMaximum', 'xs:decimal', 0, 0, {'name': 'altitudeMaximum', 'type': 'xs:decimal'}, None),
        MemberSpec_('altitudeUnits', ['LengthUnitType', 'xs:string'], 0, 0, {'name': 'altitudeUnits', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, altitudeMinimum=None, altitudeMaximum=None, altitudeUnits=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.altitudeMinimum = altitudeMinimum
        self.altitudeMinimum_nsprefix_ = None
        self.altitudeMaximum = altitudeMaximum
        self.altitudeMaximum_nsprefix_ = None
        self.altitudeUnits = altitudeUnits
        self.validate_LengthUnitType(self.altitudeUnits)
        self.altitudeUnits_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, boundingAltitudesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if boundingAltitudesType.subclass:
            return boundingAltitudesType.subclass(*args_, **kwargs_)
        else:
            return boundingAltitudesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_altitudeMinimum(self):
        return self.altitudeMinimum
    def set_altitudeMinimum(self, altitudeMinimum):
        self.altitudeMinimum = altitudeMinimum
    def get_altitudeMaximum(self):
        return self.altitudeMaximum
    def set_altitudeMaximum(self, altitudeMaximum):
        self.altitudeMaximum = altitudeMaximum
    def get_altitudeUnits(self):
        return self.altitudeUnits
    def set_altitudeUnits(self, altitudeUnits):
        self.altitudeUnits = altitudeUnits
    def validate_LengthUnitType(self, value):
        result = True
        # Validate type LengthUnitType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['meter', 'nanometer', 'micrometer', 'micron', 'millimeter', 'centimeter', 'decimeter', 'dekameter', 'hectometer', 'kilometer', 'megameter', 'angstrom', 'inch', 'Foot_US', 'foot', 'Foot_Gold_Coast', 'fathom', 'nauticalMile', 'yard', 'Yard_Indian', 'Link_Clarke', 'Yard_Sears', 'mile']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on LengthUnitType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.altitudeMinimum is not None or
            self.altitudeMaximum is not None or
            self.altitudeUnits is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0"  xmlns:unit="https://eml.ecoinformatics.org/units-2.2.0" ', name_='boundingAltitudesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('boundingAltitudesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'boundingAltitudesType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='boundingAltitudesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='boundingAltitudesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='boundingAltitudesType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0"  xmlns:unit="https://eml.ecoinformatics.org/units-2.2.0" ', name_='boundingAltitudesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.altitudeMinimum is not None:
            namespaceprefix_ = self.altitudeMinimum_nsprefix_ + ':' if (UseCapturedNS_ and self.altitudeMinimum_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saltitudeMinimum>%s</%saltitudeMinimum>%s' % (namespaceprefix_ , self.gds_format_decimal(self.altitudeMinimum, input_name='altitudeMinimum'), namespaceprefix_ , eol_))
        if self.altitudeMaximum is not None:
            namespaceprefix_ = self.altitudeMaximum_nsprefix_ + ':' if (UseCapturedNS_ and self.altitudeMaximum_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saltitudeMaximum>%s</%saltitudeMaximum>%s' % (namespaceprefix_ , self.gds_format_decimal(self.altitudeMaximum, input_name='altitudeMaximum'), namespaceprefix_ , eol_))
        if self.altitudeUnits is not None:
            namespaceprefix_ = self.altitudeUnits_nsprefix_ + ':' if (UseCapturedNS_ and self.altitudeUnits_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saltitudeUnits>%s</%saltitudeUnits>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.altitudeUnits), input_name='altitudeUnits')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'altitudeMinimum' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'altitudeMinimum')
            fval_ = self.gds_validate_decimal(fval_, node, 'altitudeMinimum')
            self.altitudeMinimum = fval_
            self.altitudeMinimum_nsprefix_ = child_.prefix
        elif nodeName_ == 'altitudeMaximum' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'altitudeMaximum')
            fval_ = self.gds_validate_decimal(fval_, node, 'altitudeMaximum')
            self.altitudeMaximum = fval_
            self.altitudeMaximum_nsprefix_ = child_.prefix
        elif nodeName_ == 'altitudeUnits':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'altitudeUnits')
            value_ = self.gds_validate_string(value_, node, 'altitudeUnits')
            self.altitudeUnits = value_
            self.altitudeUnits_nsprefix_ = child_.prefix
            # validate type LengthUnitType
            self.validate_LengthUnitType(self.altitudeUnits)
# end class boundingAltitudesType


class datasetGPolygonType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('datasetGPolygonOuterGRing', 'datasetGPolygonOuterGRingType', 0, 0, {'name': 'datasetGPolygonOuterGRing', 'type': 'datasetGPolygonOuterGRingType'}, None),
        MemberSpec_('datasetGPolygonExclusionGRing', 'datasetGPolygonExclusionGRingType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'datasetGPolygonExclusionGRing', 'type': 'datasetGPolygonExclusionGRingType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, datasetGPolygonOuterGRing=None, datasetGPolygonExclusionGRing=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.datasetGPolygonOuterGRing = datasetGPolygonOuterGRing
        self.datasetGPolygonOuterGRing_nsprefix_ = None
        if datasetGPolygonExclusionGRing is None:
            self.datasetGPolygonExclusionGRing = []
        else:
            self.datasetGPolygonExclusionGRing = datasetGPolygonExclusionGRing
        self.datasetGPolygonExclusionGRing_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, datasetGPolygonType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if datasetGPolygonType.subclass:
            return datasetGPolygonType.subclass(*args_, **kwargs_)
        else:
            return datasetGPolygonType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_datasetGPolygonOuterGRing(self):
        return self.datasetGPolygonOuterGRing
    def set_datasetGPolygonOuterGRing(self, datasetGPolygonOuterGRing):
        self.datasetGPolygonOuterGRing = datasetGPolygonOuterGRing
    def get_datasetGPolygonExclusionGRing(self):
        return self.datasetGPolygonExclusionGRing
    def set_datasetGPolygonExclusionGRing(self, datasetGPolygonExclusionGRing):
        self.datasetGPolygonExclusionGRing = datasetGPolygonExclusionGRing
    def add_datasetGPolygonExclusionGRing(self, value):
        self.datasetGPolygonExclusionGRing.append(value)
    def insert_datasetGPolygonExclusionGRing_at(self, index, value):
        self.datasetGPolygonExclusionGRing.insert(index, value)
    def replace_datasetGPolygonExclusionGRing_at(self, index, value):
        self.datasetGPolygonExclusionGRing[index] = value
    def hasContent_(self):
        if (
            self.datasetGPolygonOuterGRing is not None or
            self.datasetGPolygonExclusionGRing
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='datasetGPolygonType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('datasetGPolygonType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'datasetGPolygonType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='datasetGPolygonType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='datasetGPolygonType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='datasetGPolygonType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='datasetGPolygonType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.datasetGPolygonOuterGRing is not None:
            namespaceprefix_ = self.datasetGPolygonOuterGRing_nsprefix_ + ':' if (UseCapturedNS_ and self.datasetGPolygonOuterGRing_nsprefix_) else ''
            self.datasetGPolygonOuterGRing.export(outfile, level, namespaceprefix_, namespacedef_='', name_='datasetGPolygonOuterGRing', pretty_print=pretty_print)
        for datasetGPolygonExclusionGRing_ in self.datasetGPolygonExclusionGRing:
            namespaceprefix_ = self.datasetGPolygonExclusionGRing_nsprefix_ + ':' if (UseCapturedNS_ and self.datasetGPolygonExclusionGRing_nsprefix_) else ''
            datasetGPolygonExclusionGRing_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='datasetGPolygonExclusionGRing', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'datasetGPolygonOuterGRing':
            obj_ = datasetGPolygonOuterGRingType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.datasetGPolygonOuterGRing = obj_
            obj_.original_tagname_ = 'datasetGPolygonOuterGRing'
        elif nodeName_ == 'datasetGPolygonExclusionGRing':
            obj_ = datasetGPolygonExclusionGRingType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.datasetGPolygonExclusionGRing.append(obj_)
            obj_.original_tagname_ = 'datasetGPolygonExclusionGRing'
# end class datasetGPolygonType


class datasetGPolygonOuterGRingType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('gRingPoint', 'GRingPointType', 1, 0, {'maxOccurs': 'unbounded', 'minOccurs': '3', 'name': 'gRingPoint', 'type': 'GRingPointType'}, 57),
        MemberSpec_('gRing', ['GRingType', 'xs:string'], 0, 0, {'name': 'gRing', 'type': 'xs:string'}, 57),
    ]
    subclass = None
    superclass = None
    def __init__(self, gRingPoint=None, gRing=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if gRingPoint is None:
            self.gRingPoint = []
        else:
            self.gRingPoint = gRingPoint
        self.gRingPoint_nsprefix_ = None
        self.gRing = gRing
        self.validate_GRingType(self.gRing)
        self.gRing_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, datasetGPolygonOuterGRingType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if datasetGPolygonOuterGRingType.subclass:
            return datasetGPolygonOuterGRingType.subclass(*args_, **kwargs_)
        else:
            return datasetGPolygonOuterGRingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_gRingPoint(self):
        return self.gRingPoint
    def set_gRingPoint(self, gRingPoint):
        self.gRingPoint = gRingPoint
    def add_gRingPoint(self, value):
        self.gRingPoint.append(value)
    def insert_gRingPoint_at(self, index, value):
        self.gRingPoint.insert(index, value)
    def replace_gRingPoint_at(self, index, value):
        self.gRingPoint[index] = value
    def get_gRing(self):
        return self.gRing
    def set_gRing(self, gRing):
        self.gRing = gRing
    def validate_GRingType(self, value):
        result = True
        # Validate type GRingType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def hasContent_(self):
        if (
            self.gRingPoint or
            self.gRing is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='datasetGPolygonOuterGRingType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('datasetGPolygonOuterGRingType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'datasetGPolygonOuterGRingType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='datasetGPolygonOuterGRingType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='datasetGPolygonOuterGRingType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='datasetGPolygonOuterGRingType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='datasetGPolygonOuterGRingType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for gRingPoint_ in self.gRingPoint:
            namespaceprefix_ = self.gRingPoint_nsprefix_ + ':' if (UseCapturedNS_ and self.gRingPoint_nsprefix_) else ''
            gRingPoint_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='gRingPoint', pretty_print=pretty_print)
        if self.gRing is not None:
            namespaceprefix_ = self.gRing_nsprefix_ + ':' if (UseCapturedNS_ and self.gRing_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgRing>%s</%sgRing>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.gRing), input_name='gRing')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'gRingPoint':
            obj_ = GRingPointType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.gRingPoint.append(obj_)
            obj_.original_tagname_ = 'gRingPoint'
        elif nodeName_ == 'gRing':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'gRing')
            value_ = self.gds_validate_string(value_, node, 'gRing')
            self.gRing = value_
            self.gRing_nsprefix_ = child_.prefix
            # validate type GRingType
            self.validate_GRingType(self.gRing)
# end class datasetGPolygonOuterGRingType


class datasetGPolygonExclusionGRingType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('gRingPoint', 'GRingPointType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'gRingPoint', 'type': 'GRingPointType'}, 58),
        MemberSpec_('gRing', ['GRingType', 'xs:string'], 0, 0, {'name': 'gRing', 'type': 'xs:string'}, 58),
    ]
    subclass = None
    superclass = None
    def __init__(self, gRingPoint=None, gRing=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if gRingPoint is None:
            self.gRingPoint = []
        else:
            self.gRingPoint = gRingPoint
        self.gRingPoint_nsprefix_ = None
        self.gRing = gRing
        self.validate_GRingType(self.gRing)
        self.gRing_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, datasetGPolygonExclusionGRingType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if datasetGPolygonExclusionGRingType.subclass:
            return datasetGPolygonExclusionGRingType.subclass(*args_, **kwargs_)
        else:
            return datasetGPolygonExclusionGRingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_gRingPoint(self):
        return self.gRingPoint
    def set_gRingPoint(self, gRingPoint):
        self.gRingPoint = gRingPoint
    def add_gRingPoint(self, value):
        self.gRingPoint.append(value)
    def insert_gRingPoint_at(self, index, value):
        self.gRingPoint.insert(index, value)
    def replace_gRingPoint_at(self, index, value):
        self.gRingPoint[index] = value
    def get_gRing(self):
        return self.gRing
    def set_gRing(self, gRing):
        self.gRing = gRing
    def validate_GRingType(self, value):
        result = True
        # Validate type GRingType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def hasContent_(self):
        if (
            self.gRingPoint or
            self.gRing is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='datasetGPolygonExclusionGRingType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('datasetGPolygonExclusionGRingType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'datasetGPolygonExclusionGRingType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='datasetGPolygonExclusionGRingType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='datasetGPolygonExclusionGRingType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='datasetGPolygonExclusionGRingType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='datasetGPolygonExclusionGRingType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for gRingPoint_ in self.gRingPoint:
            namespaceprefix_ = self.gRingPoint_nsprefix_ + ':' if (UseCapturedNS_ and self.gRingPoint_nsprefix_) else ''
            gRingPoint_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='gRingPoint', pretty_print=pretty_print)
        if self.gRing is not None:
            namespaceprefix_ = self.gRing_nsprefix_ + ':' if (UseCapturedNS_ and self.gRing_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgRing>%s</%sgRing>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.gRing), input_name='gRing')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'gRingPoint':
            obj_ = GRingPointType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.gRingPoint.append(obj_)
            obj_.original_tagname_ = 'gRingPoint'
        elif nodeName_ == 'gRing':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'gRing')
            value_ = self.gds_validate_string(value_, node, 'gRing')
            self.gRing = value_
            self.gRing_nsprefix_ = child_.prefix
            # validate type GRingType
            self.validate_GRingType(self.gRing)
# end class datasetGPolygonExclusionGRingType


class referencesType9(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('system', 'SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, system=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, referencesType9)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if referencesType9.subclass:
            return referencesType9.subclass(*args_, **kwargs_)
        else:
            return referencesType9(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_SystemType(self, value):
        # Validate type SystemType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referencesType9', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('referencesType9')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'referencesType9':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='referencesType9')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='referencesType9', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='referencesType9'):
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referencesType9', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class referencesType9


class taxonomicSystemType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('classificationSystem', 'classificationSystemType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'classificationSystem', 'type': 'classificationSystemType'}, None),
        MemberSpec_('identificationReference', 'CitationType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'identificationReference', 'type': 'CitationType'}, None),
        MemberSpec_('identifierName', 'ResponsibleParty', 1, 0, {'maxOccurs': 'unbounded', 'name': 'identifierName', 'type': 'ResponsibleParty'}, None),
        MemberSpec_('taxonomicProcedures', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'taxonomicProcedures', 'type': 'xs:string'}, None),
        MemberSpec_('taxonomicCompleteness', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'taxonomicCompleteness', 'type': 'xs:string'}, None),
        MemberSpec_('vouchers', 'vouchersType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'vouchers', 'type': 'vouchersType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, classificationSystem=None, identificationReference=None, identifierName=None, taxonomicProcedures=None, taxonomicCompleteness=None, vouchers=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if classificationSystem is None:
            self.classificationSystem = []
        else:
            self.classificationSystem = classificationSystem
        self.classificationSystem_nsprefix_ = None
        if identificationReference is None:
            self.identificationReference = []
        else:
            self.identificationReference = identificationReference
        self.identificationReference_nsprefix_ = None
        if identifierName is None:
            self.identifierName = []
        else:
            self.identifierName = identifierName
        self.identifierName_nsprefix_ = None
        self.taxonomicProcedures = taxonomicProcedures
        self.validate_NonEmptyStringType(self.taxonomicProcedures)
        self.taxonomicProcedures_nsprefix_ = None
        self.taxonomicCompleteness = taxonomicCompleteness
        self.validate_NonEmptyStringType(self.taxonomicCompleteness)
        self.taxonomicCompleteness_nsprefix_ = None
        if vouchers is None:
            self.vouchers = []
        else:
            self.vouchers = vouchers
        self.vouchers_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, taxonomicSystemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if taxonomicSystemType.subclass:
            return taxonomicSystemType.subclass(*args_, **kwargs_)
        else:
            return taxonomicSystemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_classificationSystem(self):
        return self.classificationSystem
    def set_classificationSystem(self, classificationSystem):
        self.classificationSystem = classificationSystem
    def add_classificationSystem(self, value):
        self.classificationSystem.append(value)
    def insert_classificationSystem_at(self, index, value):
        self.classificationSystem.insert(index, value)
    def replace_classificationSystem_at(self, index, value):
        self.classificationSystem[index] = value
    def get_identificationReference(self):
        return self.identificationReference
    def set_identificationReference(self, identificationReference):
        self.identificationReference = identificationReference
    def add_identificationReference(self, value):
        self.identificationReference.append(value)
    def insert_identificationReference_at(self, index, value):
        self.identificationReference.insert(index, value)
    def replace_identificationReference_at(self, index, value):
        self.identificationReference[index] = value
    def get_identifierName(self):
        return self.identifierName
    def set_identifierName(self, identifierName):
        self.identifierName = identifierName
    def add_identifierName(self, value):
        self.identifierName.append(value)
    def insert_identifierName_at(self, index, value):
        self.identifierName.insert(index, value)
    def replace_identifierName_at(self, index, value):
        self.identifierName[index] = value
    def get_taxonomicProcedures(self):
        return self.taxonomicProcedures
    def set_taxonomicProcedures(self, taxonomicProcedures):
        self.taxonomicProcedures = taxonomicProcedures
    def get_taxonomicCompleteness(self):
        return self.taxonomicCompleteness
    def set_taxonomicCompleteness(self, taxonomicCompleteness):
        self.taxonomicCompleteness = taxonomicCompleteness
    def get_vouchers(self):
        return self.vouchers
    def set_vouchers(self, vouchers):
        self.vouchers = vouchers
    def add_vouchers(self, value):
        self.vouchers.append(value)
    def insert_vouchers_at(self, index, value):
        self.vouchers.insert(index, value)
    def replace_vouchers_at(self, index, value):
        self.vouchers[index] = value
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def hasContent_(self):
        if (
            self.classificationSystem or
            self.identificationReference or
            self.identifierName or
            self.taxonomicProcedures is not None or
            self.taxonomicCompleteness is not None or
            self.vouchers
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0"  xmlns:cit="https://eml.ecoinformatics.org/literature-2.2.0"  xmlns:rp="https://eml.ecoinformatics.org/party-2.2.0"  xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='taxonomicSystemType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('taxonomicSystemType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'taxonomicSystemType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='taxonomicSystemType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='taxonomicSystemType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='taxonomicSystemType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0"  xmlns:cit="https://eml.ecoinformatics.org/literature-2.2.0"  xmlns:rp="https://eml.ecoinformatics.org/party-2.2.0"  xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='taxonomicSystemType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for classificationSystem_ in self.classificationSystem:
            namespaceprefix_ = self.classificationSystem_nsprefix_ + ':' if (UseCapturedNS_ and self.classificationSystem_nsprefix_) else ''
            classificationSystem_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='classificationSystem', pretty_print=pretty_print)
        for identificationReference_ in self.identificationReference:
            namespaceprefix_ = self.identificationReference_nsprefix_ + ':' if (UseCapturedNS_ and self.identificationReference_nsprefix_) else ''
            identificationReference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='identificationReference', pretty_print=pretty_print)
        for identifierName_ in self.identifierName:
            namespaceprefix_ = self.identifierName_nsprefix_ + ':' if (UseCapturedNS_ and self.identifierName_nsprefix_) else ''
            identifierName_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='identifierName', pretty_print=pretty_print)
        if self.taxonomicProcedures is not None:
            namespaceprefix_ = self.taxonomicProcedures_nsprefix_ + ':' if (UseCapturedNS_ and self.taxonomicProcedures_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%staxonomicProcedures>%s</%staxonomicProcedures>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.taxonomicProcedures), input_name='taxonomicProcedures')), namespaceprefix_ , eol_))
        if self.taxonomicCompleteness is not None:
            namespaceprefix_ = self.taxonomicCompleteness_nsprefix_ + ':' if (UseCapturedNS_ and self.taxonomicCompleteness_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%staxonomicCompleteness>%s</%staxonomicCompleteness>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.taxonomicCompleteness), input_name='taxonomicCompleteness')), namespaceprefix_ , eol_))
        for vouchers_ in self.vouchers:
            namespaceprefix_ = self.vouchers_nsprefix_ + ':' if (UseCapturedNS_ and self.vouchers_nsprefix_) else ''
            vouchers_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='vouchers', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'classificationSystem':
            obj_ = classificationSystemType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.classificationSystem.append(obj_)
            obj_.original_tagname_ = 'classificationSystem'
        elif nodeName_ == 'identificationReference':
            obj_ = CitationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identificationReference.append(obj_)
            obj_.original_tagname_ = 'identificationReference'
        elif nodeName_ == 'identifierName':
            class_obj_ = self.get_class_obj_(child_, ResponsibleParty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifierName.append(obj_)
            obj_.original_tagname_ = 'identifierName'
        elif nodeName_ == 'taxonomicProcedures':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'taxonomicProcedures')
            value_ = self.gds_validate_string(value_, node, 'taxonomicProcedures')
            self.taxonomicProcedures = value_
            self.taxonomicProcedures_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.taxonomicProcedures)
        elif nodeName_ == 'taxonomicCompleteness':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'taxonomicCompleteness')
            value_ = self.gds_validate_string(value_, node, 'taxonomicCompleteness')
            self.taxonomicCompleteness = value_
            self.taxonomicCompleteness_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.taxonomicCompleteness)
        elif nodeName_ == 'vouchers':
            obj_ = vouchersType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vouchers.append(obj_)
            obj_.original_tagname_ = 'vouchers'
# end class taxonomicSystemType


class classificationSystemType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('classificationSystemCitation', 'CitationType', 0, 0, {'name': 'classificationSystemCitation', 'type': 'CitationType'}, None),
        MemberSpec_('classificationSystemModifications', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'classificationSystemModifications', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, classificationSystemCitation=None, classificationSystemModifications=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.classificationSystemCitation = classificationSystemCitation
        self.classificationSystemCitation_nsprefix_ = None
        self.classificationSystemModifications = classificationSystemModifications
        self.validate_NonEmptyStringType(self.classificationSystemModifications)
        self.classificationSystemModifications_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, classificationSystemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if classificationSystemType.subclass:
            return classificationSystemType.subclass(*args_, **kwargs_)
        else:
            return classificationSystemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_classificationSystemCitation(self):
        return self.classificationSystemCitation
    def set_classificationSystemCitation(self, classificationSystemCitation):
        self.classificationSystemCitation = classificationSystemCitation
    def get_classificationSystemModifications(self):
        return self.classificationSystemModifications
    def set_classificationSystemModifications(self, classificationSystemModifications):
        self.classificationSystemModifications = classificationSystemModifications
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def hasContent_(self):
        if (
            self.classificationSystemCitation is not None or
            self.classificationSystemModifications is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:cit="https://eml.ecoinformatics.org/literature-2.2.0"  xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='classificationSystemType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('classificationSystemType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'classificationSystemType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='classificationSystemType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='classificationSystemType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='classificationSystemType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:cit="https://eml.ecoinformatics.org/literature-2.2.0"  xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='classificationSystemType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.classificationSystemCitation is not None:
            namespaceprefix_ = self.classificationSystemCitation_nsprefix_ + ':' if (UseCapturedNS_ and self.classificationSystemCitation_nsprefix_) else ''
            self.classificationSystemCitation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='classificationSystemCitation', pretty_print=pretty_print)
        if self.classificationSystemModifications is not None:
            namespaceprefix_ = self.classificationSystemModifications_nsprefix_ + ':' if (UseCapturedNS_ and self.classificationSystemModifications_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sclassificationSystemModifications>%s</%sclassificationSystemModifications>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.classificationSystemModifications), input_name='classificationSystemModifications')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'classificationSystemCitation':
            obj_ = CitationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.classificationSystemCitation = obj_
            obj_.original_tagname_ = 'classificationSystemCitation'
        elif nodeName_ == 'classificationSystemModifications':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'classificationSystemModifications')
            value_ = self.gds_validate_string(value_, node, 'classificationSystemModifications')
            self.classificationSystemModifications = value_
            self.classificationSystemModifications_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.classificationSystemModifications)
# end class classificationSystemType


class vouchersType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('specimen', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'specimen', 'type': 'xs:string'}, None),
        MemberSpec_('repository', 'repositoryType', 0, 0, {'name': 'repository', 'type': 'repositoryType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, specimen=None, repository=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.specimen = specimen
        self.validate_NonEmptyStringType(self.specimen)
        self.specimen_nsprefix_ = None
        self.repository = repository
        self.repository_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, vouchersType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if vouchersType.subclass:
            return vouchersType.subclass(*args_, **kwargs_)
        else:
            return vouchersType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_specimen(self):
        return self.specimen
    def set_specimen(self, specimen):
        self.specimen = specimen
    def get_repository(self):
        return self.repository
    def set_repository(self, repository):
        self.repository = repository
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def hasContent_(self):
        if (
            self.specimen is not None or
            self.repository is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='vouchersType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vouchersType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'vouchersType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='vouchersType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='vouchersType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='vouchersType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='vouchersType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.specimen is not None:
            namespaceprefix_ = self.specimen_nsprefix_ + ':' if (UseCapturedNS_ and self.specimen_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sspecimen>%s</%sspecimen>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.specimen), input_name='specimen')), namespaceprefix_ , eol_))
        if self.repository is not None:
            namespaceprefix_ = self.repository_nsprefix_ + ':' if (UseCapturedNS_ and self.repository_nsprefix_) else ''
            self.repository.export(outfile, level, namespaceprefix_, namespacedef_='', name_='repository', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'specimen':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'specimen')
            value_ = self.gds_validate_string(value_, node, 'specimen')
            self.specimen = value_
            self.specimen_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.specimen)
        elif nodeName_ == 'repository':
            obj_ = repositoryType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.repository = obj_
            obj_.original_tagname_ = 'repository'
# end class vouchersType


class repositoryType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('originator', 'ResponsibleParty', 1, 0, {'maxOccurs': 'unbounded', 'name': 'originator', 'type': 'ResponsibleParty'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, originator=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if originator is None:
            self.originator = []
        else:
            self.originator = originator
        self.originator_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, repositoryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if repositoryType.subclass:
            return repositoryType.subclass(*args_, **kwargs_)
        else:
            return repositoryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_originator(self):
        return self.originator
    def set_originator(self, originator):
        self.originator = originator
    def add_originator(self, value):
        self.originator.append(value)
    def insert_originator_at(self, index, value):
        self.originator.insert(index, value)
    def replace_originator_at(self, index, value):
        self.originator[index] = value
    def hasContent_(self):
        if (
            self.originator
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:rp="https://eml.ecoinformatics.org/party-2.2.0" ', name_='repositoryType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('repositoryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'repositoryType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='repositoryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='repositoryType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='repositoryType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:rp="https://eml.ecoinformatics.org/party-2.2.0" ', name_='repositoryType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for originator_ in self.originator:
            namespaceprefix_ = self.originator_nsprefix_ + ':' if (UseCapturedNS_ and self.originator_nsprefix_) else ''
            originator_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='originator', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'originator':
            class_obj_ = self.get_class_obj_(child_, ResponsibleParty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.originator.append(obj_)
            obj_.original_tagname_ = 'originator'
# end class repositoryType


class referencesType10(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('system', 'SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, system=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, referencesType10)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if referencesType10.subclass:
            return referencesType10.subclass(*args_, **kwargs_)
        else:
            return referencesType10(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_SystemType(self, value):
        # Validate type SystemType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referencesType10', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('referencesType10')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'referencesType10':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='referencesType10')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='referencesType10', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='referencesType10'):
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referencesType10', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class referencesType10


class taxonIdType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('provider', 'xs:anyURI', 0, 0, {'use': 'required'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, provider=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.provider = _cast(None, provider)
        self.provider_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, taxonIdType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if taxonIdType.subclass:
            return taxonIdType.subclass(*args_, **kwargs_)
        else:
            return taxonIdType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_provider(self):
        return self.provider
    def set_provider(self, provider):
        self.provider = provider
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='taxonIdType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('taxonIdType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'taxonIdType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='taxonIdType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='taxonIdType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='taxonIdType'):
        if self.provider is not None and 'provider' not in already_processed:
            already_processed.add('provider')
            outfile.write(' provider=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.provider), input_name='provider')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='taxonIdType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('provider', node)
        if value is not None and 'provider' not in already_processed:
            already_processed.add('provider')
            self.provider = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class taxonIdType


class alternateIdentifierType11(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('system', 'SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, system=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, alternateIdentifierType11)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if alternateIdentifierType11.subclass:
            return alternateIdentifierType11.subclass(*args_, **kwargs_)
        else:
            return alternateIdentifierType11(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_SystemType(self, value):
        # Validate type SystemType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='alternateIdentifierType11', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('alternateIdentifierType11')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'alternateIdentifierType11':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='alternateIdentifierType11')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='alternateIdentifierType11', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='alternateIdentifierType11'):
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='alternateIdentifierType11', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class alternateIdentifierType11


class associatedPartyType12(ResponsibleParty):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('role', ['RoleType', 'xs:string'], 0, 0, {'name': 'role', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = ResponsibleParty
    def __init__(self, id=None, system=None, scope='document', individualName=None, organizationName=None, positionName=None, address=None, phone=None, electronicMailAddress=None, onlineUrl=None, userId=None, references=None, role=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(associatedPartyType12, self).__init__(id, system, scope, individualName, organizationName, positionName, address, phone, electronicMailAddress, onlineUrl, userId, references,  **kwargs_)
        self.role = role
        self.validate_RoleType(self.role)
        self.role_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, associatedPartyType12)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if associatedPartyType12.subclass:
            return associatedPartyType12.subclass(*args_, **kwargs_)
        else:
            return associatedPartyType12(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_role(self):
        return self.role
    def set_role(self, role):
        self.role = role
    def validate_RoleType(self, value):
        result = True
        # Validate type RoleType, a restriction on xs:string.
        pass
        return result
    def hasContent_(self):
        if (
            self.role is not None or
            super(associatedPartyType12, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:rp="https://eml.ecoinformatics.org/party-2.2.0" ', name_='associatedPartyType12', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('associatedPartyType12')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'associatedPartyType12':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='associatedPartyType12')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='associatedPartyType12', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='associatedPartyType12'):
        super(associatedPartyType12, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='associatedPartyType12')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:rp="https://eml.ecoinformatics.org/party-2.2.0" ', name_='associatedPartyType12', fromsubclass_=False, pretty_print=True):
        super(associatedPartyType12, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.role is not None:
            namespaceprefix_ = self.role_nsprefix_ + ':' if (UseCapturedNS_ and self.role_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srole>%s</%srole>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.role), input_name='role')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(associatedPartyType12, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'role':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'role')
            value_ = self.gds_validate_string(value_, node, 'role')
            self.role = value_
            self.role_nsprefix_ = child_.prefix
            # validate type RoleType
            self.validate_RoleType(self.role)
        super(associatedPartyType12, self).buildChildren(child_, node, nodeName_, True)
# end class associatedPartyType12


class keywordSetType13(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('keyword', 'keywordType14', 1, 0, {'maxOccurs': 'unbounded', 'name': 'keyword', 'type': 'keywordType14'}, None),
        MemberSpec_('keywordThesaurus', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'keywordThesaurus', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, keyword=None, keywordThesaurus=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if keyword is None:
            self.keyword = []
        else:
            self.keyword = keyword
        self.keyword_nsprefix_ = None
        self.keywordThesaurus = keywordThesaurus
        self.validate_NonEmptyStringType(self.keywordThesaurus)
        self.keywordThesaurus_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, keywordSetType13)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if keywordSetType13.subclass:
            return keywordSetType13.subclass(*args_, **kwargs_)
        else:
            return keywordSetType13(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_keyword(self):
        return self.keyword
    def set_keyword(self, keyword):
        self.keyword = keyword
    def add_keyword(self, value):
        self.keyword.append(value)
    def insert_keyword_at(self, index, value):
        self.keyword.insert(index, value)
    def replace_keyword_at(self, index, value):
        self.keyword[index] = value
    def get_keywordThesaurus(self):
        return self.keywordThesaurus
    def set_keywordThesaurus(self, keywordThesaurus):
        self.keywordThesaurus = keywordThesaurus
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def hasContent_(self):
        if (
            self.keyword or
            self.keywordThesaurus is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='keywordSetType13', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('keywordSetType13')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'keywordSetType13':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='keywordSetType13')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='keywordSetType13', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='keywordSetType13'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='keywordSetType13', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for keyword_ in self.keyword:
            namespaceprefix_ = self.keyword_nsprefix_ + ':' if (UseCapturedNS_ and self.keyword_nsprefix_) else ''
            keyword_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='keyword', pretty_print=pretty_print)
        if self.keywordThesaurus is not None:
            namespaceprefix_ = self.keywordThesaurus_nsprefix_ + ':' if (UseCapturedNS_ and self.keywordThesaurus_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%skeywordThesaurus>%s</%skeywordThesaurus>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.keywordThesaurus), input_name='keywordThesaurus')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'keyword':
            obj_ = keywordType14.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.keyword.append(obj_)
            obj_.original_tagname_ = 'keyword'
        elif nodeName_ == 'keywordThesaurus':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'keywordThesaurus')
            value_ = self.gds_validate_string(value_, node, 'keywordThesaurus')
            self.keywordThesaurus = value_
            self.keywordThesaurus_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.keywordThesaurus)
# end class keywordSetType13


class keywordType14(i18nNonEmptyStringType):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('keywordType', 'KeyTypeCode', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'i18nNonEmptyStringType', 0),
    ]
    subclass = None
    superclass = i18nNonEmptyStringType
    def __init__(self, lang=None, value=None, keywordType=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(keywordType14, self).__init__(lang, value, valueOf_, mixedclass_, content_,  **kwargs_)
        self.keywordType = _cast(None, keywordType)
        self.keywordType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, keywordType14)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if keywordType14.subclass:
            return keywordType14.subclass(*args_, **kwargs_)
        else:
            return keywordType14(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_keywordType(self):
        return self.keywordType
    def set_keywordType(self, keywordType):
        self.keywordType = keywordType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_KeyTypeCode(self, value):
        # Validate type KeyTypeCode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['place', 'stratum', 'temporal', 'theme', 'taxonomic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on KeyTypeCode' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(keywordType14, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='keywordType14', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('keywordType14')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'keywordType14':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='keywordType14')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='keywordType14', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='keywordType14'):
        super(keywordType14, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='keywordType14')
        if self.keywordType is not None and 'keywordType' not in already_processed:
            already_processed.add('keywordType')
            outfile.write(' keywordType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.keywordType), input_name='keywordType')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='keywordType14', fromsubclass_=False, pretty_print=True):
        super(keywordType14, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('keywordType', node)
        if value is not None and 'keywordType' not in already_processed:
            already_processed.add('keywordType')
            self.keywordType = value
            self.validate_KeyTypeCode(self.keywordType)    # validate type KeyTypeCode
        super(keywordType14, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(keywordType14, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class keywordType14


class referencesType15(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('system', 'SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, system=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, referencesType15)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if referencesType15.subclass:
            return referencesType15.subclass(*args_, **kwargs_)
        else:
            return referencesType15(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_SystemType(self, value):
        # Validate type SystemType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referencesType15', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('referencesType15')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'referencesType15':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='referencesType15')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='referencesType15', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='referencesType15'):
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referencesType15', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class referencesType15


class referencesType16(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('system', 'SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, system=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, referencesType16)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if referencesType16.subclass:
            return referencesType16.subclass(*args_, **kwargs_)
        else:
            return referencesType16(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_SystemType(self, value):
        # Validate type SystemType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referencesType16', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('referencesType16')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'referencesType16':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='referencesType16')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='referencesType16', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='referencesType16'):
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referencesType16', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class referencesType16


class personnelType(ResponsibleParty):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('role', ['RoleType', 'xs:string'], 1, 0, {'maxOccurs': 'unbounded', 'name': 'role', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = ResponsibleParty
    def __init__(self, id=None, system=None, scope='document', individualName=None, organizationName=None, positionName=None, address=None, phone=None, electronicMailAddress=None, onlineUrl=None, userId=None, references=None, role=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(personnelType, self).__init__(id, system, scope, individualName, organizationName, positionName, address, phone, electronicMailAddress, onlineUrl, userId, references,  **kwargs_)
        if role is None:
            self.role = []
        else:
            self.role = role
        self.role_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, personnelType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if personnelType.subclass:
            return personnelType.subclass(*args_, **kwargs_)
        else:
            return personnelType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_role(self):
        return self.role
    def set_role(self, role):
        self.role = role
    def add_role(self, value):
        self.role.append(value)
    def insert_role_at(self, index, value):
        self.role.insert(index, value)
    def replace_role_at(self, index, value):
        self.role[index] = value
    def validate_RoleType(self, value):
        result = True
        # Validate type RoleType, a restriction on xs:string.
        pass
        return result
    def hasContent_(self):
        if (
            self.role or
            super(personnelType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:rp="https://eml.ecoinformatics.org/party-2.2.0" ', name_='personnelType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('personnelType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'personnelType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='personnelType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='personnelType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='personnelType'):
        super(personnelType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='personnelType')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:rp="https://eml.ecoinformatics.org/party-2.2.0" ', name_='personnelType', fromsubclass_=False, pretty_print=True):
        super(personnelType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for role_ in self.role:
            namespaceprefix_ = self.role_nsprefix_ + ':' if (UseCapturedNS_ and self.role_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srole>%s</%srole>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(role_), input_name='role')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(personnelType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'role':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'role')
            value_ = self.gds_validate_string(value_, node, 'role')
            self.role.append(value_)
            self.role_nsprefix_ = child_.prefix
            # validate type RoleType
            self.validate_RoleType(self.role[-1])
        super(personnelType, self).buildChildren(child_, node, nodeName_, True)
# end class personnelType


class studyAreaDescriptionType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('descriptor', 'descriptorType', 1, 0, {'name': 'descriptor', 'type': 'descriptorType'}, 59),
        MemberSpec_('citation', 'CitationType', 1, 1, {'minOccurs': '0', 'name': 'citation', 'type': 'CitationType'}, 59),
        MemberSpec_('coverage', 'Coverage', 1, 1, {'minOccurs': '0', 'name': 'coverage', 'type': 'Coverage'}, 59),
    ]
    subclass = None
    superclass = None
    def __init__(self, descriptor=None, citation=None, coverage=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if descriptor is None:
            self.descriptor = []
        else:
            self.descriptor = descriptor
        self.descriptor_nsprefix_ = None
        if citation is None:
            self.citation = []
        else:
            self.citation = citation
        self.citation_nsprefix_ = None
        if coverage is None:
            self.coverage = []
        else:
            self.coverage = coverage
        self.coverage_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, studyAreaDescriptionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if studyAreaDescriptionType.subclass:
            return studyAreaDescriptionType.subclass(*args_, **kwargs_)
        else:
            return studyAreaDescriptionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_descriptor(self):
        return self.descriptor
    def set_descriptor(self, descriptor):
        self.descriptor = descriptor
    def add_descriptor(self, value):
        self.descriptor.append(value)
    def insert_descriptor_at(self, index, value):
        self.descriptor.insert(index, value)
    def replace_descriptor_at(self, index, value):
        self.descriptor[index] = value
    def get_citation(self):
        return self.citation
    def set_citation(self, citation):
        self.citation = citation
    def add_citation(self, value):
        self.citation.append(value)
    def insert_citation_at(self, index, value):
        self.citation.insert(index, value)
    def replace_citation_at(self, index, value):
        self.citation[index] = value
    def get_coverage(self):
        return self.coverage
    def set_coverage(self, coverage):
        self.coverage = coverage
    def add_coverage(self, value):
        self.coverage.append(value)
    def insert_coverage_at(self, index, value):
        self.coverage.insert(index, value)
    def replace_coverage_at(self, index, value):
        self.coverage[index] = value
    def hasContent_(self):
        if (
            self.descriptor or
            self.citation or
            self.coverage
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0"  xmlns:cit="https://eml.ecoinformatics.org/literature-2.2.0"  xmlns:cov="https://eml.ecoinformatics.org/coverage-2.2.0" ', name_='studyAreaDescriptionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('studyAreaDescriptionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'studyAreaDescriptionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='studyAreaDescriptionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='studyAreaDescriptionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='studyAreaDescriptionType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0"  xmlns:cit="https://eml.ecoinformatics.org/literature-2.2.0"  xmlns:cov="https://eml.ecoinformatics.org/coverage-2.2.0" ', name_='studyAreaDescriptionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for descriptor_ in self.descriptor:
            namespaceprefix_ = self.descriptor_nsprefix_ + ':' if (UseCapturedNS_ and self.descriptor_nsprefix_) else ''
            descriptor_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='descriptor', pretty_print=pretty_print)
        for citation_ in self.citation:
            namespaceprefix_ = self.citation_nsprefix_ + ':' if (UseCapturedNS_ and self.citation_nsprefix_) else ''
            citation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='citation', pretty_print=pretty_print)
        for coverage_ in self.coverage:
            namespaceprefix_ = self.coverage_nsprefix_ + ':' if (UseCapturedNS_ and self.coverage_nsprefix_) else ''
            coverage_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='coverage', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'descriptor':
            obj_ = descriptorType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.descriptor.append(obj_)
            obj_.original_tagname_ = 'descriptor'
        elif nodeName_ == 'citation':
            obj_ = CitationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.citation.append(obj_)
            obj_.original_tagname_ = 'citation'
        elif nodeName_ == 'coverage':
            obj_ = Coverage.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.coverage.append(obj_)
            obj_.original_tagname_ = 'coverage'
# end class studyAreaDescriptionType


class descriptorType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('name', 'DescriptorType', 0, 0, {'use': 'required'}),
        MemberSpec_('citableClassificationSystem', 'xs:boolean', 0, 0, {'use': 'required'}),
        MemberSpec_('descriptorValue', 'descriptorValueType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'descriptorValue', 'type': 'descriptorValueType'}, None),
        MemberSpec_('citation', 'CitationType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'citation', 'type': 'CitationType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, name=None, citableClassificationSystem=None, descriptorValue=None, citation=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.citableClassificationSystem = _cast(bool, citableClassificationSystem)
        self.citableClassificationSystem_nsprefix_ = None
        if descriptorValue is None:
            self.descriptorValue = []
        else:
            self.descriptorValue = descriptorValue
        self.descriptorValue_nsprefix_ = None
        if citation is None:
            self.citation = []
        else:
            self.citation = citation
        self.citation_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, descriptorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if descriptorType.subclass:
            return descriptorType.subclass(*args_, **kwargs_)
        else:
            return descriptorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_descriptorValue(self):
        return self.descriptorValue
    def set_descriptorValue(self, descriptorValue):
        self.descriptorValue = descriptorValue
    def add_descriptorValue(self, value):
        self.descriptorValue.append(value)
    def insert_descriptorValue_at(self, index, value):
        self.descriptorValue.insert(index, value)
    def replace_descriptorValue_at(self, index, value):
        self.descriptorValue[index] = value
    def get_citation(self):
        return self.citation
    def set_citation(self, citation):
        self.citation = citation
    def add_citation(self, value):
        self.citation.append(value)
    def insert_citation_at(self, index, value):
        self.citation.insert(index, value)
    def replace_citation_at(self, index, value):
        self.citation[index] = value
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_citableClassificationSystem(self):
        return self.citableClassificationSystem
    def set_citableClassificationSystem(self, citableClassificationSystem):
        self.citableClassificationSystem = citableClassificationSystem
    def validate_DescriptorType(self, value):
        # Validate type DescriptorType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.descriptorValue or
            self.citation
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0"  xmlns:cit="https://eml.ecoinformatics.org/literature-2.2.0" ', name_='descriptorType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('descriptorType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'descriptorType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='descriptorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='descriptorType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='descriptorType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.citableClassificationSystem is not None and 'citableClassificationSystem' not in already_processed:
            already_processed.add('citableClassificationSystem')
            outfile.write(' citableClassificationSystem="%s"' % self.gds_format_boolean(self.citableClassificationSystem, input_name='citableClassificationSystem'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0"  xmlns:cit="https://eml.ecoinformatics.org/literature-2.2.0" ', name_='descriptorType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for descriptorValue_ in self.descriptorValue:
            namespaceprefix_ = self.descriptorValue_nsprefix_ + ':' if (UseCapturedNS_ and self.descriptorValue_nsprefix_) else ''
            descriptorValue_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='descriptorValue', pretty_print=pretty_print)
        for citation_ in self.citation:
            namespaceprefix_ = self.citation_nsprefix_ + ':' if (UseCapturedNS_ and self.citation_nsprefix_) else ''
            citation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='citation', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
            self.validate_DescriptorType(self.name)    # validate type DescriptorType
        value = find_attr_value_('citableClassificationSystem', node)
        if value is not None and 'citableClassificationSystem' not in already_processed:
            already_processed.add('citableClassificationSystem')
            if value in ('true', '1'):
                self.citableClassificationSystem = True
            elif value in ('false', '0'):
                self.citableClassificationSystem = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'descriptorValue':
            obj_ = descriptorValueType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.descriptorValue.append(obj_)
            obj_.original_tagname_ = 'descriptorValue'
        elif nodeName_ == 'citation':
            obj_ = CitationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.citation.append(obj_)
            obj_.original_tagname_ = 'citation'
# end class descriptorType


class descriptorValueType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('name_or_id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, name_or_id=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name_or_id = _cast(None, name_or_id)
        self.name_or_id_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, descriptorValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if descriptorValueType.subclass:
            return descriptorValueType.subclass(*args_, **kwargs_)
        else:
            return descriptorValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name_or_id(self):
        return self.name_or_id
    def set_name_or_id(self, name_or_id):
        self.name_or_id = name_or_id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='descriptorValueType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('descriptorValueType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'descriptorValueType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='descriptorValueType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='descriptorValueType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='descriptorValueType'):
        if self.name_or_id is not None and 'name_or_id' not in already_processed:
            already_processed.add('name_or_id')
            outfile.write(' name_or_id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name_or_id), input_name='name_or_id')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='descriptorValueType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name_or_id', node)
        if value is not None and 'name_or_id' not in already_processed:
            already_processed.add('name_or_id')
            self.name_or_id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class descriptorValueType


class designDescriptionType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('description', 'TextType', 1, 0, {'name': 'description', 'type': 'TextType'}, 60),
        MemberSpec_('citation', 'CitationType', 1, 1, {'minOccurs': '0', 'name': 'citation', 'type': 'CitationType'}, 60),
    ]
    subclass = None
    superclass = None
    def __init__(self, description=None, citation=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if description is None:
            self.description = []
        else:
            self.description = description
        self.description_nsprefix_ = None
        if citation is None:
            self.citation = []
        else:
            self.citation = citation
        self.citation_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, designDescriptionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if designDescriptionType.subclass:
            return designDescriptionType.subclass(*args_, **kwargs_)
        else:
            return designDescriptionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def add_description(self, value):
        self.description.append(value)
    def insert_description_at(self, index, value):
        self.description.insert(index, value)
    def replace_description_at(self, index, value):
        self.description[index] = value
    def get_citation(self):
        return self.citation
    def set_citation(self, citation):
        self.citation = citation
    def add_citation(self, value):
        self.citation.append(value)
    def insert_citation_at(self, index, value):
        self.citation.insert(index, value)
    def replace_citation_at(self, index, value):
        self.citation[index] = value
    def hasContent_(self):
        if (
            self.description or
            self.citation
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:txt="https://eml.ecoinformatics.org/text-2.2.0"  xmlns:cit="https://eml.ecoinformatics.org/literature-2.2.0" ', name_='designDescriptionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('designDescriptionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'designDescriptionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='designDescriptionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='designDescriptionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='designDescriptionType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:txt="https://eml.ecoinformatics.org/text-2.2.0"  xmlns:cit="https://eml.ecoinformatics.org/literature-2.2.0" ', name_='designDescriptionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for description_ in self.description:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            description_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='description', pretty_print=pretty_print)
        for citation_ in self.citation:
            namespaceprefix_ = self.citation_nsprefix_ + ':' if (UseCapturedNS_ and self.citation_nsprefix_) else ''
            citation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='citation', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'description':
            obj_ = TextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.description.append(obj_)
            obj_.original_tagname_ = 'description'
        elif nodeName_ == 'citation':
            obj_ = CitationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.citation.append(obj_)
            obj_.original_tagname_ = 'citation'
# end class designDescriptionType


class referencesType17(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('system', 'SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, system=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, referencesType17)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if referencesType17.subclass:
            return referencesType17.subclass(*args_, **kwargs_)
        else:
            return referencesType17(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_SystemType(self, value):
        # Validate type SystemType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referencesType17', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('referencesType17')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'referencesType17':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='referencesType17')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='referencesType17', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='referencesType17'):
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referencesType17', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class referencesType17


class propertyURIType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('label', 'xs:string', 0, 0, {'use': 'required'}),
        MemberSpec_('valueOf_', 'xs:anyURI', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, label=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.label = _cast(None, label)
        self.label_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, propertyURIType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if propertyURIType.subclass:
            return propertyURIType.subclass(*args_, **kwargs_)
        else:
            return propertyURIType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_label(self):
        return self.label
    def set_label(self, label):
        self.label = label
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='propertyURIType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('propertyURIType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'propertyURIType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='propertyURIType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='propertyURIType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='propertyURIType'):
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' label=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.label), input_name='label')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='propertyURIType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class propertyURIType


class valueURIType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('label', 'xs:string', 0, 0, {'use': 'required'}),
        MemberSpec_('valueOf_', 'xs:anyURI', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, label=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.label = _cast(None, label)
        self.label_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, valueURIType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if valueURIType.subclass:
            return valueURIType.subclass(*args_, **kwargs_)
        else:
            return valueURIType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_label(self):
        return self.label
    def set_label(self, label):
        self.label = label
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='valueURIType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('valueURIType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'valueURIType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='valueURIType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='valueURIType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='valueURIType'):
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' label=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.label), input_name='label')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='valueURIType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class valueURIType


class alternateIdentifierType18(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('system', 'SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, system=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, alternateIdentifierType18)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if alternateIdentifierType18.subclass:
            return alternateIdentifierType18.subclass(*args_, **kwargs_)
        else:
            return alternateIdentifierType18(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_SystemType(self, value):
        # Validate type SystemType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='alternateIdentifierType18', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('alternateIdentifierType18')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'alternateIdentifierType18':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='alternateIdentifierType18')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='alternateIdentifierType18', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='alternateIdentifierType18'):
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='alternateIdentifierType18', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class alternateIdentifierType18


class associatedPartyType19(ResponsibleParty):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('role', ['RoleType', 'xs:string'], 0, 0, {'name': 'role', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = ResponsibleParty
    def __init__(self, id=None, system=None, scope='document', individualName=None, organizationName=None, positionName=None, address=None, phone=None, electronicMailAddress=None, onlineUrl=None, userId=None, references=None, role=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(associatedPartyType19, self).__init__(id, system, scope, individualName, organizationName, positionName, address, phone, electronicMailAddress, onlineUrl, userId, references,  **kwargs_)
        self.role = role
        self.validate_RoleType(self.role)
        self.role_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, associatedPartyType19)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if associatedPartyType19.subclass:
            return associatedPartyType19.subclass(*args_, **kwargs_)
        else:
            return associatedPartyType19(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_role(self):
        return self.role
    def set_role(self, role):
        self.role = role
    def validate_RoleType(self, value):
        result = True
        # Validate type RoleType, a restriction on xs:string.
        pass
        return result
    def hasContent_(self):
        if (
            self.role is not None or
            super(associatedPartyType19, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:rp="https://eml.ecoinformatics.org/party-2.2.0" ', name_='associatedPartyType19', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('associatedPartyType19')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'associatedPartyType19':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='associatedPartyType19')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='associatedPartyType19', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='associatedPartyType19'):
        super(associatedPartyType19, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='associatedPartyType19')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:rp="https://eml.ecoinformatics.org/party-2.2.0" ', name_='associatedPartyType19', fromsubclass_=False, pretty_print=True):
        super(associatedPartyType19, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.role is not None:
            namespaceprefix_ = self.role_nsprefix_ + ':' if (UseCapturedNS_ and self.role_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srole>%s</%srole>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.role), input_name='role')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(associatedPartyType19, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'role':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'role')
            value_ = self.gds_validate_string(value_, node, 'role')
            self.role = value_
            self.role_nsprefix_ = child_.prefix
            # validate type RoleType
            self.validate_RoleType(self.role)
        super(associatedPartyType19, self).buildChildren(child_, node, nodeName_, True)
# end class associatedPartyType19


class keywordSetType20(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('keyword', 'keywordType21', 1, 0, {'maxOccurs': 'unbounded', 'name': 'keyword', 'type': 'keywordType21'}, None),
        MemberSpec_('keywordThesaurus', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'keywordThesaurus', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, keyword=None, keywordThesaurus=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if keyword is None:
            self.keyword = []
        else:
            self.keyword = keyword
        self.keyword_nsprefix_ = None
        self.keywordThesaurus = keywordThesaurus
        self.validate_NonEmptyStringType(self.keywordThesaurus)
        self.keywordThesaurus_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, keywordSetType20)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if keywordSetType20.subclass:
            return keywordSetType20.subclass(*args_, **kwargs_)
        else:
            return keywordSetType20(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_keyword(self):
        return self.keyword
    def set_keyword(self, keyword):
        self.keyword = keyword
    def add_keyword(self, value):
        self.keyword.append(value)
    def insert_keyword_at(self, index, value):
        self.keyword.insert(index, value)
    def replace_keyword_at(self, index, value):
        self.keyword[index] = value
    def get_keywordThesaurus(self):
        return self.keywordThesaurus
    def set_keywordThesaurus(self, keywordThesaurus):
        self.keywordThesaurus = keywordThesaurus
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def hasContent_(self):
        if (
            self.keyword or
            self.keywordThesaurus is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='keywordSetType20', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('keywordSetType20')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'keywordSetType20':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='keywordSetType20')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='keywordSetType20', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='keywordSetType20'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='keywordSetType20', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for keyword_ in self.keyword:
            namespaceprefix_ = self.keyword_nsprefix_ + ':' if (UseCapturedNS_ and self.keyword_nsprefix_) else ''
            keyword_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='keyword', pretty_print=pretty_print)
        if self.keywordThesaurus is not None:
            namespaceprefix_ = self.keywordThesaurus_nsprefix_ + ':' if (UseCapturedNS_ and self.keywordThesaurus_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%skeywordThesaurus>%s</%skeywordThesaurus>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.keywordThesaurus), input_name='keywordThesaurus')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'keyword':
            obj_ = keywordType21.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.keyword.append(obj_)
            obj_.original_tagname_ = 'keyword'
        elif nodeName_ == 'keywordThesaurus':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'keywordThesaurus')
            value_ = self.gds_validate_string(value_, node, 'keywordThesaurus')
            self.keywordThesaurus = value_
            self.keywordThesaurus_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.keywordThesaurus)
# end class keywordSetType20


class keywordType21(i18nNonEmptyStringType):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('keywordType', 'KeyTypeCode', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'i18nNonEmptyStringType', 0),
    ]
    subclass = None
    superclass = i18nNonEmptyStringType
    def __init__(self, lang=None, value=None, keywordType=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(keywordType21, self).__init__(lang, value, valueOf_, mixedclass_, content_,  **kwargs_)
        self.keywordType = _cast(None, keywordType)
        self.keywordType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, keywordType21)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if keywordType21.subclass:
            return keywordType21.subclass(*args_, **kwargs_)
        else:
            return keywordType21(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_keywordType(self):
        return self.keywordType
    def set_keywordType(self, keywordType):
        self.keywordType = keywordType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_KeyTypeCode(self, value):
        # Validate type KeyTypeCode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['place', 'stratum', 'temporal', 'theme', 'taxonomic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on KeyTypeCode' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(keywordType21, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='keywordType21', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('keywordType21')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'keywordType21':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='keywordType21')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='keywordType21', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='keywordType21'):
        super(keywordType21, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='keywordType21')
        if self.keywordType is not None and 'keywordType' not in already_processed:
            already_processed.add('keywordType')
            outfile.write(' keywordType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.keywordType), input_name='keywordType')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='keywordType21', fromsubclass_=False, pretty_print=True):
        super(keywordType21, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('keywordType', node)
        if value is not None and 'keywordType' not in already_processed:
            already_processed.add('keywordType')
            self.keywordType = value
            self.validate_KeyTypeCode(self.keywordType)    # validate type KeyTypeCode
        super(keywordType21, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(keywordType21, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class keywordType21


class referencesType22(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('system', 'SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, system=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, referencesType22)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if referencesType22.subclass:
            return referencesType22.subclass(*args_, **kwargs_)
        else:
            return referencesType22(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_SystemType(self, value):
        # Validate type SystemType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referencesType22', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('referencesType22')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'referencesType22':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='referencesType22')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='referencesType22', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='referencesType22'):
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referencesType22', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class referencesType22


class changeHistoryType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('changeScope', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'changeScope', 'type': 'xs:string'}, None),
        MemberSpec_('oldValue', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'oldValue', 'type': 'xs:string'}, None),
        MemberSpec_('changeDate', 'xs:date', 0, 0, {'name': 'changeDate', 'type': 'xs:date'}, None),
        MemberSpec_('comment', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'comment', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, changeScope=None, oldValue=None, changeDate=None, comment=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.changeScope = changeScope
        self.validate_NonEmptyStringType(self.changeScope)
        self.changeScope_nsprefix_ = None
        self.oldValue = oldValue
        self.validate_NonEmptyStringType(self.oldValue)
        self.oldValue_nsprefix_ = None
        if isinstance(changeDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(changeDate, '%Y-%m-%d').date()
        else:
            initvalue_ = changeDate
        self.changeDate = initvalue_
        self.changeDate_nsprefix_ = None
        self.comment = comment
        self.validate_NonEmptyStringType(self.comment)
        self.comment_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, changeHistoryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if changeHistoryType.subclass:
            return changeHistoryType.subclass(*args_, **kwargs_)
        else:
            return changeHistoryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_changeScope(self):
        return self.changeScope
    def set_changeScope(self, changeScope):
        self.changeScope = changeScope
    def get_oldValue(self):
        return self.oldValue
    def set_oldValue(self, oldValue):
        self.oldValue = oldValue
    def get_changeDate(self):
        return self.changeDate
    def set_changeDate(self, changeDate):
        self.changeDate = changeDate
    def get_comment(self):
        return self.comment
    def set_comment(self, comment):
        self.comment = comment
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def hasContent_(self):
        if (
            self.changeScope is not None or
            self.oldValue is not None or
            self.changeDate is not None or
            self.comment is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='changeHistoryType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('changeHistoryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'changeHistoryType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='changeHistoryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='changeHistoryType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='changeHistoryType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='changeHistoryType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.changeScope is not None:
            namespaceprefix_ = self.changeScope_nsprefix_ + ':' if (UseCapturedNS_ and self.changeScope_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%schangeScope>%s</%schangeScope>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.changeScope), input_name='changeScope')), namespaceprefix_ , eol_))
        if self.oldValue is not None:
            namespaceprefix_ = self.oldValue_nsprefix_ + ':' if (UseCapturedNS_ and self.oldValue_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soldValue>%s</%soldValue>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.oldValue), input_name='oldValue')), namespaceprefix_ , eol_))
        if self.changeDate is not None:
            namespaceprefix_ = self.changeDate_nsprefix_ + ':' if (UseCapturedNS_ and self.changeDate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%schangeDate>%s</%schangeDate>%s' % (namespaceprefix_ , self.gds_format_date(self.changeDate, input_name='changeDate'), namespaceprefix_ , eol_))
        if self.comment is not None:
            namespaceprefix_ = self.comment_nsprefix_ + ':' if (UseCapturedNS_ and self.comment_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomment>%s</%scomment>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.comment), input_name='comment')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'changeScope':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'changeScope')
            value_ = self.gds_validate_string(value_, node, 'changeScope')
            self.changeScope = value_
            self.changeScope_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.changeScope)
        elif nodeName_ == 'oldValue':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'oldValue')
            value_ = self.gds_validate_string(value_, node, 'oldValue')
            self.oldValue = value_
            self.oldValue_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.oldValue)
        elif nodeName_ == 'changeDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.changeDate = dval_
            self.changeDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'comment':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'comment')
            value_ = self.gds_validate_string(value_, node, 'comment')
            self.comment = value_
            self.comment_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.comment)
# end class changeHistoryType


class alternateIdentifierType23(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('system', 'res:SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, system=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, alternateIdentifierType23)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if alternateIdentifierType23.subclass:
            return alternateIdentifierType23.subclass(*args_, **kwargs_)
        else:
            return alternateIdentifierType23(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_SystemType(self, value):
        # Validate type res:SystemType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='alternateIdentifierType23', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('alternateIdentifierType23')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'alternateIdentifierType23':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='alternateIdentifierType23')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='alternateIdentifierType23', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='alternateIdentifierType23'):
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='alternateIdentifierType23', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class alternateIdentifierType23


class referencesType24(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('system', 'SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, system=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, referencesType24)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if referencesType24.subclass:
            return referencesType24.subclass(*args_, **kwargs_)
        else:
            return referencesType24(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_SystemType(self, value):
        # Validate type SystemType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referencesType24', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('referencesType24')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'referencesType24':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='referencesType24')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='referencesType24', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='referencesType24'):
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referencesType24', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class referencesType24


class alternateIdentifierType25(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('system', 'res:SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, system=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, alternateIdentifierType25)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if alternateIdentifierType25.subclass:
            return alternateIdentifierType25.subclass(*args_, **kwargs_)
        else:
            return alternateIdentifierType25(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_SystemType(self, value):
        # Validate type res:SystemType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='alternateIdentifierType25', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('alternateIdentifierType25')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'alternateIdentifierType25':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='alternateIdentifierType25')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='alternateIdentifierType25', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='alternateIdentifierType25'):
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='alternateIdentifierType25', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class alternateIdentifierType25


class sizeType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('unit', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, unit='byte', valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.unit = _cast(None, unit)
        self.unit_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, sizeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if sizeType.subclass:
            return sizeType.subclass(*args_, **kwargs_)
        else:
            return sizeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_unit(self):
        return self.unit
    def set_unit(self, unit):
        self.unit = unit
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='sizeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('sizeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'sizeType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='sizeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='sizeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='sizeType'):
        if self.unit != "byte" and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.unit), input_name='unit')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='sizeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class sizeType


class authenticationType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('method', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, method=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.method = _cast(None, method)
        self.method_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, authenticationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if authenticationType.subclass:
            return authenticationType.subclass(*args_, **kwargs_)
        else:
            return authenticationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_method(self):
        return self.method
    def set_method(self, method):
        self.method = method
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='authenticationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('authenticationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'authenticationType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='authenticationType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='authenticationType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='authenticationType'):
        if self.method is not None and 'method' not in already_processed:
            already_processed.add('method')
            outfile.write(' method=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.method), input_name='method')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='authenticationType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('method', node)
        if value is not None and 'method' not in already_processed:
            already_processed.add('method')
            self.method = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class authenticationType


class dataFormatType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('textFormat', 'textFormatType', 0, 0, {'name': 'textFormat', 'type': 'textFormatType'}, 61),
        MemberSpec_('externallyDefinedFormat', 'externallyDefinedFormatType', 0, 0, {'name': 'externallyDefinedFormat', 'type': 'externallyDefinedFormatType'}, 61),
        MemberSpec_('binaryRasterFormat', 'binaryRasterFormatType', 0, 0, {'name': 'binaryRasterFormat', 'type': 'binaryRasterFormatType'}, 61),
    ]
    subclass = None
    superclass = None
    def __init__(self, textFormat=None, externallyDefinedFormat=None, binaryRasterFormat=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.textFormat = textFormat
        self.textFormat_nsprefix_ = None
        self.externallyDefinedFormat = externallyDefinedFormat
        self.externallyDefinedFormat_nsprefix_ = None
        self.binaryRasterFormat = binaryRasterFormat
        self.binaryRasterFormat_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, dataFormatType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if dataFormatType.subclass:
            return dataFormatType.subclass(*args_, **kwargs_)
        else:
            return dataFormatType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_textFormat(self):
        return self.textFormat
    def set_textFormat(self, textFormat):
        self.textFormat = textFormat
    def get_externallyDefinedFormat(self):
        return self.externallyDefinedFormat
    def set_externallyDefinedFormat(self, externallyDefinedFormat):
        self.externallyDefinedFormat = externallyDefinedFormat
    def get_binaryRasterFormat(self):
        return self.binaryRasterFormat
    def set_binaryRasterFormat(self, binaryRasterFormat):
        self.binaryRasterFormat = binaryRasterFormat
    def hasContent_(self):
        if (
            self.textFormat is not None or
            self.externallyDefinedFormat is not None or
            self.binaryRasterFormat is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='dataFormatType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('dataFormatType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'dataFormatType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='dataFormatType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='dataFormatType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='dataFormatType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='dataFormatType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.textFormat is not None:
            namespaceprefix_ = self.textFormat_nsprefix_ + ':' if (UseCapturedNS_ and self.textFormat_nsprefix_) else ''
            self.textFormat.export(outfile, level, namespaceprefix_, namespacedef_='', name_='textFormat', pretty_print=pretty_print)
        if self.externallyDefinedFormat is not None:
            namespaceprefix_ = self.externallyDefinedFormat_nsprefix_ + ':' if (UseCapturedNS_ and self.externallyDefinedFormat_nsprefix_) else ''
            self.externallyDefinedFormat.export(outfile, level, namespaceprefix_, namespacedef_='', name_='externallyDefinedFormat', pretty_print=pretty_print)
        if self.binaryRasterFormat is not None:
            namespaceprefix_ = self.binaryRasterFormat_nsprefix_ + ':' if (UseCapturedNS_ and self.binaryRasterFormat_nsprefix_) else ''
            self.binaryRasterFormat.export(outfile, level, namespaceprefix_, namespacedef_='', name_='binaryRasterFormat', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'textFormat':
            obj_ = textFormatType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.textFormat = obj_
            obj_.original_tagname_ = 'textFormat'
        elif nodeName_ == 'externallyDefinedFormat':
            obj_ = externallyDefinedFormatType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.externallyDefinedFormat = obj_
            obj_.original_tagname_ = 'externallyDefinedFormat'
        elif nodeName_ == 'binaryRasterFormat':
            obj_ = binaryRasterFormatType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.binaryRasterFormat = obj_
            obj_.original_tagname_ = 'binaryRasterFormat'
# end class dataFormatType


class textFormatType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('numHeaderLines', 'xs:int', 0, 1, {'minOccurs': '0', 'name': 'numHeaderLines', 'type': 'xs:int'}, None),
        MemberSpec_('numFooterLines', 'xs:int', 0, 1, {'minOccurs': '0', 'name': 'numFooterLines', 'type': 'xs:int'}, None),
        MemberSpec_('recordDelimiter', 'xs:string', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'recordDelimiter', 'type': 'xs:string'}, None),
        MemberSpec_('physicalLineDelimiter', 'xs:string', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'physicalLineDelimiter', 'type': 'xs:string'}, None),
        MemberSpec_('numPhysicalLinesPerRecord', 'xs:unsignedInt', 0, 1, {'minOccurs': '0', 'name': 'numPhysicalLinesPerRecord', 'type': 'xs:unsignedInt'}, None),
        MemberSpec_('maxRecordLength', 'xs:unsignedLong', 0, 1, {'minOccurs': '0', 'name': 'maxRecordLength', 'type': 'xs:unsignedLong'}, None),
        MemberSpec_('attributeOrientation', ['attributeOrientationType', 'xs:string'], 0, 0, {'name': 'attributeOrientation', 'type': 'xs:string'}, None),
        MemberSpec_('simpleDelimited', 'simpleDelimitedType', 0, 0, {'name': 'simpleDelimited', 'type': 'simpleDelimitedType'}, 62),
        MemberSpec_('complex', 'complexType', 0, 0, {'name': 'complex', 'type': 'complexType'}, 62),
    ]
    subclass = None
    superclass = None
    def __init__(self, numHeaderLines=None, numFooterLines=None, recordDelimiter=None, physicalLineDelimiter=None, numPhysicalLinesPerRecord=None, maxRecordLength=None, attributeOrientation=None, simpleDelimited=None, complex=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.numHeaderLines = numHeaderLines
        self.numHeaderLines_nsprefix_ = None
        self.numFooterLines = numFooterLines
        self.numFooterLines_nsprefix_ = None
        if recordDelimiter is None:
            self.recordDelimiter = []
        else:
            self.recordDelimiter = recordDelimiter
        self.recordDelimiter_nsprefix_ = None
        if physicalLineDelimiter is None:
            self.physicalLineDelimiter = []
        else:
            self.physicalLineDelimiter = physicalLineDelimiter
        self.physicalLineDelimiter_nsprefix_ = None
        self.numPhysicalLinesPerRecord = numPhysicalLinesPerRecord
        self.numPhysicalLinesPerRecord_nsprefix_ = None
        self.maxRecordLength = maxRecordLength
        self.maxRecordLength_nsprefix_ = None
        self.attributeOrientation = attributeOrientation
        self.validate_attributeOrientationType(self.attributeOrientation)
        self.attributeOrientation_nsprefix_ = None
        self.simpleDelimited = simpleDelimited
        self.simpleDelimited_nsprefix_ = None
        self.complex = complex
        self.complex_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, textFormatType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if textFormatType.subclass:
            return textFormatType.subclass(*args_, **kwargs_)
        else:
            return textFormatType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_numHeaderLines(self):
        return self.numHeaderLines
    def set_numHeaderLines(self, numHeaderLines):
        self.numHeaderLines = numHeaderLines
    def get_numFooterLines(self):
        return self.numFooterLines
    def set_numFooterLines(self, numFooterLines):
        self.numFooterLines = numFooterLines
    def get_recordDelimiter(self):
        return self.recordDelimiter
    def set_recordDelimiter(self, recordDelimiter):
        self.recordDelimiter = recordDelimiter
    def add_recordDelimiter(self, value):
        self.recordDelimiter.append(value)
    def insert_recordDelimiter_at(self, index, value):
        self.recordDelimiter.insert(index, value)
    def replace_recordDelimiter_at(self, index, value):
        self.recordDelimiter[index] = value
    def get_physicalLineDelimiter(self):
        return self.physicalLineDelimiter
    def set_physicalLineDelimiter(self, physicalLineDelimiter):
        self.physicalLineDelimiter = physicalLineDelimiter
    def add_physicalLineDelimiter(self, value):
        self.physicalLineDelimiter.append(value)
    def insert_physicalLineDelimiter_at(self, index, value):
        self.physicalLineDelimiter.insert(index, value)
    def replace_physicalLineDelimiter_at(self, index, value):
        self.physicalLineDelimiter[index] = value
    def get_numPhysicalLinesPerRecord(self):
        return self.numPhysicalLinesPerRecord
    def set_numPhysicalLinesPerRecord(self, numPhysicalLinesPerRecord):
        self.numPhysicalLinesPerRecord = numPhysicalLinesPerRecord
    def get_maxRecordLength(self):
        return self.maxRecordLength
    def set_maxRecordLength(self, maxRecordLength):
        self.maxRecordLength = maxRecordLength
    def get_attributeOrientation(self):
        return self.attributeOrientation
    def set_attributeOrientation(self, attributeOrientation):
        self.attributeOrientation = attributeOrientation
    def get_simpleDelimited(self):
        return self.simpleDelimited
    def set_simpleDelimited(self, simpleDelimited):
        self.simpleDelimited = simpleDelimited
    def get_complex(self):
        return self.complex
    def set_complex(self, complex):
        self.complex = complex
    def validate_attributeOrientationType(self, value):
        result = True
        # Validate type attributeOrientationType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['column', 'row']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on attributeOrientationType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.numHeaderLines is not None or
            self.numFooterLines is not None or
            self.recordDelimiter or
            self.physicalLineDelimiter or
            self.numPhysicalLinesPerRecord is not None or
            self.maxRecordLength is not None or
            self.attributeOrientation is not None or
            self.simpleDelimited is not None or
            self.complex is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='textFormatType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('textFormatType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'textFormatType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='textFormatType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='textFormatType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='textFormatType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='textFormatType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.numHeaderLines is not None:
            namespaceprefix_ = self.numHeaderLines_nsprefix_ + ':' if (UseCapturedNS_ and self.numHeaderLines_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snumHeaderLines>%s</%snumHeaderLines>%s' % (namespaceprefix_ , self.gds_format_integer(self.numHeaderLines, input_name='numHeaderLines'), namespaceprefix_ , eol_))
        if self.numFooterLines is not None:
            namespaceprefix_ = self.numFooterLines_nsprefix_ + ':' if (UseCapturedNS_ and self.numFooterLines_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snumFooterLines>%s</%snumFooterLines>%s' % (namespaceprefix_ , self.gds_format_integer(self.numFooterLines, input_name='numFooterLines'), namespaceprefix_ , eol_))
        for recordDelimiter_ in self.recordDelimiter:
            namespaceprefix_ = self.recordDelimiter_nsprefix_ + ':' if (UseCapturedNS_ and self.recordDelimiter_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srecordDelimiter>%s</%srecordDelimiter>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(recordDelimiter_), input_name='recordDelimiter')), namespaceprefix_ , eol_))
        for physicalLineDelimiter_ in self.physicalLineDelimiter:
            namespaceprefix_ = self.physicalLineDelimiter_nsprefix_ + ':' if (UseCapturedNS_ and self.physicalLineDelimiter_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sphysicalLineDelimiter>%s</%sphysicalLineDelimiter>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(physicalLineDelimiter_), input_name='physicalLineDelimiter')), namespaceprefix_ , eol_))
        if self.numPhysicalLinesPerRecord is not None:
            namespaceprefix_ = self.numPhysicalLinesPerRecord_nsprefix_ + ':' if (UseCapturedNS_ and self.numPhysicalLinesPerRecord_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snumPhysicalLinesPerRecord>%s</%snumPhysicalLinesPerRecord>%s' % (namespaceprefix_ , self.gds_format_integer(self.numPhysicalLinesPerRecord, input_name='numPhysicalLinesPerRecord'), namespaceprefix_ , eol_))
        if self.maxRecordLength is not None:
            namespaceprefix_ = self.maxRecordLength_nsprefix_ + ':' if (UseCapturedNS_ and self.maxRecordLength_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smaxRecordLength>%s</%smaxRecordLength>%s' % (namespaceprefix_ , self.gds_format_integer(self.maxRecordLength, input_name='maxRecordLength'), namespaceprefix_ , eol_))
        if self.attributeOrientation is not None:
            namespaceprefix_ = self.attributeOrientation_nsprefix_ + ':' if (UseCapturedNS_ and self.attributeOrientation_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sattributeOrientation>%s</%sattributeOrientation>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.attributeOrientation), input_name='attributeOrientation')), namespaceprefix_ , eol_))
        if self.simpleDelimited is not None:
            namespaceprefix_ = self.simpleDelimited_nsprefix_ + ':' if (UseCapturedNS_ and self.simpleDelimited_nsprefix_) else ''
            self.simpleDelimited.export(outfile, level, namespaceprefix_, namespacedef_='', name_='simpleDelimited', pretty_print=pretty_print)
        if self.complex is not None:
            namespaceprefix_ = self.complex_nsprefix_ + ':' if (UseCapturedNS_ and self.complex_nsprefix_) else ''
            self.complex.export(outfile, level, namespaceprefix_, namespacedef_='', name_='complex', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'numHeaderLines' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'numHeaderLines')
            ival_ = self.gds_validate_integer(ival_, node, 'numHeaderLines')
            self.numHeaderLines = ival_
            self.numHeaderLines_nsprefix_ = child_.prefix
        elif nodeName_ == 'numFooterLines' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'numFooterLines')
            ival_ = self.gds_validate_integer(ival_, node, 'numFooterLines')
            self.numFooterLines = ival_
            self.numFooterLines_nsprefix_ = child_.prefix
        elif nodeName_ == 'recordDelimiter':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'recordDelimiter')
            value_ = self.gds_validate_string(value_, node, 'recordDelimiter')
            self.recordDelimiter.append(value_)
            self.recordDelimiter_nsprefix_ = child_.prefix
        elif nodeName_ == 'physicalLineDelimiter':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'physicalLineDelimiter')
            value_ = self.gds_validate_string(value_, node, 'physicalLineDelimiter')
            self.physicalLineDelimiter.append(value_)
            self.physicalLineDelimiter_nsprefix_ = child_.prefix
        elif nodeName_ == 'numPhysicalLinesPerRecord' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'numPhysicalLinesPerRecord')
            ival_ = self.gds_validate_integer(ival_, node, 'numPhysicalLinesPerRecord')
            self.numPhysicalLinesPerRecord = ival_
            self.numPhysicalLinesPerRecord_nsprefix_ = child_.prefix
        elif nodeName_ == 'maxRecordLength' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'maxRecordLength')
            ival_ = self.gds_validate_integer(ival_, node, 'maxRecordLength')
            self.maxRecordLength = ival_
            self.maxRecordLength_nsprefix_ = child_.prefix
        elif nodeName_ == 'attributeOrientation':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'attributeOrientation')
            value_ = self.gds_validate_string(value_, node, 'attributeOrientation')
            self.attributeOrientation = value_
            self.attributeOrientation_nsprefix_ = child_.prefix
            # validate type attributeOrientationType
            self.validate_attributeOrientationType(self.attributeOrientation)
        elif nodeName_ == 'simpleDelimited':
            obj_ = simpleDelimitedType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.simpleDelimited = obj_
            obj_.original_tagname_ = 'simpleDelimited'
        elif nodeName_ == 'complex':
            obj_ = complexType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.complex = obj_
            obj_.original_tagname_ = 'complex'
# end class textFormatType


class simpleDelimitedType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('fieldDelimiter', 'xs:string', 1, 0, {'maxOccurs': 'unbounded', 'name': 'fieldDelimiter', 'type': 'xs:string'}, None),
        MemberSpec_('collapseDelimiters', ['collapseDelimitersType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'collapseDelimiters', 'type': 'xs:string'}, None),
        MemberSpec_('quoteCharacter', ['NonEmptyStringType', 'xs:string'], 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'quoteCharacter', 'type': 'xs:string'}, None),
        MemberSpec_('literalCharacter', ['NonEmptyStringType', 'xs:string'], 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'literalCharacter', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, fieldDelimiter=None, collapseDelimiters=None, quoteCharacter=None, literalCharacter=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if fieldDelimiter is None:
            self.fieldDelimiter = []
        else:
            self.fieldDelimiter = fieldDelimiter
        self.fieldDelimiter_nsprefix_ = None
        self.collapseDelimiters = collapseDelimiters
        self.validate_collapseDelimitersType(self.collapseDelimiters)
        self.collapseDelimiters_nsprefix_ = None
        if quoteCharacter is None:
            self.quoteCharacter = []
        else:
            self.quoteCharacter = quoteCharacter
        self.quoteCharacter_nsprefix_ = None
        if literalCharacter is None:
            self.literalCharacter = []
        else:
            self.literalCharacter = literalCharacter
        self.literalCharacter_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, simpleDelimitedType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if simpleDelimitedType.subclass:
            return simpleDelimitedType.subclass(*args_, **kwargs_)
        else:
            return simpleDelimitedType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_fieldDelimiter(self):
        return self.fieldDelimiter
    def set_fieldDelimiter(self, fieldDelimiter):
        self.fieldDelimiter = fieldDelimiter
    def add_fieldDelimiter(self, value):
        self.fieldDelimiter.append(value)
    def insert_fieldDelimiter_at(self, index, value):
        self.fieldDelimiter.insert(index, value)
    def replace_fieldDelimiter_at(self, index, value):
        self.fieldDelimiter[index] = value
    def get_collapseDelimiters(self):
        return self.collapseDelimiters
    def set_collapseDelimiters(self, collapseDelimiters):
        self.collapseDelimiters = collapseDelimiters
    def get_quoteCharacter(self):
        return self.quoteCharacter
    def set_quoteCharacter(self, quoteCharacter):
        self.quoteCharacter = quoteCharacter
    def add_quoteCharacter(self, value):
        self.quoteCharacter.append(value)
    def insert_quoteCharacter_at(self, index, value):
        self.quoteCharacter.insert(index, value)
    def replace_quoteCharacter_at(self, index, value):
        self.quoteCharacter[index] = value
    def get_literalCharacter(self):
        return self.literalCharacter
    def set_literalCharacter(self, literalCharacter):
        self.literalCharacter = literalCharacter
    def add_literalCharacter(self, value):
        self.literalCharacter.append(value)
    def insert_literalCharacter_at(self, index, value):
        self.literalCharacter.insert(index, value)
    def replace_literalCharacter_at(self, index, value):
        self.literalCharacter[index] = value
    def validate_collapseDelimitersType(self, value):
        result = True
        # Validate type collapseDelimitersType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on collapseDelimitersType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def hasContent_(self):
        if (
            self.fieldDelimiter or
            self.collapseDelimiters is not None or
            self.quoteCharacter or
            self.literalCharacter
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0"  xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='simpleDelimitedType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('simpleDelimitedType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'simpleDelimitedType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='simpleDelimitedType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='simpleDelimitedType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='simpleDelimitedType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0"  xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='simpleDelimitedType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for fieldDelimiter_ in self.fieldDelimiter:
            namespaceprefix_ = self.fieldDelimiter_nsprefix_ + ':' if (UseCapturedNS_ and self.fieldDelimiter_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfieldDelimiter>%s</%sfieldDelimiter>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(fieldDelimiter_), input_name='fieldDelimiter')), namespaceprefix_ , eol_))
        if self.collapseDelimiters is not None:
            namespaceprefix_ = self.collapseDelimiters_nsprefix_ + ':' if (UseCapturedNS_ and self.collapseDelimiters_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scollapseDelimiters>%s</%scollapseDelimiters>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.collapseDelimiters), input_name='collapseDelimiters')), namespaceprefix_ , eol_))
        for quoteCharacter_ in self.quoteCharacter:
            namespaceprefix_ = self.quoteCharacter_nsprefix_ + ':' if (UseCapturedNS_ and self.quoteCharacter_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%squoteCharacter>%s</%squoteCharacter>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(quoteCharacter_), input_name='quoteCharacter')), namespaceprefix_ , eol_))
        for literalCharacter_ in self.literalCharacter:
            namespaceprefix_ = self.literalCharacter_nsprefix_ + ':' if (UseCapturedNS_ and self.literalCharacter_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sliteralCharacter>%s</%sliteralCharacter>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(literalCharacter_), input_name='literalCharacter')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'fieldDelimiter':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'fieldDelimiter')
            value_ = self.gds_validate_string(value_, node, 'fieldDelimiter')
            self.fieldDelimiter.append(value_)
            self.fieldDelimiter_nsprefix_ = child_.prefix
        elif nodeName_ == 'collapseDelimiters':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'collapseDelimiters')
            value_ = self.gds_validate_string(value_, node, 'collapseDelimiters')
            self.collapseDelimiters = value_
            self.collapseDelimiters_nsprefix_ = child_.prefix
            # validate type collapseDelimitersType
            self.validate_collapseDelimitersType(self.collapseDelimiters)
        elif nodeName_ == 'quoteCharacter':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'quoteCharacter')
            value_ = self.gds_validate_string(value_, node, 'quoteCharacter')
            self.quoteCharacter.append(value_)
            self.quoteCharacter_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.quoteCharacter[-1])
        elif nodeName_ == 'literalCharacter':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'literalCharacter')
            value_ = self.gds_validate_string(value_, node, 'literalCharacter')
            self.literalCharacter.append(value_)
            self.literalCharacter_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.literalCharacter[-1])
# end class simpleDelimitedType


class complexType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('textFixed', 'textFixedType', 1, 0, {'name': 'textFixed', 'type': 'textFixedType'}, 63),
        MemberSpec_('textDelimited', 'textDelimitedType', 1, 0, {'name': 'textDelimited', 'type': 'textDelimitedType'}, 63),
    ]
    subclass = None
    superclass = None
    def __init__(self, textFixed=None, textDelimited=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if textFixed is None:
            self.textFixed = []
        else:
            self.textFixed = textFixed
        self.textFixed_nsprefix_ = None
        if textDelimited is None:
            self.textDelimited = []
        else:
            self.textDelimited = textDelimited
        self.textDelimited_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, complexType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if complexType.subclass:
            return complexType.subclass(*args_, **kwargs_)
        else:
            return complexType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_textFixed(self):
        return self.textFixed
    def set_textFixed(self, textFixed):
        self.textFixed = textFixed
    def add_textFixed(self, value):
        self.textFixed.append(value)
    def insert_textFixed_at(self, index, value):
        self.textFixed.insert(index, value)
    def replace_textFixed_at(self, index, value):
        self.textFixed[index] = value
    def get_textDelimited(self):
        return self.textDelimited
    def set_textDelimited(self, textDelimited):
        self.textDelimited = textDelimited
    def add_textDelimited(self, value):
        self.textDelimited.append(value)
    def insert_textDelimited_at(self, index, value):
        self.textDelimited.insert(index, value)
    def replace_textDelimited_at(self, index, value):
        self.textDelimited[index] = value
    def hasContent_(self):
        if (
            self.textFixed or
            self.textDelimited
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='complexType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('complexType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'complexType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='complexType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='complexType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='complexType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='complexType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for textFixed_ in self.textFixed:
            namespaceprefix_ = self.textFixed_nsprefix_ + ':' if (UseCapturedNS_ and self.textFixed_nsprefix_) else ''
            textFixed_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='textFixed', pretty_print=pretty_print)
        for textDelimited_ in self.textDelimited:
            namespaceprefix_ = self.textDelimited_nsprefix_ + ':' if (UseCapturedNS_ and self.textDelimited_nsprefix_) else ''
            textDelimited_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='textDelimited', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'textFixed':
            obj_ = textFixedType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.textFixed.append(obj_)
            obj_.original_tagname_ = 'textFixed'
        elif nodeName_ == 'textDelimited':
            obj_ = textDelimitedType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.textDelimited.append(obj_)
            obj_.original_tagname_ = 'textDelimited'
# end class complexType


class textFixedType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('fieldWidth', 'xs:unsignedLong', 0, 0, {'name': 'fieldWidth', 'type': 'xs:unsignedLong'}, None),
        MemberSpec_('lineNumber', 'xs:unsignedLong', 0, 1, {'minOccurs': '0', 'name': 'lineNumber', 'type': 'xs:unsignedLong'}, None),
        MemberSpec_('fieldStartColumn', 'xs:long', 0, 1, {'minOccurs': '0', 'name': 'fieldStartColumn', 'type': 'xs:long'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, fieldWidth=None, lineNumber=None, fieldStartColumn=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.fieldWidth = fieldWidth
        self.fieldWidth_nsprefix_ = None
        self.lineNumber = lineNumber
        self.lineNumber_nsprefix_ = None
        self.fieldStartColumn = fieldStartColumn
        self.fieldStartColumn_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, textFixedType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if textFixedType.subclass:
            return textFixedType.subclass(*args_, **kwargs_)
        else:
            return textFixedType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_fieldWidth(self):
        return self.fieldWidth
    def set_fieldWidth(self, fieldWidth):
        self.fieldWidth = fieldWidth
    def get_lineNumber(self):
        return self.lineNumber
    def set_lineNumber(self, lineNumber):
        self.lineNumber = lineNumber
    def get_fieldStartColumn(self):
        return self.fieldStartColumn
    def set_fieldStartColumn(self, fieldStartColumn):
        self.fieldStartColumn = fieldStartColumn
    def hasContent_(self):
        if (
            self.fieldWidth is not None or
            self.lineNumber is not None or
            self.fieldStartColumn is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='textFixedType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('textFixedType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'textFixedType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='textFixedType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='textFixedType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='textFixedType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='textFixedType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.fieldWidth is not None:
            namespaceprefix_ = self.fieldWidth_nsprefix_ + ':' if (UseCapturedNS_ and self.fieldWidth_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfieldWidth>%s</%sfieldWidth>%s' % (namespaceprefix_ , self.gds_format_integer(self.fieldWidth, input_name='fieldWidth'), namespaceprefix_ , eol_))
        if self.lineNumber is not None:
            namespaceprefix_ = self.lineNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.lineNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slineNumber>%s</%slineNumber>%s' % (namespaceprefix_ , self.gds_format_integer(self.lineNumber, input_name='lineNumber'), namespaceprefix_ , eol_))
        if self.fieldStartColumn is not None:
            namespaceprefix_ = self.fieldStartColumn_nsprefix_ + ':' if (UseCapturedNS_ and self.fieldStartColumn_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfieldStartColumn>%s</%sfieldStartColumn>%s' % (namespaceprefix_ , self.gds_format_integer(self.fieldStartColumn, input_name='fieldStartColumn'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'fieldWidth' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'fieldWidth')
            ival_ = self.gds_validate_integer(ival_, node, 'fieldWidth')
            self.fieldWidth = ival_
            self.fieldWidth_nsprefix_ = child_.prefix
        elif nodeName_ == 'lineNumber' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'lineNumber')
            ival_ = self.gds_validate_integer(ival_, node, 'lineNumber')
            self.lineNumber = ival_
            self.lineNumber_nsprefix_ = child_.prefix
        elif nodeName_ == 'fieldStartColumn' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'fieldStartColumn')
            ival_ = self.gds_validate_integer(ival_, node, 'fieldStartColumn')
            self.fieldStartColumn = ival_
            self.fieldStartColumn_nsprefix_ = child_.prefix
# end class textFixedType


class textDelimitedType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('fieldDelimiter', 'xs:string', 0, 0, {'name': 'fieldDelimiter', 'type': 'xs:string'}, None),
        MemberSpec_('collapseDelimiters', ['collapseDelimitersType26', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'collapseDelimiters', 'type': 'xs:string'}, None),
        MemberSpec_('lineNumber', 'xs:unsignedLong', 0, 1, {'minOccurs': '0', 'name': 'lineNumber', 'type': 'xs:unsignedLong'}, None),
        MemberSpec_('quoteCharacter', ['NonEmptyStringType', 'xs:string'], 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'quoteCharacter', 'type': 'xs:string'}, None),
        MemberSpec_('literalCharacter', ['NonEmptyStringType', 'xs:string'], 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'literalCharacter', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, fieldDelimiter=None, collapseDelimiters=None, lineNumber=None, quoteCharacter=None, literalCharacter=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.fieldDelimiter = fieldDelimiter
        self.fieldDelimiter_nsprefix_ = None
        self.collapseDelimiters = collapseDelimiters
        self.validate_collapseDelimitersType26(self.collapseDelimiters)
        self.collapseDelimiters_nsprefix_ = None
        self.lineNumber = lineNumber
        self.lineNumber_nsprefix_ = None
        if quoteCharacter is None:
            self.quoteCharacter = []
        else:
            self.quoteCharacter = quoteCharacter
        self.quoteCharacter_nsprefix_ = None
        if literalCharacter is None:
            self.literalCharacter = []
        else:
            self.literalCharacter = literalCharacter
        self.literalCharacter_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, textDelimitedType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if textDelimitedType.subclass:
            return textDelimitedType.subclass(*args_, **kwargs_)
        else:
            return textDelimitedType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_fieldDelimiter(self):
        return self.fieldDelimiter
    def set_fieldDelimiter(self, fieldDelimiter):
        self.fieldDelimiter = fieldDelimiter
    def get_collapseDelimiters(self):
        return self.collapseDelimiters
    def set_collapseDelimiters(self, collapseDelimiters):
        self.collapseDelimiters = collapseDelimiters
    def get_lineNumber(self):
        return self.lineNumber
    def set_lineNumber(self, lineNumber):
        self.lineNumber = lineNumber
    def get_quoteCharacter(self):
        return self.quoteCharacter
    def set_quoteCharacter(self, quoteCharacter):
        self.quoteCharacter = quoteCharacter
    def add_quoteCharacter(self, value):
        self.quoteCharacter.append(value)
    def insert_quoteCharacter_at(self, index, value):
        self.quoteCharacter.insert(index, value)
    def replace_quoteCharacter_at(self, index, value):
        self.quoteCharacter[index] = value
    def get_literalCharacter(self):
        return self.literalCharacter
    def set_literalCharacter(self, literalCharacter):
        self.literalCharacter = literalCharacter
    def add_literalCharacter(self, value):
        self.literalCharacter.append(value)
    def insert_literalCharacter_at(self, index, value):
        self.literalCharacter.insert(index, value)
    def replace_literalCharacter_at(self, index, value):
        self.literalCharacter[index] = value
    def validate_collapseDelimitersType26(self, value):
        result = True
        # Validate type collapseDelimitersType26, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on collapseDelimitersType26' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def hasContent_(self):
        if (
            self.fieldDelimiter is not None or
            self.collapseDelimiters is not None or
            self.lineNumber is not None or
            self.quoteCharacter or
            self.literalCharacter
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0"  xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='textDelimitedType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('textDelimitedType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'textDelimitedType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='textDelimitedType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='textDelimitedType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='textDelimitedType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0"  xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='textDelimitedType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.fieldDelimiter is not None:
            namespaceprefix_ = self.fieldDelimiter_nsprefix_ + ':' if (UseCapturedNS_ and self.fieldDelimiter_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfieldDelimiter>%s</%sfieldDelimiter>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.fieldDelimiter), input_name='fieldDelimiter')), namespaceprefix_ , eol_))
        if self.collapseDelimiters is not None:
            namespaceprefix_ = self.collapseDelimiters_nsprefix_ + ':' if (UseCapturedNS_ and self.collapseDelimiters_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scollapseDelimiters>%s</%scollapseDelimiters>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.collapseDelimiters), input_name='collapseDelimiters')), namespaceprefix_ , eol_))
        if self.lineNumber is not None:
            namespaceprefix_ = self.lineNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.lineNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slineNumber>%s</%slineNumber>%s' % (namespaceprefix_ , self.gds_format_integer(self.lineNumber, input_name='lineNumber'), namespaceprefix_ , eol_))
        for quoteCharacter_ in self.quoteCharacter:
            namespaceprefix_ = self.quoteCharacter_nsprefix_ + ':' if (UseCapturedNS_ and self.quoteCharacter_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%squoteCharacter>%s</%squoteCharacter>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(quoteCharacter_), input_name='quoteCharacter')), namespaceprefix_ , eol_))
        for literalCharacter_ in self.literalCharacter:
            namespaceprefix_ = self.literalCharacter_nsprefix_ + ':' if (UseCapturedNS_ and self.literalCharacter_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sliteralCharacter>%s</%sliteralCharacter>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(literalCharacter_), input_name='literalCharacter')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'fieldDelimiter':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'fieldDelimiter')
            value_ = self.gds_validate_string(value_, node, 'fieldDelimiter')
            self.fieldDelimiter = value_
            self.fieldDelimiter_nsprefix_ = child_.prefix
        elif nodeName_ == 'collapseDelimiters':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'collapseDelimiters')
            value_ = self.gds_validate_string(value_, node, 'collapseDelimiters')
            self.collapseDelimiters = value_
            self.collapseDelimiters_nsprefix_ = child_.prefix
            # validate type collapseDelimitersType26
            self.validate_collapseDelimitersType26(self.collapseDelimiters)
        elif nodeName_ == 'lineNumber' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'lineNumber')
            ival_ = self.gds_validate_integer(ival_, node, 'lineNumber')
            self.lineNumber = ival_
            self.lineNumber_nsprefix_ = child_.prefix
        elif nodeName_ == 'quoteCharacter':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'quoteCharacter')
            value_ = self.gds_validate_string(value_, node, 'quoteCharacter')
            self.quoteCharacter.append(value_)
            self.quoteCharacter_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.quoteCharacter[-1])
        elif nodeName_ == 'literalCharacter':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'literalCharacter')
            value_ = self.gds_validate_string(value_, node, 'literalCharacter')
            self.literalCharacter.append(value_)
            self.literalCharacter_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.literalCharacter[-1])
# end class textDelimitedType


class externallyDefinedFormatType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('formatName', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'formatName', 'type': 'xs:string'}, None),
        MemberSpec_('formatVersion', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'formatVersion', 'type': 'xs:string'}, None),
        MemberSpec_('citation', 'CitationType', 0, 1, {'minOccurs': '0', 'name': 'citation', 'type': 'CitationType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, formatName=None, formatVersion=None, citation=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.formatName = formatName
        self.validate_NonEmptyStringType(self.formatName)
        self.formatName_nsprefix_ = None
        self.formatVersion = formatVersion
        self.validate_NonEmptyStringType(self.formatVersion)
        self.formatVersion_nsprefix_ = None
        self.citation = citation
        self.citation_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, externallyDefinedFormatType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if externallyDefinedFormatType.subclass:
            return externallyDefinedFormatType.subclass(*args_, **kwargs_)
        else:
            return externallyDefinedFormatType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_formatName(self):
        return self.formatName
    def set_formatName(self, formatName):
        self.formatName = formatName
    def get_formatVersion(self):
        return self.formatVersion
    def set_formatVersion(self, formatVersion):
        self.formatVersion = formatVersion
    def get_citation(self):
        return self.citation
    def set_citation(self, citation):
        self.citation = citation
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def hasContent_(self):
        if (
            self.formatName is not None or
            self.formatVersion is not None or
            self.citation is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:cit="https://eml.ecoinformatics.org/literature-2.2.0" ', name_='externallyDefinedFormatType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('externallyDefinedFormatType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'externallyDefinedFormatType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='externallyDefinedFormatType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='externallyDefinedFormatType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='externallyDefinedFormatType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:cit="https://eml.ecoinformatics.org/literature-2.2.0" ', name_='externallyDefinedFormatType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.formatName is not None:
            namespaceprefix_ = self.formatName_nsprefix_ + ':' if (UseCapturedNS_ and self.formatName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sformatName>%s</%sformatName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.formatName), input_name='formatName')), namespaceprefix_ , eol_))
        if self.formatVersion is not None:
            namespaceprefix_ = self.formatVersion_nsprefix_ + ':' if (UseCapturedNS_ and self.formatVersion_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sformatVersion>%s</%sformatVersion>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.formatVersion), input_name='formatVersion')), namespaceprefix_ , eol_))
        if self.citation is not None:
            namespaceprefix_ = self.citation_nsprefix_ + ':' if (UseCapturedNS_ and self.citation_nsprefix_) else ''
            self.citation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='citation', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'formatName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'formatName')
            value_ = self.gds_validate_string(value_, node, 'formatName')
            self.formatName = value_
            self.formatName_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.formatName)
        elif nodeName_ == 'formatVersion':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'formatVersion')
            value_ = self.gds_validate_string(value_, node, 'formatVersion')
            self.formatVersion = value_
            self.formatVersion_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.formatVersion)
        elif nodeName_ == 'citation':
            obj_ = CitationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.citation = obj_
            obj_.original_tagname_ = 'citation'
# end class externallyDefinedFormatType


class binaryRasterFormatType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('rowColumnOrientation', ['rowColumnOrientationType', 'xs:string'], 0, 0, {'name': 'rowColumnOrientation', 'type': 'xs:string'}, None),
        MemberSpec_('multiBand', 'multiBandType', 0, 1, {'minOccurs': '0', 'name': 'multiBand', 'type': 'multiBandType'}, None),
        MemberSpec_('nbits', 'xs:int', 0, 0, {'name': 'nbits', 'type': 'xs:int'}, None),
        MemberSpec_('byteorder', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'byteorder', 'type': 'xs:string'}, None),
        MemberSpec_('skipbytes', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'skipbytes', 'type': 'xs:string'}, None),
        MemberSpec_('bandrowbytes', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'bandrowbytes', 'type': 'xs:string'}, None),
        MemberSpec_('totalrowbytes', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'totalrowbytes', 'type': 'xs:string'}, None),
        MemberSpec_('bandgapbytes', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'bandgapbytes', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, rowColumnOrientation=None, multiBand=None, nbits=None, byteorder=None, skipbytes=None, bandrowbytes=None, totalrowbytes=None, bandgapbytes=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.rowColumnOrientation = rowColumnOrientation
        self.validate_rowColumnOrientationType(self.rowColumnOrientation)
        self.rowColumnOrientation_nsprefix_ = None
        self.multiBand = multiBand
        self.multiBand_nsprefix_ = None
        self.nbits = nbits
        self.nbits_nsprefix_ = None
        self.byteorder = byteorder
        self.validate_NonEmptyStringType(self.byteorder)
        self.byteorder_nsprefix_ = None
        self.skipbytes = skipbytes
        self.validate_NonEmptyStringType(self.skipbytes)
        self.skipbytes_nsprefix_ = None
        self.bandrowbytes = bandrowbytes
        self.validate_NonEmptyStringType(self.bandrowbytes)
        self.bandrowbytes_nsprefix_ = None
        self.totalrowbytes = totalrowbytes
        self.validate_NonEmptyStringType(self.totalrowbytes)
        self.totalrowbytes_nsprefix_ = None
        self.bandgapbytes = bandgapbytes
        self.validate_NonEmptyStringType(self.bandgapbytes)
        self.bandgapbytes_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, binaryRasterFormatType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if binaryRasterFormatType.subclass:
            return binaryRasterFormatType.subclass(*args_, **kwargs_)
        else:
            return binaryRasterFormatType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_rowColumnOrientation(self):
        return self.rowColumnOrientation
    def set_rowColumnOrientation(self, rowColumnOrientation):
        self.rowColumnOrientation = rowColumnOrientation
    def get_multiBand(self):
        return self.multiBand
    def set_multiBand(self, multiBand):
        self.multiBand = multiBand
    def get_nbits(self):
        return self.nbits
    def set_nbits(self, nbits):
        self.nbits = nbits
    def get_byteorder(self):
        return self.byteorder
    def set_byteorder(self, byteorder):
        self.byteorder = byteorder
    def get_skipbytes(self):
        return self.skipbytes
    def set_skipbytes(self, skipbytes):
        self.skipbytes = skipbytes
    def get_bandrowbytes(self):
        return self.bandrowbytes
    def set_bandrowbytes(self, bandrowbytes):
        self.bandrowbytes = bandrowbytes
    def get_totalrowbytes(self):
        return self.totalrowbytes
    def set_totalrowbytes(self, totalrowbytes):
        self.totalrowbytes = totalrowbytes
    def get_bandgapbytes(self):
        return self.bandgapbytes
    def set_bandgapbytes(self, bandgapbytes):
        self.bandgapbytes = bandgapbytes
    def validate_rowColumnOrientationType(self, value):
        result = True
        # Validate type rowColumnOrientationType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['column', 'row']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on rowColumnOrientationType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def hasContent_(self):
        if (
            self.rowColumnOrientation is not None or
            self.multiBand is not None or
            self.nbits is not None or
            self.byteorder is not None or
            self.skipbytes is not None or
            self.bandrowbytes is not None or
            self.totalrowbytes is not None or
            self.bandgapbytes is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0"  xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='binaryRasterFormatType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('binaryRasterFormatType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'binaryRasterFormatType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='binaryRasterFormatType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='binaryRasterFormatType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='binaryRasterFormatType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0"  xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='binaryRasterFormatType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.rowColumnOrientation is not None:
            namespaceprefix_ = self.rowColumnOrientation_nsprefix_ + ':' if (UseCapturedNS_ and self.rowColumnOrientation_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srowColumnOrientation>%s</%srowColumnOrientation>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.rowColumnOrientation), input_name='rowColumnOrientation')), namespaceprefix_ , eol_))
        if self.multiBand is not None:
            namespaceprefix_ = self.multiBand_nsprefix_ + ':' if (UseCapturedNS_ and self.multiBand_nsprefix_) else ''
            self.multiBand.export(outfile, level, namespaceprefix_, namespacedef_='', name_='multiBand', pretty_print=pretty_print)
        if self.nbits is not None:
            namespaceprefix_ = self.nbits_nsprefix_ + ':' if (UseCapturedNS_ and self.nbits_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snbits>%s</%snbits>%s' % (namespaceprefix_ , self.gds_format_integer(self.nbits, input_name='nbits'), namespaceprefix_ , eol_))
        if self.byteorder is not None:
            namespaceprefix_ = self.byteorder_nsprefix_ + ':' if (UseCapturedNS_ and self.byteorder_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbyteorder>%s</%sbyteorder>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.byteorder), input_name='byteorder')), namespaceprefix_ , eol_))
        if self.skipbytes is not None:
            namespaceprefix_ = self.skipbytes_nsprefix_ + ':' if (UseCapturedNS_ and self.skipbytes_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sskipbytes>%s</%sskipbytes>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.skipbytes), input_name='skipbytes')), namespaceprefix_ , eol_))
        if self.bandrowbytes is not None:
            namespaceprefix_ = self.bandrowbytes_nsprefix_ + ':' if (UseCapturedNS_ and self.bandrowbytes_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbandrowbytes>%s</%sbandrowbytes>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.bandrowbytes), input_name='bandrowbytes')), namespaceprefix_ , eol_))
        if self.totalrowbytes is not None:
            namespaceprefix_ = self.totalrowbytes_nsprefix_ + ':' if (UseCapturedNS_ and self.totalrowbytes_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stotalrowbytes>%s</%stotalrowbytes>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.totalrowbytes), input_name='totalrowbytes')), namespaceprefix_ , eol_))
        if self.bandgapbytes is not None:
            namespaceprefix_ = self.bandgapbytes_nsprefix_ + ':' if (UseCapturedNS_ and self.bandgapbytes_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbandgapbytes>%s</%sbandgapbytes>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.bandgapbytes), input_name='bandgapbytes')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'rowColumnOrientation':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'rowColumnOrientation')
            value_ = self.gds_validate_string(value_, node, 'rowColumnOrientation')
            self.rowColumnOrientation = value_
            self.rowColumnOrientation_nsprefix_ = child_.prefix
            # validate type rowColumnOrientationType
            self.validate_rowColumnOrientationType(self.rowColumnOrientation)
        elif nodeName_ == 'multiBand':
            obj_ = multiBandType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.multiBand = obj_
            obj_.original_tagname_ = 'multiBand'
        elif nodeName_ == 'nbits' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'nbits')
            ival_ = self.gds_validate_integer(ival_, node, 'nbits')
            self.nbits = ival_
            self.nbits_nsprefix_ = child_.prefix
        elif nodeName_ == 'byteorder':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'byteorder')
            value_ = self.gds_validate_string(value_, node, 'byteorder')
            self.byteorder = value_
            self.byteorder_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.byteorder)
        elif nodeName_ == 'skipbytes':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'skipbytes')
            value_ = self.gds_validate_string(value_, node, 'skipbytes')
            self.skipbytes = value_
            self.skipbytes_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.skipbytes)
        elif nodeName_ == 'bandrowbytes':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'bandrowbytes')
            value_ = self.gds_validate_string(value_, node, 'bandrowbytes')
            self.bandrowbytes = value_
            self.bandrowbytes_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.bandrowbytes)
        elif nodeName_ == 'totalrowbytes':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'totalrowbytes')
            value_ = self.gds_validate_string(value_, node, 'totalrowbytes')
            self.totalrowbytes = value_
            self.totalrowbytes_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.totalrowbytes)
        elif nodeName_ == 'bandgapbytes':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'bandgapbytes')
            value_ = self.gds_validate_string(value_, node, 'bandgapbytes')
            self.bandgapbytes = value_
            self.bandgapbytes_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.bandgapbytes)
# end class binaryRasterFormatType


class multiBandType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('nbands', 'xs:int', 0, 0, {'name': 'nbands', 'type': 'xs:int'}, None),
        MemberSpec_('layout', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'layout', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, nbands=None, layout=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nbands = nbands
        self.nbands_nsprefix_ = None
        self.layout = layout
        self.validate_NonEmptyStringType(self.layout)
        self.layout_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, multiBandType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if multiBandType.subclass:
            return multiBandType.subclass(*args_, **kwargs_)
        else:
            return multiBandType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_nbands(self):
        return self.nbands
    def set_nbands(self, nbands):
        self.nbands = nbands
    def get_layout(self):
        return self.layout
    def set_layout(self, layout):
        self.layout = layout
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def hasContent_(self):
        if (
            self.nbands is not None or
            self.layout is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0"  xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='multiBandType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('multiBandType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'multiBandType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='multiBandType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='multiBandType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='multiBandType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0"  xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='multiBandType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nbands is not None:
            namespaceprefix_ = self.nbands_nsprefix_ + ':' if (UseCapturedNS_ and self.nbands_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snbands>%s</%snbands>%s' % (namespaceprefix_ , self.gds_format_integer(self.nbands, input_name='nbands'), namespaceprefix_ , eol_))
        if self.layout is not None:
            namespaceprefix_ = self.layout_nsprefix_ + ':' if (UseCapturedNS_ and self.layout_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slayout>%s</%slayout>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.layout), input_name='layout')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'nbands' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'nbands')
            ival_ = self.gds_validate_integer(ival_, node, 'nbands')
            self.nbands = ival_
            self.nbands_nsprefix_ = child_.prefix
        elif nodeName_ == 'layout':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'layout')
            value_ = self.gds_validate_string(value_, node, 'layout')
            self.layout = value_
            self.layout_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.layout)
# end class multiBandType


class referencesType27(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('system', 'SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, system=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, referencesType27)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if referencesType27.subclass:
            return referencesType27.subclass(*args_, **kwargs_)
        else:
            return referencesType27(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_SystemType(self, value):
        # Validate type SystemType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referencesType27', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('referencesType27')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'referencesType27':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='referencesType27')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='referencesType27', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='referencesType27'):
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referencesType27', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class referencesType27


class referencesType28(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('system', 'SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, system=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, referencesType28)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if referencesType28.subclass:
            return referencesType28.subclass(*args_, **kwargs_)
        else:
            return referencesType28(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_SystemType(self, value):
        # Validate type SystemType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referencesType28', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('referencesType28')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'referencesType28':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='referencesType28')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='referencesType28', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='referencesType28'):
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referencesType28', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class referencesType28


class methodStepType(ProcedureStepType):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('dataSource', 'DatasetType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'dataSource', 'type': 'DatasetType'}, None),
    ]
    subclass = None
    superclass = ProcedureStepType
    def __init__(self, description=None, citation=None, protocol=None, instrumentation=None, software=None, subStep=None, dataSource=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(methodStepType, self).__init__(description, citation, protocol, instrumentation, software, subStep,  **kwargs_)
        if dataSource is None:
            self.dataSource = []
        else:
            self.dataSource = dataSource
        self.dataSource_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, methodStepType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if methodStepType.subclass:
            return methodStepType.subclass(*args_, **kwargs_)
        else:
            return methodStepType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_dataSource(self):
        return self.dataSource
    def set_dataSource(self, dataSource):
        self.dataSource = dataSource
    def add_dataSource(self, value):
        self.dataSource.append(value)
    def insert_dataSource_at(self, index, value):
        self.dataSource.insert(index, value)
    def replace_dataSource_at(self, index, value):
        self.dataSource[index] = value
    def hasContent_(self):
        if (
            self.dataSource or
            super(methodStepType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:ds="https://eml.ecoinformatics.org/dataset-2.2.0" ', name_='methodStepType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('methodStepType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'methodStepType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='methodStepType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='methodStepType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='methodStepType'):
        super(methodStepType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='methodStepType')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:ds="https://eml.ecoinformatics.org/dataset-2.2.0" ', name_='methodStepType', fromsubclass_=False, pretty_print=True):
        super(methodStepType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for dataSource_ in self.dataSource:
            namespaceprefix_ = self.dataSource_nsprefix_ + ':' if (UseCapturedNS_ and self.dataSource_nsprefix_) else ''
            dataSource_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataSource', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(methodStepType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'dataSource':
            obj_ = DatasetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dataSource.append(obj_)
            obj_.original_tagname_ = 'dataSource'
        super(methodStepType, self).buildChildren(child_, node, nodeName_, True)
# end class methodStepType


class samplingType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('studyExtent', 'studyExtentType', 0, 0, {'name': 'studyExtent', 'type': 'studyExtentType'}, None),
        MemberSpec_('samplingDescription', 'TextType', 0, 0, {'name': 'samplingDescription', 'type': 'TextType'}, None),
        MemberSpec_('spatialSamplingUnits', 'spatialSamplingUnitsType', 0, 1, {'minOccurs': '0', 'name': 'spatialSamplingUnits', 'type': 'spatialSamplingUnitsType'}, None),
        MemberSpec_('citation', 'CitationType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'citation', 'type': 'CitationType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, studyExtent=None, samplingDescription=None, spatialSamplingUnits=None, citation=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.studyExtent = studyExtent
        self.studyExtent_nsprefix_ = None
        self.samplingDescription = samplingDescription
        self.samplingDescription_nsprefix_ = None
        self.spatialSamplingUnits = spatialSamplingUnits
        self.spatialSamplingUnits_nsprefix_ = None
        if citation is None:
            self.citation = []
        else:
            self.citation = citation
        self.citation_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, samplingType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if samplingType.subclass:
            return samplingType.subclass(*args_, **kwargs_)
        else:
            return samplingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_studyExtent(self):
        return self.studyExtent
    def set_studyExtent(self, studyExtent):
        self.studyExtent = studyExtent
    def get_samplingDescription(self):
        return self.samplingDescription
    def set_samplingDescription(self, samplingDescription):
        self.samplingDescription = samplingDescription
    def get_spatialSamplingUnits(self):
        return self.spatialSamplingUnits
    def set_spatialSamplingUnits(self, spatialSamplingUnits):
        self.spatialSamplingUnits = spatialSamplingUnits
    def get_citation(self):
        return self.citation
    def set_citation(self, citation):
        self.citation = citation
    def add_citation(self, value):
        self.citation.append(value)
    def insert_citation_at(self, index, value):
        self.citation.insert(index, value)
    def replace_citation_at(self, index, value):
        self.citation[index] = value
    def hasContent_(self):
        if (
            self.studyExtent is not None or
            self.samplingDescription is not None or
            self.spatialSamplingUnits is not None or
            self.citation
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0"  xmlns:txt="https://eml.ecoinformatics.org/text-2.2.0"  xmlns:cit="https://eml.ecoinformatics.org/literature-2.2.0" ', name_='samplingType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('samplingType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'samplingType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='samplingType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='samplingType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='samplingType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0"  xmlns:txt="https://eml.ecoinformatics.org/text-2.2.0"  xmlns:cit="https://eml.ecoinformatics.org/literature-2.2.0" ', name_='samplingType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.studyExtent is not None:
            namespaceprefix_ = self.studyExtent_nsprefix_ + ':' if (UseCapturedNS_ and self.studyExtent_nsprefix_) else ''
            self.studyExtent.export(outfile, level, namespaceprefix_, namespacedef_='', name_='studyExtent', pretty_print=pretty_print)
        if self.samplingDescription is not None:
            namespaceprefix_ = self.samplingDescription_nsprefix_ + ':' if (UseCapturedNS_ and self.samplingDescription_nsprefix_) else ''
            self.samplingDescription.export(outfile, level, namespaceprefix_, namespacedef_='', name_='samplingDescription', pretty_print=pretty_print)
        if self.spatialSamplingUnits is not None:
            namespaceprefix_ = self.spatialSamplingUnits_nsprefix_ + ':' if (UseCapturedNS_ and self.spatialSamplingUnits_nsprefix_) else ''
            self.spatialSamplingUnits.export(outfile, level, namespaceprefix_, namespacedef_='', name_='spatialSamplingUnits', pretty_print=pretty_print)
        for citation_ in self.citation:
            namespaceprefix_ = self.citation_nsprefix_ + ':' if (UseCapturedNS_ and self.citation_nsprefix_) else ''
            citation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='citation', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'studyExtent':
            obj_ = studyExtentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.studyExtent = obj_
            obj_.original_tagname_ = 'studyExtent'
        elif nodeName_ == 'samplingDescription':
            obj_ = TextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.samplingDescription = obj_
            obj_.original_tagname_ = 'samplingDescription'
        elif nodeName_ == 'spatialSamplingUnits':
            obj_ = spatialSamplingUnitsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.spatialSamplingUnits = obj_
            obj_.original_tagname_ = 'spatialSamplingUnits'
        elif nodeName_ == 'citation':
            obj_ = CitationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.citation.append(obj_)
            obj_.original_tagname_ = 'citation'
# end class samplingType


class studyExtentType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('coverage', 'Coverage', 1, 0, {'name': 'coverage', 'type': 'Coverage'}, 64),
        MemberSpec_('description', 'TextType', 1, 0, {'name': 'description', 'type': 'TextType'}, 64),
    ]
    subclass = None
    superclass = None
    def __init__(self, coverage=None, description=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if coverage is None:
            self.coverage = []
        else:
            self.coverage = coverage
        self.coverage_nsprefix_ = None
        if description is None:
            self.description = []
        else:
            self.description = description
        self.description_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, studyExtentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if studyExtentType.subclass:
            return studyExtentType.subclass(*args_, **kwargs_)
        else:
            return studyExtentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_coverage(self):
        return self.coverage
    def set_coverage(self, coverage):
        self.coverage = coverage
    def add_coverage(self, value):
        self.coverage.append(value)
    def insert_coverage_at(self, index, value):
        self.coverage.insert(index, value)
    def replace_coverage_at(self, index, value):
        self.coverage[index] = value
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def add_description(self, value):
        self.description.append(value)
    def insert_description_at(self, index, value):
        self.description.insert(index, value)
    def replace_description_at(self, index, value):
        self.description[index] = value
    def hasContent_(self):
        if (
            self.coverage or
            self.description
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:cov="https://eml.ecoinformatics.org/coverage-2.2.0"  xmlns:txt="https://eml.ecoinformatics.org/text-2.2.0" ', name_='studyExtentType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('studyExtentType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'studyExtentType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='studyExtentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='studyExtentType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='studyExtentType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:cov="https://eml.ecoinformatics.org/coverage-2.2.0"  xmlns:txt="https://eml.ecoinformatics.org/text-2.2.0" ', name_='studyExtentType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for coverage_ in self.coverage:
            namespaceprefix_ = self.coverage_nsprefix_ + ':' if (UseCapturedNS_ and self.coverage_nsprefix_) else ''
            coverage_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='coverage', pretty_print=pretty_print)
        for description_ in self.description:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            description_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='description', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'coverage':
            obj_ = Coverage.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.coverage.append(obj_)
            obj_.original_tagname_ = 'coverage'
        elif nodeName_ == 'description':
            obj_ = TextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.description.append(obj_)
            obj_.original_tagname_ = 'description'
# end class studyExtentType


class spatialSamplingUnitsType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('referencedEntityId', 'xs:string', 1, 0, {'name': 'referencedEntityId', 'type': 'xs:string'}, 65),
        MemberSpec_('coverage', 'GeographicCoverage', 1, 0, {'name': 'coverage', 'type': 'GeographicCoverage'}, 65),
    ]
    subclass = None
    superclass = None
    def __init__(self, referencedEntityId=None, coverage=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if referencedEntityId is None:
            self.referencedEntityId = []
        else:
            self.referencedEntityId = referencedEntityId
        self.referencedEntityId_nsprefix_ = None
        if coverage is None:
            self.coverage = []
        else:
            self.coverage = coverage
        self.coverage_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, spatialSamplingUnitsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if spatialSamplingUnitsType.subclass:
            return spatialSamplingUnitsType.subclass(*args_, **kwargs_)
        else:
            return spatialSamplingUnitsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_referencedEntityId(self):
        return self.referencedEntityId
    def set_referencedEntityId(self, referencedEntityId):
        self.referencedEntityId = referencedEntityId
    def add_referencedEntityId(self, value):
        self.referencedEntityId.append(value)
    def insert_referencedEntityId_at(self, index, value):
        self.referencedEntityId.insert(index, value)
    def replace_referencedEntityId_at(self, index, value):
        self.referencedEntityId[index] = value
    def get_coverage(self):
        return self.coverage
    def set_coverage(self, coverage):
        self.coverage = coverage
    def add_coverage(self, value):
        self.coverage.append(value)
    def insert_coverage_at(self, index, value):
        self.coverage.insert(index, value)
    def replace_coverage_at(self, index, value):
        self.coverage[index] = value
    def hasContent_(self):
        if (
            self.referencedEntityId or
            self.coverage
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0"  xmlns:cov="https://eml.ecoinformatics.org/coverage-2.2.0" ', name_='spatialSamplingUnitsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('spatialSamplingUnitsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'spatialSamplingUnitsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='spatialSamplingUnitsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='spatialSamplingUnitsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='spatialSamplingUnitsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0"  xmlns:cov="https://eml.ecoinformatics.org/coverage-2.2.0" ', name_='spatialSamplingUnitsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for referencedEntityId_ in self.referencedEntityId:
            namespaceprefix_ = self.referencedEntityId_nsprefix_ + ':' if (UseCapturedNS_ and self.referencedEntityId_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sreferencedEntityId>%s</%sreferencedEntityId>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(referencedEntityId_), input_name='referencedEntityId')), namespaceprefix_ , eol_))
        for coverage_ in self.coverage:
            namespaceprefix_ = self.coverage_nsprefix_ + ':' if (UseCapturedNS_ and self.coverage_nsprefix_) else ''
            coverage_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='coverage', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'referencedEntityId':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'referencedEntityId')
            value_ = self.gds_validate_string(value_, node, 'referencedEntityId')
            self.referencedEntityId.append(value_)
            self.referencedEntityId_nsprefix_ = child_.prefix
        elif nodeName_ == 'coverage':
            obj_ = GeographicCoverage.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.coverage.append(obj_)
            obj_.original_tagname_ = 'coverage'
# end class spatialSamplingUnitsType


class referencedEntityId(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, referencedEntityId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if referencedEntityId.subclass:
            return referencedEntityId.subclass(*args_, **kwargs_)
        else:
            return referencedEntityId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referencedEntityId', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('referencedEntityId')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'referencedEntityId':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='referencedEntityId')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='referencedEntityId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='referencedEntityId'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referencedEntityId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class referencedEntityId


class alternateIdentifierType29(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('system', 'SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, system=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, alternateIdentifierType29)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if alternateIdentifierType29.subclass:
            return alternateIdentifierType29.subclass(*args_, **kwargs_)
        else:
            return alternateIdentifierType29(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_SystemType(self, value):
        # Validate type SystemType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='alternateIdentifierType29', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('alternateIdentifierType29')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'alternateIdentifierType29':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='alternateIdentifierType29')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='alternateIdentifierType29', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='alternateIdentifierType29'):
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='alternateIdentifierType29', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class alternateIdentifierType29


class associatedPartyType30(ResponsibleParty):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('role', ['RoleType', 'xs:string'], 0, 0, {'name': 'role', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = ResponsibleParty
    def __init__(self, id=None, system=None, scope='document', individualName=None, organizationName=None, positionName=None, address=None, phone=None, electronicMailAddress=None, onlineUrl=None, userId=None, references=None, role=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(associatedPartyType30, self).__init__(id, system, scope, individualName, organizationName, positionName, address, phone, electronicMailAddress, onlineUrl, userId, references,  **kwargs_)
        self.role = role
        self.validate_RoleType(self.role)
        self.role_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, associatedPartyType30)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if associatedPartyType30.subclass:
            return associatedPartyType30.subclass(*args_, **kwargs_)
        else:
            return associatedPartyType30(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_role(self):
        return self.role
    def set_role(self, role):
        self.role = role
    def validate_RoleType(self, value):
        result = True
        # Validate type RoleType, a restriction on xs:string.
        pass
        return result
    def hasContent_(self):
        if (
            self.role is not None or
            super(associatedPartyType30, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:rp="https://eml.ecoinformatics.org/party-2.2.0" ', name_='associatedPartyType30', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('associatedPartyType30')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'associatedPartyType30':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='associatedPartyType30')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='associatedPartyType30', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='associatedPartyType30'):
        super(associatedPartyType30, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='associatedPartyType30')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:rp="https://eml.ecoinformatics.org/party-2.2.0" ', name_='associatedPartyType30', fromsubclass_=False, pretty_print=True):
        super(associatedPartyType30, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.role is not None:
            namespaceprefix_ = self.role_nsprefix_ + ':' if (UseCapturedNS_ and self.role_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srole>%s</%srole>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.role), input_name='role')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(associatedPartyType30, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'role':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'role')
            value_ = self.gds_validate_string(value_, node, 'role')
            self.role = value_
            self.role_nsprefix_ = child_.prefix
            # validate type RoleType
            self.validate_RoleType(self.role)
        super(associatedPartyType30, self).buildChildren(child_, node, nodeName_, True)
# end class associatedPartyType30


class keywordSetType31(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('keyword', 'keywordType32', 1, 0, {'maxOccurs': 'unbounded', 'name': 'keyword', 'type': 'keywordType32'}, None),
        MemberSpec_('keywordThesaurus', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'keywordThesaurus', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, keyword=None, keywordThesaurus=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if keyword is None:
            self.keyword = []
        else:
            self.keyword = keyword
        self.keyword_nsprefix_ = None
        self.keywordThesaurus = keywordThesaurus
        self.validate_NonEmptyStringType(self.keywordThesaurus)
        self.keywordThesaurus_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, keywordSetType31)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if keywordSetType31.subclass:
            return keywordSetType31.subclass(*args_, **kwargs_)
        else:
            return keywordSetType31(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_keyword(self):
        return self.keyword
    def set_keyword(self, keyword):
        self.keyword = keyword
    def add_keyword(self, value):
        self.keyword.append(value)
    def insert_keyword_at(self, index, value):
        self.keyword.insert(index, value)
    def replace_keyword_at(self, index, value):
        self.keyword[index] = value
    def get_keywordThesaurus(self):
        return self.keywordThesaurus
    def set_keywordThesaurus(self, keywordThesaurus):
        self.keywordThesaurus = keywordThesaurus
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def hasContent_(self):
        if (
            self.keyword or
            self.keywordThesaurus is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='keywordSetType31', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('keywordSetType31')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'keywordSetType31':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='keywordSetType31')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='keywordSetType31', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='keywordSetType31'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='keywordSetType31', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for keyword_ in self.keyword:
            namespaceprefix_ = self.keyword_nsprefix_ + ':' if (UseCapturedNS_ and self.keyword_nsprefix_) else ''
            keyword_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='keyword', pretty_print=pretty_print)
        if self.keywordThesaurus is not None:
            namespaceprefix_ = self.keywordThesaurus_nsprefix_ + ':' if (UseCapturedNS_ and self.keywordThesaurus_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%skeywordThesaurus>%s</%skeywordThesaurus>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.keywordThesaurus), input_name='keywordThesaurus')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'keyword':
            obj_ = keywordType32.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.keyword.append(obj_)
            obj_.original_tagname_ = 'keyword'
        elif nodeName_ == 'keywordThesaurus':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'keywordThesaurus')
            value_ = self.gds_validate_string(value_, node, 'keywordThesaurus')
            self.keywordThesaurus = value_
            self.keywordThesaurus_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.keywordThesaurus)
# end class keywordSetType31


class keywordType32(i18nNonEmptyStringType):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('keywordType', 'KeyTypeCode', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'i18nNonEmptyStringType', 0),
    ]
    subclass = None
    superclass = i18nNonEmptyStringType
    def __init__(self, lang=None, value=None, keywordType=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(keywordType32, self).__init__(lang, value, valueOf_, mixedclass_, content_,  **kwargs_)
        self.keywordType = _cast(None, keywordType)
        self.keywordType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, keywordType32)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if keywordType32.subclass:
            return keywordType32.subclass(*args_, **kwargs_)
        else:
            return keywordType32(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_keywordType(self):
        return self.keywordType
    def set_keywordType(self, keywordType):
        self.keywordType = keywordType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_KeyTypeCode(self, value):
        # Validate type KeyTypeCode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['place', 'stratum', 'temporal', 'theme', 'taxonomic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on KeyTypeCode' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(keywordType32, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='keywordType32', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('keywordType32')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'keywordType32':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='keywordType32')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='keywordType32', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='keywordType32'):
        super(keywordType32, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='keywordType32')
        if self.keywordType is not None and 'keywordType' not in already_processed:
            already_processed.add('keywordType')
            outfile.write(' keywordType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.keywordType), input_name='keywordType')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='keywordType32', fromsubclass_=False, pretty_print=True):
        super(keywordType32, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('keywordType', node)
        if value is not None and 'keywordType' not in already_processed:
            already_processed.add('keywordType')
            self.keywordType = value
            self.validate_KeyTypeCode(self.keywordType)    # validate type KeyTypeCode
        super(keywordType32, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(keywordType32, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class keywordType32


class implementationType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('distribution', 'PhysicalDistributionType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'distribution', 'type': 'PhysicalDistributionType'}, None),
        MemberSpec_('size', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'size', 'type': 'xs:string'}, None),
        MemberSpec_('language', 'languageType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'language', 'type': 'languageType'}, None),
        MemberSpec_('operatingSystem', ['NonEmptyStringType', 'xs:string'], 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'operatingSystem', 'type': 'xs:string'}, None),
        MemberSpec_('machineProcessor', ['NonEmptyStringType', 'xs:string'], 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'machineProcessor', 'type': 'xs:string'}, None),
        MemberSpec_('virtualMachine', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'virtualMachine', 'type': 'xs:string'}, None),
        MemberSpec_('diskUsage', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'diskUsage', 'type': 'xs:string'}, None),
        MemberSpec_('runtimeMemoryUsage', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'runtimeMemoryUsage', 'type': 'xs:string'}, None),
        MemberSpec_('programmingLanguage', ['NonEmptyStringType', 'xs:string'], 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'programmingLanguage', 'type': 'xs:string'}, None),
        MemberSpec_('checksum', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'checksum', 'type': 'xs:string'}, None),
        MemberSpec_('dependency', 'DependencyType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'dependency', 'type': 'DependencyType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, distribution=None, size=None, language=None, operatingSystem=None, machineProcessor=None, virtualMachine=None, diskUsage=None, runtimeMemoryUsage=None, programmingLanguage=None, checksum=None, dependency=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if distribution is None:
            self.distribution = []
        else:
            self.distribution = distribution
        self.distribution_nsprefix_ = None
        self.size = size
        self.validate_NonEmptyStringType(self.size)
        self.size_nsprefix_ = None
        if language is None:
            self.language = []
        else:
            self.language = language
        self.language_nsprefix_ = None
        if operatingSystem is None:
            self.operatingSystem = []
        else:
            self.operatingSystem = operatingSystem
        self.operatingSystem_nsprefix_ = None
        if machineProcessor is None:
            self.machineProcessor = []
        else:
            self.machineProcessor = machineProcessor
        self.machineProcessor_nsprefix_ = None
        self.virtualMachine = virtualMachine
        self.validate_NonEmptyStringType(self.virtualMachine)
        self.virtualMachine_nsprefix_ = None
        self.diskUsage = diskUsage
        self.validate_NonEmptyStringType(self.diskUsage)
        self.diskUsage_nsprefix_ = None
        self.runtimeMemoryUsage = runtimeMemoryUsage
        self.validate_NonEmptyStringType(self.runtimeMemoryUsage)
        self.runtimeMemoryUsage_nsprefix_ = None
        if programmingLanguage is None:
            self.programmingLanguage = []
        else:
            self.programmingLanguage = programmingLanguage
        self.programmingLanguage_nsprefix_ = None
        self.checksum = checksum
        self.validate_NonEmptyStringType(self.checksum)
        self.checksum_nsprefix_ = None
        if dependency is None:
            self.dependency = []
        else:
            self.dependency = dependency
        self.dependency_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, implementationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if implementationType.subclass:
            return implementationType.subclass(*args_, **kwargs_)
        else:
            return implementationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_distribution(self):
        return self.distribution
    def set_distribution(self, distribution):
        self.distribution = distribution
    def add_distribution(self, value):
        self.distribution.append(value)
    def insert_distribution_at(self, index, value):
        self.distribution.insert(index, value)
    def replace_distribution_at(self, index, value):
        self.distribution[index] = value
    def get_size(self):
        return self.size
    def set_size(self, size):
        self.size = size
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def add_language(self, value):
        self.language.append(value)
    def insert_language_at(self, index, value):
        self.language.insert(index, value)
    def replace_language_at(self, index, value):
        self.language[index] = value
    def get_operatingSystem(self):
        return self.operatingSystem
    def set_operatingSystem(self, operatingSystem):
        self.operatingSystem = operatingSystem
    def add_operatingSystem(self, value):
        self.operatingSystem.append(value)
    def insert_operatingSystem_at(self, index, value):
        self.operatingSystem.insert(index, value)
    def replace_operatingSystem_at(self, index, value):
        self.operatingSystem[index] = value
    def get_machineProcessor(self):
        return self.machineProcessor
    def set_machineProcessor(self, machineProcessor):
        self.machineProcessor = machineProcessor
    def add_machineProcessor(self, value):
        self.machineProcessor.append(value)
    def insert_machineProcessor_at(self, index, value):
        self.machineProcessor.insert(index, value)
    def replace_machineProcessor_at(self, index, value):
        self.machineProcessor[index] = value
    def get_virtualMachine(self):
        return self.virtualMachine
    def set_virtualMachine(self, virtualMachine):
        self.virtualMachine = virtualMachine
    def get_diskUsage(self):
        return self.diskUsage
    def set_diskUsage(self, diskUsage):
        self.diskUsage = diskUsage
    def get_runtimeMemoryUsage(self):
        return self.runtimeMemoryUsage
    def set_runtimeMemoryUsage(self, runtimeMemoryUsage):
        self.runtimeMemoryUsage = runtimeMemoryUsage
    def get_programmingLanguage(self):
        return self.programmingLanguage
    def set_programmingLanguage(self, programmingLanguage):
        self.programmingLanguage = programmingLanguage
    def add_programmingLanguage(self, value):
        self.programmingLanguage.append(value)
    def insert_programmingLanguage_at(self, index, value):
        self.programmingLanguage.insert(index, value)
    def replace_programmingLanguage_at(self, index, value):
        self.programmingLanguage[index] = value
    def get_checksum(self):
        return self.checksum
    def set_checksum(self, checksum):
        self.checksum = checksum
    def get_dependency(self):
        return self.dependency
    def set_dependency(self, dependency):
        self.dependency = dependency
    def add_dependency(self, value):
        self.dependency.append(value)
    def insert_dependency_at(self, index, value):
        self.dependency.insert(index, value)
    def replace_dependency_at(self, index, value):
        self.dependency[index] = value
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def hasContent_(self):
        if (
            self.distribution or
            self.size is not None or
            self.language or
            self.operatingSystem or
            self.machineProcessor or
            self.virtualMachine is not None or
            self.diskUsage is not None or
            self.runtimeMemoryUsage is not None or
            self.programmingLanguage or
            self.checksum is not None or
            self.dependency
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:phys="https://eml.ecoinformatics.org/physical-2.2.0"  xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='implementationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('implementationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'implementationType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='implementationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='implementationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='implementationType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:phys="https://eml.ecoinformatics.org/physical-2.2.0"  xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='implementationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for distribution_ in self.distribution:
            namespaceprefix_ = self.distribution_nsprefix_ + ':' if (UseCapturedNS_ and self.distribution_nsprefix_) else ''
            distribution_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='distribution', pretty_print=pretty_print)
        if self.size is not None:
            namespaceprefix_ = self.size_nsprefix_ + ':' if (UseCapturedNS_ and self.size_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssize>%s</%ssize>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.size), input_name='size')), namespaceprefix_ , eol_))
        for language_ in self.language:
            namespaceprefix_ = self.language_nsprefix_ + ':' if (UseCapturedNS_ and self.language_nsprefix_) else ''
            language_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='language', pretty_print=pretty_print)
        for operatingSystem_ in self.operatingSystem:
            namespaceprefix_ = self.operatingSystem_nsprefix_ + ':' if (UseCapturedNS_ and self.operatingSystem_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soperatingSystem>%s</%soperatingSystem>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(operatingSystem_), input_name='operatingSystem')), namespaceprefix_ , eol_))
        for machineProcessor_ in self.machineProcessor:
            namespaceprefix_ = self.machineProcessor_nsprefix_ + ':' if (UseCapturedNS_ and self.machineProcessor_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smachineProcessor>%s</%smachineProcessor>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(machineProcessor_), input_name='machineProcessor')), namespaceprefix_ , eol_))
        if self.virtualMachine is not None:
            namespaceprefix_ = self.virtualMachine_nsprefix_ + ':' if (UseCapturedNS_ and self.virtualMachine_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svirtualMachine>%s</%svirtualMachine>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.virtualMachine), input_name='virtualMachine')), namespaceprefix_ , eol_))
        if self.diskUsage is not None:
            namespaceprefix_ = self.diskUsage_nsprefix_ + ':' if (UseCapturedNS_ and self.diskUsage_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdiskUsage>%s</%sdiskUsage>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.diskUsage), input_name='diskUsage')), namespaceprefix_ , eol_))
        if self.runtimeMemoryUsage is not None:
            namespaceprefix_ = self.runtimeMemoryUsage_nsprefix_ + ':' if (UseCapturedNS_ and self.runtimeMemoryUsage_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sruntimeMemoryUsage>%s</%sruntimeMemoryUsage>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.runtimeMemoryUsage), input_name='runtimeMemoryUsage')), namespaceprefix_ , eol_))
        for programmingLanguage_ in self.programmingLanguage:
            namespaceprefix_ = self.programmingLanguage_nsprefix_ + ':' if (UseCapturedNS_ and self.programmingLanguage_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprogrammingLanguage>%s</%sprogrammingLanguage>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(programmingLanguage_), input_name='programmingLanguage')), namespaceprefix_ , eol_))
        if self.checksum is not None:
            namespaceprefix_ = self.checksum_nsprefix_ + ':' if (UseCapturedNS_ and self.checksum_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%schecksum>%s</%schecksum>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.checksum), input_name='checksum')), namespaceprefix_ , eol_))
        for dependency_ in self.dependency:
            namespaceprefix_ = self.dependency_nsprefix_ + ':' if (UseCapturedNS_ and self.dependency_nsprefix_) else ''
            dependency_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dependency', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'distribution':
            obj_ = PhysicalDistributionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.distribution.append(obj_)
            obj_.original_tagname_ = 'distribution'
        elif nodeName_ == 'size':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'size')
            value_ = self.gds_validate_string(value_, node, 'size')
            self.size = value_
            self.size_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.size)
        elif nodeName_ == 'language':
            obj_ = languageType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.language.append(obj_)
            obj_.original_tagname_ = 'language'
        elif nodeName_ == 'operatingSystem':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'operatingSystem')
            value_ = self.gds_validate_string(value_, node, 'operatingSystem')
            self.operatingSystem.append(value_)
            self.operatingSystem_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.operatingSystem[-1])
        elif nodeName_ == 'machineProcessor':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'machineProcessor')
            value_ = self.gds_validate_string(value_, node, 'machineProcessor')
            self.machineProcessor.append(value_)
            self.machineProcessor_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.machineProcessor[-1])
        elif nodeName_ == 'virtualMachine':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'virtualMachine')
            value_ = self.gds_validate_string(value_, node, 'virtualMachine')
            self.virtualMachine = value_
            self.virtualMachine_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.virtualMachine)
        elif nodeName_ == 'diskUsage':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'diskUsage')
            value_ = self.gds_validate_string(value_, node, 'diskUsage')
            self.diskUsage = value_
            self.diskUsage_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.diskUsage)
        elif nodeName_ == 'runtimeMemoryUsage':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'runtimeMemoryUsage')
            value_ = self.gds_validate_string(value_, node, 'runtimeMemoryUsage')
            self.runtimeMemoryUsage = value_
            self.runtimeMemoryUsage_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.runtimeMemoryUsage)
        elif nodeName_ == 'programmingLanguage':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'programmingLanguage')
            value_ = self.gds_validate_string(value_, node, 'programmingLanguage')
            self.programmingLanguage.append(value_)
            self.programmingLanguage_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.programmingLanguage[-1])
        elif nodeName_ == 'checksum':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'checksum')
            value_ = self.gds_validate_string(value_, node, 'checksum')
            self.checksum = value_
            self.checksum_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.checksum)
        elif nodeName_ == 'dependency':
            obj_ = DependencyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dependency.append(obj_)
            obj_.original_tagname_ = 'dependency'
# end class implementationType


class languageType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('LanguageValue', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'LanguageValue', 'type': 'xs:string'}, None),
        MemberSpec_('LanguageCodeStandard', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'LanguageCodeStandard', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, LanguageValue=None, LanguageCodeStandard=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.LanguageValue = LanguageValue
        self.validate_NonEmptyStringType(self.LanguageValue)
        self.LanguageValue_nsprefix_ = None
        self.LanguageCodeStandard = LanguageCodeStandard
        self.validate_NonEmptyStringType(self.LanguageCodeStandard)
        self.LanguageCodeStandard_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, languageType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if languageType.subclass:
            return languageType.subclass(*args_, **kwargs_)
        else:
            return languageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_LanguageValue(self):
        return self.LanguageValue
    def set_LanguageValue(self, LanguageValue):
        self.LanguageValue = LanguageValue
    def get_LanguageCodeStandard(self):
        return self.LanguageCodeStandard
    def set_LanguageCodeStandard(self, LanguageCodeStandard):
        self.LanguageCodeStandard = LanguageCodeStandard
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def hasContent_(self):
        if (
            self.LanguageValue is not None or
            self.LanguageCodeStandard is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='languageType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('languageType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'languageType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='languageType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='languageType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='languageType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='languageType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LanguageValue is not None:
            namespaceprefix_ = self.LanguageValue_nsprefix_ + ':' if (UseCapturedNS_ and self.LanguageValue_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLanguageValue>%s</%sLanguageValue>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.LanguageValue), input_name='LanguageValue')), namespaceprefix_ , eol_))
        if self.LanguageCodeStandard is not None:
            namespaceprefix_ = self.LanguageCodeStandard_nsprefix_ + ':' if (UseCapturedNS_ and self.LanguageCodeStandard_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLanguageCodeStandard>%s</%sLanguageCodeStandard>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.LanguageCodeStandard), input_name='LanguageCodeStandard')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'LanguageValue':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'LanguageValue')
            value_ = self.gds_validate_string(value_, node, 'LanguageValue')
            self.LanguageValue = value_
            self.LanguageValue_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.LanguageValue)
        elif nodeName_ == 'LanguageCodeStandard':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'LanguageCodeStandard')
            value_ = self.gds_validate_string(value_, node, 'LanguageCodeStandard')
            self.LanguageCodeStandard = value_
            self.LanguageCodeStandard_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.LanguageCodeStandard)
# end class languageType


class referencesType33(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('system', 'SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, system=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, referencesType33)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if referencesType33.subclass:
            return referencesType33.subclass(*args_, **kwargs_)
        else:
            return referencesType33(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_SystemType(self, value):
        # Validate type SystemType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referencesType33', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('referencesType33')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'referencesType33':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='referencesType33')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='referencesType33', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='referencesType33'):
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referencesType33', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class referencesType33


class alternateIdentifierType34(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('system', 'SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, system=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, alternateIdentifierType34)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if alternateIdentifierType34.subclass:
            return alternateIdentifierType34.subclass(*args_, **kwargs_)
        else:
            return alternateIdentifierType34(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_SystemType(self, value):
        # Validate type SystemType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='alternateIdentifierType34', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('alternateIdentifierType34')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'alternateIdentifierType34':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='alternateIdentifierType34')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='alternateIdentifierType34', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='alternateIdentifierType34'):
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='alternateIdentifierType34', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class alternateIdentifierType34


class associatedPartyType35(ResponsibleParty):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('role', ['RoleType', 'xs:string'], 0, 0, {'name': 'role', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = ResponsibleParty
    def __init__(self, id=None, system=None, scope='document', individualName=None, organizationName=None, positionName=None, address=None, phone=None, electronicMailAddress=None, onlineUrl=None, userId=None, references=None, role=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(associatedPartyType35, self).__init__(id, system, scope, individualName, organizationName, positionName, address, phone, electronicMailAddress, onlineUrl, userId, references,  **kwargs_)
        self.role = role
        self.validate_RoleType(self.role)
        self.role_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, associatedPartyType35)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if associatedPartyType35.subclass:
            return associatedPartyType35.subclass(*args_, **kwargs_)
        else:
            return associatedPartyType35(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_role(self):
        return self.role
    def set_role(self, role):
        self.role = role
    def validate_RoleType(self, value):
        result = True
        # Validate type RoleType, a restriction on xs:string.
        pass
        return result
    def hasContent_(self):
        if (
            self.role is not None or
            super(associatedPartyType35, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:rp="https://eml.ecoinformatics.org/party-2.2.0" ', name_='associatedPartyType35', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('associatedPartyType35')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'associatedPartyType35':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='associatedPartyType35')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='associatedPartyType35', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='associatedPartyType35'):
        super(associatedPartyType35, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='associatedPartyType35')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:rp="https://eml.ecoinformatics.org/party-2.2.0" ', name_='associatedPartyType35', fromsubclass_=False, pretty_print=True):
        super(associatedPartyType35, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.role is not None:
            namespaceprefix_ = self.role_nsprefix_ + ':' if (UseCapturedNS_ and self.role_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srole>%s</%srole>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.role), input_name='role')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(associatedPartyType35, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'role':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'role')
            value_ = self.gds_validate_string(value_, node, 'role')
            self.role = value_
            self.role_nsprefix_ = child_.prefix
            # validate type RoleType
            self.validate_RoleType(self.role)
        super(associatedPartyType35, self).buildChildren(child_, node, nodeName_, True)
# end class associatedPartyType35


class keywordSetType36(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('keyword', 'keywordType37', 1, 0, {'maxOccurs': 'unbounded', 'name': 'keyword', 'type': 'keywordType37'}, None),
        MemberSpec_('keywordThesaurus', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'keywordThesaurus', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, keyword=None, keywordThesaurus=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if keyword is None:
            self.keyword = []
        else:
            self.keyword = keyword
        self.keyword_nsprefix_ = None
        self.keywordThesaurus = keywordThesaurus
        self.validate_NonEmptyStringType(self.keywordThesaurus)
        self.keywordThesaurus_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, keywordSetType36)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if keywordSetType36.subclass:
            return keywordSetType36.subclass(*args_, **kwargs_)
        else:
            return keywordSetType36(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_keyword(self):
        return self.keyword
    def set_keyword(self, keyword):
        self.keyword = keyword
    def add_keyword(self, value):
        self.keyword.append(value)
    def insert_keyword_at(self, index, value):
        self.keyword.insert(index, value)
    def replace_keyword_at(self, index, value):
        self.keyword[index] = value
    def get_keywordThesaurus(self):
        return self.keywordThesaurus
    def set_keywordThesaurus(self, keywordThesaurus):
        self.keywordThesaurus = keywordThesaurus
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def hasContent_(self):
        if (
            self.keyword or
            self.keywordThesaurus is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='keywordSetType36', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('keywordSetType36')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'keywordSetType36':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='keywordSetType36')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='keywordSetType36', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='keywordSetType36'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='keywordSetType36', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for keyword_ in self.keyword:
            namespaceprefix_ = self.keyword_nsprefix_ + ':' if (UseCapturedNS_ and self.keyword_nsprefix_) else ''
            keyword_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='keyword', pretty_print=pretty_print)
        if self.keywordThesaurus is not None:
            namespaceprefix_ = self.keywordThesaurus_nsprefix_ + ':' if (UseCapturedNS_ and self.keywordThesaurus_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%skeywordThesaurus>%s</%skeywordThesaurus>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.keywordThesaurus), input_name='keywordThesaurus')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'keyword':
            obj_ = keywordType37.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.keyword.append(obj_)
            obj_.original_tagname_ = 'keyword'
        elif nodeName_ == 'keywordThesaurus':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'keywordThesaurus')
            value_ = self.gds_validate_string(value_, node, 'keywordThesaurus')
            self.keywordThesaurus = value_
            self.keywordThesaurus_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.keywordThesaurus)
# end class keywordSetType36


class keywordType37(i18nNonEmptyStringType):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('keywordType', 'KeyTypeCode', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'i18nNonEmptyStringType', 0),
    ]
    subclass = None
    superclass = i18nNonEmptyStringType
    def __init__(self, lang=None, value=None, keywordType=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(keywordType37, self).__init__(lang, value, valueOf_, mixedclass_, content_,  **kwargs_)
        self.keywordType = _cast(None, keywordType)
        self.keywordType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, keywordType37)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if keywordType37.subclass:
            return keywordType37.subclass(*args_, **kwargs_)
        else:
            return keywordType37(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_keywordType(self):
        return self.keywordType
    def set_keywordType(self, keywordType):
        self.keywordType = keywordType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_KeyTypeCode(self, value):
        # Validate type KeyTypeCode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['place', 'stratum', 'temporal', 'theme', 'taxonomic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on KeyTypeCode' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(keywordType37, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='keywordType37', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('keywordType37')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'keywordType37':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='keywordType37')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='keywordType37', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='keywordType37'):
        super(keywordType37, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='keywordType37')
        if self.keywordType is not None and 'keywordType' not in already_processed:
            already_processed.add('keywordType')
            outfile.write(' keywordType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.keywordType), input_name='keywordType')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='keywordType37', fromsubclass_=False, pretty_print=True):
        super(keywordType37, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('keywordType', node)
        if value is not None and 'keywordType' not in already_processed:
            already_processed.add('keywordType')
            self.keywordType = value
            self.validate_KeyTypeCode(self.keywordType)    # validate type KeyTypeCode
        super(keywordType37, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(keywordType37, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class keywordType37


class referencesType38(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('system', 'SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, system=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, referencesType38)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if referencesType38.subclass:
            return referencesType38.subclass(*args_, **kwargs_)
        else:
            return referencesType38(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_SystemType(self, value):
        # Validate type SystemType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referencesType38', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('referencesType38')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'referencesType38':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='referencesType38')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='referencesType38', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='referencesType38'):
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referencesType38', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class referencesType38


class referencesType39(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('system', 'SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, system=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, referencesType39)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if referencesType39.subclass:
            return referencesType39.subclass(*args_, **kwargs_)
        else:
            return referencesType39(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_SystemType(self, value):
        # Validate type SystemType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referencesType39', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('referencesType39')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'referencesType39':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='referencesType39')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='referencesType39', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='referencesType39'):
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referencesType39', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class referencesType39


class storageTypeType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('typeSystem', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, typeSystem='http://www.w3.org/2001/XMLSchema-datatypes', valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.typeSystem = _cast(None, typeSystem)
        self.typeSystem_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, storageTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if storageTypeType.subclass:
            return storageTypeType.subclass(*args_, **kwargs_)
        else:
            return storageTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_typeSystem(self):
        return self.typeSystem
    def set_typeSystem(self, typeSystem):
        self.typeSystem = typeSystem
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='storageTypeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('storageTypeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'storageTypeType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='storageTypeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='storageTypeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='storageTypeType'):
        if self.typeSystem != "http://www.w3.org/2001/XMLSchema-datatypes" and 'typeSystem' not in already_processed:
            already_processed.add('typeSystem')
            outfile.write(' typeSystem=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.typeSystem), input_name='typeSystem')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='storageTypeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('typeSystem', node)
        if value is not None and 'typeSystem' not in already_processed:
            already_processed.add('typeSystem')
            self.typeSystem = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class storageTypeType


class measurementScaleType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('nominal', 'nominalType', 0, 0, {'name': 'nominal', 'type': 'nominalType'}, 66),
        MemberSpec_('ordinal', 'ordinalType', 0, 0, {'name': 'ordinal', 'type': 'ordinalType'}, 66),
        MemberSpec_('interval', 'intervalType', 0, 0, {'name': 'interval', 'type': 'intervalType'}, 66),
        MemberSpec_('ratio', 'ratioType', 0, 0, {'name': 'ratio', 'type': 'ratioType'}, 66),
        MemberSpec_('dateTime', 'dateTimeType', 0, 0, {'name': 'dateTime', 'type': 'dateTimeType'}, 66),
    ]
    subclass = None
    superclass = None
    def __init__(self, nominal=None, ordinal=None, interval=None, ratio=None, dateTime=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nominal = nominal
        self.nominal_nsprefix_ = None
        self.ordinal = ordinal
        self.ordinal_nsprefix_ = None
        self.interval = interval
        self.interval_nsprefix_ = None
        self.ratio = ratio
        self.ratio_nsprefix_ = None
        self.dateTime = dateTime
        self.dateTime_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, measurementScaleType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if measurementScaleType.subclass:
            return measurementScaleType.subclass(*args_, **kwargs_)
        else:
            return measurementScaleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_nominal(self):
        return self.nominal
    def set_nominal(self, nominal):
        self.nominal = nominal
    def get_ordinal(self):
        return self.ordinal
    def set_ordinal(self, ordinal):
        self.ordinal = ordinal
    def get_interval(self):
        return self.interval
    def set_interval(self, interval):
        self.interval = interval
    def get_ratio(self):
        return self.ratio
    def set_ratio(self, ratio):
        self.ratio = ratio
    def get_dateTime(self):
        return self.dateTime
    def set_dateTime(self, dateTime):
        self.dateTime = dateTime
    def hasContent_(self):
        if (
            self.nominal is not None or
            self.ordinal is not None or
            self.interval is not None or
            self.ratio is not None or
            self.dateTime is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='measurementScaleType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('measurementScaleType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'measurementScaleType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='measurementScaleType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='measurementScaleType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='measurementScaleType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='measurementScaleType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nominal is not None:
            namespaceprefix_ = self.nominal_nsprefix_ + ':' if (UseCapturedNS_ and self.nominal_nsprefix_) else ''
            self.nominal.export(outfile, level, namespaceprefix_, namespacedef_='', name_='nominal', pretty_print=pretty_print)
        if self.ordinal is not None:
            namespaceprefix_ = self.ordinal_nsprefix_ + ':' if (UseCapturedNS_ and self.ordinal_nsprefix_) else ''
            self.ordinal.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ordinal', pretty_print=pretty_print)
        if self.interval is not None:
            namespaceprefix_ = self.interval_nsprefix_ + ':' if (UseCapturedNS_ and self.interval_nsprefix_) else ''
            self.interval.export(outfile, level, namespaceprefix_, namespacedef_='', name_='interval', pretty_print=pretty_print)
        if self.ratio is not None:
            namespaceprefix_ = self.ratio_nsprefix_ + ':' if (UseCapturedNS_ and self.ratio_nsprefix_) else ''
            self.ratio.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ratio', pretty_print=pretty_print)
        if self.dateTime is not None:
            namespaceprefix_ = self.dateTime_nsprefix_ + ':' if (UseCapturedNS_ and self.dateTime_nsprefix_) else ''
            self.dateTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dateTime', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'nominal':
            obj_ = nominalType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.nominal = obj_
            obj_.original_tagname_ = 'nominal'
        elif nodeName_ == 'ordinal':
            obj_ = ordinalType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ordinal = obj_
            obj_.original_tagname_ = 'ordinal'
        elif nodeName_ == 'interval':
            obj_ = intervalType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.interval = obj_
            obj_.original_tagname_ = 'interval'
        elif nodeName_ == 'ratio':
            obj_ = ratioType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ratio = obj_
            obj_.original_tagname_ = 'ratio'
        elif nodeName_ == 'dateTime':
            obj_ = dateTimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dateTime = obj_
            obj_.original_tagname_ = 'dateTime'
# end class measurementScaleType


class nominalType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('nonNumericDomain', 'NonNumericDomainType', 0, 0, {'name': 'nonNumericDomain', 'type': 'NonNumericDomainType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, nonNumericDomain=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nonNumericDomain = nonNumericDomain
        self.nonNumericDomain_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nominalType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nominalType.subclass:
            return nominalType.subclass(*args_, **kwargs_)
        else:
            return nominalType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_nonNumericDomain(self):
        return self.nonNumericDomain
    def set_nonNumericDomain(self, nonNumericDomain):
        self.nonNumericDomain = nonNumericDomain
    def hasContent_(self):
        if (
            self.nonNumericDomain is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='nominalType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('nominalType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'nominalType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='nominalType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='nominalType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='nominalType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='nominalType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nonNumericDomain is not None:
            namespaceprefix_ = self.nonNumericDomain_nsprefix_ + ':' if (UseCapturedNS_ and self.nonNumericDomain_nsprefix_) else ''
            self.nonNumericDomain.export(outfile, level, namespaceprefix_, namespacedef_='', name_='nonNumericDomain', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'nonNumericDomain':
            obj_ = NonNumericDomainType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.nonNumericDomain = obj_
            obj_.original_tagname_ = 'nonNumericDomain'
# end class nominalType


class ordinalType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('nonNumericDomain', 'NonNumericDomainType', 0, 0, {'name': 'nonNumericDomain', 'type': 'NonNumericDomainType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, nonNumericDomain=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nonNumericDomain = nonNumericDomain
        self.nonNumericDomain_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ordinalType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ordinalType.subclass:
            return ordinalType.subclass(*args_, **kwargs_)
        else:
            return ordinalType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_nonNumericDomain(self):
        return self.nonNumericDomain
    def set_nonNumericDomain(self, nonNumericDomain):
        self.nonNumericDomain = nonNumericDomain
    def hasContent_(self):
        if (
            self.nonNumericDomain is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='ordinalType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ordinalType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ordinalType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ordinalType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ordinalType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ordinalType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='ordinalType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nonNumericDomain is not None:
            namespaceprefix_ = self.nonNumericDomain_nsprefix_ + ':' if (UseCapturedNS_ and self.nonNumericDomain_nsprefix_) else ''
            self.nonNumericDomain.export(outfile, level, namespaceprefix_, namespacedef_='', name_='nonNumericDomain', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'nonNumericDomain':
            obj_ = NonNumericDomainType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.nonNumericDomain = obj_
            obj_.original_tagname_ = 'nonNumericDomain'
# end class ordinalType


class intervalType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('unit', 'UnitType', 0, 0, {'name': 'unit', 'type': 'UnitType'}, None),
        MemberSpec_('precision', 'PrecisionType', 0, 1, {'minOccurs': '0', 'name': 'precision', 'type': 'PrecisionType'}, None),
        MemberSpec_('numericDomain', 'NumericDomainType', 0, 0, {'name': 'numericDomain', 'type': 'NumericDomainType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, unit=None, precision=None, numericDomain=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.unit = unit
        self.unit_nsprefix_ = None
        self.precision = precision
        self.precision_nsprefix_ = None
        self.numericDomain = numericDomain
        self.numericDomain_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, intervalType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if intervalType.subclass:
            return intervalType.subclass(*args_, **kwargs_)
        else:
            return intervalType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_unit(self):
        return self.unit
    def set_unit(self, unit):
        self.unit = unit
    def get_precision(self):
        return self.precision
    def set_precision(self, precision):
        self.precision = precision
    def get_numericDomain(self):
        return self.numericDomain
    def set_numericDomain(self, numericDomain):
        self.numericDomain = numericDomain
    def hasContent_(self):
        if (
            self.unit is not None or
            self.precision is not None or
            self.numericDomain is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='intervalType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('intervalType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'intervalType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='intervalType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='intervalType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='intervalType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='intervalType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.unit is not None:
            namespaceprefix_ = self.unit_nsprefix_ + ':' if (UseCapturedNS_ and self.unit_nsprefix_) else ''
            self.unit.export(outfile, level, namespaceprefix_, namespacedef_='', name_='unit', pretty_print=pretty_print)
        if self.precision is not None:
            namespaceprefix_ = self.precision_nsprefix_ + ':' if (UseCapturedNS_ and self.precision_nsprefix_) else ''
            self.precision.export(outfile, level, namespaceprefix_, namespacedef_='', name_='precision', pretty_print=pretty_print)
        if self.numericDomain is not None:
            namespaceprefix_ = self.numericDomain_nsprefix_ + ':' if (UseCapturedNS_ and self.numericDomain_nsprefix_) else ''
            self.numericDomain.export(outfile, level, namespaceprefix_, namespacedef_='', name_='numericDomain', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'unit':
            obj_ = UnitType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.unit = obj_
            obj_.original_tagname_ = 'unit'
        elif nodeName_ == 'precision':
            obj_ = PrecisionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.precision = obj_
            obj_.original_tagname_ = 'precision'
        elif nodeName_ == 'numericDomain':
            obj_ = NumericDomainType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.numericDomain = obj_
            obj_.original_tagname_ = 'numericDomain'
# end class intervalType


class ratioType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('unit', 'UnitType', 0, 0, {'name': 'unit', 'type': 'UnitType'}, None),
        MemberSpec_('precision', 'PrecisionType', 0, 1, {'minOccurs': '0', 'name': 'precision', 'type': 'PrecisionType'}, None),
        MemberSpec_('numericDomain', 'NumericDomainType', 0, 0, {'name': 'numericDomain', 'type': 'NumericDomainType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, unit=None, precision=None, numericDomain=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.unit = unit
        self.unit_nsprefix_ = None
        self.precision = precision
        self.precision_nsprefix_ = None
        self.numericDomain = numericDomain
        self.numericDomain_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ratioType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ratioType.subclass:
            return ratioType.subclass(*args_, **kwargs_)
        else:
            return ratioType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_unit(self):
        return self.unit
    def set_unit(self, unit):
        self.unit = unit
    def get_precision(self):
        return self.precision
    def set_precision(self, precision):
        self.precision = precision
    def get_numericDomain(self):
        return self.numericDomain
    def set_numericDomain(self, numericDomain):
        self.numericDomain = numericDomain
    def hasContent_(self):
        if (
            self.unit is not None or
            self.precision is not None or
            self.numericDomain is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='ratioType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ratioType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ratioType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ratioType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ratioType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ratioType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='ratioType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.unit is not None:
            namespaceprefix_ = self.unit_nsprefix_ + ':' if (UseCapturedNS_ and self.unit_nsprefix_) else ''
            self.unit.export(outfile, level, namespaceprefix_, namespacedef_='', name_='unit', pretty_print=pretty_print)
        if self.precision is not None:
            namespaceprefix_ = self.precision_nsprefix_ + ':' if (UseCapturedNS_ and self.precision_nsprefix_) else ''
            self.precision.export(outfile, level, namespaceprefix_, namespacedef_='', name_='precision', pretty_print=pretty_print)
        if self.numericDomain is not None:
            namespaceprefix_ = self.numericDomain_nsprefix_ + ':' if (UseCapturedNS_ and self.numericDomain_nsprefix_) else ''
            self.numericDomain.export(outfile, level, namespaceprefix_, namespacedef_='', name_='numericDomain', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'unit':
            obj_ = UnitType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.unit = obj_
            obj_.original_tagname_ = 'unit'
        elif nodeName_ == 'precision':
            obj_ = PrecisionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.precision = obj_
            obj_.original_tagname_ = 'precision'
        elif nodeName_ == 'numericDomain':
            obj_ = NumericDomainType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.numericDomain = obj_
            obj_.original_tagname_ = 'numericDomain'
# end class ratioType


class dateTimeType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('formatString', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'formatString', 'type': 'xs:string'}, None),
        MemberSpec_('dateTimePrecision', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'dateTimePrecision', 'type': 'xs:string'}, None),
        MemberSpec_('dateTimeDomain', 'DateTimeDomainType', 0, 1, {'minOccurs': '0', 'name': 'dateTimeDomain', 'type': 'DateTimeDomainType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, formatString=None, dateTimePrecision=None, dateTimeDomain=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.formatString = formatString
        self.validate_NonEmptyStringType(self.formatString)
        self.formatString_nsprefix_ = None
        self.dateTimePrecision = dateTimePrecision
        self.validate_NonEmptyStringType(self.dateTimePrecision)
        self.dateTimePrecision_nsprefix_ = None
        self.dateTimeDomain = dateTimeDomain
        self.dateTimeDomain_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, dateTimeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if dateTimeType.subclass:
            return dateTimeType.subclass(*args_, **kwargs_)
        else:
            return dateTimeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_formatString(self):
        return self.formatString
    def set_formatString(self, formatString):
        self.formatString = formatString
    def get_dateTimePrecision(self):
        return self.dateTimePrecision
    def set_dateTimePrecision(self, dateTimePrecision):
        self.dateTimePrecision = dateTimePrecision
    def get_dateTimeDomain(self):
        return self.dateTimeDomain
    def set_dateTimeDomain(self, dateTimeDomain):
        self.dateTimeDomain = dateTimeDomain
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def hasContent_(self):
        if (
            self.formatString is not None or
            self.dateTimePrecision is not None or
            self.dateTimeDomain is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='dateTimeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('dateTimeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'dateTimeType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='dateTimeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='dateTimeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='dateTimeType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='dateTimeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.formatString is not None:
            namespaceprefix_ = self.formatString_nsprefix_ + ':' if (UseCapturedNS_ and self.formatString_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sformatString>%s</%sformatString>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.formatString), input_name='formatString')), namespaceprefix_ , eol_))
        if self.dateTimePrecision is not None:
            namespaceprefix_ = self.dateTimePrecision_nsprefix_ + ':' if (UseCapturedNS_ and self.dateTimePrecision_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdateTimePrecision>%s</%sdateTimePrecision>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.dateTimePrecision), input_name='dateTimePrecision')), namespaceprefix_ , eol_))
        if self.dateTimeDomain is not None:
            namespaceprefix_ = self.dateTimeDomain_nsprefix_ + ':' if (UseCapturedNS_ and self.dateTimeDomain_nsprefix_) else ''
            self.dateTimeDomain.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dateTimeDomain', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'formatString':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'formatString')
            value_ = self.gds_validate_string(value_, node, 'formatString')
            self.formatString = value_
            self.formatString_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.formatString)
        elif nodeName_ == 'dateTimePrecision':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'dateTimePrecision')
            value_ = self.gds_validate_string(value_, node, 'dateTimePrecision')
            self.dateTimePrecision = value_
            self.dateTimePrecision_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.dateTimePrecision)
        elif nodeName_ == 'dateTimeDomain':
            obj_ = DateTimeDomainType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dateTimeDomain = obj_
            obj_.original_tagname_ = 'dateTimeDomain'
# end class dateTimeType


class missingValueCodeType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('code', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        MemberSpec_('codeExplanation', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'codeExplanation', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, code=None, codeExplanation=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = code
        self.validate_NonEmptyStringType(self.code)
        self.code_nsprefix_ = None
        self.codeExplanation = codeExplanation
        self.validate_NonEmptyStringType(self.codeExplanation)
        self.codeExplanation_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, missingValueCodeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if missingValueCodeType.subclass:
            return missingValueCodeType.subclass(*args_, **kwargs_)
        else:
            return missingValueCodeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_codeExplanation(self):
        return self.codeExplanation
    def set_codeExplanation(self, codeExplanation):
        self.codeExplanation = codeExplanation
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def hasContent_(self):
        if (
            self.code is not None or
            self.codeExplanation is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='missingValueCodeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('missingValueCodeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'missingValueCodeType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='missingValueCodeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='missingValueCodeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='missingValueCodeType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='missingValueCodeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scode>%s</%scode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.code), input_name='code')), namespaceprefix_ , eol_))
        if self.codeExplanation is not None:
            namespaceprefix_ = self.codeExplanation_nsprefix_ + ':' if (UseCapturedNS_ and self.codeExplanation_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scodeExplanation>%s</%scodeExplanation>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.codeExplanation), input_name='codeExplanation')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.code)
        elif nodeName_ == 'codeExplanation':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'codeExplanation')
            value_ = self.gds_validate_string(value_, node, 'codeExplanation')
            self.codeExplanation = value_
            self.codeExplanation_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.codeExplanation)
# end class missingValueCodeType


class referencesType40(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('system', 'SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, system=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, referencesType40)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if referencesType40.subclass:
            return referencesType40.subclass(*args_, **kwargs_)
        else:
            return referencesType40(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_SystemType(self, value):
        # Validate type SystemType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referencesType40', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('referencesType40')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'referencesType40':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='referencesType40')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='referencesType40', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='referencesType40'):
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referencesType40', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class referencesType40


class quantitativeAttributeAccuracyAssessmentType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('attributeAccuracyValue', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'attributeAccuracyValue', 'type': 'xs:string'}, None),
        MemberSpec_('attributeAccuracyExplanation', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'attributeAccuracyExplanation', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, attributeAccuracyValue=None, attributeAccuracyExplanation=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.attributeAccuracyValue = attributeAccuracyValue
        self.validate_NonEmptyStringType(self.attributeAccuracyValue)
        self.attributeAccuracyValue_nsprefix_ = None
        self.attributeAccuracyExplanation = attributeAccuracyExplanation
        self.validate_NonEmptyStringType(self.attributeAccuracyExplanation)
        self.attributeAccuracyExplanation_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, quantitativeAttributeAccuracyAssessmentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if quantitativeAttributeAccuracyAssessmentType.subclass:
            return quantitativeAttributeAccuracyAssessmentType.subclass(*args_, **kwargs_)
        else:
            return quantitativeAttributeAccuracyAssessmentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_attributeAccuracyValue(self):
        return self.attributeAccuracyValue
    def set_attributeAccuracyValue(self, attributeAccuracyValue):
        self.attributeAccuracyValue = attributeAccuracyValue
    def get_attributeAccuracyExplanation(self):
        return self.attributeAccuracyExplanation
    def set_attributeAccuracyExplanation(self, attributeAccuracyExplanation):
        self.attributeAccuracyExplanation = attributeAccuracyExplanation
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def hasContent_(self):
        if (
            self.attributeAccuracyValue is not None or
            self.attributeAccuracyExplanation is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='quantitativeAttributeAccuracyAssessmentType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('quantitativeAttributeAccuracyAssessmentType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'quantitativeAttributeAccuracyAssessmentType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='quantitativeAttributeAccuracyAssessmentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='quantitativeAttributeAccuracyAssessmentType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='quantitativeAttributeAccuracyAssessmentType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='quantitativeAttributeAccuracyAssessmentType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.attributeAccuracyValue is not None:
            namespaceprefix_ = self.attributeAccuracyValue_nsprefix_ + ':' if (UseCapturedNS_ and self.attributeAccuracyValue_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sattributeAccuracyValue>%s</%sattributeAccuracyValue>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.attributeAccuracyValue), input_name='attributeAccuracyValue')), namespaceprefix_ , eol_))
        if self.attributeAccuracyExplanation is not None:
            namespaceprefix_ = self.attributeAccuracyExplanation_nsprefix_ + ':' if (UseCapturedNS_ and self.attributeAccuracyExplanation_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sattributeAccuracyExplanation>%s</%sattributeAccuracyExplanation>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.attributeAccuracyExplanation), input_name='attributeAccuracyExplanation')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'attributeAccuracyValue':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'attributeAccuracyValue')
            value_ = self.gds_validate_string(value_, node, 'attributeAccuracyValue')
            self.attributeAccuracyValue = value_
            self.attributeAccuracyValue_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.attributeAccuracyValue)
        elif nodeName_ == 'attributeAccuracyExplanation':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'attributeAccuracyExplanation')
            value_ = self.gds_validate_string(value_, node, 'attributeAccuracyExplanation')
            self.attributeAccuracyExplanation = value_
            self.attributeAccuracyExplanation_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.attributeAccuracyExplanation)
# end class quantitativeAttributeAccuracyAssessmentType


class enumeratedDomainType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('enforced', 'enforcedType', 0, 1, {'use': 'optional'}),
        MemberSpec_('codeDefinition', 'codeDefinitionType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'codeDefinition', 'type': 'codeDefinitionType'}, 67),
        MemberSpec_('externalCodeSet', 'externalCodeSetType', 0, 0, {'name': 'externalCodeSet', 'type': 'externalCodeSetType'}, 67),
        MemberSpec_('entityCodeList', 'entityCodeListType', 0, 0, {'name': 'entityCodeList', 'type': 'entityCodeListType'}, 67),
    ]
    subclass = None
    superclass = None
    def __init__(self, enforced='yes', codeDefinition=None, externalCodeSet=None, entityCodeList=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.enforced = _cast(None, enforced)
        self.enforced_nsprefix_ = None
        if codeDefinition is None:
            self.codeDefinition = []
        else:
            self.codeDefinition = codeDefinition
        self.codeDefinition_nsprefix_ = None
        self.externalCodeSet = externalCodeSet
        self.externalCodeSet_nsprefix_ = None
        self.entityCodeList = entityCodeList
        self.entityCodeList_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, enumeratedDomainType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if enumeratedDomainType.subclass:
            return enumeratedDomainType.subclass(*args_, **kwargs_)
        else:
            return enumeratedDomainType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_codeDefinition(self):
        return self.codeDefinition
    def set_codeDefinition(self, codeDefinition):
        self.codeDefinition = codeDefinition
    def add_codeDefinition(self, value):
        self.codeDefinition.append(value)
    def insert_codeDefinition_at(self, index, value):
        self.codeDefinition.insert(index, value)
    def replace_codeDefinition_at(self, index, value):
        self.codeDefinition[index] = value
    def get_externalCodeSet(self):
        return self.externalCodeSet
    def set_externalCodeSet(self, externalCodeSet):
        self.externalCodeSet = externalCodeSet
    def get_entityCodeList(self):
        return self.entityCodeList
    def set_entityCodeList(self, entityCodeList):
        self.entityCodeList = entityCodeList
    def get_enforced(self):
        return self.enforced
    def set_enforced(self, enforced):
        self.enforced = enforced
    def validate_enforcedType(self, value):
        # Validate type enforcedType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on enforcedType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.codeDefinition or
            self.externalCodeSet is not None or
            self.entityCodeList is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='enumeratedDomainType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('enumeratedDomainType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'enumeratedDomainType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='enumeratedDomainType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='enumeratedDomainType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='enumeratedDomainType'):
        if self.enforced != "yes" and 'enforced' not in already_processed:
            already_processed.add('enforced')
            outfile.write(' enforced=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.enforced), input_name='enforced')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='enumeratedDomainType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for codeDefinition_ in self.codeDefinition:
            namespaceprefix_ = self.codeDefinition_nsprefix_ + ':' if (UseCapturedNS_ and self.codeDefinition_nsprefix_) else ''
            codeDefinition_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='codeDefinition', pretty_print=pretty_print)
        if self.externalCodeSet is not None:
            namespaceprefix_ = self.externalCodeSet_nsprefix_ + ':' if (UseCapturedNS_ and self.externalCodeSet_nsprefix_) else ''
            self.externalCodeSet.export(outfile, level, namespaceprefix_, namespacedef_='', name_='externalCodeSet', pretty_print=pretty_print)
        if self.entityCodeList is not None:
            namespaceprefix_ = self.entityCodeList_nsprefix_ + ':' if (UseCapturedNS_ and self.entityCodeList_nsprefix_) else ''
            self.entityCodeList.export(outfile, level, namespaceprefix_, namespacedef_='', name_='entityCodeList', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('enforced', node)
        if value is not None and 'enforced' not in already_processed:
            already_processed.add('enforced')
            self.enforced = value
            self.validate_enforcedType(self.enforced)    # validate type enforcedType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'codeDefinition':
            obj_ = codeDefinitionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.codeDefinition.append(obj_)
            obj_.original_tagname_ = 'codeDefinition'
        elif nodeName_ == 'externalCodeSet':
            obj_ = externalCodeSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.externalCodeSet = obj_
            obj_.original_tagname_ = 'externalCodeSet'
        elif nodeName_ == 'entityCodeList':
            obj_ = entityCodeListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.entityCodeList = obj_
            obj_.original_tagname_ = 'entityCodeList'
# end class enumeratedDomainType


class codeDefinitionType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('order', 'xs:long', 0, 1, {'use': 'optional'}),
        MemberSpec_('code', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        MemberSpec_('definition', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'definition', 'type': 'xs:string'}, None),
        MemberSpec_('source', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'source', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, order=None, code=None, definition=None, source=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.order = _cast(int, order)
        self.order_nsprefix_ = None
        self.code = code
        self.validate_NonEmptyStringType(self.code)
        self.code_nsprefix_ = None
        self.definition = definition
        self.validate_NonEmptyStringType(self.definition)
        self.definition_nsprefix_ = None
        self.source = source
        self.validate_NonEmptyStringType(self.source)
        self.source_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, codeDefinitionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if codeDefinitionType.subclass:
            return codeDefinitionType.subclass(*args_, **kwargs_)
        else:
            return codeDefinitionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_definition(self):
        return self.definition
    def set_definition(self, definition):
        self.definition = definition
    def get_source(self):
        return self.source
    def set_source(self, source):
        self.source = source
    def get_order(self):
        return self.order
    def set_order(self, order):
        self.order = order
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def hasContent_(self):
        if (
            self.code is not None or
            self.definition is not None or
            self.source is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='codeDefinitionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('codeDefinitionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'codeDefinitionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='codeDefinitionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='codeDefinitionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='codeDefinitionType'):
        if self.order is not None and 'order' not in already_processed:
            already_processed.add('order')
            outfile.write(' order="%s"' % self.gds_format_integer(self.order, input_name='order'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='codeDefinitionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scode>%s</%scode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.code), input_name='code')), namespaceprefix_ , eol_))
        if self.definition is not None:
            namespaceprefix_ = self.definition_nsprefix_ + ':' if (UseCapturedNS_ and self.definition_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdefinition>%s</%sdefinition>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.definition), input_name='definition')), namespaceprefix_ , eol_))
        if self.source is not None:
            namespaceprefix_ = self.source_nsprefix_ + ':' if (UseCapturedNS_ and self.source_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssource>%s</%ssource>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.source), input_name='source')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('order', node)
        if value is not None and 'order' not in already_processed:
            already_processed.add('order')
            self.order = self.gds_parse_integer(value, node, 'order')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'code')
            value_ = self.gds_validate_string(value_, node, 'code')
            self.code = value_
            self.code_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.code)
        elif nodeName_ == 'definition':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'definition')
            value_ = self.gds_validate_string(value_, node, 'definition')
            self.definition = value_
            self.definition_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.definition)
        elif nodeName_ == 'source':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'source')
            value_ = self.gds_validate_string(value_, node, 'source')
            self.source = value_
            self.source_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.source)
# end class codeDefinitionType


class externalCodeSetType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('codesetName', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'codesetName', 'type': 'xs:string'}, None),
        MemberSpec_('citation', 'CitationType', 1, 0, {'name': 'citation', 'type': 'CitationType'}, 68),
        MemberSpec_('codesetURL', 'xs:anyURI', 1, 0, {'name': 'codesetURL', 'type': 'xs:anyURI'}, 68),
    ]
    subclass = None
    superclass = None
    def __init__(self, codesetName=None, citation=None, codesetURL=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.codesetName = codesetName
        self.validate_NonEmptyStringType(self.codesetName)
        self.codesetName_nsprefix_ = None
        if citation is None:
            self.citation = []
        else:
            self.citation = citation
        self.citation_nsprefix_ = None
        if codesetURL is None:
            self.codesetURL = []
        else:
            self.codesetURL = codesetURL
        self.codesetURL_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, externalCodeSetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if externalCodeSetType.subclass:
            return externalCodeSetType.subclass(*args_, **kwargs_)
        else:
            return externalCodeSetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_codesetName(self):
        return self.codesetName
    def set_codesetName(self, codesetName):
        self.codesetName = codesetName
    def get_citation(self):
        return self.citation
    def set_citation(self, citation):
        self.citation = citation
    def add_citation(self, value):
        self.citation.append(value)
    def insert_citation_at(self, index, value):
        self.citation.insert(index, value)
    def replace_citation_at(self, index, value):
        self.citation[index] = value
    def get_codesetURL(self):
        return self.codesetURL
    def set_codesetURL(self, codesetURL):
        self.codesetURL = codesetURL
    def add_codesetURL(self, value):
        self.codesetURL.append(value)
    def insert_codesetURL_at(self, index, value):
        self.codesetURL.insert(index, value)
    def replace_codesetURL_at(self, index, value):
        self.codesetURL[index] = value
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def hasContent_(self):
        if (
            self.codesetName is not None or
            self.citation or
            self.codesetURL
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:cit="https://eml.ecoinformatics.org/literature-2.2.0"  xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='externalCodeSetType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('externalCodeSetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'externalCodeSetType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='externalCodeSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='externalCodeSetType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='externalCodeSetType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:cit="https://eml.ecoinformatics.org/literature-2.2.0"  xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='externalCodeSetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.codesetName is not None:
            namespaceprefix_ = self.codesetName_nsprefix_ + ':' if (UseCapturedNS_ and self.codesetName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scodesetName>%s</%scodesetName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.codesetName), input_name='codesetName')), namespaceprefix_ , eol_))
        for citation_ in self.citation:
            namespaceprefix_ = self.citation_nsprefix_ + ':' if (UseCapturedNS_ and self.citation_nsprefix_) else ''
            citation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='citation', pretty_print=pretty_print)
        for codesetURL_ in self.codesetURL:
            namespaceprefix_ = self.codesetURL_nsprefix_ + ':' if (UseCapturedNS_ and self.codesetURL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scodesetURL>%s</%scodesetURL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(codesetURL_), input_name='codesetURL')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'codesetName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'codesetName')
            value_ = self.gds_validate_string(value_, node, 'codesetName')
            self.codesetName = value_
            self.codesetName_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.codesetName)
        elif nodeName_ == 'citation':
            obj_ = CitationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.citation.append(obj_)
            obj_.original_tagname_ = 'citation'
        elif nodeName_ == 'codesetURL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'codesetURL')
            value_ = self.gds_validate_string(value_, node, 'codesetURL')
            self.codesetURL.append(value_)
            self.codesetURL_nsprefix_ = child_.prefix
# end class externalCodeSetType


class entityCodeListType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('entityReference', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'entityReference', 'type': 'xs:string'}, None),
        MemberSpec_('valueAttributeReference', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'valueAttributeReference', 'type': 'xs:string'}, None),
        MemberSpec_('definitionAttributeReference', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'definitionAttributeReference', 'type': 'xs:string'}, None),
        MemberSpec_('orderAttributeReference', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'orderAttributeReference', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, entityReference=None, valueAttributeReference=None, definitionAttributeReference=None, orderAttributeReference=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.entityReference = entityReference
        self.validate_NonEmptyStringType(self.entityReference)
        self.entityReference_nsprefix_ = None
        self.valueAttributeReference = valueAttributeReference
        self.validate_NonEmptyStringType(self.valueAttributeReference)
        self.valueAttributeReference_nsprefix_ = None
        self.definitionAttributeReference = definitionAttributeReference
        self.validate_NonEmptyStringType(self.definitionAttributeReference)
        self.definitionAttributeReference_nsprefix_ = None
        self.orderAttributeReference = orderAttributeReference
        self.validate_NonEmptyStringType(self.orderAttributeReference)
        self.orderAttributeReference_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, entityCodeListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if entityCodeListType.subclass:
            return entityCodeListType.subclass(*args_, **kwargs_)
        else:
            return entityCodeListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_entityReference(self):
        return self.entityReference
    def set_entityReference(self, entityReference):
        self.entityReference = entityReference
    def get_valueAttributeReference(self):
        return self.valueAttributeReference
    def set_valueAttributeReference(self, valueAttributeReference):
        self.valueAttributeReference = valueAttributeReference
    def get_definitionAttributeReference(self):
        return self.definitionAttributeReference
    def set_definitionAttributeReference(self, definitionAttributeReference):
        self.definitionAttributeReference = definitionAttributeReference
    def get_orderAttributeReference(self):
        return self.orderAttributeReference
    def set_orderAttributeReference(self, orderAttributeReference):
        self.orderAttributeReference = orderAttributeReference
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def hasContent_(self):
        if (
            self.entityReference is not None or
            self.valueAttributeReference is not None or
            self.definitionAttributeReference is not None or
            self.orderAttributeReference is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='entityCodeListType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('entityCodeListType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'entityCodeListType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='entityCodeListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='entityCodeListType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='entityCodeListType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='entityCodeListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.entityReference is not None:
            namespaceprefix_ = self.entityReference_nsprefix_ + ':' if (UseCapturedNS_ and self.entityReference_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sentityReference>%s</%sentityReference>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.entityReference), input_name='entityReference')), namespaceprefix_ , eol_))
        if self.valueAttributeReference is not None:
            namespaceprefix_ = self.valueAttributeReference_nsprefix_ + ':' if (UseCapturedNS_ and self.valueAttributeReference_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalueAttributeReference>%s</%svalueAttributeReference>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.valueAttributeReference), input_name='valueAttributeReference')), namespaceprefix_ , eol_))
        if self.definitionAttributeReference is not None:
            namespaceprefix_ = self.definitionAttributeReference_nsprefix_ + ':' if (UseCapturedNS_ and self.definitionAttributeReference_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdefinitionAttributeReference>%s</%sdefinitionAttributeReference>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.definitionAttributeReference), input_name='definitionAttributeReference')), namespaceprefix_ , eol_))
        if self.orderAttributeReference is not None:
            namespaceprefix_ = self.orderAttributeReference_nsprefix_ + ':' if (UseCapturedNS_ and self.orderAttributeReference_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sorderAttributeReference>%s</%sorderAttributeReference>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.orderAttributeReference), input_name='orderAttributeReference')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'entityReference':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'entityReference')
            value_ = self.gds_validate_string(value_, node, 'entityReference')
            self.entityReference = value_
            self.entityReference_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.entityReference)
        elif nodeName_ == 'valueAttributeReference':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'valueAttributeReference')
            value_ = self.gds_validate_string(value_, node, 'valueAttributeReference')
            self.valueAttributeReference = value_
            self.valueAttributeReference_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.valueAttributeReference)
        elif nodeName_ == 'definitionAttributeReference':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'definitionAttributeReference')
            value_ = self.gds_validate_string(value_, node, 'definitionAttributeReference')
            self.definitionAttributeReference = value_
            self.definitionAttributeReference_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.definitionAttributeReference)
        elif nodeName_ == 'orderAttributeReference':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'orderAttributeReference')
            value_ = self.gds_validate_string(value_, node, 'orderAttributeReference')
            self.orderAttributeReference = value_
            self.orderAttributeReference_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.orderAttributeReference)
# end class entityCodeListType


class textDomainType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('definition', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'definition', 'type': 'xs:string'}, None),
        MemberSpec_('pattern', ['NonEmptyStringType', 'xs:string'], 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'pattern', 'type': 'xs:string'}, None),
        MemberSpec_('source', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'source', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, definition=None, pattern=None, source=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.definition = definition
        self.validate_NonEmptyStringType(self.definition)
        self.definition_nsprefix_ = None
        if pattern is None:
            self.pattern = []
        else:
            self.pattern = pattern
        self.pattern_nsprefix_ = None
        self.source = source
        self.validate_NonEmptyStringType(self.source)
        self.source_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, textDomainType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if textDomainType.subclass:
            return textDomainType.subclass(*args_, **kwargs_)
        else:
            return textDomainType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_definition(self):
        return self.definition
    def set_definition(self, definition):
        self.definition = definition
    def get_pattern(self):
        return self.pattern
    def set_pattern(self, pattern):
        self.pattern = pattern
    def add_pattern(self, value):
        self.pattern.append(value)
    def insert_pattern_at(self, index, value):
        self.pattern.insert(index, value)
    def replace_pattern_at(self, index, value):
        self.pattern[index] = value
    def get_source(self):
        return self.source
    def set_source(self, source):
        self.source = source
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def hasContent_(self):
        if (
            self.definition is not None or
            self.pattern or
            self.source is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='textDomainType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('textDomainType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'textDomainType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='textDomainType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='textDomainType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='textDomainType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='textDomainType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.definition is not None:
            namespaceprefix_ = self.definition_nsprefix_ + ':' if (UseCapturedNS_ and self.definition_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdefinition>%s</%sdefinition>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.definition), input_name='definition')), namespaceprefix_ , eol_))
        for pattern_ in self.pattern:
            namespaceprefix_ = self.pattern_nsprefix_ + ':' if (UseCapturedNS_ and self.pattern_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spattern>%s</%spattern>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(pattern_), input_name='pattern')), namespaceprefix_ , eol_))
        if self.source is not None:
            namespaceprefix_ = self.source_nsprefix_ + ':' if (UseCapturedNS_ and self.source_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssource>%s</%ssource>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.source), input_name='source')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'definition':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'definition')
            value_ = self.gds_validate_string(value_, node, 'definition')
            self.definition = value_
            self.definition_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.definition)
        elif nodeName_ == 'pattern':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'pattern')
            value_ = self.gds_validate_string(value_, node, 'pattern')
            self.pattern.append(value_)
            self.pattern_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.pattern[-1])
        elif nodeName_ == 'source':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'source')
            value_ = self.gds_validate_string(value_, node, 'source')
            self.source = value_
            self.source_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.source)
# end class textDomainType


class referencesType41(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('system', 'SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, system=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, referencesType41)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if referencesType41.subclass:
            return referencesType41.subclass(*args_, **kwargs_)
        else:
            return referencesType41(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_SystemType(self, value):
        # Validate type SystemType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referencesType41', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('referencesType41')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'referencesType41':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='referencesType41')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='referencesType41', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='referencesType41'):
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referencesType41', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class referencesType41


class boundsType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('minimum', 'minimumType', 0, 1, {'minOccurs': '0', 'name': 'minimum', 'type': 'minimumType'}, None),
        MemberSpec_('maximum', 'maximumType', 0, 1, {'minOccurs': '0', 'name': 'maximum', 'type': 'maximumType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, minimum=None, maximum=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.minimum = minimum
        self.minimum_nsprefix_ = None
        self.maximum = maximum
        self.maximum_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, boundsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if boundsType.subclass:
            return boundsType.subclass(*args_, **kwargs_)
        else:
            return boundsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_minimum(self):
        return self.minimum
    def set_minimum(self, minimum):
        self.minimum = minimum
    def get_maximum(self):
        return self.maximum
    def set_maximum(self, maximum):
        self.maximum = maximum
    def hasContent_(self):
        if (
            self.minimum is not None or
            self.maximum is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='boundsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('boundsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'boundsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='boundsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='boundsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='boundsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='boundsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.minimum is not None:
            namespaceprefix_ = self.minimum_nsprefix_ + ':' if (UseCapturedNS_ and self.minimum_nsprefix_) else ''
            self.minimum.export(outfile, level, namespaceprefix_, namespacedef_='', name_='minimum', pretty_print=pretty_print)
        if self.maximum is not None:
            namespaceprefix_ = self.maximum_nsprefix_ + ':' if (UseCapturedNS_ and self.maximum_nsprefix_) else ''
            self.maximum.export(outfile, level, namespaceprefix_, namespacedef_='', name_='maximum', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'minimum':
            obj_ = minimumType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.minimum = obj_
            obj_.original_tagname_ = 'minimum'
        elif nodeName_ == 'maximum':
            obj_ = maximumType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.maximum = obj_
            obj_.original_tagname_ = 'maximum'
# end class boundsType


class minimumType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('exclusive', 'xs:boolean', 0, 0, {'use': 'required'}),
        MemberSpec_('valueOf_', 'xs:float', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, exclusive=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.exclusive = _cast(bool, exclusive)
        self.exclusive_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, minimumType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if minimumType.subclass:
            return minimumType.subclass(*args_, **kwargs_)
        else:
            return minimumType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_exclusive(self):
        return self.exclusive
    def set_exclusive(self, exclusive):
        self.exclusive = exclusive
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='minimumType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('minimumType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'minimumType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='minimumType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='minimumType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='minimumType'):
        if self.exclusive is not None and 'exclusive' not in already_processed:
            already_processed.add('exclusive')
            outfile.write(' exclusive="%s"' % self.gds_format_boolean(self.exclusive, input_name='exclusive'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='minimumType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('exclusive', node)
        if value is not None and 'exclusive' not in already_processed:
            already_processed.add('exclusive')
            if value in ('true', '1'):
                self.exclusive = True
            elif value in ('false', '0'):
                self.exclusive = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class minimumType


class maximumType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('exclusive', 'xs:boolean', 0, 0, {'use': 'required'}),
        MemberSpec_('valueOf_', 'xs:float', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, exclusive=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.exclusive = _cast(bool, exclusive)
        self.exclusive_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, maximumType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if maximumType.subclass:
            return maximumType.subclass(*args_, **kwargs_)
        else:
            return maximumType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_exclusive(self):
        return self.exclusive
    def set_exclusive(self, exclusive):
        self.exclusive = exclusive
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='maximumType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('maximumType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'maximumType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='maximumType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='maximumType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='maximumType'):
        if self.exclusive is not None and 'exclusive' not in already_processed:
            already_processed.add('exclusive')
            outfile.write(' exclusive="%s"' % self.gds_format_boolean(self.exclusive, input_name='exclusive'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='maximumType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('exclusive', node)
        if value is not None and 'exclusive' not in already_processed:
            already_processed.add('exclusive')
            if value in ('true', '1'):
                self.exclusive = True
            elif value in ('false', '0'):
                self.exclusive = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class maximumType


class referencesType42(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('system', 'SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, system=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, referencesType42)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if referencesType42.subclass:
            return referencesType42.subclass(*args_, **kwargs_)
        else:
            return referencesType42(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_SystemType(self, value):
        # Validate type SystemType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referencesType42', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('referencesType42')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'referencesType42':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='referencesType42')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='referencesType42', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='referencesType42'):
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referencesType42', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class referencesType42


class boundsType43(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('minimum', 'minimumType44', 0, 1, {'minOccurs': '0', 'name': 'minimum', 'type': 'minimumType44'}, None),
        MemberSpec_('maximum', 'maximumType45', 0, 1, {'minOccurs': '0', 'name': 'maximum', 'type': 'maximumType45'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, minimum=None, maximum=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.minimum = minimum
        self.minimum_nsprefix_ = None
        self.maximum = maximum
        self.maximum_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, boundsType43)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if boundsType43.subclass:
            return boundsType43.subclass(*args_, **kwargs_)
        else:
            return boundsType43(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_minimum(self):
        return self.minimum
    def set_minimum(self, minimum):
        self.minimum = minimum
    def get_maximum(self):
        return self.maximum
    def set_maximum(self, maximum):
        self.maximum = maximum
    def hasContent_(self):
        if (
            self.minimum is not None or
            self.maximum is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='boundsType43', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('boundsType43')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'boundsType43':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='boundsType43')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='boundsType43', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='boundsType43'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='boundsType43', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.minimum is not None:
            namespaceprefix_ = self.minimum_nsprefix_ + ':' if (UseCapturedNS_ and self.minimum_nsprefix_) else ''
            self.minimum.export(outfile, level, namespaceprefix_, namespacedef_='', name_='minimum', pretty_print=pretty_print)
        if self.maximum is not None:
            namespaceprefix_ = self.maximum_nsprefix_ + ':' if (UseCapturedNS_ and self.maximum_nsprefix_) else ''
            self.maximum.export(outfile, level, namespaceprefix_, namespacedef_='', name_='maximum', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'minimum':
            obj_ = minimumType44.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.minimum = obj_
            obj_.original_tagname_ = 'minimum'
        elif nodeName_ == 'maximum':
            obj_ = maximumType45.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.maximum = obj_
            obj_.original_tagname_ = 'maximum'
# end class boundsType43


class minimumType44(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('exclusive', 'xs:boolean', 0, 0, {'use': 'required'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, exclusive=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.exclusive = _cast(bool, exclusive)
        self.exclusive_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, minimumType44)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if minimumType44.subclass:
            return minimumType44.subclass(*args_, **kwargs_)
        else:
            return minimumType44(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_exclusive(self):
        return self.exclusive
    def set_exclusive(self, exclusive):
        self.exclusive = exclusive
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='minimumType44', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('minimumType44')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'minimumType44':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='minimumType44')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='minimumType44', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='minimumType44'):
        if self.exclusive is not None and 'exclusive' not in already_processed:
            already_processed.add('exclusive')
            outfile.write(' exclusive="%s"' % self.gds_format_boolean(self.exclusive, input_name='exclusive'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='minimumType44', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('exclusive', node)
        if value is not None and 'exclusive' not in already_processed:
            already_processed.add('exclusive')
            if value in ('true', '1'):
                self.exclusive = True
            elif value in ('false', '0'):
                self.exclusive = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class minimumType44


class maximumType45(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('exclusive', 'xs:boolean', 0, 0, {'use': 'required'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, exclusive=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.exclusive = _cast(bool, exclusive)
        self.exclusive_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, maximumType45)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if maximumType45.subclass:
            return maximumType45.subclass(*args_, **kwargs_)
        else:
            return maximumType45(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_exclusive(self):
        return self.exclusive
    def set_exclusive(self, exclusive):
        self.exclusive = exclusive
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='maximumType45', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('maximumType45')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'maximumType45':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='maximumType45')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='maximumType45', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='maximumType45'):
        if self.exclusive is not None and 'exclusive' not in already_processed:
            already_processed.add('exclusive')
            outfile.write(' exclusive="%s"' % self.gds_format_boolean(self.exclusive, input_name='exclusive'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='maximumType45', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('exclusive', node)
        if value is not None and 'exclusive' not in already_processed:
            already_processed.add('exclusive')
            if value in ('true', '1'):
                self.exclusive = True
            elif value in ('false', '0'):
                self.exclusive = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class maximumType45


class referencesType46(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('system', 'SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, system=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, referencesType46)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if referencesType46.subclass:
            return referencesType46.subclass(*args_, **kwargs_)
        else:
            return referencesType46(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_SystemType(self, value):
        # Validate type SystemType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referencesType46', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('referencesType46')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'referencesType46':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='referencesType46')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='referencesType46', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='referencesType46'):
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referencesType46', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class referencesType46


class boundsType47(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('minimum', 'minimumType48', 0, 1, {'minOccurs': '0', 'name': 'minimum', 'type': 'minimumType48'}, None),
        MemberSpec_('maximum', 'maximumType49', 0, 1, {'minOccurs': '0', 'name': 'maximum', 'type': 'maximumType49'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, minimum=None, maximum=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.minimum = minimum
        self.minimum_nsprefix_ = None
        self.maximum = maximum
        self.maximum_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, boundsType47)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if boundsType47.subclass:
            return boundsType47.subclass(*args_, **kwargs_)
        else:
            return boundsType47(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_minimum(self):
        return self.minimum
    def set_minimum(self, minimum):
        self.minimum = minimum
    def get_maximum(self):
        return self.maximum
    def set_maximum(self, maximum):
        self.maximum = maximum
    def hasContent_(self):
        if (
            self.minimum is not None or
            self.maximum is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='boundsType47', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('boundsType47')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'boundsType47':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='boundsType47')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='boundsType47', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='boundsType47'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='boundsType47', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.minimum is not None:
            namespaceprefix_ = self.minimum_nsprefix_ + ':' if (UseCapturedNS_ and self.minimum_nsprefix_) else ''
            self.minimum.export(outfile, level, namespaceprefix_, namespacedef_='', name_='minimum', pretty_print=pretty_print)
        if self.maximum is not None:
            namespaceprefix_ = self.maximum_nsprefix_ + ':' if (UseCapturedNS_ and self.maximum_nsprefix_) else ''
            self.maximum.export(outfile, level, namespaceprefix_, namespacedef_='', name_='maximum', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'minimum':
            obj_ = minimumType48.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.minimum = obj_
            obj_.original_tagname_ = 'minimum'
        elif nodeName_ == 'maximum':
            obj_ = maximumType49.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.maximum = obj_
            obj_.original_tagname_ = 'maximum'
# end class boundsType47


class minimumType48(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('exclusive', 'xs:boolean', 0, 0, {'use': 'required'}),
        MemberSpec_('valueOf_', 'xs:float', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, exclusive=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.exclusive = _cast(bool, exclusive)
        self.exclusive_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, minimumType48)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if minimumType48.subclass:
            return minimumType48.subclass(*args_, **kwargs_)
        else:
            return minimumType48(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_exclusive(self):
        return self.exclusive
    def set_exclusive(self, exclusive):
        self.exclusive = exclusive
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='minimumType48', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('minimumType48')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'minimumType48':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='minimumType48')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='minimumType48', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='minimumType48'):
        if self.exclusive is not None and 'exclusive' not in already_processed:
            already_processed.add('exclusive')
            outfile.write(' exclusive="%s"' % self.gds_format_boolean(self.exclusive, input_name='exclusive'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='minimumType48', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('exclusive', node)
        if value is not None and 'exclusive' not in already_processed:
            already_processed.add('exclusive')
            if value in ('true', '1'):
                self.exclusive = True
            elif value in ('false', '0'):
                self.exclusive = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class minimumType48


class maximumType49(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('exclusive', 'xs:boolean', 0, 0, {'use': 'required'}),
        MemberSpec_('valueOf_', 'xs:float', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, exclusive=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.exclusive = _cast(bool, exclusive)
        self.exclusive_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, maximumType49)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if maximumType49.subclass:
            return maximumType49.subclass(*args_, **kwargs_)
        else:
            return maximumType49(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_exclusive(self):
        return self.exclusive
    def set_exclusive(self, exclusive):
        self.exclusive = exclusive
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='maximumType49', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('maximumType49')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'maximumType49':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='maximumType49')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='maximumType49', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='maximumType49'):
        if self.exclusive is not None and 'exclusive' not in already_processed:
            already_processed.add('exclusive')
            outfile.write(' exclusive="%s"' % self.gds_format_boolean(self.exclusive, input_name='exclusive'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='maximumType49', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('exclusive', node)
        if value is not None and 'exclusive' not in already_processed:
            already_processed.add('exclusive')
            if value in ('true', '1'):
                self.exclusive = True
            elif value in ('false', '0'):
                self.exclusive = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class maximumType49


class boundsType50(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('minimum', 'minimumType51', 0, 1, {'minOccurs': '0', 'name': 'minimum', 'type': 'minimumType51'}, None),
        MemberSpec_('maximum', 'maximumType52', 0, 1, {'minOccurs': '0', 'name': 'maximum', 'type': 'maximumType52'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, minimum=None, maximum=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.minimum = minimum
        self.minimum_nsprefix_ = None
        self.maximum = maximum
        self.maximum_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, boundsType50)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if boundsType50.subclass:
            return boundsType50.subclass(*args_, **kwargs_)
        else:
            return boundsType50(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_minimum(self):
        return self.minimum
    def set_minimum(self, minimum):
        self.minimum = minimum
    def get_maximum(self):
        return self.maximum
    def set_maximum(self, maximum):
        self.maximum = maximum
    def hasContent_(self):
        if (
            self.minimum is not None or
            self.maximum is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='boundsType50', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('boundsType50')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'boundsType50':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='boundsType50')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='boundsType50', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='boundsType50'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='boundsType50', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.minimum is not None:
            namespaceprefix_ = self.minimum_nsprefix_ + ':' if (UseCapturedNS_ and self.minimum_nsprefix_) else ''
            self.minimum.export(outfile, level, namespaceprefix_, namespacedef_='', name_='minimum', pretty_print=pretty_print)
        if self.maximum is not None:
            namespaceprefix_ = self.maximum_nsprefix_ + ':' if (UseCapturedNS_ and self.maximum_nsprefix_) else ''
            self.maximum.export(outfile, level, namespaceprefix_, namespacedef_='', name_='maximum', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'minimum':
            obj_ = minimumType51.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.minimum = obj_
            obj_.original_tagname_ = 'minimum'
        elif nodeName_ == 'maximum':
            obj_ = maximumType52.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.maximum = obj_
            obj_.original_tagname_ = 'maximum'
# end class boundsType50


class minimumType51(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('exclusive', 'xs:boolean', 0, 0, {'use': 'required'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, exclusive=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.exclusive = _cast(bool, exclusive)
        self.exclusive_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, minimumType51)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if minimumType51.subclass:
            return minimumType51.subclass(*args_, **kwargs_)
        else:
            return minimumType51(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_exclusive(self):
        return self.exclusive
    def set_exclusive(self, exclusive):
        self.exclusive = exclusive
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='minimumType51', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('minimumType51')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'minimumType51':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='minimumType51')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='minimumType51', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='minimumType51'):
        if self.exclusive is not None and 'exclusive' not in already_processed:
            already_processed.add('exclusive')
            outfile.write(' exclusive="%s"' % self.gds_format_boolean(self.exclusive, input_name='exclusive'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='minimumType51', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('exclusive', node)
        if value is not None and 'exclusive' not in already_processed:
            already_processed.add('exclusive')
            if value in ('true', '1'):
                self.exclusive = True
            elif value in ('false', '0'):
                self.exclusive = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class minimumType51


class maximumType52(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('exclusive', 'xs:boolean', 0, 0, {'use': 'required'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, exclusive=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.exclusive = _cast(bool, exclusive)
        self.exclusive_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, maximumType52)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if maximumType52.subclass:
            return maximumType52.subclass(*args_, **kwargs_)
        else:
            return maximumType52(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_exclusive(self):
        return self.exclusive
    def set_exclusive(self, exclusive):
        self.exclusive = exclusive
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='maximumType52', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('maximumType52')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'maximumType52':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='maximumType52')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='maximumType52', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='maximumType52'):
        if self.exclusive is not None and 'exclusive' not in already_processed:
            already_processed.add('exclusive')
            outfile.write(' exclusive="%s"' % self.gds_format_boolean(self.exclusive, input_name='exclusive'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='maximumType52', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('exclusive', node)
        if value is not None and 'exclusive' not in already_processed:
            already_processed.add('exclusive')
            if value in ('true', '1'):
                self.exclusive = True
            elif value in ('false', '0'):
                self.exclusive = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class maximumType52


class primaryKeyType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('constraintName', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'constraintName', 'type': 'xs:string'}, None),
        MemberSpec_('constraintDescription', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'constraintDescription', 'type': 'xs:string'}, None),
        MemberSpec_('key', 'keyType', 0, 0, {'name': 'key', 'type': 'keyType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, constraintName=None, constraintDescription=None, key=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.constraintName = constraintName
        self.validate_NonEmptyStringType(self.constraintName)
        self.constraintName_nsprefix_ = None
        self.constraintDescription = constraintDescription
        self.constraintDescription_nsprefix_ = None
        self.key = key
        self.key_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, primaryKeyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if primaryKeyType.subclass:
            return primaryKeyType.subclass(*args_, **kwargs_)
        else:
            return primaryKeyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_constraintName(self):
        return self.constraintName
    def set_constraintName(self, constraintName):
        self.constraintName = constraintName
    def get_constraintDescription(self):
        return self.constraintDescription
    def set_constraintDescription(self, constraintDescription):
        self.constraintDescription = constraintDescription
    def get_key(self):
        return self.key
    def set_key(self, key):
        self.key = key
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def hasContent_(self):
        if (
            self.constraintName is not None or
            self.constraintDescription is not None or
            self.key is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='primaryKeyType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('primaryKeyType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'primaryKeyType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='primaryKeyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='primaryKeyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='primaryKeyType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='primaryKeyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.constraintName is not None:
            namespaceprefix_ = self.constraintName_nsprefix_ + ':' if (UseCapturedNS_ and self.constraintName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sconstraintName>%s</%sconstraintName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.constraintName), input_name='constraintName')), namespaceprefix_ , eol_))
        if self.constraintDescription is not None:
            namespaceprefix_ = self.constraintDescription_nsprefix_ + ':' if (UseCapturedNS_ and self.constraintDescription_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sconstraintDescription>%s</%sconstraintDescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.constraintDescription), input_name='constraintDescription')), namespaceprefix_ , eol_))
        if self.key is not None:
            namespaceprefix_ = self.key_nsprefix_ + ':' if (UseCapturedNS_ and self.key_nsprefix_) else ''
            self.key.export(outfile, level, namespaceprefix_, namespacedef_='', name_='key', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'constraintName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'constraintName')
            value_ = self.gds_validate_string(value_, node, 'constraintName')
            self.constraintName = value_
            self.constraintName_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.constraintName)
        elif nodeName_ == 'constraintDescription':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'constraintDescription')
            value_ = self.gds_validate_string(value_, node, 'constraintDescription')
            self.constraintDescription = value_
            self.constraintDescription_nsprefix_ = child_.prefix
        elif nodeName_ == 'key':
            obj_ = keyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.key = obj_
            obj_.original_tagname_ = 'key'
# end class primaryKeyType


class constraintDescription(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, constraintDescription)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if constraintDescription.subclass:
            return constraintDescription.subclass(*args_, **kwargs_)
        else:
            return constraintDescription(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='constraintDescription', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('constraintDescription')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'constraintDescription':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='constraintDescription')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='constraintDescription', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='constraintDescription'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='constraintDescription', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class constraintDescription


class keyType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('attributeReference', ['NonEmptyStringType', 'xs:string'], 1, 0, {'maxOccurs': 'unbounded', 'name': 'attributeReference', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, attributeReference=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if attributeReference is None:
            self.attributeReference = []
        else:
            self.attributeReference = attributeReference
        self.attributeReference_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, keyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if keyType.subclass:
            return keyType.subclass(*args_, **kwargs_)
        else:
            return keyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_attributeReference(self):
        return self.attributeReference
    def set_attributeReference(self, attributeReference):
        self.attributeReference = attributeReference
    def add_attributeReference(self, value):
        self.attributeReference.append(value)
    def insert_attributeReference_at(self, index, value):
        self.attributeReference.insert(index, value)
    def replace_attributeReference_at(self, index, value):
        self.attributeReference[index] = value
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def hasContent_(self):
        if (
            self.attributeReference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='keyType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('keyType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'keyType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='keyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='keyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='keyType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='keyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for attributeReference_ in self.attributeReference:
            namespaceprefix_ = self.attributeReference_nsprefix_ + ':' if (UseCapturedNS_ and self.attributeReference_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sattributeReference>%s</%sattributeReference>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(attributeReference_), input_name='attributeReference')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'attributeReference':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'attributeReference')
            value_ = self.gds_validate_string(value_, node, 'attributeReference')
            self.attributeReference.append(value_)
            self.attributeReference_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.attributeReference[-1])
# end class keyType


class uniqueKeyType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('constraintName', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'constraintName', 'type': 'xs:string'}, None),
        MemberSpec_('constraintDescription', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'constraintDescription', 'type': 'xs:string'}, None),
        MemberSpec_('key', 'keyType53', 0, 0, {'name': 'key', 'type': 'keyType53'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, constraintName=None, constraintDescription=None, key=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.constraintName = constraintName
        self.validate_NonEmptyStringType(self.constraintName)
        self.constraintName_nsprefix_ = None
        self.constraintDescription = constraintDescription
        self.constraintDescription_nsprefix_ = None
        self.key = key
        self.key_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, uniqueKeyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if uniqueKeyType.subclass:
            return uniqueKeyType.subclass(*args_, **kwargs_)
        else:
            return uniqueKeyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_constraintName(self):
        return self.constraintName
    def set_constraintName(self, constraintName):
        self.constraintName = constraintName
    def get_constraintDescription(self):
        return self.constraintDescription
    def set_constraintDescription(self, constraintDescription):
        self.constraintDescription = constraintDescription
    def get_key(self):
        return self.key
    def set_key(self, key):
        self.key = key
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def hasContent_(self):
        if (
            self.constraintName is not None or
            self.constraintDescription is not None or
            self.key is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='uniqueKeyType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('uniqueKeyType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'uniqueKeyType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='uniqueKeyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='uniqueKeyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='uniqueKeyType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='uniqueKeyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.constraintName is not None:
            namespaceprefix_ = self.constraintName_nsprefix_ + ':' if (UseCapturedNS_ and self.constraintName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sconstraintName>%s</%sconstraintName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.constraintName), input_name='constraintName')), namespaceprefix_ , eol_))
        if self.constraintDescription is not None:
            namespaceprefix_ = self.constraintDescription_nsprefix_ + ':' if (UseCapturedNS_ and self.constraintDescription_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sconstraintDescription>%s</%sconstraintDescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.constraintDescription), input_name='constraintDescription')), namespaceprefix_ , eol_))
        if self.key is not None:
            namespaceprefix_ = self.key_nsprefix_ + ':' if (UseCapturedNS_ and self.key_nsprefix_) else ''
            self.key.export(outfile, level, namespaceprefix_, namespacedef_='', name_='key', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'constraintName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'constraintName')
            value_ = self.gds_validate_string(value_, node, 'constraintName')
            self.constraintName = value_
            self.constraintName_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.constraintName)
        elif nodeName_ == 'constraintDescription':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'constraintDescription')
            value_ = self.gds_validate_string(value_, node, 'constraintDescription')
            self.constraintDescription = value_
            self.constraintDescription_nsprefix_ = child_.prefix
        elif nodeName_ == 'key':
            obj_ = keyType53.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.key = obj_
            obj_.original_tagname_ = 'key'
# end class uniqueKeyType


class keyType53(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('attributeReference', ['NonEmptyStringType', 'xs:string'], 1, 0, {'maxOccurs': 'unbounded', 'name': 'attributeReference', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, attributeReference=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if attributeReference is None:
            self.attributeReference = []
        else:
            self.attributeReference = attributeReference
        self.attributeReference_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, keyType53)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if keyType53.subclass:
            return keyType53.subclass(*args_, **kwargs_)
        else:
            return keyType53(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_attributeReference(self):
        return self.attributeReference
    def set_attributeReference(self, attributeReference):
        self.attributeReference = attributeReference
    def add_attributeReference(self, value):
        self.attributeReference.append(value)
    def insert_attributeReference_at(self, index, value):
        self.attributeReference.insert(index, value)
    def replace_attributeReference_at(self, index, value):
        self.attributeReference[index] = value
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def hasContent_(self):
        if (
            self.attributeReference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='keyType53', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('keyType53')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'keyType53':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='keyType53')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='keyType53', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='keyType53'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='keyType53', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for attributeReference_ in self.attributeReference:
            namespaceprefix_ = self.attributeReference_nsprefix_ + ':' if (UseCapturedNS_ and self.attributeReference_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sattributeReference>%s</%sattributeReference>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(attributeReference_), input_name='attributeReference')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'attributeReference':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'attributeReference')
            value_ = self.gds_validate_string(value_, node, 'attributeReference')
            self.attributeReference.append(value_)
            self.attributeReference_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.attributeReference[-1])
# end class keyType53


class checkConstraintType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('language', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('constraintName', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'constraintName', 'type': 'xs:string'}, None),
        MemberSpec_('constraintDescription', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'constraintDescription', 'type': 'xs:string'}, None),
        MemberSpec_('checkCondition', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'checkCondition', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, language=None, constraintName=None, constraintDescription=None, checkCondition=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.constraintName = constraintName
        self.validate_NonEmptyStringType(self.constraintName)
        self.constraintName_nsprefix_ = None
        self.constraintDescription = constraintDescription
        self.constraintDescription_nsprefix_ = None
        self.checkCondition = checkCondition
        self.validate_NonEmptyStringType(self.checkCondition)
        self.checkCondition_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, checkConstraintType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if checkConstraintType.subclass:
            return checkConstraintType.subclass(*args_, **kwargs_)
        else:
            return checkConstraintType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_constraintName(self):
        return self.constraintName
    def set_constraintName(self, constraintName):
        self.constraintName = constraintName
    def get_constraintDescription(self):
        return self.constraintDescription
    def set_constraintDescription(self, constraintDescription):
        self.constraintDescription = constraintDescription
    def get_checkCondition(self):
        return self.checkCondition
    def set_checkCondition(self, checkCondition):
        self.checkCondition = checkCondition
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def hasContent_(self):
        if (
            self.constraintName is not None or
            self.constraintDescription is not None or
            self.checkCondition is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='checkConstraintType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('checkConstraintType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'checkConstraintType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='checkConstraintType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='checkConstraintType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='checkConstraintType'):
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='checkConstraintType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.constraintName is not None:
            namespaceprefix_ = self.constraintName_nsprefix_ + ':' if (UseCapturedNS_ and self.constraintName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sconstraintName>%s</%sconstraintName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.constraintName), input_name='constraintName')), namespaceprefix_ , eol_))
        if self.constraintDescription is not None:
            namespaceprefix_ = self.constraintDescription_nsprefix_ + ':' if (UseCapturedNS_ and self.constraintDescription_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sconstraintDescription>%s</%sconstraintDescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.constraintDescription), input_name='constraintDescription')), namespaceprefix_ , eol_))
        if self.checkCondition is not None:
            namespaceprefix_ = self.checkCondition_nsprefix_ + ':' if (UseCapturedNS_ and self.checkCondition_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scheckCondition>%s</%scheckCondition>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.checkCondition), input_name='checkCondition')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'constraintName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'constraintName')
            value_ = self.gds_validate_string(value_, node, 'constraintName')
            self.constraintName = value_
            self.constraintName_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.constraintName)
        elif nodeName_ == 'constraintDescription':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'constraintDescription')
            value_ = self.gds_validate_string(value_, node, 'constraintDescription')
            self.constraintDescription = value_
            self.constraintDescription_nsprefix_ = child_.prefix
        elif nodeName_ == 'checkCondition':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'checkCondition')
            value_ = self.gds_validate_string(value_, node, 'checkCondition')
            self.checkCondition = value_
            self.checkCondition_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.checkCondition)
# end class checkConstraintType


class foreignKeyType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('constraintName', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'constraintName', 'type': 'xs:string'}, None),
        MemberSpec_('constraintDescription', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'constraintDescription', 'type': 'xs:string'}, None),
        MemberSpec_('key', 'keyType54', 0, 0, {'name': 'key', 'type': 'keyType54'}, None),
        MemberSpec_('entityReference', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'entityReference', 'type': 'xs:string'}, None),
        MemberSpec_('relationshipType', ['relationshipTypeType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'relationshipType', 'type': 'xs:string'}, None),
        MemberSpec_('cardinality', 'cardinalityType', 0, 1, {'minOccurs': '0', 'name': 'cardinality', 'type': 'cardinalityType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, constraintName=None, constraintDescription=None, key=None, entityReference=None, relationshipType=None, cardinality=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.constraintName = constraintName
        self.validate_NonEmptyStringType(self.constraintName)
        self.constraintName_nsprefix_ = None
        self.constraintDescription = constraintDescription
        self.constraintDescription_nsprefix_ = None
        self.key = key
        self.key_nsprefix_ = None
        self.entityReference = entityReference
        self.validate_NonEmptyStringType(self.entityReference)
        self.entityReference_nsprefix_ = None
        self.relationshipType = relationshipType
        self.validate_relationshipTypeType(self.relationshipType)
        self.relationshipType_nsprefix_ = None
        self.cardinality = cardinality
        self.cardinality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, foreignKeyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if foreignKeyType.subclass:
            return foreignKeyType.subclass(*args_, **kwargs_)
        else:
            return foreignKeyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_constraintName(self):
        return self.constraintName
    def set_constraintName(self, constraintName):
        self.constraintName = constraintName
    def get_constraintDescription(self):
        return self.constraintDescription
    def set_constraintDescription(self, constraintDescription):
        self.constraintDescription = constraintDescription
    def get_key(self):
        return self.key
    def set_key(self, key):
        self.key = key
    def get_entityReference(self):
        return self.entityReference
    def set_entityReference(self, entityReference):
        self.entityReference = entityReference
    def get_relationshipType(self):
        return self.relationshipType
    def set_relationshipType(self, relationshipType):
        self.relationshipType = relationshipType
    def get_cardinality(self):
        return self.cardinality
    def set_cardinality(self, cardinality):
        self.cardinality = cardinality
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def validate_relationshipTypeType(self, value):
        result = True
        # Validate type relationshipTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['identifying', 'non-identifying']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on relationshipTypeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.constraintName is not None or
            self.constraintDescription is not None or
            self.key is not None or
            self.entityReference is not None or
            self.relationshipType is not None or
            self.cardinality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='foreignKeyType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('foreignKeyType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'foreignKeyType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='foreignKeyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='foreignKeyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='foreignKeyType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='foreignKeyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.constraintName is not None:
            namespaceprefix_ = self.constraintName_nsprefix_ + ':' if (UseCapturedNS_ and self.constraintName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sconstraintName>%s</%sconstraintName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.constraintName), input_name='constraintName')), namespaceprefix_ , eol_))
        if self.constraintDescription is not None:
            namespaceprefix_ = self.constraintDescription_nsprefix_ + ':' if (UseCapturedNS_ and self.constraintDescription_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sconstraintDescription>%s</%sconstraintDescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.constraintDescription), input_name='constraintDescription')), namespaceprefix_ , eol_))
        if self.key is not None:
            namespaceprefix_ = self.key_nsprefix_ + ':' if (UseCapturedNS_ and self.key_nsprefix_) else ''
            self.key.export(outfile, level, namespaceprefix_, namespacedef_='', name_='key', pretty_print=pretty_print)
        if self.entityReference is not None:
            namespaceprefix_ = self.entityReference_nsprefix_ + ':' if (UseCapturedNS_ and self.entityReference_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sentityReference>%s</%sentityReference>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.entityReference), input_name='entityReference')), namespaceprefix_ , eol_))
        if self.relationshipType is not None:
            namespaceprefix_ = self.relationshipType_nsprefix_ + ':' if (UseCapturedNS_ and self.relationshipType_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srelationshipType>%s</%srelationshipType>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.relationshipType), input_name='relationshipType')), namespaceprefix_ , eol_))
        if self.cardinality is not None:
            namespaceprefix_ = self.cardinality_nsprefix_ + ':' if (UseCapturedNS_ and self.cardinality_nsprefix_) else ''
            self.cardinality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='cardinality', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'constraintName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'constraintName')
            value_ = self.gds_validate_string(value_, node, 'constraintName')
            self.constraintName = value_
            self.constraintName_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.constraintName)
        elif nodeName_ == 'constraintDescription':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'constraintDescription')
            value_ = self.gds_validate_string(value_, node, 'constraintDescription')
            self.constraintDescription = value_
            self.constraintDescription_nsprefix_ = child_.prefix
        elif nodeName_ == 'key':
            obj_ = keyType54.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.key = obj_
            obj_.original_tagname_ = 'key'
        elif nodeName_ == 'entityReference':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'entityReference')
            value_ = self.gds_validate_string(value_, node, 'entityReference')
            self.entityReference = value_
            self.entityReference_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.entityReference)
        elif nodeName_ == 'relationshipType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'relationshipType')
            value_ = self.gds_validate_string(value_, node, 'relationshipType')
            self.relationshipType = value_
            self.relationshipType_nsprefix_ = child_.prefix
            # validate type relationshipTypeType
            self.validate_relationshipTypeType(self.relationshipType)
        elif nodeName_ == 'cardinality':
            obj_ = cardinalityType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.cardinality = obj_
            obj_.original_tagname_ = 'cardinality'
# end class foreignKeyType


class keyType54(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('attributeReference', ['NonEmptyStringType', 'xs:string'], 1, 0, {'maxOccurs': 'unbounded', 'name': 'attributeReference', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, attributeReference=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if attributeReference is None:
            self.attributeReference = []
        else:
            self.attributeReference = attributeReference
        self.attributeReference_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, keyType54)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if keyType54.subclass:
            return keyType54.subclass(*args_, **kwargs_)
        else:
            return keyType54(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_attributeReference(self):
        return self.attributeReference
    def set_attributeReference(self, attributeReference):
        self.attributeReference = attributeReference
    def add_attributeReference(self, value):
        self.attributeReference.append(value)
    def insert_attributeReference_at(self, index, value):
        self.attributeReference.insert(index, value)
    def replace_attributeReference_at(self, index, value):
        self.attributeReference[index] = value
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def hasContent_(self):
        if (
            self.attributeReference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='keyType54', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('keyType54')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'keyType54':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='keyType54')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='keyType54', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='keyType54'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='keyType54', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for attributeReference_ in self.attributeReference:
            namespaceprefix_ = self.attributeReference_nsprefix_ + ':' if (UseCapturedNS_ and self.attributeReference_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sattributeReference>%s</%sattributeReference>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(attributeReference_), input_name='attributeReference')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'attributeReference':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'attributeReference')
            value_ = self.gds_validate_string(value_, node, 'attributeReference')
            self.attributeReference.append(value_)
            self.attributeReference_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.attributeReference[-1])
# end class keyType54


class cardinalityType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('parentOccurences', ['parentOccurencesType', 'xs:integer'], 0, 0, {'name': 'parentOccurences', 'type': 'xs:integer'}, None),
        MemberSpec_('childOccurences', ['CardinalityChildOccurancesType', 'xs:string'], 0, 0, {'name': 'childOccurences', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, parentOccurences=None, childOccurences=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.parentOccurences = parentOccurences
        self.validate_parentOccurencesType(self.parentOccurences)
        self.parentOccurences_nsprefix_ = None
        self.childOccurences = childOccurences
        self.validate_CardinalityChildOccurancesType(self.childOccurences)
        self.childOccurences_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cardinalityType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cardinalityType.subclass:
            return cardinalityType.subclass(*args_, **kwargs_)
        else:
            return cardinalityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_parentOccurences(self):
        return self.parentOccurences
    def set_parentOccurences(self, parentOccurences):
        self.parentOccurences = parentOccurences
    def get_childOccurences(self):
        return self.childOccurences
    def set_childOccurences(self, childOccurences):
        self.childOccurences = childOccurences
    def validate_parentOccurencesType(self, value):
        result = True
        # Validate type parentOccurencesType, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = [0, 1]
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on parentOccurencesType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_CardinalityChildOccurancesType(self, value):
        result = True
        # Validate type CardinalityChildOccurancesType, a restriction on xs:string.
        pass
        return result
    def hasContent_(self):
        if (
            self.parentOccurences is not None or
            self.childOccurences is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='cardinalityType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cardinalityType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'cardinalityType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='cardinalityType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='cardinalityType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='cardinalityType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='cardinalityType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.parentOccurences is not None:
            namespaceprefix_ = self.parentOccurences_nsprefix_ + ':' if (UseCapturedNS_ and self.parentOccurences_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sparentOccurences>%s</%sparentOccurences>%s' % (namespaceprefix_ , self.gds_format_integer(self.parentOccurences, input_name='parentOccurences'), namespaceprefix_ , eol_))
        if self.childOccurences is not None:
            namespaceprefix_ = self.childOccurences_nsprefix_ + ':' if (UseCapturedNS_ and self.childOccurences_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%schildOccurences>%s</%schildOccurences>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.childOccurences), input_name='childOccurences')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'parentOccurences' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'parentOccurences')
            ival_ = self.gds_validate_integer(ival_, node, 'parentOccurences')
            self.parentOccurences = ival_
            self.parentOccurences_nsprefix_ = child_.prefix
            # validate type parentOccurencesType
            self.validate_parentOccurencesType(self.parentOccurences)
        elif nodeName_ == 'childOccurences':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'childOccurences')
            value_ = self.gds_validate_string(value_, node, 'childOccurences')
            self.childOccurences = value_
            self.childOccurences_nsprefix_ = child_.prefix
            # validate type CardinalityChildOccurancesType
            self.validate_CardinalityChildOccurancesType(self.childOccurences)
# end class cardinalityType


class joinConditionType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('constraintName', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'constraintName', 'type': 'xs:string'}, None),
        MemberSpec_('constraintDescription', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'constraintDescription', 'type': 'xs:string'}, None),
        MemberSpec_('key', 'keyType55', 0, 0, {'name': 'key', 'type': 'keyType55'}, None),
        MemberSpec_('entityReference', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'entityReference', 'type': 'xs:string'}, None),
        MemberSpec_('relationshipType', ['relationshipTypeType56', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'relationshipType', 'type': 'xs:string'}, None),
        MemberSpec_('cardinality', 'cardinalityType57', 0, 1, {'minOccurs': '0', 'name': 'cardinality', 'type': 'cardinalityType57'}, None),
        MemberSpec_('referencedKey', 'referencedKeyType', 0, 0, {'name': 'referencedKey', 'type': 'referencedKeyType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, constraintName=None, constraintDescription=None, key=None, entityReference=None, relationshipType=None, cardinality=None, referencedKey=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.constraintName = constraintName
        self.validate_NonEmptyStringType(self.constraintName)
        self.constraintName_nsprefix_ = None
        self.constraintDescription = constraintDescription
        self.constraintDescription_nsprefix_ = None
        self.key = key
        self.key_nsprefix_ = None
        self.entityReference = entityReference
        self.validate_NonEmptyStringType(self.entityReference)
        self.entityReference_nsprefix_ = None
        self.relationshipType = relationshipType
        self.validate_relationshipTypeType56(self.relationshipType)
        self.relationshipType_nsprefix_ = None
        self.cardinality = cardinality
        self.cardinality_nsprefix_ = None
        self.referencedKey = referencedKey
        self.referencedKey_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, joinConditionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if joinConditionType.subclass:
            return joinConditionType.subclass(*args_, **kwargs_)
        else:
            return joinConditionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_constraintName(self):
        return self.constraintName
    def set_constraintName(self, constraintName):
        self.constraintName = constraintName
    def get_constraintDescription(self):
        return self.constraintDescription
    def set_constraintDescription(self, constraintDescription):
        self.constraintDescription = constraintDescription
    def get_key(self):
        return self.key
    def set_key(self, key):
        self.key = key
    def get_entityReference(self):
        return self.entityReference
    def set_entityReference(self, entityReference):
        self.entityReference = entityReference
    def get_relationshipType(self):
        return self.relationshipType
    def set_relationshipType(self, relationshipType):
        self.relationshipType = relationshipType
    def get_cardinality(self):
        return self.cardinality
    def set_cardinality(self, cardinality):
        self.cardinality = cardinality
    def get_referencedKey(self):
        return self.referencedKey
    def set_referencedKey(self, referencedKey):
        self.referencedKey = referencedKey
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def validate_relationshipTypeType56(self, value):
        result = True
        # Validate type relationshipTypeType56, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['identifying', 'non-identifying']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on relationshipTypeType56' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.constraintName is not None or
            self.constraintDescription is not None or
            self.key is not None or
            self.entityReference is not None or
            self.relationshipType is not None or
            self.cardinality is not None or
            self.referencedKey is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='joinConditionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('joinConditionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'joinConditionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='joinConditionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='joinConditionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='joinConditionType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='joinConditionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.constraintName is not None:
            namespaceprefix_ = self.constraintName_nsprefix_ + ':' if (UseCapturedNS_ and self.constraintName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sconstraintName>%s</%sconstraintName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.constraintName), input_name='constraintName')), namespaceprefix_ , eol_))
        if self.constraintDescription is not None:
            namespaceprefix_ = self.constraintDescription_nsprefix_ + ':' if (UseCapturedNS_ and self.constraintDescription_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sconstraintDescription>%s</%sconstraintDescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.constraintDescription), input_name='constraintDescription')), namespaceprefix_ , eol_))
        if self.key is not None:
            namespaceprefix_ = self.key_nsprefix_ + ':' if (UseCapturedNS_ and self.key_nsprefix_) else ''
            self.key.export(outfile, level, namespaceprefix_, namespacedef_='', name_='key', pretty_print=pretty_print)
        if self.entityReference is not None:
            namespaceprefix_ = self.entityReference_nsprefix_ + ':' if (UseCapturedNS_ and self.entityReference_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sentityReference>%s</%sentityReference>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.entityReference), input_name='entityReference')), namespaceprefix_ , eol_))
        if self.relationshipType is not None:
            namespaceprefix_ = self.relationshipType_nsprefix_ + ':' if (UseCapturedNS_ and self.relationshipType_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srelationshipType>%s</%srelationshipType>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.relationshipType), input_name='relationshipType')), namespaceprefix_ , eol_))
        if self.cardinality is not None:
            namespaceprefix_ = self.cardinality_nsprefix_ + ':' if (UseCapturedNS_ and self.cardinality_nsprefix_) else ''
            self.cardinality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='cardinality', pretty_print=pretty_print)
        if self.referencedKey is not None:
            namespaceprefix_ = self.referencedKey_nsprefix_ + ':' if (UseCapturedNS_ and self.referencedKey_nsprefix_) else ''
            self.referencedKey.export(outfile, level, namespaceprefix_, namespacedef_='', name_='referencedKey', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'constraintName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'constraintName')
            value_ = self.gds_validate_string(value_, node, 'constraintName')
            self.constraintName = value_
            self.constraintName_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.constraintName)
        elif nodeName_ == 'constraintDescription':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'constraintDescription')
            value_ = self.gds_validate_string(value_, node, 'constraintDescription')
            self.constraintDescription = value_
            self.constraintDescription_nsprefix_ = child_.prefix
        elif nodeName_ == 'key':
            obj_ = keyType55.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.key = obj_
            obj_.original_tagname_ = 'key'
        elif nodeName_ == 'entityReference':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'entityReference')
            value_ = self.gds_validate_string(value_, node, 'entityReference')
            self.entityReference = value_
            self.entityReference_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.entityReference)
        elif nodeName_ == 'relationshipType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'relationshipType')
            value_ = self.gds_validate_string(value_, node, 'relationshipType')
            self.relationshipType = value_
            self.relationshipType_nsprefix_ = child_.prefix
            # validate type relationshipTypeType56
            self.validate_relationshipTypeType56(self.relationshipType)
        elif nodeName_ == 'cardinality':
            obj_ = cardinalityType57.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.cardinality = obj_
            obj_.original_tagname_ = 'cardinality'
        elif nodeName_ == 'referencedKey':
            obj_ = referencedKeyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.referencedKey = obj_
            obj_.original_tagname_ = 'referencedKey'
# end class joinConditionType


class keyType55(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('attributeReference', ['NonEmptyStringType', 'xs:string'], 1, 0, {'maxOccurs': 'unbounded', 'name': 'attributeReference', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, attributeReference=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if attributeReference is None:
            self.attributeReference = []
        else:
            self.attributeReference = attributeReference
        self.attributeReference_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, keyType55)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if keyType55.subclass:
            return keyType55.subclass(*args_, **kwargs_)
        else:
            return keyType55(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_attributeReference(self):
        return self.attributeReference
    def set_attributeReference(self, attributeReference):
        self.attributeReference = attributeReference
    def add_attributeReference(self, value):
        self.attributeReference.append(value)
    def insert_attributeReference_at(self, index, value):
        self.attributeReference.insert(index, value)
    def replace_attributeReference_at(self, index, value):
        self.attributeReference[index] = value
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def hasContent_(self):
        if (
            self.attributeReference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='keyType55', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('keyType55')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'keyType55':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='keyType55')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='keyType55', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='keyType55'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='keyType55', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for attributeReference_ in self.attributeReference:
            namespaceprefix_ = self.attributeReference_nsprefix_ + ':' if (UseCapturedNS_ and self.attributeReference_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sattributeReference>%s</%sattributeReference>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(attributeReference_), input_name='attributeReference')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'attributeReference':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'attributeReference')
            value_ = self.gds_validate_string(value_, node, 'attributeReference')
            self.attributeReference.append(value_)
            self.attributeReference_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.attributeReference[-1])
# end class keyType55


class cardinalityType57(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('parentOccurences', ['parentOccurencesType58', 'xs:integer'], 0, 0, {'name': 'parentOccurences', 'type': 'xs:integer'}, None),
        MemberSpec_('childOccurences', ['CardinalityChildOccurancesType', 'xs:string'], 0, 0, {'name': 'childOccurences', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, parentOccurences=None, childOccurences=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.parentOccurences = parentOccurences
        self.validate_parentOccurencesType58(self.parentOccurences)
        self.parentOccurences_nsprefix_ = None
        self.childOccurences = childOccurences
        self.validate_CardinalityChildOccurancesType(self.childOccurences)
        self.childOccurences_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cardinalityType57)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cardinalityType57.subclass:
            return cardinalityType57.subclass(*args_, **kwargs_)
        else:
            return cardinalityType57(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_parentOccurences(self):
        return self.parentOccurences
    def set_parentOccurences(self, parentOccurences):
        self.parentOccurences = parentOccurences
    def get_childOccurences(self):
        return self.childOccurences
    def set_childOccurences(self, childOccurences):
        self.childOccurences = childOccurences
    def validate_parentOccurencesType58(self, value):
        result = True
        # Validate type parentOccurencesType58, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = [0, 1]
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on parentOccurencesType58' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_CardinalityChildOccurancesType(self, value):
        result = True
        # Validate type CardinalityChildOccurancesType, a restriction on xs:string.
        pass
        return result
    def hasContent_(self):
        if (
            self.parentOccurences is not None or
            self.childOccurences is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='cardinalityType57', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cardinalityType57')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'cardinalityType57':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='cardinalityType57')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='cardinalityType57', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='cardinalityType57'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='cardinalityType57', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.parentOccurences is not None:
            namespaceprefix_ = self.parentOccurences_nsprefix_ + ':' if (UseCapturedNS_ and self.parentOccurences_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sparentOccurences>%s</%sparentOccurences>%s' % (namespaceprefix_ , self.gds_format_integer(self.parentOccurences, input_name='parentOccurences'), namespaceprefix_ , eol_))
        if self.childOccurences is not None:
            namespaceprefix_ = self.childOccurences_nsprefix_ + ':' if (UseCapturedNS_ and self.childOccurences_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%schildOccurences>%s</%schildOccurences>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.childOccurences), input_name='childOccurences')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'parentOccurences' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'parentOccurences')
            ival_ = self.gds_validate_integer(ival_, node, 'parentOccurences')
            self.parentOccurences = ival_
            self.parentOccurences_nsprefix_ = child_.prefix
            # validate type parentOccurencesType58
            self.validate_parentOccurencesType58(self.parentOccurences)
        elif nodeName_ == 'childOccurences':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'childOccurences')
            value_ = self.gds_validate_string(value_, node, 'childOccurences')
            self.childOccurences = value_
            self.childOccurences_nsprefix_ = child_.prefix
            # validate type CardinalityChildOccurancesType
            self.validate_CardinalityChildOccurancesType(self.childOccurences)
# end class cardinalityType57


class referencedKeyType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('attributeReference', ['NonEmptyStringType', 'xs:string'], 1, 0, {'maxOccurs': 'unbounded', 'name': 'attributeReference', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, attributeReference=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if attributeReference is None:
            self.attributeReference = []
        else:
            self.attributeReference = attributeReference
        self.attributeReference_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, referencedKeyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if referencedKeyType.subclass:
            return referencedKeyType.subclass(*args_, **kwargs_)
        else:
            return referencedKeyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_attributeReference(self):
        return self.attributeReference
    def set_attributeReference(self, attributeReference):
        self.attributeReference = attributeReference
    def add_attributeReference(self, value):
        self.attributeReference.append(value)
    def insert_attributeReference_at(self, index, value):
        self.attributeReference.insert(index, value)
    def replace_attributeReference_at(self, index, value):
        self.attributeReference[index] = value
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def hasContent_(self):
        if (
            self.attributeReference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='referencedKeyType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('referencedKeyType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'referencedKeyType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='referencedKeyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='referencedKeyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='referencedKeyType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='referencedKeyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for attributeReference_ in self.attributeReference:
            namespaceprefix_ = self.attributeReference_nsprefix_ + ':' if (UseCapturedNS_ and self.attributeReference_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sattributeReference>%s</%sattributeReference>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(attributeReference_), input_name='attributeReference')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'attributeReference':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'attributeReference')
            value_ = self.gds_validate_string(value_, node, 'attributeReference')
            self.attributeReference.append(value_)
            self.attributeReference_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.attributeReference[-1])
# end class referencedKeyType


class notNullConstraintType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('constraintName', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'constraintName', 'type': 'xs:string'}, None),
        MemberSpec_('constraintDescription', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'constraintDescription', 'type': 'xs:string'}, None),
        MemberSpec_('key', 'keyType59', 0, 0, {'name': 'key', 'type': 'keyType59'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, constraintName=None, constraintDescription=None, key=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.constraintName = constraintName
        self.validate_NonEmptyStringType(self.constraintName)
        self.constraintName_nsprefix_ = None
        self.constraintDescription = constraintDescription
        self.constraintDescription_nsprefix_ = None
        self.key = key
        self.key_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, notNullConstraintType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if notNullConstraintType.subclass:
            return notNullConstraintType.subclass(*args_, **kwargs_)
        else:
            return notNullConstraintType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_constraintName(self):
        return self.constraintName
    def set_constraintName(self, constraintName):
        self.constraintName = constraintName
    def get_constraintDescription(self):
        return self.constraintDescription
    def set_constraintDescription(self, constraintDescription):
        self.constraintDescription = constraintDescription
    def get_key(self):
        return self.key
    def set_key(self, key):
        self.key = key
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def hasContent_(self):
        if (
            self.constraintName is not None or
            self.constraintDescription is not None or
            self.key is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='notNullConstraintType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('notNullConstraintType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'notNullConstraintType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='notNullConstraintType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='notNullConstraintType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='notNullConstraintType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0"  xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='notNullConstraintType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.constraintName is not None:
            namespaceprefix_ = self.constraintName_nsprefix_ + ':' if (UseCapturedNS_ and self.constraintName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sconstraintName>%s</%sconstraintName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.constraintName), input_name='constraintName')), namespaceprefix_ , eol_))
        if self.constraintDescription is not None:
            namespaceprefix_ = self.constraintDescription_nsprefix_ + ':' if (UseCapturedNS_ and self.constraintDescription_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sconstraintDescription>%s</%sconstraintDescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.constraintDescription), input_name='constraintDescription')), namespaceprefix_ , eol_))
        if self.key is not None:
            namespaceprefix_ = self.key_nsprefix_ + ':' if (UseCapturedNS_ and self.key_nsprefix_) else ''
            self.key.export(outfile, level, namespaceprefix_, namespacedef_='', name_='key', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'constraintName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'constraintName')
            value_ = self.gds_validate_string(value_, node, 'constraintName')
            self.constraintName = value_
            self.constraintName_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.constraintName)
        elif nodeName_ == 'constraintDescription':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'constraintDescription')
            value_ = self.gds_validate_string(value_, node, 'constraintDescription')
            self.constraintDescription = value_
            self.constraintDescription_nsprefix_ = child_.prefix
        elif nodeName_ == 'key':
            obj_ = keyType59.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.key = obj_
            obj_.original_tagname_ = 'key'
# end class notNullConstraintType


class keyType59(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('attributeReference', ['NonEmptyStringType', 'xs:string'], 1, 0, {'maxOccurs': 'unbounded', 'name': 'attributeReference', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, attributeReference=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if attributeReference is None:
            self.attributeReference = []
        else:
            self.attributeReference = attributeReference
        self.attributeReference_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, keyType59)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if keyType59.subclass:
            return keyType59.subclass(*args_, **kwargs_)
        else:
            return keyType59(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_attributeReference(self):
        return self.attributeReference
    def set_attributeReference(self, attributeReference):
        self.attributeReference = attributeReference
    def add_attributeReference(self, value):
        self.attributeReference.append(value)
    def insert_attributeReference_at(self, index, value):
        self.attributeReference.insert(index, value)
    def replace_attributeReference_at(self, index, value):
        self.attributeReference[index] = value
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def hasContent_(self):
        if (
            self.attributeReference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='keyType59', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('keyType59')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'keyType59':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='keyType59')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='keyType59', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='keyType59'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='keyType59', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for attributeReference_ in self.attributeReference:
            namespaceprefix_ = self.attributeReference_nsprefix_ + ':' if (UseCapturedNS_ and self.attributeReference_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sattributeReference>%s</%sattributeReference>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(attributeReference_), input_name='attributeReference')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'attributeReference':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'attributeReference')
            value_ = self.gds_validate_string(value_, node, 'attributeReference')
            self.attributeReference.append(value_)
            self.attributeReference_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.attributeReference[-1])
# end class keyType59


class keyType60(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('attributeReference', ['NonEmptyStringType', 'xs:string'], 1, 0, {'maxOccurs': 'unbounded', 'name': 'attributeReference', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, attributeReference=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if attributeReference is None:
            self.attributeReference = []
        else:
            self.attributeReference = attributeReference
        self.attributeReference_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, keyType60)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if keyType60.subclass:
            return keyType60.subclass(*args_, **kwargs_)
        else:
            return keyType60(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_attributeReference(self):
        return self.attributeReference
    def set_attributeReference(self, attributeReference):
        self.attributeReference = attributeReference
    def add_attributeReference(self, value):
        self.attributeReference.append(value)
    def insert_attributeReference_at(self, index, value):
        self.attributeReference.insert(index, value)
    def replace_attributeReference_at(self, index, value):
        self.attributeReference[index] = value
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def hasContent_(self):
        if (
            self.attributeReference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='keyType60', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('keyType60')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'keyType60':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='keyType60')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='keyType60', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='keyType60'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='keyType60', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for attributeReference_ in self.attributeReference:
            namespaceprefix_ = self.attributeReference_nsprefix_ + ':' if (UseCapturedNS_ and self.attributeReference_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sattributeReference>%s</%sattributeReference>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(attributeReference_), input_name='attributeReference')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'attributeReference':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'attributeReference')
            value_ = self.gds_validate_string(value_, node, 'attributeReference')
            self.attributeReference.append(value_)
            self.attributeReference_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.attributeReference[-1])
# end class keyType60


class cardinalityType62(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('parentOccurences', ['parentOccurencesType63', 'xs:integer'], 0, 0, {'name': 'parentOccurences', 'type': 'xs:integer'}, None),
        MemberSpec_('childOccurences', ['CardinalityChildOccurancesType', 'xs:string'], 0, 0, {'name': 'childOccurences', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, parentOccurences=None, childOccurences=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.parentOccurences = parentOccurences
        self.validate_parentOccurencesType63(self.parentOccurences)
        self.parentOccurences_nsprefix_ = None
        self.childOccurences = childOccurences
        self.validate_CardinalityChildOccurancesType(self.childOccurences)
        self.childOccurences_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cardinalityType62)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cardinalityType62.subclass:
            return cardinalityType62.subclass(*args_, **kwargs_)
        else:
            return cardinalityType62(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_parentOccurences(self):
        return self.parentOccurences
    def set_parentOccurences(self, parentOccurences):
        self.parentOccurences = parentOccurences
    def get_childOccurences(self):
        return self.childOccurences
    def set_childOccurences(self, childOccurences):
        self.childOccurences = childOccurences
    def validate_parentOccurencesType63(self, value):
        result = True
        # Validate type parentOccurencesType63, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = [0, 1]
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on parentOccurencesType63' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_CardinalityChildOccurancesType(self, value):
        result = True
        # Validate type CardinalityChildOccurancesType, a restriction on xs:string.
        pass
        return result
    def hasContent_(self):
        if (
            self.parentOccurences is not None or
            self.childOccurences is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='cardinalityType62', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cardinalityType62')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'cardinalityType62':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='cardinalityType62')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='cardinalityType62', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='cardinalityType62'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='cardinalityType62', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.parentOccurences is not None:
            namespaceprefix_ = self.parentOccurences_nsprefix_ + ':' if (UseCapturedNS_ and self.parentOccurences_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sparentOccurences>%s</%sparentOccurences>%s' % (namespaceprefix_ , self.gds_format_integer(self.parentOccurences, input_name='parentOccurences'), namespaceprefix_ , eol_))
        if self.childOccurences is not None:
            namespaceprefix_ = self.childOccurences_nsprefix_ + ':' if (UseCapturedNS_ and self.childOccurences_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%schildOccurences>%s</%schildOccurences>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.childOccurences), input_name='childOccurences')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'parentOccurences' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'parentOccurences')
            ival_ = self.gds_validate_integer(ival_, node, 'parentOccurences')
            self.parentOccurences = ival_
            self.parentOccurences_nsprefix_ = child_.prefix
            # validate type parentOccurencesType63
            self.validate_parentOccurencesType63(self.parentOccurences)
        elif nodeName_ == 'childOccurences':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'childOccurences')
            value_ = self.gds_validate_string(value_, node, 'childOccurences')
            self.childOccurences = value_
            self.childOccurences_nsprefix_ = child_.prefix
            # validate type CardinalityChildOccurancesType
            self.validate_CardinalityChildOccurancesType(self.childOccurences)
# end class cardinalityType62


class alternateIdentifierType64(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('system', 'res:SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, system=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, alternateIdentifierType64)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if alternateIdentifierType64.subclass:
            return alternateIdentifierType64.subclass(*args_, **kwargs_)
        else:
            return alternateIdentifierType64(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_SystemType(self, value):
        # Validate type res:SystemType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='alternateIdentifierType64', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('alternateIdentifierType64')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'alternateIdentifierType64':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='alternateIdentifierType64')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='alternateIdentifierType64', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='alternateIdentifierType64'):
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='alternateIdentifierType64', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class alternateIdentifierType64


class referencesType65(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('system', 'SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, system=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, referencesType65)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if referencesType65.subclass:
            return referencesType65.subclass(*args_, **kwargs_)
        else:
            return referencesType65(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_SystemType(self, value):
        # Validate type SystemType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referencesType65', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('referencesType65')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'referencesType65':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='referencesType65')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='referencesType65', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='referencesType65'):
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referencesType65', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class referencesType65


class alternateIdentifierType66(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('system', 'res:SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, system=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, alternateIdentifierType66)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if alternateIdentifierType66.subclass:
            return alternateIdentifierType66.subclass(*args_, **kwargs_)
        else:
            return alternateIdentifierType66(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_SystemType(self, value):
        # Validate type res:SystemType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='alternateIdentifierType66', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('alternateIdentifierType66')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'alternateIdentifierType66':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='alternateIdentifierType66')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='alternateIdentifierType66', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='alternateIdentifierType66'):
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='alternateIdentifierType66', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class alternateIdentifierType66


class georeferenceInfoType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('cornerPoint', 'cornerPointType', 1, 0, {'maxOccurs': '4', 'name': 'cornerPoint', 'type': 'cornerPointType'}, 69),
        MemberSpec_('controlPoint', 'controlPointType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'controlPoint', 'type': 'controlPointType'}, 69),
        MemberSpec_('bilinearFit', 'bilinearFitType', 0, 0, {'name': 'bilinearFit', 'type': 'bilinearFitType'}, 69),
    ]
    subclass = None
    superclass = None
    def __init__(self, cornerPoint=None, controlPoint=None, bilinearFit=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if cornerPoint is None:
            self.cornerPoint = []
        else:
            self.cornerPoint = cornerPoint
        self.cornerPoint_nsprefix_ = None
        if controlPoint is None:
            self.controlPoint = []
        else:
            self.controlPoint = controlPoint
        self.controlPoint_nsprefix_ = None
        self.bilinearFit = bilinearFit
        self.bilinearFit_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, georeferenceInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if georeferenceInfoType.subclass:
            return georeferenceInfoType.subclass(*args_, **kwargs_)
        else:
            return georeferenceInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_cornerPoint(self):
        return self.cornerPoint
    def set_cornerPoint(self, cornerPoint):
        self.cornerPoint = cornerPoint
    def add_cornerPoint(self, value):
        self.cornerPoint.append(value)
    def insert_cornerPoint_at(self, index, value):
        self.cornerPoint.insert(index, value)
    def replace_cornerPoint_at(self, index, value):
        self.cornerPoint[index] = value
    def get_controlPoint(self):
        return self.controlPoint
    def set_controlPoint(self, controlPoint):
        self.controlPoint = controlPoint
    def add_controlPoint(self, value):
        self.controlPoint.append(value)
    def insert_controlPoint_at(self, index, value):
        self.controlPoint.insert(index, value)
    def replace_controlPoint_at(self, index, value):
        self.controlPoint[index] = value
    def get_bilinearFit(self):
        return self.bilinearFit
    def set_bilinearFit(self, bilinearFit):
        self.bilinearFit = bilinearFit
    def hasContent_(self):
        if (
            self.cornerPoint or
            self.controlPoint or
            self.bilinearFit is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='georeferenceInfoType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('georeferenceInfoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'georeferenceInfoType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='georeferenceInfoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='georeferenceInfoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='georeferenceInfoType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='georeferenceInfoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for cornerPoint_ in self.cornerPoint:
            namespaceprefix_ = self.cornerPoint_nsprefix_ + ':' if (UseCapturedNS_ and self.cornerPoint_nsprefix_) else ''
            cornerPoint_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='cornerPoint', pretty_print=pretty_print)
        for controlPoint_ in self.controlPoint:
            namespaceprefix_ = self.controlPoint_nsprefix_ + ':' if (UseCapturedNS_ and self.controlPoint_nsprefix_) else ''
            controlPoint_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='controlPoint', pretty_print=pretty_print)
        if self.bilinearFit is not None:
            namespaceprefix_ = self.bilinearFit_nsprefix_ + ':' if (UseCapturedNS_ and self.bilinearFit_nsprefix_) else ''
            self.bilinearFit.export(outfile, level, namespaceprefix_, namespacedef_='', name_='bilinearFit', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'cornerPoint':
            obj_ = cornerPointType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.cornerPoint.append(obj_)
            obj_.original_tagname_ = 'cornerPoint'
        elif nodeName_ == 'controlPoint':
            obj_ = controlPointType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.controlPoint.append(obj_)
            obj_.original_tagname_ = 'controlPoint'
        elif nodeName_ == 'bilinearFit':
            obj_ = bilinearFitType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.bilinearFit = obj_
            obj_.original_tagname_ = 'bilinearFit'
# end class georeferenceInfoType


class cornerPointType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('xCoordinate', 'xs:float', 0, 0, {'name': 'xCoordinate', 'type': 'xs:float'}, None),
        MemberSpec_('yCoordinate', 'xs:float', 0, 0, {'name': 'yCoordinate', 'type': 'xs:float'}, None),
        MemberSpec_('pointInPixel', ['pointInPixelType', 'xs:string'], 0, 0, {'name': 'pointInPixel', 'type': 'xs:string'}, None),
        MemberSpec_('corner', ['rasterOriginType', 'xs:string'], 0, 0, {'name': 'corner', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, xCoordinate=None, yCoordinate=None, pointInPixel=None, corner=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.xCoordinate = xCoordinate
        self.xCoordinate_nsprefix_ = None
        self.yCoordinate = yCoordinate
        self.yCoordinate_nsprefix_ = None
        self.pointInPixel = pointInPixel
        self.validate_pointInPixelType(self.pointInPixel)
        self.pointInPixel_nsprefix_ = None
        self.corner = corner
        self.validate_rasterOriginType(self.corner)
        self.corner_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cornerPointType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cornerPointType.subclass:
            return cornerPointType.subclass(*args_, **kwargs_)
        else:
            return cornerPointType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_xCoordinate(self):
        return self.xCoordinate
    def set_xCoordinate(self, xCoordinate):
        self.xCoordinate = xCoordinate
    def get_yCoordinate(self):
        return self.yCoordinate
    def set_yCoordinate(self, yCoordinate):
        self.yCoordinate = yCoordinate
    def get_pointInPixel(self):
        return self.pointInPixel
    def set_pointInPixel(self, pointInPixel):
        self.pointInPixel = pointInPixel
    def get_corner(self):
        return self.corner
    def set_corner(self, corner):
        self.corner = corner
    def validate_pointInPixelType(self, value):
        result = True
        # Validate type pointInPixelType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['upperLeft', 'upperRight', 'lowerRight', 'lowerLeft', 'center']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on pointInPixelType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_rasterOriginType(self, value):
        result = True
        # Validate type rasterOriginType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Upper Left', 'Lower Left', 'Upper Right', 'Lower Right']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on rasterOriginType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.xCoordinate is not None or
            self.yCoordinate is not None or
            self.pointInPixel is not None or
            self.corner is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='cornerPointType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cornerPointType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'cornerPointType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='cornerPointType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='cornerPointType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='cornerPointType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='cornerPointType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xCoordinate is not None:
            namespaceprefix_ = self.xCoordinate_nsprefix_ + ':' if (UseCapturedNS_ and self.xCoordinate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxCoordinate>%s</%sxCoordinate>%s' % (namespaceprefix_ , self.gds_format_float(self.xCoordinate, input_name='xCoordinate'), namespaceprefix_ , eol_))
        if self.yCoordinate is not None:
            namespaceprefix_ = self.yCoordinate_nsprefix_ + ':' if (UseCapturedNS_ and self.yCoordinate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%syCoordinate>%s</%syCoordinate>%s' % (namespaceprefix_ , self.gds_format_float(self.yCoordinate, input_name='yCoordinate'), namespaceprefix_ , eol_))
        if self.pointInPixel is not None:
            namespaceprefix_ = self.pointInPixel_nsprefix_ + ':' if (UseCapturedNS_ and self.pointInPixel_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spointInPixel>%s</%spointInPixel>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pointInPixel), input_name='pointInPixel')), namespaceprefix_ , eol_))
        if self.corner is not None:
            namespaceprefix_ = self.corner_nsprefix_ + ':' if (UseCapturedNS_ and self.corner_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scorner>%s</%scorner>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.corner), input_name='corner')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'xCoordinate' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_float(sval_, node, 'xCoordinate')
            fval_ = self.gds_validate_float(fval_, node, 'xCoordinate')
            self.xCoordinate = fval_
            self.xCoordinate_nsprefix_ = child_.prefix
        elif nodeName_ == 'yCoordinate' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_float(sval_, node, 'yCoordinate')
            fval_ = self.gds_validate_float(fval_, node, 'yCoordinate')
            self.yCoordinate = fval_
            self.yCoordinate_nsprefix_ = child_.prefix
        elif nodeName_ == 'pointInPixel':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'pointInPixel')
            value_ = self.gds_validate_string(value_, node, 'pointInPixel')
            self.pointInPixel = value_
            self.pointInPixel_nsprefix_ = child_.prefix
            # validate type pointInPixelType
            self.validate_pointInPixelType(self.pointInPixel)
        elif nodeName_ == 'corner':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'corner')
            value_ = self.gds_validate_string(value_, node, 'corner')
            self.corner = value_
            self.corner_nsprefix_ = child_.prefix
            # validate type rasterOriginType
            self.validate_rasterOriginType(self.corner)
# end class cornerPointType


class controlPointType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('column', 'xs:int', 0, 0, {'name': 'column', 'type': 'xs:int'}, None),
        MemberSpec_('row', 'xs:int', 0, 0, {'name': 'row', 'type': 'xs:int'}, None),
        MemberSpec_('xCoordinate', 'xs:float', 0, 0, {'name': 'xCoordinate', 'type': 'xs:float'}, None),
        MemberSpec_('yCoordinate', 'xs:float', 0, 0, {'name': 'yCoordinate', 'type': 'xs:float'}, None),
        MemberSpec_('pointInPixel', ['pointInPixelType67', 'xs:string'], 0, 0, {'name': 'pointInPixel', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, column=None, row=None, xCoordinate=None, yCoordinate=None, pointInPixel=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.column = column
        self.column_nsprefix_ = None
        self.row = row
        self.row_nsprefix_ = None
        self.xCoordinate = xCoordinate
        self.xCoordinate_nsprefix_ = None
        self.yCoordinate = yCoordinate
        self.yCoordinate_nsprefix_ = None
        self.pointInPixel = pointInPixel
        self.validate_pointInPixelType67(self.pointInPixel)
        self.pointInPixel_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, controlPointType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if controlPointType.subclass:
            return controlPointType.subclass(*args_, **kwargs_)
        else:
            return controlPointType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_column(self):
        return self.column
    def set_column(self, column):
        self.column = column
    def get_row(self):
        return self.row
    def set_row(self, row):
        self.row = row
    def get_xCoordinate(self):
        return self.xCoordinate
    def set_xCoordinate(self, xCoordinate):
        self.xCoordinate = xCoordinate
    def get_yCoordinate(self):
        return self.yCoordinate
    def set_yCoordinate(self, yCoordinate):
        self.yCoordinate = yCoordinate
    def get_pointInPixel(self):
        return self.pointInPixel
    def set_pointInPixel(self, pointInPixel):
        self.pointInPixel = pointInPixel
    def validate_pointInPixelType67(self, value):
        result = True
        # Validate type pointInPixelType67, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['upperLeft', 'upperRight', 'lowerRight', 'lowerLeft', 'center']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on pointInPixelType67' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.column is not None or
            self.row is not None or
            self.xCoordinate is not None or
            self.yCoordinate is not None or
            self.pointInPixel is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='controlPointType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('controlPointType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'controlPointType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='controlPointType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='controlPointType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='controlPointType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='controlPointType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.column is not None:
            namespaceprefix_ = self.column_nsprefix_ + ':' if (UseCapturedNS_ and self.column_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scolumn>%s</%scolumn>%s' % (namespaceprefix_ , self.gds_format_integer(self.column, input_name='column'), namespaceprefix_ , eol_))
        if self.row is not None:
            namespaceprefix_ = self.row_nsprefix_ + ':' if (UseCapturedNS_ and self.row_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srow>%s</%srow>%s' % (namespaceprefix_ , self.gds_format_integer(self.row, input_name='row'), namespaceprefix_ , eol_))
        if self.xCoordinate is not None:
            namespaceprefix_ = self.xCoordinate_nsprefix_ + ':' if (UseCapturedNS_ and self.xCoordinate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxCoordinate>%s</%sxCoordinate>%s' % (namespaceprefix_ , self.gds_format_float(self.xCoordinate, input_name='xCoordinate'), namespaceprefix_ , eol_))
        if self.yCoordinate is not None:
            namespaceprefix_ = self.yCoordinate_nsprefix_ + ':' if (UseCapturedNS_ and self.yCoordinate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%syCoordinate>%s</%syCoordinate>%s' % (namespaceprefix_ , self.gds_format_float(self.yCoordinate, input_name='yCoordinate'), namespaceprefix_ , eol_))
        if self.pointInPixel is not None:
            namespaceprefix_ = self.pointInPixel_nsprefix_ + ':' if (UseCapturedNS_ and self.pointInPixel_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spointInPixel>%s</%spointInPixel>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pointInPixel), input_name='pointInPixel')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'column' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'column')
            ival_ = self.gds_validate_integer(ival_, node, 'column')
            self.column = ival_
            self.column_nsprefix_ = child_.prefix
        elif nodeName_ == 'row' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'row')
            ival_ = self.gds_validate_integer(ival_, node, 'row')
            self.row = ival_
            self.row_nsprefix_ = child_.prefix
        elif nodeName_ == 'xCoordinate' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_float(sval_, node, 'xCoordinate')
            fval_ = self.gds_validate_float(fval_, node, 'xCoordinate')
            self.xCoordinate = fval_
            self.xCoordinate_nsprefix_ = child_.prefix
        elif nodeName_ == 'yCoordinate' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_float(sval_, node, 'yCoordinate')
            fval_ = self.gds_validate_float(fval_, node, 'yCoordinate')
            self.yCoordinate = fval_
            self.yCoordinate_nsprefix_ = child_.prefix
        elif nodeName_ == 'pointInPixel':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'pointInPixel')
            value_ = self.gds_validate_string(value_, node, 'pointInPixel')
            self.pointInPixel = value_
            self.pointInPixel_nsprefix_ = child_.prefix
            # validate type pointInPixelType67
            self.validate_pointInPixelType67(self.pointInPixel)
# end class controlPointType


class bilinearFitType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('xIntercept', 'xs:float', 0, 0, {'name': 'xIntercept', 'type': 'xs:float'}, None),
        MemberSpec_('xSlope', 'xs:float', 0, 0, {'name': 'xSlope', 'type': 'xs:float'}, None),
        MemberSpec_('yIntercept', 'xs:float', 0, 0, {'name': 'yIntercept', 'type': 'xs:float'}, None),
        MemberSpec_('ySlope', 'xs:float', 0, 0, {'name': 'ySlope', 'type': 'xs:float'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, xIntercept=None, xSlope=None, yIntercept=None, ySlope=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.xIntercept = xIntercept
        self.xIntercept_nsprefix_ = None
        self.xSlope = xSlope
        self.xSlope_nsprefix_ = None
        self.yIntercept = yIntercept
        self.yIntercept_nsprefix_ = None
        self.ySlope = ySlope
        self.ySlope_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, bilinearFitType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if bilinearFitType.subclass:
            return bilinearFitType.subclass(*args_, **kwargs_)
        else:
            return bilinearFitType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_xIntercept(self):
        return self.xIntercept
    def set_xIntercept(self, xIntercept):
        self.xIntercept = xIntercept
    def get_xSlope(self):
        return self.xSlope
    def set_xSlope(self, xSlope):
        self.xSlope = xSlope
    def get_yIntercept(self):
        return self.yIntercept
    def set_yIntercept(self, yIntercept):
        self.yIntercept = yIntercept
    def get_ySlope(self):
        return self.ySlope
    def set_ySlope(self, ySlope):
        self.ySlope = ySlope
    def hasContent_(self):
        if (
            self.xIntercept is not None or
            self.xSlope is not None or
            self.yIntercept is not None or
            self.ySlope is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='bilinearFitType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('bilinearFitType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'bilinearFitType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='bilinearFitType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='bilinearFitType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='bilinearFitType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='bilinearFitType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xIntercept is not None:
            namespaceprefix_ = self.xIntercept_nsprefix_ + ':' if (UseCapturedNS_ and self.xIntercept_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxIntercept>%s</%sxIntercept>%s' % (namespaceprefix_ , self.gds_format_float(self.xIntercept, input_name='xIntercept'), namespaceprefix_ , eol_))
        if self.xSlope is not None:
            namespaceprefix_ = self.xSlope_nsprefix_ + ':' if (UseCapturedNS_ and self.xSlope_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxSlope>%s</%sxSlope>%s' % (namespaceprefix_ , self.gds_format_float(self.xSlope, input_name='xSlope'), namespaceprefix_ , eol_))
        if self.yIntercept is not None:
            namespaceprefix_ = self.yIntercept_nsprefix_ + ':' if (UseCapturedNS_ and self.yIntercept_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%syIntercept>%s</%syIntercept>%s' % (namespaceprefix_ , self.gds_format_float(self.yIntercept, input_name='yIntercept'), namespaceprefix_ , eol_))
        if self.ySlope is not None:
            namespaceprefix_ = self.ySlope_nsprefix_ + ':' if (UseCapturedNS_ and self.ySlope_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sySlope>%s</%sySlope>%s' % (namespaceprefix_ , self.gds_format_float(self.ySlope, input_name='ySlope'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'xIntercept' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_float(sval_, node, 'xIntercept')
            fval_ = self.gds_validate_float(fval_, node, 'xIntercept')
            self.xIntercept = fval_
            self.xIntercept_nsprefix_ = child_.prefix
        elif nodeName_ == 'xSlope' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_float(sval_, node, 'xSlope')
            fval_ = self.gds_validate_float(fval_, node, 'xSlope')
            self.xSlope = fval_
            self.xSlope_nsprefix_ = child_.prefix
        elif nodeName_ == 'yIntercept' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_float(sval_, node, 'yIntercept')
            fval_ = self.gds_validate_float(fval_, node, 'yIntercept')
            self.yIntercept = fval_
            self.yIntercept_nsprefix_ = child_.prefix
        elif nodeName_ == 'ySlope' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_float(sval_, node, 'ySlope')
            fval_ = self.gds_validate_float(fval_, node, 'ySlope')
            self.ySlope = fval_
            self.ySlope_nsprefix_ = child_.prefix
# end class bilinearFitType


class imageDescriptionType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('illuminationElevationAngle', 'xs:float', 0, 1, {'minOccurs': '0', 'name': 'illuminationElevationAngle', 'type': 'xs:float'}, None),
        MemberSpec_('illuminationAzimuthAngle', 'xs:float', 0, 1, {'minOccurs': '0', 'name': 'illuminationAzimuthAngle', 'type': 'xs:float'}, None),
        MemberSpec_('imageOrientationAngle', 'xs:float', 0, 1, {'minOccurs': '0', 'name': 'imageOrientationAngle', 'type': 'xs:float'}, None),
        MemberSpec_('imagingCondition', ['ImagingConditionCode', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'imagingCondition', 'type': 'xs:string'}, None),
        MemberSpec_('imageQualityCode', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'imageQualityCode', 'type': 'xs:string'}, None),
        MemberSpec_('cloudCoverPercentage', 'xs:float', 0, 1, {'minOccurs': '0', 'name': 'cloudCoverPercentage', 'type': 'xs:float'}, None),
        MemberSpec_('preProcessingTypeCode', ['NonEmptyStringType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'preProcessingTypeCode', 'type': 'xs:string'}, None),
        MemberSpec_('compressionGenerationQuality', 'xs:integer', 0, 1, {'minOccurs': '0', 'name': 'compressionGenerationQuality', 'type': 'xs:integer'}, None),
        MemberSpec_('triangulationIndicator', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'triangulationIndicator', 'type': 'xs:boolean'}, None),
        MemberSpec_('radiometricDataAvailability', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'radiometricDataAvailability', 'type': 'xs:boolean'}, None),
        MemberSpec_('cameraCalibrationInformationAvailability', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'cameraCalibrationInformationAvailability', 'type': 'xs:boolean'}, None),
        MemberSpec_('filmDistortionInformationAvailability', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'filmDistortionInformationAvailability', 'type': 'xs:boolean'}, None),
        MemberSpec_('lensDistortionInformationAvailability', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'lensDistortionInformationAvailability', 'type': 'xs:boolean'}, None),
        MemberSpec_('bandDescription', 'BandType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'bandDescription', 'type': 'BandType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, illuminationElevationAngle=None, illuminationAzimuthAngle=None, imageOrientationAngle=None, imagingCondition=None, imageQualityCode=None, cloudCoverPercentage=None, preProcessingTypeCode=None, compressionGenerationQuality=None, triangulationIndicator=None, radiometricDataAvailability=None, cameraCalibrationInformationAvailability=None, filmDistortionInformationAvailability=None, lensDistortionInformationAvailability=None, bandDescription=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.illuminationElevationAngle = illuminationElevationAngle
        self.illuminationElevationAngle_nsprefix_ = None
        self.illuminationAzimuthAngle = illuminationAzimuthAngle
        self.illuminationAzimuthAngle_nsprefix_ = None
        self.imageOrientationAngle = imageOrientationAngle
        self.imageOrientationAngle_nsprefix_ = None
        self.imagingCondition = imagingCondition
        self.validate_ImagingConditionCode(self.imagingCondition)
        self.imagingCondition_nsprefix_ = None
        self.imageQualityCode = imageQualityCode
        self.validate_NonEmptyStringType(self.imageQualityCode)
        self.imageQualityCode_nsprefix_ = None
        self.cloudCoverPercentage = cloudCoverPercentage
        self.cloudCoverPercentage_nsprefix_ = None
        self.preProcessingTypeCode = preProcessingTypeCode
        self.validate_NonEmptyStringType(self.preProcessingTypeCode)
        self.preProcessingTypeCode_nsprefix_ = None
        self.compressionGenerationQuality = compressionGenerationQuality
        self.compressionGenerationQuality_nsprefix_ = None
        self.triangulationIndicator = triangulationIndicator
        self.triangulationIndicator_nsprefix_ = None
        self.radiometricDataAvailability = radiometricDataAvailability
        self.radiometricDataAvailability_nsprefix_ = None
        self.cameraCalibrationInformationAvailability = cameraCalibrationInformationAvailability
        self.cameraCalibrationInformationAvailability_nsprefix_ = None
        self.filmDistortionInformationAvailability = filmDistortionInformationAvailability
        self.filmDistortionInformationAvailability_nsprefix_ = None
        self.lensDistortionInformationAvailability = lensDistortionInformationAvailability
        self.lensDistortionInformationAvailability_nsprefix_ = None
        if bandDescription is None:
            self.bandDescription = []
        else:
            self.bandDescription = bandDescription
        self.bandDescription_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, imageDescriptionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if imageDescriptionType.subclass:
            return imageDescriptionType.subclass(*args_, **kwargs_)
        else:
            return imageDescriptionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_illuminationElevationAngle(self):
        return self.illuminationElevationAngle
    def set_illuminationElevationAngle(self, illuminationElevationAngle):
        self.illuminationElevationAngle = illuminationElevationAngle
    def get_illuminationAzimuthAngle(self):
        return self.illuminationAzimuthAngle
    def set_illuminationAzimuthAngle(self, illuminationAzimuthAngle):
        self.illuminationAzimuthAngle = illuminationAzimuthAngle
    def get_imageOrientationAngle(self):
        return self.imageOrientationAngle
    def set_imageOrientationAngle(self, imageOrientationAngle):
        self.imageOrientationAngle = imageOrientationAngle
    def get_imagingCondition(self):
        return self.imagingCondition
    def set_imagingCondition(self, imagingCondition):
        self.imagingCondition = imagingCondition
    def get_imageQualityCode(self):
        return self.imageQualityCode
    def set_imageQualityCode(self, imageQualityCode):
        self.imageQualityCode = imageQualityCode
    def get_cloudCoverPercentage(self):
        return self.cloudCoverPercentage
    def set_cloudCoverPercentage(self, cloudCoverPercentage):
        self.cloudCoverPercentage = cloudCoverPercentage
    def get_preProcessingTypeCode(self):
        return self.preProcessingTypeCode
    def set_preProcessingTypeCode(self, preProcessingTypeCode):
        self.preProcessingTypeCode = preProcessingTypeCode
    def get_compressionGenerationQuality(self):
        return self.compressionGenerationQuality
    def set_compressionGenerationQuality(self, compressionGenerationQuality):
        self.compressionGenerationQuality = compressionGenerationQuality
    def get_triangulationIndicator(self):
        return self.triangulationIndicator
    def set_triangulationIndicator(self, triangulationIndicator):
        self.triangulationIndicator = triangulationIndicator
    def get_radiometricDataAvailability(self):
        return self.radiometricDataAvailability
    def set_radiometricDataAvailability(self, radiometricDataAvailability):
        self.radiometricDataAvailability = radiometricDataAvailability
    def get_cameraCalibrationInformationAvailability(self):
        return self.cameraCalibrationInformationAvailability
    def set_cameraCalibrationInformationAvailability(self, cameraCalibrationInformationAvailability):
        self.cameraCalibrationInformationAvailability = cameraCalibrationInformationAvailability
    def get_filmDistortionInformationAvailability(self):
        return self.filmDistortionInformationAvailability
    def set_filmDistortionInformationAvailability(self, filmDistortionInformationAvailability):
        self.filmDistortionInformationAvailability = filmDistortionInformationAvailability
    def get_lensDistortionInformationAvailability(self):
        return self.lensDistortionInformationAvailability
    def set_lensDistortionInformationAvailability(self, lensDistortionInformationAvailability):
        self.lensDistortionInformationAvailability = lensDistortionInformationAvailability
    def get_bandDescription(self):
        return self.bandDescription
    def set_bandDescription(self, bandDescription):
        self.bandDescription = bandDescription
    def add_bandDescription(self, value):
        self.bandDescription.append(value)
    def insert_bandDescription_at(self, index, value):
        self.bandDescription.insert(index, value)
    def replace_bandDescription_at(self, index, value):
        self.bandDescription[index] = value
    def validate_ImagingConditionCode(self, value):
        result = True
        # Validate type ImagingConditionCode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['blurredimage', 'cloud', 'degradingObliquity', 'fog', 'heavySmokeorDust', 'night', 'rain', 'semiDarkness', 'shadow', 'snow', 'terrainMasking']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ImagingConditionCode' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def hasContent_(self):
        if (
            self.illuminationElevationAngle is not None or
            self.illuminationAzimuthAngle is not None or
            self.imageOrientationAngle is not None or
            self.imagingCondition is not None or
            self.imageQualityCode is not None or
            self.cloudCoverPercentage is not None or
            self.preProcessingTypeCode is not None or
            self.compressionGenerationQuality is not None or
            self.triangulationIndicator is not None or
            self.radiometricDataAvailability is not None or
            self.cameraCalibrationInformationAvailability is not None or
            self.filmDistortionInformationAvailability is not None or
            self.lensDistortionInformationAvailability is not None or
            self.bandDescription
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0"  xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='imageDescriptionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('imageDescriptionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'imageDescriptionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='imageDescriptionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='imageDescriptionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='imageDescriptionType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0"  xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='imageDescriptionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.illuminationElevationAngle is not None:
            namespaceprefix_ = self.illuminationElevationAngle_nsprefix_ + ':' if (UseCapturedNS_ and self.illuminationElevationAngle_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%silluminationElevationAngle>%s</%silluminationElevationAngle>%s' % (namespaceprefix_ , self.gds_format_float(self.illuminationElevationAngle, input_name='illuminationElevationAngle'), namespaceprefix_ , eol_))
        if self.illuminationAzimuthAngle is not None:
            namespaceprefix_ = self.illuminationAzimuthAngle_nsprefix_ + ':' if (UseCapturedNS_ and self.illuminationAzimuthAngle_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%silluminationAzimuthAngle>%s</%silluminationAzimuthAngle>%s' % (namespaceprefix_ , self.gds_format_float(self.illuminationAzimuthAngle, input_name='illuminationAzimuthAngle'), namespaceprefix_ , eol_))
        if self.imageOrientationAngle is not None:
            namespaceprefix_ = self.imageOrientationAngle_nsprefix_ + ':' if (UseCapturedNS_ and self.imageOrientationAngle_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%simageOrientationAngle>%s</%simageOrientationAngle>%s' % (namespaceprefix_ , self.gds_format_float(self.imageOrientationAngle, input_name='imageOrientationAngle'), namespaceprefix_ , eol_))
        if self.imagingCondition is not None:
            namespaceprefix_ = self.imagingCondition_nsprefix_ + ':' if (UseCapturedNS_ and self.imagingCondition_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%simagingCondition>%s</%simagingCondition>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.imagingCondition), input_name='imagingCondition')), namespaceprefix_ , eol_))
        if self.imageQualityCode is not None:
            namespaceprefix_ = self.imageQualityCode_nsprefix_ + ':' if (UseCapturedNS_ and self.imageQualityCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%simageQualityCode>%s</%simageQualityCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.imageQualityCode), input_name='imageQualityCode')), namespaceprefix_ , eol_))
        if self.cloudCoverPercentage is not None:
            namespaceprefix_ = self.cloudCoverPercentage_nsprefix_ + ':' if (UseCapturedNS_ and self.cloudCoverPercentage_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scloudCoverPercentage>%s</%scloudCoverPercentage>%s' % (namespaceprefix_ , self.gds_format_float(self.cloudCoverPercentage, input_name='cloudCoverPercentage'), namespaceprefix_ , eol_))
        if self.preProcessingTypeCode is not None:
            namespaceprefix_ = self.preProcessingTypeCode_nsprefix_ + ':' if (UseCapturedNS_ and self.preProcessingTypeCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spreProcessingTypeCode>%s</%spreProcessingTypeCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.preProcessingTypeCode), input_name='preProcessingTypeCode')), namespaceprefix_ , eol_))
        if self.compressionGenerationQuality is not None:
            namespaceprefix_ = self.compressionGenerationQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.compressionGenerationQuality_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scompressionGenerationQuality>%s</%scompressionGenerationQuality>%s' % (namespaceprefix_ , self.gds_format_integer(self.compressionGenerationQuality, input_name='compressionGenerationQuality'), namespaceprefix_ , eol_))
        if self.triangulationIndicator is not None:
            namespaceprefix_ = self.triangulationIndicator_nsprefix_ + ':' if (UseCapturedNS_ and self.triangulationIndicator_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%striangulationIndicator>%s</%striangulationIndicator>%s' % (namespaceprefix_ , self.gds_format_boolean(self.triangulationIndicator, input_name='triangulationIndicator'), namespaceprefix_ , eol_))
        if self.radiometricDataAvailability is not None:
            namespaceprefix_ = self.radiometricDataAvailability_nsprefix_ + ':' if (UseCapturedNS_ and self.radiometricDataAvailability_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sradiometricDataAvailability>%s</%sradiometricDataAvailability>%s' % (namespaceprefix_ , self.gds_format_boolean(self.radiometricDataAvailability, input_name='radiometricDataAvailability'), namespaceprefix_ , eol_))
        if self.cameraCalibrationInformationAvailability is not None:
            namespaceprefix_ = self.cameraCalibrationInformationAvailability_nsprefix_ + ':' if (UseCapturedNS_ and self.cameraCalibrationInformationAvailability_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scameraCalibrationInformationAvailability>%s</%scameraCalibrationInformationAvailability>%s' % (namespaceprefix_ , self.gds_format_boolean(self.cameraCalibrationInformationAvailability, input_name='cameraCalibrationInformationAvailability'), namespaceprefix_ , eol_))
        if self.filmDistortionInformationAvailability is not None:
            namespaceprefix_ = self.filmDistortionInformationAvailability_nsprefix_ + ':' if (UseCapturedNS_ and self.filmDistortionInformationAvailability_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfilmDistortionInformationAvailability>%s</%sfilmDistortionInformationAvailability>%s' % (namespaceprefix_ , self.gds_format_boolean(self.filmDistortionInformationAvailability, input_name='filmDistortionInformationAvailability'), namespaceprefix_ , eol_))
        if self.lensDistortionInformationAvailability is not None:
            namespaceprefix_ = self.lensDistortionInformationAvailability_nsprefix_ + ':' if (UseCapturedNS_ and self.lensDistortionInformationAvailability_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slensDistortionInformationAvailability>%s</%slensDistortionInformationAvailability>%s' % (namespaceprefix_ , self.gds_format_boolean(self.lensDistortionInformationAvailability, input_name='lensDistortionInformationAvailability'), namespaceprefix_ , eol_))
        for bandDescription_ in self.bandDescription:
            namespaceprefix_ = self.bandDescription_nsprefix_ + ':' if (UseCapturedNS_ and self.bandDescription_nsprefix_) else ''
            bandDescription_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='bandDescription', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'illuminationElevationAngle' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_float(sval_, node, 'illuminationElevationAngle')
            fval_ = self.gds_validate_float(fval_, node, 'illuminationElevationAngle')
            self.illuminationElevationAngle = fval_
            self.illuminationElevationAngle_nsprefix_ = child_.prefix
        elif nodeName_ == 'illuminationAzimuthAngle' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_float(sval_, node, 'illuminationAzimuthAngle')
            fval_ = self.gds_validate_float(fval_, node, 'illuminationAzimuthAngle')
            self.illuminationAzimuthAngle = fval_
            self.illuminationAzimuthAngle_nsprefix_ = child_.prefix
        elif nodeName_ == 'imageOrientationAngle' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_float(sval_, node, 'imageOrientationAngle')
            fval_ = self.gds_validate_float(fval_, node, 'imageOrientationAngle')
            self.imageOrientationAngle = fval_
            self.imageOrientationAngle_nsprefix_ = child_.prefix
        elif nodeName_ == 'imagingCondition':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'imagingCondition')
            value_ = self.gds_validate_string(value_, node, 'imagingCondition')
            self.imagingCondition = value_
            self.imagingCondition_nsprefix_ = child_.prefix
            # validate type ImagingConditionCode
            self.validate_ImagingConditionCode(self.imagingCondition)
        elif nodeName_ == 'imageQualityCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'imageQualityCode')
            value_ = self.gds_validate_string(value_, node, 'imageQualityCode')
            self.imageQualityCode = value_
            self.imageQualityCode_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.imageQualityCode)
        elif nodeName_ == 'cloudCoverPercentage' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_float(sval_, node, 'cloudCoverPercentage')
            fval_ = self.gds_validate_float(fval_, node, 'cloudCoverPercentage')
            self.cloudCoverPercentage = fval_
            self.cloudCoverPercentage_nsprefix_ = child_.prefix
        elif nodeName_ == 'preProcessingTypeCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'preProcessingTypeCode')
            value_ = self.gds_validate_string(value_, node, 'preProcessingTypeCode')
            self.preProcessingTypeCode = value_
            self.preProcessingTypeCode_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.preProcessingTypeCode)
        elif nodeName_ == 'compressionGenerationQuality' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'compressionGenerationQuality')
            ival_ = self.gds_validate_integer(ival_, node, 'compressionGenerationQuality')
            self.compressionGenerationQuality = ival_
            self.compressionGenerationQuality_nsprefix_ = child_.prefix
        elif nodeName_ == 'triangulationIndicator':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'triangulationIndicator')
            ival_ = self.gds_validate_boolean(ival_, node, 'triangulationIndicator')
            self.triangulationIndicator = ival_
            self.triangulationIndicator_nsprefix_ = child_.prefix
        elif nodeName_ == 'radiometricDataAvailability':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'radiometricDataAvailability')
            ival_ = self.gds_validate_boolean(ival_, node, 'radiometricDataAvailability')
            self.radiometricDataAvailability = ival_
            self.radiometricDataAvailability_nsprefix_ = child_.prefix
        elif nodeName_ == 'cameraCalibrationInformationAvailability':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'cameraCalibrationInformationAvailability')
            ival_ = self.gds_validate_boolean(ival_, node, 'cameraCalibrationInformationAvailability')
            self.cameraCalibrationInformationAvailability = ival_
            self.cameraCalibrationInformationAvailability_nsprefix_ = child_.prefix
        elif nodeName_ == 'filmDistortionInformationAvailability':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'filmDistortionInformationAvailability')
            ival_ = self.gds_validate_boolean(ival_, node, 'filmDistortionInformationAvailability')
            self.filmDistortionInformationAvailability = ival_
            self.filmDistortionInformationAvailability_nsprefix_ = child_.prefix
        elif nodeName_ == 'lensDistortionInformationAvailability':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'lensDistortionInformationAvailability')
            ival_ = self.gds_validate_boolean(ival_, node, 'lensDistortionInformationAvailability')
            self.lensDistortionInformationAvailability = ival_
            self.lensDistortionInformationAvailability_nsprefix_ = child_.prefix
        elif nodeName_ == 'bandDescription':
            obj_ = BandType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.bandDescription.append(obj_)
            obj_.original_tagname_ = 'bandDescription'
# end class imageDescriptionType


class referencesType68(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('system', 'SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, system=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, referencesType68)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if referencesType68.subclass:
            return referencesType68.subclass(*args_, **kwargs_)
        else:
            return referencesType68(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_SystemType(self, value):
        # Validate type SystemType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referencesType68', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('referencesType68')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'referencesType68':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='referencesType68')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='referencesType68', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='referencesType68'):
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referencesType68', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class referencesType68


class quantitativeAccuracyReportType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('quantitativeAccuracyValue', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'quantitativeAccuracyValue', 'type': 'xs:string'}, None),
        MemberSpec_('quantitativeAccuracyMethod', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'quantitativeAccuracyMethod', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, quantitativeAccuracyValue=None, quantitativeAccuracyMethod=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.quantitativeAccuracyValue = quantitativeAccuracyValue
        self.validate_NonEmptyStringType(self.quantitativeAccuracyValue)
        self.quantitativeAccuracyValue_nsprefix_ = None
        self.quantitativeAccuracyMethod = quantitativeAccuracyMethod
        self.validate_NonEmptyStringType(self.quantitativeAccuracyMethod)
        self.quantitativeAccuracyMethod_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, quantitativeAccuracyReportType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if quantitativeAccuracyReportType.subclass:
            return quantitativeAccuracyReportType.subclass(*args_, **kwargs_)
        else:
            return quantitativeAccuracyReportType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_quantitativeAccuracyValue(self):
        return self.quantitativeAccuracyValue
    def set_quantitativeAccuracyValue(self, quantitativeAccuracyValue):
        self.quantitativeAccuracyValue = quantitativeAccuracyValue
    def get_quantitativeAccuracyMethod(self):
        return self.quantitativeAccuracyMethod
    def set_quantitativeAccuracyMethod(self, quantitativeAccuracyMethod):
        self.quantitativeAccuracyMethod = quantitativeAccuracyMethod
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def hasContent_(self):
        if (
            self.quantitativeAccuracyValue is not None or
            self.quantitativeAccuracyMethod is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='quantitativeAccuracyReportType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('quantitativeAccuracyReportType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'quantitativeAccuracyReportType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='quantitativeAccuracyReportType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='quantitativeAccuracyReportType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='quantitativeAccuracyReportType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='quantitativeAccuracyReportType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.quantitativeAccuracyValue is not None:
            namespaceprefix_ = self.quantitativeAccuracyValue_nsprefix_ + ':' if (UseCapturedNS_ and self.quantitativeAccuracyValue_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%squantitativeAccuracyValue>%s</%squantitativeAccuracyValue>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.quantitativeAccuracyValue), input_name='quantitativeAccuracyValue')), namespaceprefix_ , eol_))
        if self.quantitativeAccuracyMethod is not None:
            namespaceprefix_ = self.quantitativeAccuracyMethod_nsprefix_ + ':' if (UseCapturedNS_ and self.quantitativeAccuracyMethod_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%squantitativeAccuracyMethod>%s</%squantitativeAccuracyMethod>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.quantitativeAccuracyMethod), input_name='quantitativeAccuracyMethod')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'quantitativeAccuracyValue':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'quantitativeAccuracyValue')
            value_ = self.gds_validate_string(value_, node, 'quantitativeAccuracyValue')
            self.quantitativeAccuracyValue = value_
            self.quantitativeAccuracyValue_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.quantitativeAccuracyValue)
        elif nodeName_ == 'quantitativeAccuracyMethod':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'quantitativeAccuracyMethod')
            value_ = self.gds_validate_string(value_, node, 'quantitativeAccuracyMethod')
            self.quantitativeAccuracyMethod = value_
            self.quantitativeAccuracyMethod_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.quantitativeAccuracyMethod)
# end class quantitativeAccuracyReportType


class vertCoordSysType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('altitudeSysDef', 'altitudeSysDefType', 0, 1, {'minOccurs': '0', 'name': 'altitudeSysDef', 'type': 'altitudeSysDefType'}, None),
        MemberSpec_('depthSysDef', 'depthSysDefType', 0, 1, {'minOccurs': '0', 'name': 'depthSysDef', 'type': 'depthSysDefType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, altitudeSysDef=None, depthSysDef=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.altitudeSysDef = altitudeSysDef
        self.altitudeSysDef_nsprefix_ = None
        self.depthSysDef = depthSysDef
        self.depthSysDef_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, vertCoordSysType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if vertCoordSysType.subclass:
            return vertCoordSysType.subclass(*args_, **kwargs_)
        else:
            return vertCoordSysType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_altitudeSysDef(self):
        return self.altitudeSysDef
    def set_altitudeSysDef(self, altitudeSysDef):
        self.altitudeSysDef = altitudeSysDef
    def get_depthSysDef(self):
        return self.depthSysDef
    def set_depthSysDef(self, depthSysDef):
        self.depthSysDef = depthSysDef
    def hasContent_(self):
        if (
            self.altitudeSysDef is not None or
            self.depthSysDef is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='vertCoordSysType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vertCoordSysType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'vertCoordSysType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='vertCoordSysType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='vertCoordSysType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='vertCoordSysType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='vertCoordSysType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.altitudeSysDef is not None:
            namespaceprefix_ = self.altitudeSysDef_nsprefix_ + ':' if (UseCapturedNS_ and self.altitudeSysDef_nsprefix_) else ''
            self.altitudeSysDef.export(outfile, level, namespaceprefix_, namespacedef_='', name_='altitudeSysDef', pretty_print=pretty_print)
        if self.depthSysDef is not None:
            namespaceprefix_ = self.depthSysDef_nsprefix_ + ':' if (UseCapturedNS_ and self.depthSysDef_nsprefix_) else ''
            self.depthSysDef.export(outfile, level, namespaceprefix_, namespacedef_='', name_='depthSysDef', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'altitudeSysDef':
            obj_ = altitudeSysDefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.altitudeSysDef = obj_
            obj_.original_tagname_ = 'altitudeSysDef'
        elif nodeName_ == 'depthSysDef':
            obj_ = depthSysDefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.depthSysDef = obj_
            obj_.original_tagname_ = 'depthSysDef'
# end class vertCoordSysType


class altitudeSysDefType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('altitudeDatumName', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'altitudeDatumName', 'type': 'xs:string'}, None),
        MemberSpec_('altitudeResolution', ['NonEmptyStringType', 'xs:string'], 1, 0, {'maxOccurs': 'unbounded', 'name': 'altitudeResolution', 'type': 'xs:string'}, None),
        MemberSpec_('altitudeDistanceUnits', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'altitudeDistanceUnits', 'type': 'xs:string'}, None),
        MemberSpec_('altitudeEncodingMethod', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'altitudeEncodingMethod', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, altitudeDatumName=None, altitudeResolution=None, altitudeDistanceUnits=None, altitudeEncodingMethod=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.altitudeDatumName = altitudeDatumName
        self.validate_NonEmptyStringType(self.altitudeDatumName)
        self.altitudeDatumName_nsprefix_ = None
        if altitudeResolution is None:
            self.altitudeResolution = []
        else:
            self.altitudeResolution = altitudeResolution
        self.altitudeResolution_nsprefix_ = None
        self.altitudeDistanceUnits = altitudeDistanceUnits
        self.validate_NonEmptyStringType(self.altitudeDistanceUnits)
        self.altitudeDistanceUnits_nsprefix_ = None
        self.altitudeEncodingMethod = altitudeEncodingMethod
        self.validate_NonEmptyStringType(self.altitudeEncodingMethod)
        self.altitudeEncodingMethod_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, altitudeSysDefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if altitudeSysDefType.subclass:
            return altitudeSysDefType.subclass(*args_, **kwargs_)
        else:
            return altitudeSysDefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_altitudeDatumName(self):
        return self.altitudeDatumName
    def set_altitudeDatumName(self, altitudeDatumName):
        self.altitudeDatumName = altitudeDatumName
    def get_altitudeResolution(self):
        return self.altitudeResolution
    def set_altitudeResolution(self, altitudeResolution):
        self.altitudeResolution = altitudeResolution
    def add_altitudeResolution(self, value):
        self.altitudeResolution.append(value)
    def insert_altitudeResolution_at(self, index, value):
        self.altitudeResolution.insert(index, value)
    def replace_altitudeResolution_at(self, index, value):
        self.altitudeResolution[index] = value
    def get_altitudeDistanceUnits(self):
        return self.altitudeDistanceUnits
    def set_altitudeDistanceUnits(self, altitudeDistanceUnits):
        self.altitudeDistanceUnits = altitudeDistanceUnits
    def get_altitudeEncodingMethod(self):
        return self.altitudeEncodingMethod
    def set_altitudeEncodingMethod(self, altitudeEncodingMethod):
        self.altitudeEncodingMethod = altitudeEncodingMethod
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def hasContent_(self):
        if (
            self.altitudeDatumName is not None or
            self.altitudeResolution or
            self.altitudeDistanceUnits is not None or
            self.altitudeEncodingMethod is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='altitudeSysDefType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('altitudeSysDefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'altitudeSysDefType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='altitudeSysDefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='altitudeSysDefType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='altitudeSysDefType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='altitudeSysDefType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.altitudeDatumName is not None:
            namespaceprefix_ = self.altitudeDatumName_nsprefix_ + ':' if (UseCapturedNS_ and self.altitudeDatumName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saltitudeDatumName>%s</%saltitudeDatumName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.altitudeDatumName), input_name='altitudeDatumName')), namespaceprefix_ , eol_))
        for altitudeResolution_ in self.altitudeResolution:
            namespaceprefix_ = self.altitudeResolution_nsprefix_ + ':' if (UseCapturedNS_ and self.altitudeResolution_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saltitudeResolution>%s</%saltitudeResolution>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(altitudeResolution_), input_name='altitudeResolution')), namespaceprefix_ , eol_))
        if self.altitudeDistanceUnits is not None:
            namespaceprefix_ = self.altitudeDistanceUnits_nsprefix_ + ':' if (UseCapturedNS_ and self.altitudeDistanceUnits_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saltitudeDistanceUnits>%s</%saltitudeDistanceUnits>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.altitudeDistanceUnits), input_name='altitudeDistanceUnits')), namespaceprefix_ , eol_))
        if self.altitudeEncodingMethod is not None:
            namespaceprefix_ = self.altitudeEncodingMethod_nsprefix_ + ':' if (UseCapturedNS_ and self.altitudeEncodingMethod_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saltitudeEncodingMethod>%s</%saltitudeEncodingMethod>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.altitudeEncodingMethod), input_name='altitudeEncodingMethod')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'altitudeDatumName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'altitudeDatumName')
            value_ = self.gds_validate_string(value_, node, 'altitudeDatumName')
            self.altitudeDatumName = value_
            self.altitudeDatumName_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.altitudeDatumName)
        elif nodeName_ == 'altitudeResolution':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'altitudeResolution')
            value_ = self.gds_validate_string(value_, node, 'altitudeResolution')
            self.altitudeResolution.append(value_)
            self.altitudeResolution_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.altitudeResolution[-1])
        elif nodeName_ == 'altitudeDistanceUnits':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'altitudeDistanceUnits')
            value_ = self.gds_validate_string(value_, node, 'altitudeDistanceUnits')
            self.altitudeDistanceUnits = value_
            self.altitudeDistanceUnits_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.altitudeDistanceUnits)
        elif nodeName_ == 'altitudeEncodingMethod':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'altitudeEncodingMethod')
            value_ = self.gds_validate_string(value_, node, 'altitudeEncodingMethod')
            self.altitudeEncodingMethod = value_
            self.altitudeEncodingMethod_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.altitudeEncodingMethod)
# end class altitudeSysDefType


class depthSysDefType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('depthDatumName', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'depthDatumName', 'type': 'xs:string'}, None),
        MemberSpec_('depthResolution', ['NonEmptyStringType', 'xs:string'], 1, 0, {'maxOccurs': 'unbounded', 'name': 'depthResolution', 'type': 'xs:string'}, None),
        MemberSpec_('depthDistanceUnits', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'depthDistanceUnits', 'type': 'xs:string'}, None),
        MemberSpec_('depthEncodingMethod', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'depthEncodingMethod', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, depthDatumName=None, depthResolution=None, depthDistanceUnits=None, depthEncodingMethod=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.depthDatumName = depthDatumName
        self.validate_NonEmptyStringType(self.depthDatumName)
        self.depthDatumName_nsprefix_ = None
        if depthResolution is None:
            self.depthResolution = []
        else:
            self.depthResolution = depthResolution
        self.depthResolution_nsprefix_ = None
        self.depthDistanceUnits = depthDistanceUnits
        self.validate_NonEmptyStringType(self.depthDistanceUnits)
        self.depthDistanceUnits_nsprefix_ = None
        self.depthEncodingMethod = depthEncodingMethod
        self.validate_NonEmptyStringType(self.depthEncodingMethod)
        self.depthEncodingMethod_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, depthSysDefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if depthSysDefType.subclass:
            return depthSysDefType.subclass(*args_, **kwargs_)
        else:
            return depthSysDefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_depthDatumName(self):
        return self.depthDatumName
    def set_depthDatumName(self, depthDatumName):
        self.depthDatumName = depthDatumName
    def get_depthResolution(self):
        return self.depthResolution
    def set_depthResolution(self, depthResolution):
        self.depthResolution = depthResolution
    def add_depthResolution(self, value):
        self.depthResolution.append(value)
    def insert_depthResolution_at(self, index, value):
        self.depthResolution.insert(index, value)
    def replace_depthResolution_at(self, index, value):
        self.depthResolution[index] = value
    def get_depthDistanceUnits(self):
        return self.depthDistanceUnits
    def set_depthDistanceUnits(self, depthDistanceUnits):
        self.depthDistanceUnits = depthDistanceUnits
    def get_depthEncodingMethod(self):
        return self.depthEncodingMethod
    def set_depthEncodingMethod(self, depthEncodingMethod):
        self.depthEncodingMethod = depthEncodingMethod
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def hasContent_(self):
        if (
            self.depthDatumName is not None or
            self.depthResolution or
            self.depthDistanceUnits is not None or
            self.depthEncodingMethod is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='depthSysDefType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('depthSysDefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'depthSysDefType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='depthSysDefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='depthSysDefType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='depthSysDefType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='depthSysDefType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.depthDatumName is not None:
            namespaceprefix_ = self.depthDatumName_nsprefix_ + ':' if (UseCapturedNS_ and self.depthDatumName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdepthDatumName>%s</%sdepthDatumName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.depthDatumName), input_name='depthDatumName')), namespaceprefix_ , eol_))
        for depthResolution_ in self.depthResolution:
            namespaceprefix_ = self.depthResolution_nsprefix_ + ':' if (UseCapturedNS_ and self.depthResolution_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdepthResolution>%s</%sdepthResolution>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(depthResolution_), input_name='depthResolution')), namespaceprefix_ , eol_))
        if self.depthDistanceUnits is not None:
            namespaceprefix_ = self.depthDistanceUnits_nsprefix_ + ':' if (UseCapturedNS_ and self.depthDistanceUnits_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdepthDistanceUnits>%s</%sdepthDistanceUnits>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.depthDistanceUnits), input_name='depthDistanceUnits')), namespaceprefix_ , eol_))
        if self.depthEncodingMethod is not None:
            namespaceprefix_ = self.depthEncodingMethod_nsprefix_ + ':' if (UseCapturedNS_ and self.depthEncodingMethod_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdepthEncodingMethod>%s</%sdepthEncodingMethod>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.depthEncodingMethod), input_name='depthEncodingMethod')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'depthDatumName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'depthDatumName')
            value_ = self.gds_validate_string(value_, node, 'depthDatumName')
            self.depthDatumName = value_
            self.depthDatumName_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.depthDatumName)
        elif nodeName_ == 'depthResolution':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'depthResolution')
            value_ = self.gds_validate_string(value_, node, 'depthResolution')
            self.depthResolution.append(value_)
            self.depthResolution_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.depthResolution[-1])
        elif nodeName_ == 'depthDistanceUnits':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'depthDistanceUnits')
            value_ = self.gds_validate_string(value_, node, 'depthDistanceUnits')
            self.depthDistanceUnits = value_
            self.depthDistanceUnits_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.depthDistanceUnits)
        elif nodeName_ == 'depthEncodingMethod':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'depthEncodingMethod')
            value_ = self.gds_validate_string(value_, node, 'depthEncodingMethod')
            self.depthEncodingMethod = value_
            self.depthEncodingMethod_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.depthEncodingMethod)
# end class depthSysDefType


class referencesType69(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('system', 'SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, system=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, referencesType69)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if referencesType69.subclass:
            return referencesType69.subclass(*args_, **kwargs_)
        else:
            return referencesType69(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_SystemType(self, value):
        # Validate type SystemType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referencesType69', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('referencesType69')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'referencesType69':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='referencesType69')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='referencesType69', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='referencesType69'):
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referencesType69', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class referencesType69


class datumType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('name', 'xs:string', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, datumType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if datumType.subclass:
            return datumType.subclass(*args_, **kwargs_)
        else:
            return datumType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='datumType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('datumType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'datumType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='datumType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='datumType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='datumType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='datumType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class datumType


class spheroidType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('name', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('semiAxisMajor', 'xs:float', 0, 1, {'use': 'optional'}),
        MemberSpec_('denomFlatRatio', 'xs:float', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, name=None, semiAxisMajor=None, denomFlatRatio=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.semiAxisMajor = _cast(float, semiAxisMajor)
        self.semiAxisMajor_nsprefix_ = None
        self.denomFlatRatio = _cast(float, denomFlatRatio)
        self.denomFlatRatio_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, spheroidType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if spheroidType.subclass:
            return spheroidType.subclass(*args_, **kwargs_)
        else:
            return spheroidType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_semiAxisMajor(self):
        return self.semiAxisMajor
    def set_semiAxisMajor(self, semiAxisMajor):
        self.semiAxisMajor = semiAxisMajor
    def get_denomFlatRatio(self):
        return self.denomFlatRatio
    def set_denomFlatRatio(self, denomFlatRatio):
        self.denomFlatRatio = denomFlatRatio
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='spheroidType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('spheroidType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'spheroidType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='spheroidType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='spheroidType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='spheroidType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.semiAxisMajor is not None and 'semiAxisMajor' not in already_processed:
            already_processed.add('semiAxisMajor')
            outfile.write(' semiAxisMajor="%s"' % self.gds_format_float(self.semiAxisMajor, input_name='semiAxisMajor'))
        if self.denomFlatRatio is not None and 'denomFlatRatio' not in already_processed:
            already_processed.add('denomFlatRatio')
            outfile.write(' denomFlatRatio="%s"' % self.gds_format_float(self.denomFlatRatio, input_name='denomFlatRatio'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='spheroidType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('semiAxisMajor', node)
        if value is not None and 'semiAxisMajor' not in already_processed:
            already_processed.add('semiAxisMajor')
            value = self.gds_parse_float(value, node, 'semiAxisMajor')
            self.semiAxisMajor = value
        value = find_attr_value_('denomFlatRatio', node)
        if value is not None and 'denomFlatRatio' not in already_processed:
            already_processed.add('denomFlatRatio')
            value = self.gds_parse_float(value, node, 'denomFlatRatio')
            self.denomFlatRatio = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class spheroidType


class primeMeridianType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('name', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('longitude', 'longitudeType', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, name=None, longitude=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.longitude = _cast(float, longitude)
        self.longitude_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, primeMeridianType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if primeMeridianType.subclass:
            return primeMeridianType.subclass(*args_, **kwargs_)
        else:
            return primeMeridianType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_longitude(self):
        return self.longitude
    def set_longitude(self, longitude):
        self.longitude = longitude
    def validate_longitudeType(self, value):
        # Validate type longitudeType, a restriction on xs:float.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            if value < -180:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on longitudeType' % {"value": value, "lineno": lineno} )
                result = False
            if value > 180:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on longitudeType' % {"value": value, "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='primeMeridianType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('primeMeridianType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'primeMeridianType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='primeMeridianType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='primeMeridianType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='primeMeridianType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.longitude is not None and 'longitude' not in already_processed:
            already_processed.add('longitude')
            outfile.write(' longitude="%s"' % self.gds_format_float(self.longitude, input_name='longitude'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='primeMeridianType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('longitude', node)
        if value is not None and 'longitude' not in already_processed:
            already_processed.add('longitude')
            value = self.gds_parse_float(value, node, 'longitude')
            self.longitude = value
            self.validate_longitudeType(self.longitude)    # validate type longitudeType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class primeMeridianType


class unitType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('name', 'angleUnits', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, unitType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if unitType.subclass:
            return unitType.subclass(*args_, **kwargs_)
        else:
            return unitType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def validate_angleUnits(self, value):
        # Validate type angleUnits, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['radian', 'degree', 'grad', 'degree', 'grad']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on angleUnits' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='unitType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('unitType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'unitType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='unitType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='unitType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='unitType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='unitType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
            self.validate_angleUnits(self.name)    # validate type angleUnits
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class unitType


class projCoordSysType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('geogCoordSys', 'geogCoordSysType', 0, 0, {'name': 'geogCoordSys', 'type': 'geogCoordSysType'}, None),
        MemberSpec_('projection', 'projectionType', 0, 0, {'name': 'projection', 'type': 'projectionType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, geogCoordSys=None, projection=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.geogCoordSys = geogCoordSys
        self.geogCoordSys_nsprefix_ = None
        self.projection = projection
        self.projection_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, projCoordSysType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if projCoordSysType.subclass:
            return projCoordSysType.subclass(*args_, **kwargs_)
        else:
            return projCoordSysType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_geogCoordSys(self):
        return self.geogCoordSys
    def set_geogCoordSys(self, geogCoordSys):
        self.geogCoordSys = geogCoordSys
    def get_projection(self):
        return self.projection
    def set_projection(self, projection):
        self.projection = projection
    def hasContent_(self):
        if (
            self.geogCoordSys is not None or
            self.projection is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='projCoordSysType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('projCoordSysType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'projCoordSysType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='projCoordSysType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='projCoordSysType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='projCoordSysType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='projCoordSysType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.geogCoordSys is not None:
            namespaceprefix_ = self.geogCoordSys_nsprefix_ + ':' if (UseCapturedNS_ and self.geogCoordSys_nsprefix_) else ''
            self.geogCoordSys.export(outfile, level, namespaceprefix_, namespacedef_='', name_='geogCoordSys', pretty_print=pretty_print)
        if self.projection is not None:
            namespaceprefix_ = self.projection_nsprefix_ + ':' if (UseCapturedNS_ and self.projection_nsprefix_) else ''
            self.projection.export(outfile, level, namespaceprefix_, namespacedef_='', name_='projection', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'geogCoordSys':
            obj_ = geogCoordSysType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.geogCoordSys = obj_
            obj_.original_tagname_ = 'geogCoordSys'
        elif nodeName_ == 'projection':
            obj_ = projectionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.projection = obj_
            obj_.original_tagname_ = 'projection'
# end class projCoordSysType


class projectionType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('name', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('parameter', 'parameterType70', 1, 0, {'maxOccurs': 'unbounded', 'name': 'parameter', 'type': 'parameterType70'}, None),
        MemberSpec_('unit', 'unitType71', 0, 0, {'name': 'unit', 'type': 'unitType71'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, name=None, parameter=None, unit=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        if parameter is None:
            self.parameter = []
        else:
            self.parameter = parameter
        self.parameter_nsprefix_ = None
        self.unit = unit
        self.unit_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, projectionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if projectionType.subclass:
            return projectionType.subclass(*args_, **kwargs_)
        else:
            return projectionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_parameter(self):
        return self.parameter
    def set_parameter(self, parameter):
        self.parameter = parameter
    def add_parameter(self, value):
        self.parameter.append(value)
    def insert_parameter_at(self, index, value):
        self.parameter.insert(index, value)
    def replace_parameter_at(self, index, value):
        self.parameter[index] = value
    def get_unit(self):
        return self.unit
    def set_unit(self, unit):
        self.unit = unit
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def hasContent_(self):
        if (
            self.parameter or
            self.unit is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='projectionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('projectionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'projectionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='projectionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='projectionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='projectionType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:None="https://eml.ecoinformatics.org/view-2.2.0" ', name_='projectionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for parameter_ in self.parameter:
            namespaceprefix_ = self.parameter_nsprefix_ + ':' if (UseCapturedNS_ and self.parameter_nsprefix_) else ''
            parameter_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='parameter', pretty_print=pretty_print)
        if self.unit is not None:
            namespaceprefix_ = self.unit_nsprefix_ + ':' if (UseCapturedNS_ and self.unit_nsprefix_) else ''
            self.unit.export(outfile, level, namespaceprefix_, namespacedef_='', name_='unit', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'parameter':
            obj_ = parameterType70.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.parameter.append(obj_)
            obj_.original_tagname_ = 'parameter'
        elif nodeName_ == 'unit':
            obj_ = unitType71.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.unit = obj_
            obj_.original_tagname_ = 'unit'
# end class projectionType


class parameterType70(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('name', 'xs:string', 0, 0, {'use': 'required'}),
        MemberSpec_('description', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('value', 'xs:anySimpleType', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, name=None, description=None, value=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.description = _cast(None, description)
        self.description_nsprefix_ = None
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, parameterType70)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if parameterType70.subclass:
            return parameterType70.subclass(*args_, **kwargs_)
        else:
            return parameterType70(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='parameterType70', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('parameterType70')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'parameterType70':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='parameterType70')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='parameterType70', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='parameterType70'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            outfile.write(' description=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.description), input_name='description')), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (quote_attrib(self.value), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='parameterType70', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.add('description')
            self.description = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class parameterType70


class unitType71(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('name', 'lengthUnits', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, unitType71)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if unitType71.subclass:
            return unitType71.subclass(*args_, **kwargs_)
        else:
            return unitType71(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def validate_lengthUnits(self, value):
        # Validate type lengthUnits, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['meter', 'nanometer', 'micrometer', 'micron', 'millimeter', 'centimeter', 'decimeter', 'dekameter', 'hectometer', 'kilometer', 'megameter', 'angstrom', 'inch', 'Foot_US', 'foot', 'Foot_Gold_Coast', 'fathom', 'nauticalMile', 'yard', 'Yard_Indian', 'Link_Clarke', 'Yard_Sears', 'mile']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on lengthUnits' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='unitType71', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('unitType71')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'unitType71':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='unitType71')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='unitType71', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='unitType71'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='unitType71', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
            self.validate_lengthUnits(self.name)    # validate type lengthUnits
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class unitType71


class alternateIdentifierType72(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('system', 'res:SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, system=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, alternateIdentifierType72)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if alternateIdentifierType72.subclass:
            return alternateIdentifierType72.subclass(*args_, **kwargs_)
        else:
            return alternateIdentifierType72(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_SystemType(self, value):
        # Validate type res:SystemType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='alternateIdentifierType72', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('alternateIdentifierType72')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'alternateIdentifierType72':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='alternateIdentifierType72')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='alternateIdentifierType72', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='alternateIdentifierType72'):
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='alternateIdentifierType72', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class alternateIdentifierType72


class referencesType73(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('system', 'SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, system=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, referencesType73)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if referencesType73.subclass:
            return referencesType73.subclass(*args_, **kwargs_)
        else:
            return referencesType73(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_SystemType(self, value):
        # Validate type SystemType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referencesType73', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('referencesType73')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'referencesType73':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='referencesType73')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='referencesType73', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='referencesType73'):
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referencesType73', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class referencesType73


class quantitativeAccuracyReportType74(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('quantitativeAccuracyValue', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'quantitativeAccuracyValue', 'type': 'xs:string'}, None),
        MemberSpec_('quantitativeAccuracyMethod', ['NonEmptyStringType', 'xs:string'], 0, 0, {'name': 'quantitativeAccuracyMethod', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, quantitativeAccuracyValue=None, quantitativeAccuracyMethod=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.quantitativeAccuracyValue = quantitativeAccuracyValue
        self.validate_NonEmptyStringType(self.quantitativeAccuracyValue)
        self.quantitativeAccuracyValue_nsprefix_ = None
        self.quantitativeAccuracyMethod = quantitativeAccuracyMethod
        self.validate_NonEmptyStringType(self.quantitativeAccuracyMethod)
        self.quantitativeAccuracyMethod_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, quantitativeAccuracyReportType74)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if quantitativeAccuracyReportType74.subclass:
            return quantitativeAccuracyReportType74.subclass(*args_, **kwargs_)
        else:
            return quantitativeAccuracyReportType74(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_quantitativeAccuracyValue(self):
        return self.quantitativeAccuracyValue
    def set_quantitativeAccuracyValue(self, quantitativeAccuracyValue):
        self.quantitativeAccuracyValue = quantitativeAccuracyValue
    def get_quantitativeAccuracyMethod(self):
        return self.quantitativeAccuracyMethod
    def set_quantitativeAccuracyMethod(self, quantitativeAccuracyMethod):
        self.quantitativeAccuracyMethod = quantitativeAccuracyMethod
    def validate_NonEmptyStringType(self, value):
        result = True
        # Validate type NonEmptyStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NonEmptyStringType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NonEmptyStringType_patterns_, ))
                result = False
        return result
    validate_NonEmptyStringType_patterns_ = [['^([\\s]*[\\S][\\s\\S]*)$']]
    def hasContent_(self):
        if (
            self.quantitativeAccuracyValue is not None or
            self.quantitativeAccuracyMethod is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='quantitativeAccuracyReportType74', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('quantitativeAccuracyReportType74')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'quantitativeAccuracyReportType74':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='quantitativeAccuracyReportType74')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='quantitativeAccuracyReportType74', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='quantitativeAccuracyReportType74'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0" xmlns:res="https://eml.ecoinformatics.org/resource-2.2.0" ', name_='quantitativeAccuracyReportType74', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.quantitativeAccuracyValue is not None:
            namespaceprefix_ = self.quantitativeAccuracyValue_nsprefix_ + ':' if (UseCapturedNS_ and self.quantitativeAccuracyValue_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%squantitativeAccuracyValue>%s</%squantitativeAccuracyValue>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.quantitativeAccuracyValue), input_name='quantitativeAccuracyValue')), namespaceprefix_ , eol_))
        if self.quantitativeAccuracyMethod is not None:
            namespaceprefix_ = self.quantitativeAccuracyMethod_nsprefix_ + ':' if (UseCapturedNS_ and self.quantitativeAccuracyMethod_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%squantitativeAccuracyMethod>%s</%squantitativeAccuracyMethod>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.quantitativeAccuracyMethod), input_name='quantitativeAccuracyMethod')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'quantitativeAccuracyValue':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'quantitativeAccuracyValue')
            value_ = self.gds_validate_string(value_, node, 'quantitativeAccuracyValue')
            self.quantitativeAccuracyValue = value_
            self.quantitativeAccuracyValue_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.quantitativeAccuracyValue)
        elif nodeName_ == 'quantitativeAccuracyMethod':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'quantitativeAccuracyMethod')
            value_ = self.gds_validate_string(value_, node, 'quantitativeAccuracyMethod')
            self.quantitativeAccuracyMethod = value_
            self.quantitativeAccuracyMethod_nsprefix_ = child_.prefix
            # validate type NonEmptyStringType
            self.validate_NonEmptyStringType(self.quantitativeAccuracyMethod)
# end class quantitativeAccuracyReportType74


class alternateIdentifierType75(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('system', 'res:SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, system=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, alternateIdentifierType75)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if alternateIdentifierType75.subclass:
            return alternateIdentifierType75.subclass(*args_, **kwargs_)
        else:
            return alternateIdentifierType75(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_SystemType(self, value):
        # Validate type res:SystemType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='alternateIdentifierType75', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('alternateIdentifierType75')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'alternateIdentifierType75':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='alternateIdentifierType75')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='alternateIdentifierType75', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='alternateIdentifierType75'):
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='alternateIdentifierType75', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class alternateIdentifierType75


class referencesType76(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('system', 'SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, system=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, referencesType76)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if referencesType76.subclass:
            return referencesType76.subclass(*args_, **kwargs_)
        else:
            return referencesType76(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_SystemType(self, value):
        # Validate type SystemType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referencesType76', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('referencesType76')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'referencesType76':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='referencesType76')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='referencesType76', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='referencesType76'):
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referencesType76', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class referencesType76


class alternateIdentifierType77(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('system', 'res:SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, system=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, alternateIdentifierType77)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if alternateIdentifierType77.subclass:
            return alternateIdentifierType77.subclass(*args_, **kwargs_)
        else:
            return alternateIdentifierType77(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_SystemType(self, value):
        # Validate type res:SystemType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='alternateIdentifierType77', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('alternateIdentifierType77')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'alternateIdentifierType77':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='alternateIdentifierType77')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='alternateIdentifierType77', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='alternateIdentifierType77'):
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='alternateIdentifierType77', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class alternateIdentifierType77


class referencesType78(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('system', 'SystemType', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, system=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, referencesType78)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if referencesType78.subclass:
            return referencesType78.subclass(*args_, **kwargs_)
        else:
            return referencesType78(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_SystemType(self, value):
        # Validate type SystemType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referencesType78', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('referencesType78')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'referencesType78':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='referencesType78')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='referencesType78', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='referencesType78'):
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"', name_='referencesType78', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_SystemType(self.system)    # validate type SystemType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class referencesType78


GDSClassesMapping = {
    'access': AccessType,
    'annotation': SemanticAnnotation,
    'attribute': AttributeType,
    'attributeList': AttributeListType,
    'citation': CitationType,
    'dataTable': DataTableType,
    'dataset': DatasetType,
    'dependency': DependencyType,
    'description': TextType,
    'example': TextType,
    'methods': MethodsType,
    'otherEntity': OtherEntityType,
    'party': ResponsibleParty,
    'physical': PhysicalType,
    'protocol': ProtocolType,
    'researchProject': ResearchProjectType,
    'software': SoftwareType,
    'spatialRaster': SpatialRasterType,
    'spatialReference': SpatialReferenceType,
    'spatialVector': SpatialVectorType,
    'storedProcedure': StoredProcedureType,
    'text': TextType,
    'view': ViewType,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def get_required_ns_prefix_defs(rootNode):
    '''Get all name space prefix definitions required in this XML doc.
    Return a dictionary of definitions and a char string of definitions.
    '''
    nsmap = {
        prefix: uri
        for node in rootNode.iter()
        for (prefix, uri) in node.nsmap.items()
        if prefix is not None
    }
    namespacedefs = ' '.join([
        'xmlns:{}="{}"'.format(prefix, uri)
        for prefix, uri in nsmap.items()
    ])
    return nsmap, namespacedefs


def parse(inFileName, silence=False, print_warnings=True):
    global CapturedNsmap_
    gds_collector = GdsCollector_()
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'eml'
        rootClass = eml
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    CapturedNsmap_, namespacedefs = get_required_ns_prefix_defs(rootNode)
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_=namespacedefs,
            pretty_print=True)
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseEtree(inFileName, silence=False, print_warnings=True,
               mapping=None, nsmap=None):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'eml'
        rootClass = eml
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    # Enable Python to collect the space used by the DOM.
    if mapping is None:
        mapping = {}
    rootElement = rootObj.to_etree(
        None, name_=rootTag, mapping_=mapping, nsmap_=nsmap)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(str(content))
        sys.stdout.write('\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False, print_warnings=True):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    gds_collector = GdsCollector_()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'eml'
        rootClass = eml
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    if not SaveElementTreeNode:
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0"')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseLiteral(inFileName, silence=False, print_warnings=True):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'eml'
        rootClass = eml
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    # Enable Python to collect the space used by the DOM.
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('#from emllib import *\n\n')
        sys.stdout.write('import emllib as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()

RenameMappings_ = {
    "{https://eml.ecoinformatics.org/spatialVector-2.2.0}DataQuality": "DataQuality1",
}

#
# Mapping of namespaces to types defined in them
# and the file in which each is defined.
# simpleTypes are marked "ST" and complexTypes "CT".
NamespaceToDefMappings_ = {'http://www.w3.org/XML/1998/namespace': [],
 'https://eml.ecoinformatics.org/access-2.2.0': [('AccessType',
                                                  '../xsd/eml-access.xsd',
                                                  'CT'),
                                                 ('AccessRule',
                                                  '../xsd/eml-access.xsd',
                                                  'CT')],
 'https://eml.ecoinformatics.org/attribute-2.2.0': [('NumberType',
                                                     '../xsd/eml-attribute.xsd',
                                                     'ST'),
                                                    ('AttributeListType',
                                                     '../xsd/eml-attribute.xsd',
                                                     'CT'),
                                                    ('AttributeType',
                                                     '../xsd/eml-attribute.xsd',
                                                     'CT'),
                                                    ('Accuracy',
                                                     '../xsd/eml-attribute.xsd',
                                                     'CT'),
                                                    ('UnitType',
                                                     '../xsd/eml-attribute.xsd',
                                                     'CT'),
                                                    ('PrecisionType',
                                                     '../xsd/eml-attribute.xsd',
                                                     'CT'),
                                                    ('NonNumericDomainType',
                                                     '../xsd/eml-attribute.xsd',
                                                     'CT'),
                                                    ('NumericDomainType',
                                                     '../xsd/eml-attribute.xsd',
                                                     'CT'),
                                                    ('DateTimeDomainType',
                                                     '../xsd/eml-attribute.xsd',
                                                     'CT')],
 'https://eml.ecoinformatics.org/constraint-2.2.0': [('CardinalityChildOccurancesType',
                                                      '../xsd/eml-constraint.xsd',
                                                      'ST'),
                                                     ('ConstraintType',
                                                      '../xsd/eml-constraint.xsd',
                                                      'CT')],
 'https://eml.ecoinformatics.org/coverage-2.2.0': [('GRingType',
                                                    '../xsd/eml-coverage.xsd',
                                                    'ST'),
                                                   ('Coverage',
                                                    '../xsd/eml-coverage.xsd',
                                                    'CT'),
                                                   ('TemporalCoverage',
                                                    '../xsd/eml-coverage.xsd',
                                                    'CT'),
                                                   ('SingleDateTimeType',
                                                    '../xsd/eml-coverage.xsd',
                                                    'CT'),
                                                   ('GeographicCoverage',
                                                    '../xsd/eml-coverage.xsd',
                                                    'CT'),
                                                   ('GRingPointType',
                                                    '../xsd/eml-coverage.xsd',
                                                    'CT'),
                                                   ('TaxonomicCoverage',
                                                    '../xsd/eml-coverage.xsd',
                                                    'CT'),
                                                   ('TaxonomicClassificationType',
                                                    '../xsd/eml-coverage.xsd',
                                                    'CT')],
 'https://eml.ecoinformatics.org/dataTable-2.2.0': [('DataTableType',
                                                     '../xsd/eml-dataTable.xsd',
                                                     'CT')],
 'https://eml.ecoinformatics.org/dataset-2.2.0': [('MaintUpFreqType',
                                                   '../xsd/eml-dataset.xsd',
                                                   'ST'),
                                                  ('DatasetType',
                                                   '../xsd/eml-dataset.xsd',
                                                   'CT'),
                                                  ('MaintenanceType',
                                                   '../xsd/eml-dataset.xsd',
                                                   'CT')],
 'https://eml.ecoinformatics.org/documentation-2.2.0': [],
 'https://eml.ecoinformatics.org/eml-2.2.0': [],
 'https://eml.ecoinformatics.org/entity-2.2.0': [('OtherEntityType',
                                                  '../xsd/eml-entity.xsd',
                                                  'CT')],
 'https://eml.ecoinformatics.org/literature-2.2.0': [('CitationType',
                                                      '../xsd/eml-literature.xsd',
                                                      'CT'),
                                                     ('Article',
                                                      '../xsd/eml-literature.xsd',
                                                      'CT'),
                                                     ('Book',
                                                      '../xsd/eml-literature.xsd',
                                                      'CT'),
                                                     ('Chapter',
                                                      '../xsd/eml-literature.xsd',
                                                      'CT'),
                                                     ('ConferenceProceedings',
                                                      '../xsd/eml-literature.xsd',
                                                      'CT'),
                                                     ('Manuscript',
                                                      '../xsd/eml-literature.xsd',
                                                      'CT'),
                                                     ('Report',
                                                      '../xsd/eml-literature.xsd',
                                                      'CT'),
                                                     ('PersonalCommunication',
                                                      '../xsd/eml-literature.xsd',
                                                      'CT'),
                                                     ('Map',
                                                      '../xsd/eml-literature.xsd',
                                                      'CT'),
                                                     ('AudioVisual',
                                                      '../xsd/eml-literature.xsd',
                                                      'CT'),
                                                     ('Generic',
                                                      '../xsd/eml-literature.xsd',
                                                      'CT'),
                                                     ('Thesis',
                                                      '../xsd/eml-literature.xsd',
                                                      'CT'),
                                                     ('Presentation',
                                                      '../xsd/eml-literature.xsd',
                                                      'CT'),
                                                     ('CitationListType',
                                                      '../xsd/eml-literature.xsd',
                                                      'CT')],
 'https://eml.ecoinformatics.org/methods-2.2.0': [('MethodsType',
                                                   '../xsd/eml-methods.xsd',
                                                   'CT'),
                                                  ('ProcedureStepType',
                                                   '../xsd/eml-methods.xsd',
                                                   'CT')],
 'https://eml.ecoinformatics.org/party-2.2.0': [('RoleType',
                                                 '../xsd/eml-party.xsd',
                                                 'ST'),
                                                ('ResponsibleParty',
                                                 '../xsd/eml-party.xsd',
                                                 'CT'),
                                                ('Person',
                                                 '../xsd/eml-party.xsd',
                                                 'CT'),
                                                ('Address',
                                                 '../xsd/eml-party.xsd',
                                                 'CT')],
 'https://eml.ecoinformatics.org/physical-2.2.0': [('PhysicalType',
                                                    '../xsd/eml-physical.xsd',
                                                    'CT'),
                                                   ('PhysicalDistributionType',
                                                    '../xsd/eml-physical.xsd',
                                                    'CT'),
                                                   ('PhysicalOnlineType',
                                                    '../xsd/eml-physical.xsd',
                                                    'CT')],
 'https://eml.ecoinformatics.org/project-2.2.0': [('DescriptorType',
                                                   '../xsd/eml-project.xsd',
                                                   'ST'),
                                                  ('ResearchProjectType',
                                                   '../xsd/eml-project.xsd',
                                                   'CT'),
                                                  ('AwardType',
                                                   '../xsd/eml-project.xsd',
                                                   'CT')],
 'https://eml.ecoinformatics.org/protocol-2.2.0': [('ProtocolType',
                                                    '../xsd/eml-protocol.xsd',
                                                    'CT')],
 'https://eml.ecoinformatics.org/resource-2.2.0': [('KeyTypeCode',
                                                    '../xsd/eml-resource.xsd',
                                                    'ST'),
                                                   ('yearDate',
                                                    '../xsd/eml-resource.xsd',
                                                    'ST'),
                                                   ('IDType',
                                                    '../xsd/eml-resource.xsd',
                                                    'ST'),
                                                   ('SystemType',
                                                    '../xsd/eml-resource.xsd',
                                                    'ST'),
                                                   ('ScopeType',
                                                    '../xsd/eml-resource.xsd',
                                                    'ST'),
                                                   ('FunctionType',
                                                    '../xsd/eml-resource.xsd',
                                                    'ST'),
                                                   ('NonEmptyStringType',
                                                    '../xsd/eml-resource.xsd',
                                                    'ST'),
                                                   ('DistributionType',
                                                    '../xsd/eml-resource.xsd',
                                                    'CT'),
                                                   ('ConnectionDefinitionType',
                                                    '../xsd/eml-resource.xsd',
                                                    'CT'),
                                                   ('InlineType',
                                                    '../xsd/eml-resource.xsd',
                                                    'CT'),
                                                   ('OfflineType',
                                                    '../xsd/eml-resource.xsd',
                                                    'CT'),
                                                   ('OnlineType',
                                                    '../xsd/eml-resource.xsd',
                                                    'CT'),
                                                   ('UrlType',
                                                    '../xsd/eml-resource.xsd',
                                                    'CT'),
                                                   ('ConnectionType',
                                                    '../xsd/eml-resource.xsd',
                                                    'CT'),
                                                   ('i18nNonEmptyStringType',
                                                    '../xsd/eml-resource.xsd',
                                                    'CT'),
                                                   ('LicenseType',
                                                    '../xsd/eml-resource.xsd',
                                                    'CT')],
 'https://eml.ecoinformatics.org/semantics-2.2.0': [('SemanticAnnotation',
                                                     '../xsd/eml-semantics.xsd',
                                                     'CT')],
 'https://eml.ecoinformatics.org/software-2.2.0': [('Action',
                                                    '../xsd/eml-software.xsd',
                                                    'ST'),
                                                   ('SoftwareType',
                                                    '../xsd/eml-software.xsd',
                                                    'CT'),
                                                   ('DependencyType',
                                                    '../xsd/eml-software.xsd',
                                                    'CT')],
 'https://eml.ecoinformatics.org/spatialRaster-2.2.0': [('CellValueType',
                                                         '../xsd/eml-spatialRaster.xsd',
                                                         'ST'),
                                                        ('ImagingConditionCode',
                                                         '../xsd/eml-spatialRaster.xsd',
                                                         'ST'),
                                                        ('rasterOriginType',
                                                         '../xsd/eml-spatialRaster.xsd',
                                                         'ST'),
                                                        ('CellGeometryType',
                                                         '../xsd/eml-spatialRaster.xsd',
                                                         'ST'),
                                                        ('SpatialRasterType',
                                                         '../xsd/eml-spatialRaster.xsd',
                                                         'CT'),
                                                        ('BandType',
                                                         '../xsd/eml-spatialRaster.xsd',
                                                         'CT'),
                                                        ('DataQuality',
                                                         '../xsd/eml-spatialRaster.xsd',
                                                         'CT')],
 'https://eml.ecoinformatics.org/spatialReference-2.2.0': [('lengthUnits',
                                                            '../xsd/eml-spatialReference.xsd',
                                                            'ST'),
                                                           ('angleUnits',
                                                            '../xsd/eml-spatialReference.xsd',
                                                            'ST'),
                                                           ('SpatialReferenceType',
                                                            '../xsd/eml-spatialReference.xsd',
                                                            'CT'),
                                                           ('geogCoordSysType',
                                                            '../xsd/eml-spatialReference.xsd',
                                                            'CT'),
                                                           ('horizCoordSysType',
                                                            '../xsd/eml-spatialReference.xsd',
                                                            'CT')],
 'https://eml.ecoinformatics.org/spatialVector-2.2.0': [('GeometryType',
                                                         '../xsd/eml-spatialVector.xsd',
                                                         'ST'),
                                                        ('TopologyLevel',
                                                         '../xsd/eml-spatialVector.xsd',
                                                         'ST'),
                                                        ('SpatialVectorType',
                                                         '../xsd/eml-spatialVector.xsd',
                                                         'CT'),
                                                        ('DataQuality',
                                                         '../xsd/eml-spatialVector.xsd',
                                                         'CT')],
 'https://eml.ecoinformatics.org/storedProcedure-2.2.0': [('StoredProcedureType',
                                                           '../xsd/eml-storedProcedure.xsd',
                                                           'CT'),
                                                          ('ParameterType',
                                                           '../xsd/eml-storedProcedure.xsd',
                                                           'CT')],
 'https://eml.ecoinformatics.org/text-2.2.0': [('TextType',
                                                '../xsd/eml-text.xsd',
                                                'CT'),
                                               ('ParagraphType',
                                                '../xsd/eml-text.xsd',
                                                'CT'),
                                               ('SectionType',
                                                '../xsd/eml-text.xsd',
                                                'CT'),
                                               ('ListType',
                                                '../xsd/eml-text.xsd',
                                                'CT'),
                                               ('SubSuperScriptType',
                                                '../xsd/eml-text.xsd',
                                                'CT'),
                                               ('i18nString',
                                                '../xsd/eml-text.xsd',
                                                'CT')],
 'https://eml.ecoinformatics.org/units-2.2.0': [('StandardUnitDictionary',
                                                 '../xsd/eml-unitTypeDefinitions.xsd',
                                                 'ST'),
                                                ('LengthUnitType',
                                                 '../xsd/eml-unitTypeDefinitions.xsd',
                                                 'ST'),
                                                ('MassUnitType',
                                                 '../xsd/eml-unitTypeDefinitions.xsd',
                                                 'ST'),
                                                ('otherUnitType',
                                                 '../xsd/eml-unitTypeDefinitions.xsd',
                                                 'ST'),
                                                ('angleUnitType',
                                                 '../xsd/eml-unitTypeDefinitions.xsd',
                                                 'ST')],
 'https://eml.ecoinformatics.org/view-2.2.0': [('ViewType',
                                                '../xsd/eml-view.xsd',
                                                'CT')]}

__all__ = [
    "AccessRule",
    "AccessType",
    "Accuracy",
    "Address",
    "Article",
    "AttributeListType",
    "AttributeType",
    "AudioVisual",
    "AwardType",
    "BandType",
    "Book",
    "Chapter",
    "CitationListType",
    "CitationType",
    "ConferenceProceedings",
    "ConnectionDefinitionType",
    "ConnectionType",
    "ConstraintType",
    "Coverage",
    "DataQuality",
    "DataQuality1",
    "DataTableType",
    "DatasetType",
    "DateTimeDomainType",
    "DependencyType",
    "DistributionType",
    "GRingPointType",
    "Generic",
    "GeographicCoverage",
    "InlineType",
    "LicenseType",
    "ListType",
    "MaintenanceType",
    "Manuscript",
    "Map",
    "MethodsType",
    "NonNumericDomainType",
    "NumericDomainType",
    "OfflineType",
    "OnlineType",
    "OtherEntityType",
    "ParagraphType",
    "ParameterType",
    "Person",
    "PersonalCommunication",
    "PhysicalDistributionType",
    "PhysicalOnlineType",
    "PhysicalType",
    "PrecisionType",
    "Presentation",
    "ProcedureStepType",
    "ProtocolType",
    "Report",
    "ResearchProjectType",
    "ResponsibleParty",
    "SectionType",
    "SemanticAnnotation",
    "SingleDateTimeType",
    "SoftwareType",
    "SpatialRasterType",
    "SpatialReferenceType",
    "SpatialVectorType",
    "StoredProcedureType",
    "SubSuperScriptType",
    "TaxonomicClassificationType",
    "TaxonomicCoverage",
    "TemporalCoverage",
    "TextType",
    "Thesis",
    "UnitType",
    "UrlType",
    "ViewType",
    "additionalMetadataType",
    "alternateIdentifierType",
    "alternateIdentifierType11",
    "alternateIdentifierType18",
    "alternateIdentifierType23",
    "alternateIdentifierType25",
    "alternateIdentifierType29",
    "alternateIdentifierType34",
    "alternateIdentifierType64",
    "alternateIdentifierType66",
    "alternateIdentifierType72",
    "alternateIdentifierType75",
    "alternateIdentifierType77",
    "alternativeTimeScaleType",
    "altitudeSysDefType",
    "annotationType",
    "annotationsType",
    "associatedPartyType",
    "associatedPartyType12",
    "associatedPartyType19",
    "associatedPartyType30",
    "associatedPartyType35",
    "authenticationType",
    "bilinearFitType",
    "binaryRasterFormatType",
    "boundingAltitudesType",
    "boundingCoordinatesType",
    "boundsType",
    "boundsType43",
    "boundsType47",
    "boundsType50",
    "cardinalityType",
    "cardinalityType57",
    "cardinalityType62",
    "cellSizeXDirection",
    "cellSizeYDirection",
    "changeHistoryType",
    "checkConstraintType",
    "classificationSystemType",
    "codeDefinitionType",
    "complexType",
    "constraintDescription",
    "controlPointType",
    "cornerPointType",
    "dataFormatType",
    "datasetGPolygonExclusionGRingType",
    "datasetGPolygonOuterGRingType",
    "datasetGPolygonType",
    "dateTimeType",
    "datumType",
    "depthSysDefType",
    "descriptorType",
    "descriptorValueType",
    "designDescriptionType",
    "eml",
    "emphasisType",
    "entityCodeListType",
    "enumeratedDomainType",
    "externalCodeSetType",
    "externallyDefinedFormatType",
    "foreignKeyType",
    "geogCoordSysType",
    "georeferenceInfoType",
    "horizCoordSysType",
    "i18nNonEmptyStringType",
    "i18nString",
    "imageDescriptionType",
    "implementationType",
    "intervalType",
    "joinConditionType",
    "keyType",
    "keyType53",
    "keyType54",
    "keyType55",
    "keyType59",
    "keyType60",
    "keywordSetType",
    "keywordSetType13",
    "keywordSetType20",
    "keywordSetType31",
    "keywordSetType36",
    "keywordType",
    "keywordType14",
    "keywordType21",
    "keywordType32",
    "keywordType37",
    "languageType",
    "listitemType",
    "literalLayoutType",
    "markdownType",
    "maximumType",
    "maximumType45",
    "maximumType49",
    "maximumType52",
    "measurementScaleType",
    "metadataType",
    "methodStepType",
    "minimumType",
    "minimumType44",
    "minimumType48",
    "minimumType51",
    "missingValueCodeType",
    "moduleDocs",
    "multiBandType",
    "nominalType",
    "notNullConstraintType",
    "numberOfBands",
    "ordinalType",
    "parameterDefinitionType",
    "parameterType",
    "parameterType70",
    "peakResponse",
    "personnelType",
    "phoneType",
    "primaryKeyType",
    "primeMeridianType",
    "projCoordSysType",
    "projectionList",
    "projectionType",
    "propertyURIType",
    "quantitativeAccuracyReportType",
    "quantitativeAccuracyReportType74",
    "quantitativeAttributeAccuracyAssessmentType",
    "rangeOfDatesType",
    "ratioType",
    "referenceType",
    "referencedEntityId",
    "referencedKeyType",
    "referencesType",
    "referencesType10",
    "referencesType15",
    "referencesType16",
    "referencesType17",
    "referencesType2",
    "referencesType22",
    "referencesType24",
    "referencesType27",
    "referencesType28",
    "referencesType3",
    "referencesType33",
    "referencesType38",
    "referencesType39",
    "referencesType4",
    "referencesType40",
    "referencesType41",
    "referencesType42",
    "referencesType46",
    "referencesType5",
    "referencesType6",
    "referencesType65",
    "referencesType68",
    "referencesType69",
    "referencesType7",
    "referencesType73",
    "referencesType76",
    "referencesType78",
    "referencesType8",
    "referencesType9",
    "repositoryType",
    "samplingType",
    "schemeNameType",
    "simpleDelimitedType",
    "sizeType",
    "spatialSamplingUnitsType",
    "spheroidType",
    "storageTypeType",
    "studyAreaDescriptionType",
    "studyExtentType",
    "taxonIdType",
    "taxonomicCoverageType",
    "taxonomicSystemType",
    "temporalCoverageType",
    "textDelimitedType",
    "textDomainType",
    "textFixedType",
    "textFormatType",
    "ulinkType",
    "uniqueKeyType",
    "unitType",
    "unitType71",
    "userIdType",
    "valueType",
    "valueURIType",
    "vertCoordSysType",
    "verticals",
    "vouchersType",
    "NamespaceToDefMappings_"
]
